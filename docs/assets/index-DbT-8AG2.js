const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      'assets/SetlistsIndex-CO_nWPJI.js',
      'assets/AppLayout.vue_vue_type_script_setup_true_lang-B2aB8Sgr.js',
      'assets/auth-CbtkUdst.js',
      'assets/SetlistCreateUpdate-D57DwXV-.js',
      'assets/sheetBaseDirectory-BnjYEQ72.js',
      'assets/helpers-Hh-SjjSI.js',
      'assets/plugin-vue_export-helper-DlAUqK2U.js',
      'assets/SetlistCreateUpdate-BwedoV8-.css',
      'assets/SetlistRead-6iFH7K3d.js',
      'assets/SetlistRead-Cmvf00kW.css',
      'assets/Login-CAiAw9gx.js',
      'assets/Settings-DZPSPFku.js',
      'assets/Settings-UBz24cDf.css',
    ])
) => i.map((i) => d[i])
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r)
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === 'childList')
        for (const o of s.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && i(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(r) {
    const s = {}
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : r.crossOrigin === 'anonymous'
        ? (s.credentials = 'omit')
        : (s.credentials = 'same-origin'),
      s
    )
  }
  function i(r) {
    if (r.ep) return
    r.ep = !0
    const s = n(r)
    fetch(r.href, s)
  }
})()
/**
 * @vue/shared v3.4.33
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ /*! #__NO_SIDE_EFFECTS__ */ function yy(e, t) {
  const n = new Set(e.split(','))
  return (i) => n.has(i)
}
const Vt = {},
  Ya = [],
  Ei = () => {},
  yM = () => !1,
  kf = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
  _y = (e) => e.startsWith('onUpdate:'),
  rn = Object.assign,
  by = (e, t) => {
    const n = e.indexOf(t)
    n > -1 && e.splice(n, 1)
  },
  _M = Object.prototype.hasOwnProperty,
  ut = (e, t) => _M.call(e, t),
  Ue = Array.isArray,
  Qa = (e) => Pf(e) === '[object Map]',
  IC = (e) => Pf(e) === '[object Set]',
  qe = (e) => typeof e == 'function',
  Bt = (e) => typeof e == 'string',
  Bs = (e) => typeof e == 'symbol',
  St = (e) => e !== null && typeof e == 'object',
  SC = (e) => (St(e) || qe(e)) && qe(e.then) && qe(e.catch),
  EC = Object.prototype.toString,
  Pf = (e) => EC.call(e),
  bM = (e) => Pf(e).slice(8, -1),
  TC = (e) => Pf(e) === '[object Object]',
  wy = (e) => Bt(e) && e !== 'NaN' && e[0] !== '-' && '' + parseInt(e, 10) === e,
  Mu = yy(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
  ),
  Rf = (e) => {
    const t = Object.create(null)
    return (n) => t[n] || (t[n] = e(n))
  },
  wM = /-(\w)/g,
  gi = Rf((e) => e.replace(wM, (t, n) => (n ? n.toUpperCase() : ''))),
  IM = /\B([A-Z])/g,
  ta = Rf((e) => e.replace(IM, '-$1').toLowerCase()),
  gr = Rf((e) => e.charAt(0).toUpperCase() + e.slice(1)),
  yg = Rf((e) => (e ? `on${gr(e)}` : '')),
  Vs = (e, t) => !Object.is(e, t),
  hh = (e, ...t) => {
    for (let n = 0; n < e.length; n++) e[n](...t)
  },
  CC = (e, t, n, i = !1) => {
    Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: i, value: n })
  },
  yv = (e) => {
    const t = parseFloat(e)
    return isNaN(t) ? e : t
  },
  AC = (e) => {
    const t = Bt(e) ? Number(e) : NaN
    return isNaN(t) ? e : t
  }
let gI
const kC = () =>
  gI ||
  (gI =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
      ? self
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : {})
function xf(e) {
  if (Ue(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) {
      const i = e[n],
        r = Bt(i) ? CM(i) : xf(i)
      if (r) for (const s in r) t[s] = r[s]
    }
    return t
  } else if (Bt(e) || St(e)) return e
}
const SM = /;(?![^(]*\))/g,
  EM = /:([^]+)/,
  TM = /\/\*[^]*?\*\//g
function CM(e) {
  const t = {}
  return (
    e
      .replace(TM, '')
      .split(SM)
      .forEach((n) => {
        if (n) {
          const i = n.split(EM)
          i.length > 1 && (t[i[0].trim()] = i[1].trim())
        }
      }),
    t
  )
}
function Vf(e) {
  let t = ''
  if (Bt(e)) t = e
  else if (Ue(e))
    for (let n = 0; n < e.length; n++) {
      const i = Vf(e[n])
      i && (t += i + ' ')
    }
  else if (St(e)) for (const n in e) e[n] && (t += n + ' ')
  return t.trim()
}
function Vte(e) {
  if (!e) return null
  let { class: t, style: n } = e
  return t && !Bt(t) && (e.class = Vf(t)), n && (e.style = xf(n)), e
}
const AM = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  kM = yy(AM)
function PC(e) {
  return !!e || e === ''
}
const RC = (e) => !!(e && e.__v_isRef === !0),
  xC = (e) =>
    Bt(e)
      ? e
      : e == null
      ? ''
      : Ue(e) || (St(e) && (e.toString === EC || !qe(e.toString)))
      ? RC(e)
        ? xC(e.value)
        : JSON.stringify(e, VC, 2)
      : String(e),
  VC = (e, t) =>
    RC(t)
      ? VC(e, t.value)
      : Qa(t)
      ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [i, r], s) => ((n[_g(i, s) + ' =>'] = r), n), {}) }
      : IC(t)
      ? { [`Set(${t.size})`]: [...t.values()].map((n) => _g(n)) }
      : Bs(t)
      ? _g(t)
      : St(t) && !Ue(t) && !TC(t)
      ? String(t)
      : t,
  _g = (e, t = '') => {
    var n
    return Bs(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
  }
/**
 * @vue/reactivity v3.4.33
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let ai
class DC {
  constructor(t = !1) {
    ;(this.detached = t),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this.parent = ai),
      !t && ai && (this.index = (ai.scopes || (ai.scopes = [])).push(this) - 1)
  }
  get active() {
    return this._active
  }
  run(t) {
    if (this._active) {
      const n = ai
      try {
        return (ai = this), t()
      } finally {
        ai = n
      }
    }
  }
  on() {
    ai = this
  }
  off() {
    ai = this.parent
  }
  stop(t) {
    if (this._active) {
      let n, i
      for (n = 0, i = this.effects.length; n < i; n++) this.effects[n].stop()
      for (n = 0, i = this.cleanups.length; n < i; n++) this.cleanups[n]()
      if (this.scopes) for (n = 0, i = this.scopes.length; n < i; n++) this.scopes[n].stop(!0)
      if (!this.detached && this.parent && !t) {
        const r = this.parent.scopes.pop()
        r && r !== this && ((this.parent.scopes[this.index] = r), (r.index = this.index))
      }
      ;(this.parent = void 0), (this._active = !1)
    }
  }
}
function Nl(e) {
  return new DC(e)
}
function PM(e, t = ai) {
  t && t.active && t.effects.push(e)
}
function Iy() {
  return ai
}
function gn(e) {
  ai && ai.cleanups.push(e)
}
let bo
class Sy {
  constructor(t, n, i, r) {
    ;(this.fn = t),
      (this.trigger = n),
      (this.scheduler = i),
      (this.active = !0),
      (this.deps = []),
      (this._dirtyLevel = 4),
      (this._trackId = 0),
      (this._runnings = 0),
      (this._shouldSchedule = !1),
      (this._depsLength = 0),
      PM(this, r)
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      ;(this._dirtyLevel = 1), $s()
      for (let t = 0; t < this._depsLength; t++) {
        const n = this.deps[t]
        if (n.computed && (RM(n.computed), this._dirtyLevel >= 4)) break
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), Us()
    }
    return this._dirtyLevel >= 4
  }
  set dirty(t) {
    this._dirtyLevel = t ? 4 : 0
  }
  run() {
    if (((this._dirtyLevel = 0), !this.active)) return this.fn()
    let t = Ss,
      n = bo
    try {
      return (Ss = !0), (bo = this), this._runnings++, vI(this), this.fn()
    } finally {
      pI(this), this._runnings--, (bo = n), (Ss = t)
    }
  }
  stop() {
    this.active && (vI(this), pI(this), this.onStop && this.onStop(), (this.active = !1))
  }
}
function RM(e) {
  return e.value
}
function vI(e) {
  e._trackId++, (e._depsLength = 0)
}
function pI(e) {
  if (e.deps.length > e._depsLength) {
    for (let t = e._depsLength; t < e.deps.length; t++) NC(e.deps[t], e)
    e.deps.length = e._depsLength
  }
}
function NC(e, t) {
  const n = e.get(t)
  n !== void 0 && t._trackId !== n && (e.delete(t), e.size === 0 && e.cleanup())
}
let Ss = !0,
  _v = 0
const OC = []
function $s() {
  OC.push(Ss), (Ss = !1)
}
function Us() {
  const e = OC.pop()
  Ss = e === void 0 ? !0 : e
}
function Ey() {
  _v++
}
function Ty() {
  for (_v--; !_v && bv.length; ) bv.shift()()
}
function MC(e, t, n) {
  if (t.get(e) !== e._trackId) {
    t.set(e, e._trackId)
    const i = e.deps[e._depsLength]
    i !== t ? (i && NC(i, e), (e.deps[e._depsLength++] = t)) : e._depsLength++
  }
}
const bv = []
function LC(e, t, n) {
  Ey()
  for (const i of e.keys()) {
    let r
    i._dirtyLevel < t &&
      (r ?? (r = e.get(i) === i._trackId)) &&
      (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0), (i._dirtyLevel = t)),
      i._shouldSchedule &&
        (r ?? (r = e.get(i) === i._trackId)) &&
        (i.trigger(),
        (!i._runnings || i.allowRecurse) &&
          i._dirtyLevel !== 2 &&
          ((i._shouldSchedule = !1), i.scheduler && bv.push(i.scheduler)))
  }
  Ty()
}
const FC = (e, t) => {
    const n = new Map()
    return (n.cleanup = e), (n.computed = t), n
  },
  Dh = new WeakMap(),
  wo = Symbol(''),
  wv = Symbol('')
function ri(e, t, n) {
  if (Ss && bo) {
    let i = Dh.get(e)
    i || Dh.set(e, (i = new Map()))
    let r = i.get(n)
    r || i.set(n, (r = FC(() => i.delete(n)))), MC(bo, r)
  }
}
function Vr(e, t, n, i, r, s) {
  const o = Dh.get(e)
  if (!o) return
  let a = []
  if (t === 'clear') a = [...o.values()]
  else if (n === 'length' && Ue(e)) {
    const l = Number(i)
    o.forEach((u, c) => {
      ;(c === 'length' || (!Bs(c) && c >= l)) && a.push(u)
    })
  } else
    switch ((n !== void 0 && a.push(o.get(n)), t)) {
      case 'add':
        Ue(e) ? wy(n) && a.push(o.get('length')) : (a.push(o.get(wo)), Qa(e) && a.push(o.get(wv)))
        break
      case 'delete':
        Ue(e) || (a.push(o.get(wo)), Qa(e) && a.push(o.get(wv)))
        break
      case 'set':
        Qa(e) && a.push(o.get(wo))
        break
    }
  Ey()
  for (const l of a) l && LC(l, 4)
  Ty()
}
function xM(e, t) {
  const n = Dh.get(e)
  return n && n.get(t)
}
const VM = yy('__proto__,__v_isRef,__isVue'),
  BC = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((e) => e !== 'arguments' && e !== 'caller')
      .map((e) => Symbol[e])
      .filter(Bs)
  ),
  yI = DM()
function DM() {
  const e = {}
  return (
    ['includes', 'indexOf', 'lastIndexOf'].forEach((t) => {
      e[t] = function (...n) {
        const i = ze(this)
        for (let s = 0, o = this.length; s < o; s++) ri(i, 'get', s + '')
        const r = i[t](...n)
        return r === -1 || r === !1 ? i[t](...n.map(ze)) : r
      }
    }),
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((t) => {
      e[t] = function (...n) {
        $s(), Ey()
        const i = ze(this)[t].apply(this, n)
        return Ty(), Us(), i
      }
    }),
    e
  )
}
function NM(e) {
  Bs(e) || (e = String(e))
  const t = ze(this)
  return ri(t, 'has', e), t.hasOwnProperty(e)
}
class $C {
  constructor(t = !1, n = !1) {
    ;(this._isReadonly = t), (this._isShallow = n)
  }
  get(t, n, i) {
    const r = this._isReadonly,
      s = this._isShallow
    if (n === '__v_isReactive') return !r
    if (n === '__v_isReadonly') return r
    if (n === '__v_isShallow') return s
    if (n === '__v_raw')
      return i === (r ? (s ? GM : HC) : s ? zC : jC).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(i)
        ? t
        : void 0
    const o = Ue(t)
    if (!r) {
      if (o && ut(yI, n)) return Reflect.get(yI, n, i)
      if (n === 'hasOwnProperty') return NM
    }
    const a = Reflect.get(t, n, i)
    return (Bs(n) ? BC.has(n) : VM(n)) || (r || ri(t, 'get', n), s)
      ? a
      : It(a)
      ? o && wy(n)
        ? a
        : a.value
      : St(a)
      ? r
        ? Ol(a)
        : wn(a)
      : a
  }
}
class UC extends $C {
  constructor(t = !1) {
    super(!1, t)
  }
  set(t, n, i, r) {
    let s = t[n]
    if (!this._isShallow) {
      const l = Ro(s)
      if ((!al(i) && !Ro(i) && ((s = ze(s)), (i = ze(i))), !Ue(t) && It(s) && !It(i)))
        return l ? !1 : ((s.value = i), !0)
    }
    const o = Ue(t) && wy(n) ? Number(n) < t.length : ut(t, n),
      a = Reflect.set(t, n, i, r)
    return t === ze(r) && (o ? Vs(i, s) && Vr(t, 'set', n, i) : Vr(t, 'add', n, i)), a
  }
  deleteProperty(t, n) {
    const i = ut(t, n)
    t[n]
    const r = Reflect.deleteProperty(t, n)
    return r && i && Vr(t, 'delete', n, void 0), r
  }
  has(t, n) {
    const i = Reflect.has(t, n)
    return (!Bs(n) || !BC.has(n)) && ri(t, 'has', n), i
  }
  ownKeys(t) {
    return ri(t, 'iterate', Ue(t) ? 'length' : wo), Reflect.ownKeys(t)
  }
}
class OM extends $C {
  constructor(t = !1) {
    super(!0, t)
  }
  set(t, n) {
    return !0
  }
  deleteProperty(t, n) {
    return !0
  }
}
const MM = new UC(),
  LM = new OM(),
  FM = new UC(!0)
const Cy = (e) => e,
  Df = (e) => Reflect.getPrototypeOf(e)
function Nd(e, t, n = !1, i = !1) {
  e = e.__v_raw
  const r = ze(e),
    s = ze(t)
  n || (Vs(t, s) && ri(r, 'get', t), ri(r, 'get', s))
  const { has: o } = Df(r),
    a = i ? Cy : n ? Py : nc
  if (o.call(r, t)) return a(e.get(t))
  if (o.call(r, s)) return a(e.get(s))
  e !== r && e.get(t)
}
function Od(e, t = !1) {
  const n = this.__v_raw,
    i = ze(n),
    r = ze(e)
  return t || (Vs(e, r) && ri(i, 'has', e), ri(i, 'has', r)), e === r ? n.has(e) : n.has(e) || n.has(r)
}
function Md(e, t = !1) {
  return (e = e.__v_raw), !t && ri(ze(e), 'iterate', wo), Reflect.get(e, 'size', e)
}
function _I(e, t = !1) {
  !t && !al(e) && !Ro(e) && (e = ze(e))
  const n = ze(this)
  return Df(n).has.call(n, e) || (n.add(e), Vr(n, 'add', e, e)), this
}
function bI(e, t, n = !1) {
  !n && !al(t) && !Ro(t) && (t = ze(t))
  const i = ze(this),
    { has: r, get: s } = Df(i)
  let o = r.call(i, e)
  o || ((e = ze(e)), (o = r.call(i, e)))
  const a = s.call(i, e)
  return i.set(e, t), o ? Vs(t, a) && Vr(i, 'set', e, t) : Vr(i, 'add', e, t), this
}
function wI(e) {
  const t = ze(this),
    { has: n, get: i } = Df(t)
  let r = n.call(t, e)
  r || ((e = ze(e)), (r = n.call(t, e))), i && i.call(t, e)
  const s = t.delete(e)
  return r && Vr(t, 'delete', e, void 0), s
}
function II() {
  const e = ze(this),
    t = e.size !== 0,
    n = e.clear()
  return t && Vr(e, 'clear', void 0, void 0), n
}
function Ld(e, t) {
  return function (i, r) {
    const s = this,
      o = s.__v_raw,
      a = ze(o),
      l = t ? Cy : e ? Py : nc
    return !e && ri(a, 'iterate', wo), o.forEach((u, c) => i.call(r, l(u), l(c), s))
  }
}
function Fd(e, t, n) {
  return function (...i) {
    const r = this.__v_raw,
      s = ze(r),
      o = Qa(s),
      a = e === 'entries' || (e === Symbol.iterator && o),
      l = e === 'keys' && o,
      u = r[e](...i),
      c = n ? Cy : t ? Py : nc
    return (
      !t && ri(s, 'iterate', l ? wv : wo),
      {
        next() {
          const { value: d, done: f } = u.next()
          return f ? { value: d, done: f } : { value: a ? [c(d[0]), c(d[1])] : c(d), done: f }
        },
        [Symbol.iterator]() {
          return this
        },
      }
    )
  }
}
function ns(e) {
  return function (...t) {
    return e === 'delete' ? !1 : e === 'clear' ? void 0 : this
  }
}
function BM() {
  const e = {
      get(s) {
        return Nd(this, s)
      },
      get size() {
        return Md(this)
      },
      has: Od,
      add: _I,
      set: bI,
      delete: wI,
      clear: II,
      forEach: Ld(!1, !1),
    },
    t = {
      get(s) {
        return Nd(this, s, !1, !0)
      },
      get size() {
        return Md(this)
      },
      has: Od,
      add(s) {
        return _I.call(this, s, !0)
      },
      set(s, o) {
        return bI.call(this, s, o, !0)
      },
      delete: wI,
      clear: II,
      forEach: Ld(!1, !0),
    },
    n = {
      get(s) {
        return Nd(this, s, !0)
      },
      get size() {
        return Md(this, !0)
      },
      has(s) {
        return Od.call(this, s, !0)
      },
      add: ns('add'),
      set: ns('set'),
      delete: ns('delete'),
      clear: ns('clear'),
      forEach: Ld(!0, !1),
    },
    i = {
      get(s) {
        return Nd(this, s, !0, !0)
      },
      get size() {
        return Md(this, !0)
      },
      has(s) {
        return Od.call(this, s, !0)
      },
      add: ns('add'),
      set: ns('set'),
      delete: ns('delete'),
      clear: ns('clear'),
      forEach: Ld(!0, !0),
    }
  return (
    ['keys', 'values', 'entries', Symbol.iterator].forEach((s) => {
      ;(e[s] = Fd(s, !1, !1)), (n[s] = Fd(s, !0, !1)), (t[s] = Fd(s, !1, !0)), (i[s] = Fd(s, !0, !0))
    }),
    [e, n, t, i]
  )
}
const [$M, UM, jM, zM] = BM()
function Ay(e, t) {
  const n = t ? (e ? zM : jM) : e ? UM : $M
  return (i, r, s) =>
    r === '__v_isReactive'
      ? !e
      : r === '__v_isReadonly'
      ? e
      : r === '__v_raw'
      ? i
      : Reflect.get(ut(n, r) && r in i ? n : i, r, s)
}
const HM = { get: Ay(!1, !1) },
  WM = { get: Ay(!1, !0) },
  qM = { get: Ay(!0, !1) }
const jC = new WeakMap(),
  zC = new WeakMap(),
  HC = new WeakMap(),
  GM = new WeakMap()
function KM(e) {
  switch (e) {
    case 'Object':
    case 'Array':
      return 1
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
    default:
      return 0
  }
}
function YM(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : KM(bM(e))
}
function wn(e) {
  return Ro(e) ? e : ky(e, !1, MM, HM, jC)
}
function WC(e) {
  return ky(e, !1, FM, WM, zC)
}
function Ol(e) {
  return ky(e, !0, LM, qM, HC)
}
function ky(e, t, n, i, r) {
  if (!St(e) || (e.__v_raw && !(t && e.__v_isReactive))) return e
  const s = r.get(e)
  if (s) return s
  const o = YM(e)
  if (o === 0) return e
  const a = new Proxy(e, o === 2 ? i : n)
  return r.set(e, a), a
}
function Io(e) {
  return Ro(e) ? Io(e.__v_raw) : !!(e && e.__v_isReactive)
}
function Ro(e) {
  return !!(e && e.__v_isReadonly)
}
function al(e) {
  return !!(e && e.__v_isShallow)
}
function qC(e) {
  return e ? !!e.__v_raw : !1
}
function ze(e) {
  const t = e && e.__v_raw
  return t ? ze(t) : e
}
function Nf(e) {
  return Object.isExtensible(e) && CC(e, '__v_skip', !0), e
}
const nc = (e) => (St(e) ? wn(e) : e),
  Py = (e) => (St(e) ? Ol(e) : e)
class GC {
  constructor(t, n, i, r) {
    ;(this.getter = t),
      (this._setter = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this.__v_isReadonly = !1),
      (this.effect = new Sy(
        () => t(this._value),
        () => fh(this, this.effect._dirtyLevel === 2 ? 2 : 3)
      )),
      (this.effect.computed = this),
      (this.effect.active = this._cacheable = !r),
      (this.__v_isReadonly = i)
  }
  get value() {
    const t = ze(this)
    return (
      (!t._cacheable || t.effect.dirty) && Vs(t._value, (t._value = t.effect.run())) && fh(t, 4),
      KC(t),
      t.effect._dirtyLevel >= 2 && fh(t, 2),
      t._value
    )
  }
  set value(t) {
    this._setter(t)
  }
  get _dirty() {
    return this.effect.dirty
  }
  set _dirty(t) {
    this.effect.dirty = t
  }
}
function QM(e, t, n = !1) {
  let i, r
  const s = qe(e)
  return s ? ((i = e), (r = Ei)) : ((i = e.get), (r = e.set)), new GC(i, r, s || !r, n)
}
function KC(e) {
  var t
  Ss &&
    bo &&
    ((e = ze(e)), MC(bo, (t = e.dep) != null ? t : (e.dep = FC(() => (e.dep = void 0), e instanceof GC ? e : void 0))))
}
function fh(e, t = 4, n, i) {
  e = ze(e)
  const r = e.dep
  r && LC(r, t)
}
function It(e) {
  return !!(e && e.__v_isRef === !0)
}
function le(e) {
  return YC(e, !1)
}
function ye(e) {
  return YC(e, !0)
}
function YC(e, t) {
  return It(e) ? e : new XM(e, t)
}
class XM {
  constructor(t, n) {
    ;(this.__v_isShallow = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._rawValue = n ? t : ze(t)),
      (this._value = n ? t : nc(t))
  }
  get value() {
    return KC(this), this._value
  }
  set value(t) {
    const n = this.__v_isShallow || al(t) || Ro(t)
    ;(t = n ? t : ze(t)),
      Vs(t, this._rawValue) && (this._rawValue, (this._rawValue = t), (this._value = n ? t : nc(t)), fh(this, 4))
  }
}
function Lt(e) {
  return It(e) ? e.value : e
}
function Er(e) {
  return qe(e) ? e() : Lt(e)
}
const JM = {
  get: (e, t, n) => Lt(Reflect.get(e, t, n)),
  set: (e, t, n, i) => {
    const r = e[t]
    return It(r) && !It(n) ? ((r.value = n), !0) : Reflect.set(e, t, n, i)
  },
}
function QC(e) {
  return Io(e) ? e : new Proxy(e, JM)
}
function js(e) {
  const t = Ue(e) ? new Array(e.length) : {}
  for (const n in e) t[n] = XC(e, n)
  return t
}
class ZM {
  constructor(t, n, i) {
    ;(this._object = t), (this._key = n), (this._defaultValue = i), (this.__v_isRef = !0)
  }
  get value() {
    const t = this._object[this._key]
    return t === void 0 ? this._defaultValue : t
  }
  set value(t) {
    this._object[this._key] = t
  }
  get dep() {
    return xM(ze(this._object), this._key)
  }
}
class eL {
  constructor(t) {
    ;(this._getter = t), (this.__v_isRef = !0), (this.__v_isReadonly = !0)
  }
  get value() {
    return this._getter()
  }
}
function Q(e, t, n) {
  return It(e) ? e : qe(e) ? new eL(e) : St(e) && arguments.length > 1 ? XC(e, t, n) : le(e)
}
function XC(e, t, n) {
  const i = e[t]
  return It(i) ? i : new ZM(e, t, n)
}
/**
 * @vue/runtime-core v3.4.33
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Es(e, t, n, i) {
  try {
    return i ? e(...i) : e()
  } catch (r) {
    Fc(r, t, n)
  }
}
function ki(e, t, n, i) {
  if (qe(e)) {
    const r = Es(e, t, n, i)
    return (
      r &&
        SC(r) &&
        r.catch((s) => {
          Fc(s, t, n)
        }),
      r
    )
  }
  if (Ue(e)) {
    const r = []
    for (let s = 0; s < e.length; s++) r.push(ki(e[s], t, n, i))
    return r
  }
}
function Fc(e, t, n, i = !0) {
  const r = t ? t.vnode : null
  if (t) {
    let s = t.parent
    const o = t.proxy,
      a = `https://vuejs.org/error-reference/#runtime-${n}`
    for (; s; ) {
      const u = s.ec
      if (u) {
        for (let c = 0; c < u.length; c++) if (u[c](e, o, a) === !1) return
      }
      s = s.parent
    }
    const l = t.appContext.config.errorHandler
    if (l) {
      $s(), Es(l, null, 10, [e, o, a]), Us()
      return
    }
  }
  tL(e, n, r, i)
}
function tL(e, t, n, i = !0) {
  console.error(e)
}
let ic = !1,
  Iv = !1
const On = []
let Zi = 0
const Xa = []
let cs = null,
  co = 0
const JC = Promise.resolve()
let Ry = null
function Xe(e) {
  const t = Ry || JC
  return e ? t.then(this ? e.bind(this) : e) : t
}
function nL(e) {
  let t = Zi + 1,
    n = On.length
  for (; t < n; ) {
    const i = (t + n) >>> 1,
      r = On[i],
      s = rc(r)
    s < e || (s === e && r.pre) ? (t = i + 1) : (n = i)
  }
  return t
}
function xy(e) {
  ;(!On.length || !On.includes(e, ic && e.allowRecurse ? Zi + 1 : Zi)) &&
    (e.id == null ? On.push(e) : On.splice(nL(e.id), 0, e), ZC())
}
function ZC() {
  !ic && !Iv && ((Iv = !0), (Ry = JC.then(tA)))
}
function iL(e) {
  const t = On.indexOf(e)
  t > Zi && On.splice(t, 1)
}
function Sv(e) {
  Ue(e) ? Xa.push(...e) : (!cs || !cs.includes(e, e.allowRecurse ? co + 1 : co)) && Xa.push(e), ZC()
}
function SI(e, t, n = ic ? Zi + 1 : 0) {
  for (; n < On.length; n++) {
    const i = On[n]
    if (i && i.pre) {
      if (e && i.id !== e.uid) continue
      On.splice(n, 1), n--, i()
    }
  }
}
function eA(e) {
  if (Xa.length) {
    const t = [...new Set(Xa)].sort((n, i) => rc(n) - rc(i))
    if (((Xa.length = 0), cs)) {
      cs.push(...t)
      return
    }
    for (cs = t, co = 0; co < cs.length; co++) {
      const n = cs[co]
      n.active !== !1 && n()
    }
    ;(cs = null), (co = 0)
  }
}
const rc = (e) => (e.id == null ? 1 / 0 : e.id),
  rL = (e, t) => {
    const n = rc(e) - rc(t)
    if (n === 0) {
      if (e.pre && !t.pre) return -1
      if (t.pre && !e.pre) return 1
    }
    return n
  }
function tA(e) {
  ;(Iv = !1), (ic = !0), On.sort(rL)
  try {
    for (Zi = 0; Zi < On.length; Zi++) {
      const t = On[Zi]
      t && t.active !== !1 && Es(t, t.i, t.i ? 15 : 14)
    }
  } finally {
    ;(Zi = 0), (On.length = 0), eA(), (ic = !1), (Ry = null), (On.length || Xa.length) && tA()
  }
}
let tn = null,
  nA = null
function Nh(e) {
  const t = tn
  return (tn = e), (nA = (e && e.type.__scopeId) || null), t
}
function sL(e, t = tn, n) {
  if (!t || e._n) return e
  const i = (...r) => {
    i._d && BI(-1)
    const s = Nh(t)
    let o
    try {
      o = e(...r)
    } finally {
      Nh(s), i._d && BI(1)
    }
    return o
  }
  return (i._n = !0), (i._c = !0), (i._d = !0), i
}
function Rt(e, t) {
  if (tn === null) return e
  const n = Uf(tn),
    i = e.dirs || (e.dirs = [])
  for (let r = 0; r < t.length; r++) {
    let [s, o, a, l = Vt] = t[r]
    s &&
      (qe(s) && (s = { mounted: s, updated: s }),
      s.deep && ms(o),
      i.push({ dir: s, instance: n, value: o, oldValue: void 0, arg: a, modifiers: l }))
  }
  return e
}
function eo(e, t, n, i) {
  const r = e.dirs,
    s = t && t.dirs
  for (let o = 0; o < r.length; o++) {
    const a = r[o]
    s && (a.oldValue = s[o].value)
    let l = a.dir[i]
    l && ($s(), ki(l, n, 8, [e.el, a, e, t]), Us())
  }
}
const ds = Symbol('_leaveCb'),
  Bd = Symbol('_enterCb')
function iA() {
  const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
  return (
    An(() => {
      e.isMounted = !0
    }),
    kn(() => {
      e.isUnmounting = !0
    }),
    e
  )
}
const Si = [Function, Array],
  rA = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Si,
    onEnter: Si,
    onAfterEnter: Si,
    onEnterCancelled: Si,
    onBeforeLeave: Si,
    onLeave: Si,
    onAfterLeave: Si,
    onLeaveCancelled: Si,
    onBeforeAppear: Si,
    onAppear: Si,
    onAfterAppear: Si,
    onAppearCancelled: Si,
  },
  sA = (e) => {
    const t = e.subTree
    return t.component ? sA(t.component) : t
  },
  oL = {
    name: 'BaseTransition',
    props: rA,
    setup(e, { slots: t }) {
      const n = $c(),
        i = iA()
      return () => {
        const r = t.default && Vy(t.default(), !0)
        if (!r || !r.length) return
        let s = r[0]
        if (r.length > 1) {
          for (const f of r)
            if (f.type !== In) {
              s = f
              break
            }
        }
        const o = ze(e),
          { mode: a } = o
        if (i.isLeaving) return bg(s)
        const l = EI(s)
        if (!l) return bg(s)
        let u = sc(l, o, i, n, (f) => (u = f))
        ll(l, u)
        const c = n.subTree,
          d = c && EI(c)
        if (d && d.type !== In && !er(l, d) && sA(n).type !== In) {
          const f = sc(d, o, i, n)
          if ((ll(d, f), a === 'out-in' && l.type !== In))
            return (
              (i.isLeaving = !0),
              (f.afterLeave = () => {
                ;(i.isLeaving = !1), n.update.active !== !1 && ((n.effect.dirty = !0), n.update())
              }),
              bg(s)
            )
          a === 'in-out' &&
            l.type !== In &&
            (f.delayLeave = (m, p, v) => {
              const y = oA(i, d)
              ;(y[String(d.key)] = d),
                (m[ds] = () => {
                  p(), (m[ds] = void 0), delete u.delayedLeave
                }),
                (u.delayedLeave = v)
            })
        }
        return s
      }
    },
  },
  aL = oL
function oA(e, t) {
  const { leavingVNodes: n } = e
  let i = n.get(t.type)
  return i || ((i = Object.create(null)), n.set(t.type, i)), i
}
function sc(e, t, n, i, r) {
  const {
      appear: s,
      mode: o,
      persisted: a = !1,
      onBeforeEnter: l,
      onEnter: u,
      onAfterEnter: c,
      onEnterCancelled: d,
      onBeforeLeave: f,
      onLeave: m,
      onAfterLeave: p,
      onLeaveCancelled: v,
      onBeforeAppear: y,
      onAppear: T,
      onAfterAppear: A,
      onAppearCancelled: x,
    } = t,
    N = String(e.key),
    V = oA(n, e),
    D = (_, S) => {
      _ && ki(_, i, 9, S)
    },
    I = (_, S) => {
      const E = S[1]
      D(_, S), Ue(_) ? _.every((C) => C.length <= 1) && E() : _.length <= 1 && E()
    },
    w = {
      mode: o,
      persisted: a,
      beforeEnter(_) {
        let S = l
        if (!n.isMounted)
          if (s) S = y || l
          else return
        _[ds] && _[ds](!0)
        const E = V[N]
        E && er(e, E) && E.el[ds] && E.el[ds](), D(S, [_])
      },
      enter(_) {
        let S = u,
          E = c,
          C = d
        if (!n.isMounted)
          if (s) (S = T || u), (E = A || c), (C = x || d)
          else return
        let R = !1
        const B = (_[Bd] = (U) => {
          R || ((R = !0), U ? D(C, [_]) : D(E, [_]), w.delayedLeave && w.delayedLeave(), (_[Bd] = void 0))
        })
        S ? I(S, [_, B]) : B()
      },
      leave(_, S) {
        const E = String(e.key)
        if ((_[Bd] && _[Bd](!0), n.isUnmounting)) return S()
        D(f, [_])
        let C = !1
        const R = (_[ds] = (B) => {
          C || ((C = !0), S(), B ? D(v, [_]) : D(p, [_]), (_[ds] = void 0), V[E] === e && delete V[E])
        })
        ;(V[E] = e), m ? I(m, [_, R]) : R()
      },
      clone(_) {
        const S = sc(_, t, n, i, r)
        return r && r(S), S
      },
    }
  return w
}
function bg(e) {
  if (Mf(e)) return (e = Nr(e)), (e.children = null), e
}
function EI(e) {
  if (!Mf(e)) return e
  const { shapeFlag: t, children: n } = e
  if (n) {
    if (t & 16) return n[0]
    if (t & 32 && qe(n.default)) return n.default()
  }
}
function ll(e, t) {
  e.shapeFlag & 6 && e.component
    ? ll(e.component.subTree, t)
    : e.shapeFlag & 128
    ? ((e.ssContent.transition = t.clone(e.ssContent)), (e.ssFallback.transition = t.clone(e.ssFallback)))
    : (e.transition = t)
}
function Vy(e, t = !1, n) {
  let i = [],
    r = 0
  for (let s = 0; s < e.length; s++) {
    let o = e[s]
    const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s)
    o.type === ke
      ? (o.patchFlag & 128 && r++, (i = i.concat(Vy(o.children, t, a))))
      : (t || o.type !== In) && i.push(a != null ? Nr(o, { key: a }) : o)
  }
  if (r > 1) for (let s = 0; s < i.length; s++) i[s].patchFlag = -2
  return i
}
/*! #__NO_SIDE_EFFECTS__ */ function Of(e, t) {
  return qe(e) ? rn({ name: e.name }, t, { setup: e }) : e
}
const Lu = (e) => !!e.type.__asyncLoader,
  Mf = (e) => e.type.__isKeepAlive
function aA(e, t) {
  uA(e, 'a', t)
}
function lA(e, t) {
  uA(e, 'da', t)
}
function uA(e, t, n = dn) {
  const i =
    e.__wdc ||
    (e.__wdc = () => {
      let r = n
      for (; r; ) {
        if (r.isDeactivated) return
        r = r.parent
      }
      return e()
    })
  if ((Lf(t, i, n), n)) {
    let r = n.parent
    for (; r && r.parent; ) Mf(r.parent.vnode) && lL(i, t, n, r), (r = r.parent)
  }
}
function lL(e, t, n, i) {
  const r = Lf(t, e, i, !0)
  Oy(() => {
    by(i[t], r)
  }, n)
}
function Lf(e, t, n = dn, i = !1) {
  if (n) {
    const r = n[e] || (n[e] = []),
      s =
        t.__weh ||
        (t.__weh = (...o) => {
          $s()
          const a = Uc(n),
            l = ki(t, n, e, o)
          return a(), Us(), l
        })
    return i ? r.unshift(s) : r.push(s), s
  }
}
const jr =
    (e) =>
    (t, n = dn) => {
      ;(!$f || e === 'sp') && Lf(e, (...i) => t(...i), n)
    },
  Dy = jr('bm'),
  An = jr('m'),
  cA = jr('bu'),
  Ny = jr('u'),
  kn = jr('bum'),
  Oy = jr('um'),
  dA = jr('sp'),
  uL = jr('rtg'),
  cL = jr('rtc')
function dL(e, t = dn) {
  Lf('ec', e, t)
}
const My = 'components',
  hL = 'directives'
function fL(e, t) {
  return Ly(My, e, !0, t) || e
}
const hA = Symbol.for('v-ndc')
function mL(e) {
  return Bt(e) ? Ly(My, e, !1) || e : e || hA
}
function pi(e) {
  return Ly(hL, e)
}
function Ly(e, t, n = !0, i = !1) {
  const r = tn || dn
  if (r) {
    const s = r.type
    if (e === My) {
      const a = cF(s, !1)
      if (a && (a === t || a === gi(t) || a === gr(gi(t)))) return s
    }
    const o = TI(r[e] || s[e], t) || TI(r.appContext[e], t)
    return !o && i ? s : o
  }
}
function TI(e, t) {
  return e && (e[t] || e[gi(t)] || e[gr(gi(t))])
}
function Dte(e, t, n, i) {
  let r
  const s = n
  if (Ue(e) || Bt(e)) {
    r = new Array(e.length)
    for (let o = 0, a = e.length; o < a; o++) r[o] = t(e[o], o, void 0, s)
  } else if (typeof e == 'number') {
    r = new Array(e)
    for (let o = 0; o < e; o++) r[o] = t(o + 1, o, void 0, s)
  } else if (St(e))
    if (e[Symbol.iterator]) r = Array.from(e, (o, a) => t(o, a, void 0, s))
    else {
      const o = Object.keys(e)
      r = new Array(o.length)
      for (let a = 0, l = o.length; a < l; a++) {
        const u = o[a]
        r[a] = t(e[u], u, a, s)
      }
    }
  else r = []
  return r
}
function Nte(e, t) {
  for (let n = 0; n < t.length; n++) {
    const i = t[n]
    if (Ue(i)) for (let r = 0; r < i.length; r++) e[i[r].name] = i[r].fn
    else
      i &&
        (e[i.name] = i.key
          ? (...r) => {
              const s = i.fn(...r)
              return s && (s.key = i.key), s
            }
          : i.fn)
  }
  return e
}
function Ote(e, t, n = {}, i, r) {
  if (tn.isCE || (tn.parent && Lu(tn.parent) && tn.parent.isCE)) return t !== 'default' && (n.name = t), g('slot', n, i)
  let s = e[t]
  s && s._c && (s._d = !1), Bf()
  const o = s && fA(s(n)),
    a = zy(ke, { key: (n.key || (o && o.key) || `_${t}`) + (!o && i ? '_fb' : '') }, o || [], o && e._ === 1 ? 64 : -2)
  return a.scopeId && (a.slotScopeIds = [a.scopeId + '-s']), s && s._c && (s._d = !0), a
}
function fA(e) {
  return e.some((t) => (cl(t) ? !(t.type === In || (t.type === ke && !fA(t.children))) : !0)) ? e : null
}
const Ev = (e) => (e ? (MA(e) ? Uf(e) : Ev(e.parent)) : null),
  Fu = rn(Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => Ev(e.parent),
    $root: (e) => Ev(e.root),
    $emit: (e) => e.emit,
    $options: (e) => Fy(e),
    $forceUpdate: (e) =>
      e.f ||
      (e.f = () => {
        ;(e.effect.dirty = !0), xy(e.update)
      }),
    $nextTick: (e) => e.n || (e.n = Xe.bind(e.proxy)),
    $watch: (e) => $L.bind(e),
  }),
  wg = (e, t) => e !== Vt && !e.__isScriptSetup && ut(e, t),
  gL = {
    get({ _: e }, t) {
      if (t === '__v_skip') return !0
      const { ctx: n, setupState: i, data: r, props: s, accessCache: o, type: a, appContext: l } = e
      let u
      if (t[0] !== '$') {
        const m = o[t]
        if (m !== void 0)
          switch (m) {
            case 1:
              return i[t]
            case 2:
              return r[t]
            case 4:
              return n[t]
            case 3:
              return s[t]
          }
        else {
          if (wg(i, t)) return (o[t] = 1), i[t]
          if (r !== Vt && ut(r, t)) return (o[t] = 2), r[t]
          if ((u = e.propsOptions[0]) && ut(u, t)) return (o[t] = 3), s[t]
          if (n !== Vt && ut(n, t)) return (o[t] = 4), n[t]
          Tv && (o[t] = 0)
        }
      }
      const c = Fu[t]
      let d, f
      if (c) return t === '$attrs' && ri(e.attrs, 'get', ''), c(e)
      if ((d = a.__cssModules) && (d = d[t])) return d
      if (n !== Vt && ut(n, t)) return (o[t] = 4), n[t]
      if (((f = l.config.globalProperties), ut(f, t))) return f[t]
    },
    set({ _: e }, t, n) {
      const { data: i, setupState: r, ctx: s } = e
      return wg(r, t)
        ? ((r[t] = n), !0)
        : i !== Vt && ut(i, t)
        ? ((i[t] = n), !0)
        : ut(e.props, t) || (t[0] === '$' && t.slice(1) in e)
        ? !1
        : ((s[t] = n), !0)
    },
    has({ _: { data: e, setupState: t, accessCache: n, ctx: i, appContext: r, propsOptions: s } }, o) {
      let a
      return (
        !!n[o] ||
        (e !== Vt && ut(e, o)) ||
        wg(t, o) ||
        ((a = s[0]) && ut(a, o)) ||
        ut(i, o) ||
        ut(Fu, o) ||
        ut(r.config.globalProperties, o)
      )
    },
    defineProperty(e, t, n) {
      return (
        n.get != null ? (e._.accessCache[t] = 0) : ut(n, 'value') && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
      )
    },
  }
function CI(e) {
  return Ue(e) ? e.reduce((t, n) => ((t[n] = null), t), {}) : e
}
let Tv = !0
function vL(e) {
  const t = Fy(e),
    n = e.proxy,
    i = e.ctx
  ;(Tv = !1), t.beforeCreate && AI(t.beforeCreate, e, 'bc')
  const {
    data: r,
    computed: s,
    methods: o,
    watch: a,
    provide: l,
    inject: u,
    created: c,
    beforeMount: d,
    mounted: f,
    beforeUpdate: m,
    updated: p,
    activated: v,
    deactivated: y,
    beforeDestroy: T,
    beforeUnmount: A,
    destroyed: x,
    unmounted: N,
    render: V,
    renderTracked: D,
    renderTriggered: I,
    errorCaptured: w,
    serverPrefetch: _,
    expose: S,
    inheritAttrs: E,
    components: C,
    directives: R,
    filters: B,
  } = t
  if ((u && pL(u, i, null), o))
    for (const G in o) {
      const F = o[G]
      qe(F) && (i[G] = F.bind(n))
    }
  if (r) {
    const G = r.call(n, n)
    St(G) && (e.data = wn(G))
  }
  if (((Tv = !0), s))
    for (const G in s) {
      const F = s[G],
        K = qe(F) ? F.bind(n, n) : qe(F.get) ? F.get.bind(n, n) : Ei,
        j = !qe(F) && qe(F.set) ? F.set.bind(n) : Ei,
        q = k({ get: K, set: j })
      Object.defineProperty(i, G, { enumerable: !0, configurable: !0, get: () => q.value, set: (te) => (q.value = te) })
    }
  if (a) for (const G in a) mA(a[G], i, n, G)
  if (l) {
    const G = qe(l) ? l.call(n) : l
    Reflect.ownKeys(G).forEach((F) => {
      mt(F, G[F])
    })
  }
  c && AI(c, e, 'c')
  function $(G, F) {
    Ue(F) ? F.forEach((K) => G(K.bind(n))) : F && G(F.bind(n))
  }
  if (
    ($(Dy, d),
    $(An, f),
    $(cA, m),
    $(Ny, p),
    $(aA, v),
    $(lA, y),
    $(dL, w),
    $(cL, D),
    $(uL, I),
    $(kn, A),
    $(Oy, N),
    $(dA, _),
    Ue(S))
  )
    if (S.length) {
      const G = e.exposed || (e.exposed = {})
      S.forEach((F) => {
        Object.defineProperty(G, F, { get: () => n[F], set: (K) => (n[F] = K) })
      })
    } else e.exposed || (e.exposed = {})
  V && e.render === Ei && (e.render = V),
    E != null && (e.inheritAttrs = E),
    C && (e.components = C),
    R && (e.directives = R)
}
function pL(e, t, n = Ei) {
  Ue(e) && (e = Cv(e))
  for (const i in e) {
    const r = e[i]
    let s
    St(r) ? ('default' in r ? (s = je(r.from || i, r.default, !0)) : (s = je(r.from || i))) : (s = je(r)),
      It(s)
        ? Object.defineProperty(t, i, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: (o) => (s.value = o),
          })
        : (t[i] = s)
  }
}
function AI(e, t, n) {
  ki(Ue(e) ? e.map((i) => i.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function mA(e, t, n, i) {
  const r = i.includes('.') ? kA(n, i) : () => n[i]
  if (Bt(e)) {
    const s = t[e]
    qe(s) && be(r, s)
  } else if (qe(e)) be(r, e.bind(n))
  else if (St(e))
    if (Ue(e)) e.forEach((s) => mA(s, t, n, i))
    else {
      const s = qe(e.handler) ? e.handler.bind(n) : t[e.handler]
      qe(s) && be(r, s, e)
    }
}
function Fy(e) {
  const t = e.type,
    { mixins: n, extends: i } = t,
    {
      mixins: r,
      optionsCache: s,
      config: { optionMergeStrategies: o },
    } = e.appContext,
    a = s.get(t)
  let l
  return (
    a
      ? (l = a)
      : !r.length && !n && !i
      ? (l = t)
      : ((l = {}), r.length && r.forEach((u) => Oh(l, u, o, !0)), Oh(l, t, o)),
    St(t) && s.set(t, l),
    l
  )
}
function Oh(e, t, n, i = !1) {
  const { mixins: r, extends: s } = t
  s && Oh(e, s, n, !0), r && r.forEach((o) => Oh(e, o, n, !0))
  for (const o in t)
    if (!(i && o === 'expose')) {
      const a = yL[o] || (n && n[o])
      e[o] = a ? a(e[o], t[o]) : t[o]
    }
  return e
}
const yL = {
  data: kI,
  props: PI,
  emits: PI,
  methods: Tu,
  computed: Tu,
  beforeCreate: Wn,
  created: Wn,
  beforeMount: Wn,
  mounted: Wn,
  beforeUpdate: Wn,
  updated: Wn,
  beforeDestroy: Wn,
  beforeUnmount: Wn,
  destroyed: Wn,
  unmounted: Wn,
  activated: Wn,
  deactivated: Wn,
  errorCaptured: Wn,
  serverPrefetch: Wn,
  components: Tu,
  directives: Tu,
  watch: bL,
  provide: kI,
  inject: _L,
}
function kI(e, t) {
  return t
    ? e
      ? function () {
          return rn(qe(e) ? e.call(this, this) : e, qe(t) ? t.call(this, this) : t)
        }
      : t
    : e
}
function _L(e, t) {
  return Tu(Cv(e), Cv(t))
}
function Cv(e) {
  if (Ue(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n]
    return t
  }
  return e
}
function Wn(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}
function Tu(e, t) {
  return e ? rn(Object.create(null), e, t) : t
}
function PI(e, t) {
  return e ? (Ue(e) && Ue(t) ? [...new Set([...e, ...t])] : rn(Object.create(null), CI(e), CI(t ?? {}))) : t
}
function bL(e, t) {
  if (!e) return t
  if (!t) return e
  const n = rn(Object.create(null), e)
  for (const i in t) n[i] = Wn(e[i], t[i])
  return n
}
function gA() {
  return {
    app: null,
    config: {
      isNativeTag: yM,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap(),
  }
}
let wL = 0
function IL(e, t) {
  return function (i, r = null) {
    qe(i) || (i = rn({}, i)), r != null && !St(r) && (r = null)
    const s = gA(),
      o = new WeakSet()
    let a = !1
    const l = (s.app = {
      _uid: wL++,
      _component: i,
      _props: r,
      _container: null,
      _context: s,
      _instance: null,
      version: hF,
      get config() {
        return s.config
      },
      set config(u) {},
      use(u, ...c) {
        return o.has(u) || (u && qe(u.install) ? (o.add(u), u.install(l, ...c)) : qe(u) && (o.add(u), u(l, ...c))), l
      },
      mixin(u) {
        return s.mixins.includes(u) || s.mixins.push(u), l
      },
      component(u, c) {
        return c ? ((s.components[u] = c), l) : s.components[u]
      },
      directive(u, c) {
        return c ? ((s.directives[u] = c), l) : s.directives[u]
      },
      mount(u, c, d) {
        if (!a) {
          const f = g(i, r)
          return (
            (f.appContext = s),
            d === !0 ? (d = 'svg') : d === !1 && (d = void 0),
            c && t ? t(f, u) : e(f, u, d),
            (a = !0),
            (l._container = u),
            (u.__vue_app__ = l),
            Uf(f.component)
          )
        }
      },
      unmount() {
        a && (e(null, l._container), delete l._container.__vue_app__)
      },
      provide(u, c) {
        return (s.provides[u] = c), l
      },
      runWithContext(u) {
        const c = Ja
        Ja = l
        try {
          return u()
        } finally {
          Ja = c
        }
      },
    })
    return l
  }
}
let Ja = null
function mt(e, t) {
  if (dn) {
    let n = dn.provides
    const i = dn.parent && dn.parent.provides
    i === n && (n = dn.provides = Object.create(i)), (n[e] = t)
  }
}
function je(e, t, n = !1) {
  const i = dn || tn
  if (i || Ja) {
    const r = i
      ? i.parent == null
        ? i.vnode.appContext && i.vnode.appContext.provides
        : i.parent.provides
      : Ja._context.provides
    if (r && e in r) return r[e]
    if (arguments.length > 1) return n && qe(t) ? t.call(i && i.proxy) : t
  }
}
function SL() {
  return !!(dn || tn || Ja)
}
const vA = {},
  pA = () => Object.create(vA),
  yA = (e) => Object.getPrototypeOf(e) === vA
function EL(e, t, n, i = !1) {
  const r = {},
    s = pA()
  ;(e.propsDefaults = Object.create(null)), _A(e, t, r, s)
  for (const o in e.propsOptions[0]) o in r || (r[o] = void 0)
  n ? (e.props = i ? r : WC(r)) : e.type.props ? (e.props = r) : (e.props = s), (e.attrs = s)
}
function TL(e, t, n, i) {
  const {
      props: r,
      attrs: s,
      vnode: { patchFlag: o },
    } = e,
    a = ze(r),
    [l] = e.propsOptions
  let u = !1
  if ((i || o > 0) && !(o & 16)) {
    if (o & 8) {
      const c = e.vnode.dynamicProps
      for (let d = 0; d < c.length; d++) {
        let f = c[d]
        if (Ff(e.emitsOptions, f)) continue
        const m = t[f]
        if (l)
          if (ut(s, f)) m !== s[f] && ((s[f] = m), (u = !0))
          else {
            const p = gi(f)
            r[p] = Av(l, a, p, m, e, !1)
          }
        else m !== s[f] && ((s[f] = m), (u = !0))
      }
    }
  } else {
    _A(e, t, r, s) && (u = !0)
    let c
    for (const d in a)
      (!t || (!ut(t, d) && ((c = ta(d)) === d || !ut(t, c)))) &&
        (l ? n && (n[d] !== void 0 || n[c] !== void 0) && (r[d] = Av(l, a, d, void 0, e, !0)) : delete r[d])
    if (s !== a) for (const d in s) (!t || !ut(t, d)) && (delete s[d], (u = !0))
  }
  u && Vr(e.attrs, 'set', '')
}
function _A(e, t, n, i) {
  const [r, s] = e.propsOptions
  let o = !1,
    a
  if (t)
    for (let l in t) {
      if (Mu(l)) continue
      const u = t[l]
      let c
      r && ut(r, (c = gi(l)))
        ? !s || !s.includes(c)
          ? (n[c] = u)
          : ((a || (a = {}))[c] = u)
        : Ff(e.emitsOptions, l) || ((!(l in i) || u !== i[l]) && ((i[l] = u), (o = !0)))
    }
  if (s) {
    const l = ze(n),
      u = a || Vt
    for (let c = 0; c < s.length; c++) {
      const d = s[c]
      n[d] = Av(r, l, d, u[d], e, !ut(u, d))
    }
  }
  return o
}
function Av(e, t, n, i, r, s) {
  const o = e[n]
  if (o != null) {
    const a = ut(o, 'default')
    if (a && i === void 0) {
      const l = o.default
      if (o.type !== Function && !o.skipFactory && qe(l)) {
        const { propsDefaults: u } = r
        if (n in u) i = u[n]
        else {
          const c = Uc(r)
          ;(i = u[n] = l.call(null, t)), c()
        }
      } else i = l
    }
    o[0] && (s && !a ? (i = !1) : o[1] && (i === '' || i === ta(n)) && (i = !0))
  }
  return i
}
const CL = new WeakMap()
function bA(e, t, n = !1) {
  const i = n ? CL : t.propsCache,
    r = i.get(e)
  if (r) return r
  const s = e.props,
    o = {},
    a = []
  let l = !1
  if (!qe(e)) {
    const c = (d) => {
      l = !0
      const [f, m] = bA(d, t, !0)
      rn(o, f), m && a.push(...m)
    }
    !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c)
  }
  if (!s && !l) return St(e) && i.set(e, Ya), Ya
  if (Ue(s))
    for (let c = 0; c < s.length; c++) {
      const d = gi(s[c])
      RI(d) && (o[d] = Vt)
    }
  else if (s)
    for (const c in s) {
      const d = gi(c)
      if (RI(d)) {
        const f = s[c],
          m = (o[d] = Ue(f) || qe(f) ? { type: f } : rn({}, f))
        if (m) {
          const p = DI(Boolean, m.type),
            v = DI(String, m.type)
          ;(m[0] = p > -1), (m[1] = v < 0 || p < v), (p > -1 || ut(m, 'default')) && a.push(d)
        }
      }
    }
  const u = [o, a]
  return St(e) && i.set(e, u), u
}
function RI(e) {
  return e[0] !== '$' && !Mu(e)
}
function xI(e) {
  return e === null
    ? 'null'
    : typeof e == 'function'
    ? e.name || ''
    : (typeof e == 'object' && e.constructor && e.constructor.name) || ''
}
function VI(e, t) {
  return xI(e) === xI(t)
}
function DI(e, t) {
  return Ue(t) ? t.findIndex((n) => VI(n, e)) : qe(t) && VI(t, e) ? 0 : -1
}
const wA = (e) => e[0] === '_' || e === '$stable',
  By = (e) => (Ue(e) ? e.map($i) : [$i(e)]),
  AL = (e, t, n) => {
    if (t._n) return t
    const i = sL((...r) => By(t(...r)), n)
    return (i._c = !1), i
  },
  IA = (e, t, n) => {
    const i = e._ctx
    for (const r in e) {
      if (wA(r)) continue
      const s = e[r]
      if (qe(s)) t[r] = AL(r, s, i)
      else if (s != null) {
        const o = By(s)
        t[r] = () => o
      }
    }
  },
  SA = (e, t) => {
    const n = By(t)
    e.slots.default = () => n
  },
  EA = (e, t, n) => {
    for (const i in t) (n || i !== '_') && (e[i] = t[i])
  },
  kL = (e, t, n) => {
    const i = (e.slots = pA())
    if (e.vnode.shapeFlag & 32) {
      const r = t._
      r ? (EA(i, t, n), n && CC(i, '_', r, !0)) : IA(t, i)
    } else t && SA(e, t)
  },
  PL = (e, t, n) => {
    const { vnode: i, slots: r } = e
    let s = !0,
      o = Vt
    if (i.shapeFlag & 32) {
      const a = t._
      a ? (n && a === 1 ? (s = !1) : EA(r, t, n)) : ((s = !t.$stable), IA(t, r)), (o = t)
    } else t && (SA(e, t), (o = { default: 1 }))
    if (s) for (const a in r) !wA(a) && o[a] == null && delete r[a]
  }
function kv(e, t, n, i, r = !1) {
  if (Ue(e)) {
    e.forEach((f, m) => kv(f, t && (Ue(t) ? t[m] : t), n, i, r))
    return
  }
  if (Lu(i) && !r) return
  const s = i.shapeFlag & 4 ? Uf(i.component) : i.el,
    o = r ? null : s,
    { i: a, r: l } = e,
    u = t && t.r,
    c = a.refs === Vt ? (a.refs = {}) : a.refs,
    d = a.setupState
  if ((u != null && u !== l && (Bt(u) ? ((c[u] = null), ut(d, u) && (d[u] = null)) : It(u) && (u.value = null)), qe(l)))
    Es(l, a, 12, [o, c])
  else {
    const f = Bt(l),
      m = It(l)
    if (f || m) {
      const p = () => {
        if (e.f) {
          const v = f ? (ut(d, l) ? d[l] : c[l]) : l.value
          r
            ? Ue(v) && by(v, s)
            : Ue(v)
            ? v.includes(s) || v.push(s)
            : f
            ? ((c[l] = [s]), ut(d, l) && (d[l] = c[l]))
            : ((l.value = [s]), e.k && (c[e.k] = l.value))
        } else f ? ((c[l] = o), ut(d, l) && (d[l] = o)) : m && ((l.value = o), e.k && (c[e.k] = o))
      }
      o ? ((p.id = -1), Jn(p, n)) : p()
    }
  }
}
const TA = Symbol('_vte'),
  RL = (e) => e.__isTeleport,
  Bu = (e) => e && (e.disabled || e.disabled === ''),
  NI = (e) => typeof SVGElement < 'u' && e instanceof SVGElement,
  OI = (e) => typeof MathMLElement == 'function' && e instanceof MathMLElement,
  Pv = (e, t) => {
    const n = e && e.to
    return Bt(n) ? (t ? t(n) : null) : n
  },
  xL = {
    name: 'Teleport',
    __isTeleport: !0,
    process(e, t, n, i, r, s, o, a, l, u) {
      const {
          mc: c,
          pc: d,
          pbc: f,
          o: { insert: m, querySelector: p, createText: v, createComment: y },
        } = u,
        T = Bu(t.props)
      let { shapeFlag: A, children: x, dynamicChildren: N } = t
      if (e == null) {
        const V = (t.el = v('')),
          D = (t.anchor = v('')),
          I = (t.target = Pv(t.props, p)),
          w = (t.targetStart = v('')),
          _ = (t.targetAnchor = v(''))
        m(V, n, i),
          m(D, n, i),
          (w[TA] = _),
          I && (m(w, I), m(_, I), o === 'svg' || NI(I) ? (o = 'svg') : (o === 'mathml' || OI(I)) && (o = 'mathml'))
        const S = (E, C) => {
          A & 16 && c(x, E, C, r, s, o, a, l)
        }
        T ? S(n, D) : I && S(I, _)
      } else {
        ;(t.el = e.el), (t.targetStart = e.targetStart)
        const V = (t.anchor = e.anchor),
          D = (t.target = e.target),
          I = (t.targetAnchor = e.targetAnchor),
          w = Bu(e.props),
          _ = w ? n : D,
          S = w ? V : I
        if (
          (o === 'svg' || NI(D) ? (o = 'svg') : (o === 'mathml' || OI(D)) && (o = 'mathml'),
          N ? (f(e.dynamicChildren, N, _, r, s, o, a), $y(e, t, !0)) : l || d(e, t, _, S, r, s, o, a, !1),
          T)
        )
          w ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : $d(t, n, V, u, 1)
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const E = (t.target = Pv(t.props, p))
          E && $d(t, E, null, u, 0)
        } else w && $d(t, D, I, u, 1)
      }
      CA(t)
    },
    remove(e, t, n, { um: i, o: { remove: r } }, s) {
      const { shapeFlag: o, children: a, anchor: l, targetStart: u, targetAnchor: c, target: d, props: f } = e
      if ((d && (r(u), r(c)), s && r(l), o & 16)) {
        const m = s || !Bu(f)
        for (let p = 0; p < a.length; p++) {
          const v = a[p]
          i(v, t, n, m, !!v.dynamicChildren)
        }
      }
    },
    move: $d,
    hydrate: VL,
  }
function $d(e, t, n, { o: { insert: i }, m: r }, s = 2) {
  s === 0 && i(e.targetAnchor, t, n)
  const { el: o, anchor: a, shapeFlag: l, children: u, props: c } = e,
    d = s === 2
  if ((d && i(o, t, n), (!d || Bu(c)) && l & 16)) for (let f = 0; f < u.length; f++) r(u[f], t, n, 2)
  d && i(a, t, n)
}
function VL(e, t, n, i, r, s, { o: { nextSibling: o, parentNode: a, querySelector: l } }, u) {
  const c = (t.target = Pv(t.props, l))
  if (c) {
    const d = c._lpa || c.firstChild
    if (t.shapeFlag & 16)
      if (Bu(t.props)) (t.anchor = u(o(e), t, a(e), n, i, r, s)), (t.targetAnchor = d)
      else {
        t.anchor = o(e)
        let f = d
        for (; f; )
          if (((f = o(f)), f && f.nodeType === 8 && f.data === 'teleport anchor')) {
            ;(t.targetAnchor = f), (c._lpa = t.targetAnchor && o(t.targetAnchor))
            break
          }
        u(d, t, c, n, i, r, s)
      }
    CA(t)
  }
  return t.anchor && o(t.anchor)
}
const DL = xL
function CA(e) {
  const t = e.ctx
  if (t && t.ut) {
    let n = e.children[0].el
    for (; n && n !== e.targetAnchor; ) n.nodeType === 1 && n.setAttribute('data-v-owner', t.uid), (n = n.nextSibling)
    t.ut()
  }
}
const Jn = ZL
function NL(e) {
  return OL(e)
}
function OL(e, t) {
  const n = kC()
  n.__VUE__ = !0
  const {
      insert: i,
      remove: r,
      patchProp: s,
      createElement: o,
      createText: a,
      createComment: l,
      setText: u,
      setElementText: c,
      parentNode: d,
      nextSibling: f,
      setScopeId: m = Ei,
      insertStaticContent: p,
    } = e,
    v = (O, L, H, X = null, ee = null, he = null, ge = void 0, Ie = null, _e = !!L.dynamicChildren) => {
      if (O === L) return
      O && !er(O, L) && ((X = z(O)), te(O, ee, he, !0), (O = null)),
        L.patchFlag === -2 && ((_e = !1), (L.dynamicChildren = null))
      const { type: ve, ref: Ae, shapeFlag: Ne } = L
      switch (ve) {
        case Bc:
          y(O, L, H, X)
          break
        case In:
          T(O, L, H, X)
          break
        case Eg:
          O == null && A(L, H, X, ge)
          break
        case ke:
          C(O, L, H, X, ee, he, ge, Ie, _e)
          break
        default:
          Ne & 1
            ? V(O, L, H, X, ee, he, ge, Ie, _e)
            : Ne & 6
            ? R(O, L, H, X, ee, he, ge, Ie, _e)
            : (Ne & 64 || Ne & 128) && ve.process(O, L, H, X, ee, he, ge, Ie, _e, Z)
      }
      Ae != null && ee && kv(Ae, O && O.ref, he, L || O, !L)
    },
    y = (O, L, H, X) => {
      if (O == null) i((L.el = a(L.children)), H, X)
      else {
        const ee = (L.el = O.el)
        L.children !== O.children && u(ee, L.children)
      }
    },
    T = (O, L, H, X) => {
      O == null ? i((L.el = l(L.children || '')), H, X) : (L.el = O.el)
    },
    A = (O, L, H, X) => {
      ;[O.el, O.anchor] = p(O.children, L, H, X, O.el, O.anchor)
    },
    x = ({ el: O, anchor: L }, H, X) => {
      let ee
      for (; O && O !== L; ) (ee = f(O)), i(O, H, X), (O = ee)
      i(L, H, X)
    },
    N = ({ el: O, anchor: L }) => {
      let H
      for (; O && O !== L; ) (H = f(O)), r(O), (O = H)
      r(L)
    },
    V = (O, L, H, X, ee, he, ge, Ie, _e) => {
      L.type === 'svg' ? (ge = 'svg') : L.type === 'math' && (ge = 'mathml'),
        O == null ? D(L, H, X, ee, he, ge, Ie, _e) : _(O, L, ee, he, ge, Ie, _e)
    },
    D = (O, L, H, X, ee, he, ge, Ie) => {
      let _e, ve
      const { props: Ae, shapeFlag: Ne, transition: De, dirs: Me } = O
      if (
        ((_e = O.el = o(O.type, he, Ae && Ae.is, Ae)),
        Ne & 8 ? c(_e, O.children) : Ne & 16 && w(O.children, _e, null, X, ee, Ig(O, he), ge, Ie),
        Me && eo(O, null, X, 'created'),
        I(_e, O, O.scopeId, ge, X),
        Ae)
      ) {
        for (const ht in Ae) ht !== 'value' && !Mu(ht) && s(_e, ht, null, Ae[ht], he, X)
        'value' in Ae && s(_e, 'value', null, Ae.value, he), (ve = Ae.onVnodeBeforeMount) && Ji(ve, X, O)
      }
      Me && eo(O, null, X, 'beforeMount')
      const Be = ML(ee, De)
      Be && De.beforeEnter(_e),
        i(_e, L, H),
        ((ve = Ae && Ae.onVnodeMounted) || Be || Me) &&
          Jn(() => {
            ve && Ji(ve, X, O), Be && De.enter(_e), Me && eo(O, null, X, 'mounted')
          }, ee)
    },
    I = (O, L, H, X, ee) => {
      if ((H && m(O, H), X)) for (let he = 0; he < X.length; he++) m(O, X[he])
      if (ee) {
        let he = ee.subTree
        if (L === he) {
          const ge = ee.vnode
          I(O, ge, ge.scopeId, ge.slotScopeIds, ee.parent)
        }
      }
    },
    w = (O, L, H, X, ee, he, ge, Ie, _e = 0) => {
      for (let ve = _e; ve < O.length; ve++) {
        const Ae = (O[ve] = Ie ? hs(O[ve]) : $i(O[ve]))
        v(null, Ae, L, H, X, ee, he, ge, Ie)
      }
    },
    _ = (O, L, H, X, ee, he, ge) => {
      const Ie = (L.el = O.el)
      let { patchFlag: _e, dynamicChildren: ve, dirs: Ae } = L
      _e |= O.patchFlag & 16
      const Ne = O.props || Vt,
        De = L.props || Vt
      let Me
      if (
        (H && to(H, !1),
        (Me = De.onVnodeBeforeUpdate) && Ji(Me, H, L, O),
        Ae && eo(L, O, H, 'beforeUpdate'),
        H && to(H, !0),
        ((Ne.innerHTML && De.innerHTML == null) || (Ne.textContent && De.textContent == null)) && c(Ie, ''),
        ve ? S(O.dynamicChildren, ve, Ie, H, X, Ig(L, ee), he) : ge || F(O, L, Ie, null, H, X, Ig(L, ee), he, !1),
        _e > 0)
      ) {
        if (_e & 16) E(Ie, Ne, De, H, ee)
        else if (
          (_e & 2 && Ne.class !== De.class && s(Ie, 'class', null, De.class, ee),
          _e & 4 && s(Ie, 'style', Ne.style, De.style, ee),
          _e & 8)
        ) {
          const Be = L.dynamicProps
          for (let ht = 0; ht < Be.length; ht++) {
            const lt = Be[ht],
              Yt = Ne[lt],
              si = De[lt]
            ;(si !== Yt || lt === 'value') && s(Ie, lt, Yt, si, ee, H)
          }
        }
        _e & 1 && O.children !== L.children && c(Ie, L.children)
      } else !ge && ve == null && E(Ie, Ne, De, H, ee)
      ;((Me = De.onVnodeUpdated) || Ae) &&
        Jn(() => {
          Me && Ji(Me, H, L, O), Ae && eo(L, O, H, 'updated')
        }, X)
    },
    S = (O, L, H, X, ee, he, ge) => {
      for (let Ie = 0; Ie < L.length; Ie++) {
        const _e = O[Ie],
          ve = L[Ie],
          Ae = _e.el && (_e.type === ke || !er(_e, ve) || _e.shapeFlag & 70) ? d(_e.el) : H
        v(_e, ve, Ae, null, X, ee, he, ge, !0)
      }
    },
    E = (O, L, H, X, ee) => {
      if (L !== H) {
        if (L !== Vt) for (const he in L) !Mu(he) && !(he in H) && s(O, he, L[he], null, ee, X)
        for (const he in H) {
          if (Mu(he)) continue
          const ge = H[he],
            Ie = L[he]
          ge !== Ie && he !== 'value' && s(O, he, Ie, ge, ee, X)
        }
        'value' in H && s(O, 'value', L.value, H.value, ee)
      }
    },
    C = (O, L, H, X, ee, he, ge, Ie, _e) => {
      const ve = (L.el = O ? O.el : a('')),
        Ae = (L.anchor = O ? O.anchor : a(''))
      let { patchFlag: Ne, dynamicChildren: De, slotScopeIds: Me } = L
      Me && (Ie = Ie ? Ie.concat(Me) : Me),
        O == null
          ? (i(ve, H, X), i(Ae, H, X), w(L.children || [], H, Ae, ee, he, ge, Ie, _e))
          : Ne > 0 && Ne & 64 && De && O.dynamicChildren
          ? (S(O.dynamicChildren, De, H, ee, he, ge, Ie), (L.key != null || (ee && L === ee.subTree)) && $y(O, L, !0))
          : F(O, L, H, Ae, ee, he, ge, Ie, _e)
    },
    R = (O, L, H, X, ee, he, ge, Ie, _e) => {
      ;(L.slotScopeIds = Ie),
        O == null ? (L.shapeFlag & 512 ? ee.ctx.activate(L, H, X, ge, _e) : B(L, H, X, ee, he, ge, _e)) : U(O, L, _e)
    },
    B = (O, L, H, X, ee, he, ge) => {
      const Ie = (O.component = sF(O, X, ee))
      if ((Mf(O) && (Ie.ctx.renderer = Z), oF(Ie, !1, ge), Ie.asyncDep)) {
        if ((ee && ee.registerDep(Ie, $, ge), !O.el)) {
          const _e = (Ie.subTree = g(In))
          T(null, _e, L, H)
        }
      } else $(Ie, O, L, H, ee, he, ge)
    },
    U = (O, L, H) => {
      const X = (L.component = O.component)
      if (qL(O, L, H))
        if (X.asyncDep && !X.asyncResolved) {
          G(X, L, H)
          return
        } else (X.next = L), iL(X.update), (X.effect.dirty = !0), X.update()
      else (L.el = O.el), (X.vnode = L)
    },
    $ = (O, L, H, X, ee, he, ge) => {
      const Ie = () => {
          if (O.isMounted) {
            let { next: Ae, bu: Ne, u: De, parent: Me, vnode: Be } = O
            {
              const wi = AA(O)
              if (wi) {
                Ae && ((Ae.el = Be.el), G(O, Ae, ge)),
                  wi.asyncDep.then(() => {
                    O.isUnmounted || Ie()
                  })
                return
              }
            }
            let ht = Ae,
              lt
            to(O, !1),
              Ae ? ((Ae.el = Be.el), G(O, Ae, ge)) : (Ae = Be),
              Ne && hh(Ne),
              (lt = Ae.props && Ae.props.onVnodeBeforeUpdate) && Ji(lt, Me, Ae, Be),
              to(O, !0)
            const Yt = Sg(O),
              si = O.subTree
            ;(O.subTree = Yt),
              v(si, Yt, d(si.el), z(si), O, ee, he),
              (Ae.el = Yt.el),
              ht === null && jy(O, Yt.el),
              De && Jn(De, ee),
              (lt = Ae.props && Ae.props.onVnodeUpdated) && Jn(() => Ji(lt, Me, Ae, Be), ee)
          } else {
            let Ae
            const { el: Ne, props: De } = L,
              { bm: Me, m: Be, parent: ht } = O,
              lt = Lu(L)
            if (
              (to(O, !1), Me && hh(Me), !lt && (Ae = De && De.onVnodeBeforeMount) && Ji(Ae, ht, L), to(O, !0), Ne && re)
            ) {
              const Yt = () => {
                ;(O.subTree = Sg(O)), re(Ne, O.subTree, O, ee, null)
              }
              lt ? L.type.__asyncLoader().then(() => !O.isUnmounted && Yt()) : Yt()
            } else {
              const Yt = (O.subTree = Sg(O))
              v(null, Yt, H, X, O, ee, he), (L.el = Yt.el)
            }
            if ((Be && Jn(Be, ee), !lt && (Ae = De && De.onVnodeMounted))) {
              const Yt = L
              Jn(() => Ji(Ae, ht, Yt), ee)
            }
            ;(L.shapeFlag & 256 || (ht && Lu(ht.vnode) && ht.vnode.shapeFlag & 256)) && O.a && Jn(O.a, ee),
              (O.isMounted = !0),
              (L = H = X = null)
          }
        },
        _e = (O.effect = new Sy(Ie, Ei, () => xy(ve), O.scope)),
        ve = (O.update = () => {
          _e.dirty && _e.run()
        })
      ;(ve.i = O), (ve.id = O.uid), to(O, !0), ve()
    },
    G = (O, L, H) => {
      L.component = O
      const X = O.vnode.props
      ;(O.vnode = L), (O.next = null), TL(O, L.props, X, H), PL(O, L.children, H), $s(), SI(O), Us()
    },
    F = (O, L, H, X, ee, he, ge, Ie, _e = !1) => {
      const ve = O && O.children,
        Ae = O ? O.shapeFlag : 0,
        Ne = L.children,
        { patchFlag: De, shapeFlag: Me } = L
      if (De > 0) {
        if (De & 128) {
          j(ve, Ne, H, X, ee, he, ge, Ie, _e)
          return
        } else if (De & 256) {
          K(ve, Ne, H, X, ee, he, ge, Ie, _e)
          return
        }
      }
      Me & 8
        ? (Ae & 16 && oe(ve, ee, he), Ne !== ve && c(H, Ne))
        : Ae & 16
        ? Me & 16
          ? j(ve, Ne, H, X, ee, he, ge, Ie, _e)
          : oe(ve, ee, he, !0)
        : (Ae & 8 && c(H, ''), Me & 16 && w(Ne, H, X, ee, he, ge, Ie, _e))
    },
    K = (O, L, H, X, ee, he, ge, Ie, _e) => {
      ;(O = O || Ya), (L = L || Ya)
      const ve = O.length,
        Ae = L.length,
        Ne = Math.min(ve, Ae)
      let De
      for (De = 0; De < Ne; De++) {
        const Me = (L[De] = _e ? hs(L[De]) : $i(L[De]))
        v(O[De], Me, H, null, ee, he, ge, Ie, _e)
      }
      ve > Ae ? oe(O, ee, he, !0, !1, Ne) : w(L, H, X, ee, he, ge, Ie, _e, Ne)
    },
    j = (O, L, H, X, ee, he, ge, Ie, _e) => {
      let ve = 0
      const Ae = L.length
      let Ne = O.length - 1,
        De = Ae - 1
      for (; ve <= Ne && ve <= De; ) {
        const Me = O[ve],
          Be = (L[ve] = _e ? hs(L[ve]) : $i(L[ve]))
        if (er(Me, Be)) v(Me, Be, H, null, ee, he, ge, Ie, _e)
        else break
        ve++
      }
      for (; ve <= Ne && ve <= De; ) {
        const Me = O[Ne],
          Be = (L[De] = _e ? hs(L[De]) : $i(L[De]))
        if (er(Me, Be)) v(Me, Be, H, null, ee, he, ge, Ie, _e)
        else break
        Ne--, De--
      }
      if (ve > Ne) {
        if (ve <= De) {
          const Me = De + 1,
            Be = Me < Ae ? L[Me].el : X
          for (; ve <= De; ) v(null, (L[ve] = _e ? hs(L[ve]) : $i(L[ve])), H, Be, ee, he, ge, Ie, _e), ve++
        }
      } else if (ve > De) for (; ve <= Ne; ) te(O[ve], ee, he, !0), ve++
      else {
        const Me = ve,
          Be = ve,
          ht = new Map()
        for (ve = Be; ve <= De; ve++) {
          const jn = (L[ve] = _e ? hs(L[ve]) : $i(L[ve]))
          jn.key != null && ht.set(jn.key, ve)
        }
        let lt,
          Yt = 0
        const si = De - Be + 1
        let wi = !1,
          Xl = 0
        const Jr = new Array(si)
        for (ve = 0; ve < si; ve++) Jr[ve] = 0
        for (ve = Me; ve <= Ne; ve++) {
          const jn = O[ve]
          if (Yt >= si) {
            te(jn, ee, he, !0)
            continue
          }
          let Ii
          if (jn.key != null) Ii = ht.get(jn.key)
          else
            for (lt = Be; lt <= De; lt++)
              if (Jr[lt - Be] === 0 && er(jn, L[lt])) {
                Ii = lt
                break
              }
          Ii === void 0
            ? te(jn, ee, he, !0)
            : ((Jr[Ii - Be] = ve + 1),
              Ii >= Xl ? (Xl = Ii) : (wi = !0),
              v(jn, L[Ii], H, null, ee, he, ge, Ie, _e),
              Yt++)
        }
        const ba = wi ? LL(Jr) : Ya
        for (lt = ba.length - 1, ve = si - 1; ve >= 0; ve--) {
          const jn = Be + ve,
            Ii = L[jn],
            wa = jn + 1 < Ae ? L[jn + 1].el : X
          Jr[ve] === 0
            ? v(null, Ii, H, wa, ee, he, ge, Ie, _e)
            : wi && (lt < 0 || ve !== ba[lt] ? q(Ii, H, wa, 2) : lt--)
        }
      }
    },
    q = (O, L, H, X, ee = null) => {
      const { el: he, type: ge, transition: Ie, children: _e, shapeFlag: ve } = O
      if (ve & 6) {
        q(O.component.subTree, L, H, X)
        return
      }
      if (ve & 128) {
        O.suspense.move(L, H, X)
        return
      }
      if (ve & 64) {
        ge.move(O, L, H, Z)
        return
      }
      if (ge === ke) {
        i(he, L, H)
        for (let Ne = 0; Ne < _e.length; Ne++) q(_e[Ne], L, H, X)
        i(O.anchor, L, H)
        return
      }
      if (ge === Eg) {
        x(O, L, H)
        return
      }
      if (X !== 2 && ve & 1 && Ie)
        if (X === 0) Ie.beforeEnter(he), i(he, L, H), Jn(() => Ie.enter(he), ee)
        else {
          const { leave: Ne, delayLeave: De, afterLeave: Me } = Ie,
            Be = () => i(he, L, H),
            ht = () => {
              Ne(he, () => {
                Be(), Me && Me()
              })
            }
          De ? De(he, Be, ht) : ht()
        }
      else i(he, L, H)
    },
    te = (O, L, H, X = !1, ee = !1) => {
      const {
        type: he,
        props: ge,
        ref: Ie,
        children: _e,
        dynamicChildren: ve,
        shapeFlag: Ae,
        patchFlag: Ne,
        dirs: De,
        cacheIndex: Me,
      } = O
      if (
        (Ne === -2 && (ee = !1),
        Ie != null && kv(Ie, null, H, O, !0),
        Me != null && (L.renderCache[Me] = void 0),
        Ae & 256)
      ) {
        L.ctx.deactivate(O)
        return
      }
      const Be = Ae & 1 && De,
        ht = !Lu(O)
      let lt
      if ((ht && (lt = ge && ge.onVnodeBeforeUnmount) && Ji(lt, L, O), Ae & 6)) me(O.component, H, X)
      else {
        if (Ae & 128) {
          O.suspense.unmount(H, X)
          return
        }
        Be && eo(O, null, L, 'beforeUnmount'),
          Ae & 64
            ? O.type.remove(O, L, H, Z, X)
            : ve && !ve.hasOnce && (he !== ke || (Ne > 0 && Ne & 64))
            ? oe(ve, L, H, !1, !0)
            : ((he === ke && Ne & 384) || (!ee && Ae & 16)) && oe(_e, L, H),
          X && ce(O)
      }
      ;((ht && (lt = ge && ge.onVnodeUnmounted)) || Be) &&
        Jn(() => {
          lt && Ji(lt, L, O), Be && eo(O, null, L, 'unmounted')
        }, H)
    },
    ce = (O) => {
      const { type: L, el: H, anchor: X, transition: ee } = O
      if (L === ke) {
        Ee(H, X)
        return
      }
      if (L === Eg) {
        N(O)
        return
      }
      const he = () => {
        r(H), ee && !ee.persisted && ee.afterLeave && ee.afterLeave()
      }
      if (O.shapeFlag & 1 && ee && !ee.persisted) {
        const { leave: ge, delayLeave: Ie } = ee,
          _e = () => ge(H, he)
        Ie ? Ie(O.el, he, _e) : _e()
      } else he()
    },
    Ee = (O, L) => {
      let H
      for (; O !== L; ) (H = f(O)), r(O), (O = H)
      r(L)
    },
    me = (O, L, H) => {
      const { bum: X, scope: ee, update: he, subTree: ge, um: Ie, m: _e, a: ve } = O
      MI(_e),
        MI(ve),
        X && hh(X),
        ee.stop(),
        he && ((he.active = !1), te(ge, O, L, H)),
        Ie && Jn(Ie, L),
        Jn(() => {
          O.isUnmounted = !0
        }, L),
        L &&
          L.pendingBranch &&
          !L.isUnmounted &&
          O.asyncDep &&
          !O.asyncResolved &&
          O.suspenseId === L.pendingId &&
          (L.deps--, L.deps === 0 && L.resolve())
    },
    oe = (O, L, H, X = !1, ee = !1, he = 0) => {
      for (let ge = he; ge < O.length; ge++) te(O[ge], L, H, X, ee)
    },
    z = (O) => {
      if (O.shapeFlag & 6) return z(O.component.subTree)
      if (O.shapeFlag & 128) return O.suspense.next()
      const L = f(O.anchor || O.el),
        H = L && L[TA]
      return H ? f(H) : L
    }
  let ue = !1
  const de = (O, L, H) => {
      O == null ? L._vnode && te(L._vnode, null, null, !0) : v(L._vnode || null, O, L, null, null, null, H),
        ue || ((ue = !0), SI(), eA(), (ue = !1)),
        (L._vnode = O)
    },
    Z = { p: v, um: te, m: q, r: ce, mt: B, mc: w, pc: F, pbc: S, n: z, o: e }
  let pe, re
  return { render: de, hydrate: pe, createApp: IL(de, pe) }
}
function Ig({ type: e, props: t }, n) {
  return (n === 'svg' && e === 'foreignObject') ||
    (n === 'mathml' && e === 'annotation-xml' && t && t.encoding && t.encoding.includes('html'))
    ? void 0
    : n
}
function to({ effect: e, update: t }, n) {
  e.allowRecurse = t.allowRecurse = n
}
function ML(e, t) {
  return (!e || (e && !e.pendingBranch)) && t && !t.persisted
}
function $y(e, t, n = !1) {
  const i = e.children,
    r = t.children
  if (Ue(i) && Ue(r))
    for (let s = 0; s < i.length; s++) {
      const o = i[s]
      let a = r[s]
      a.shapeFlag & 1 &&
        !a.dynamicChildren &&
        ((a.patchFlag <= 0 || a.patchFlag === 32) && ((a = r[s] = hs(r[s])), (a.el = o.el)),
        !n && a.patchFlag !== -2 && $y(o, a)),
        a.type === Bc && (a.el = o.el)
    }
}
function LL(e) {
  const t = e.slice(),
    n = [0]
  let i, r, s, o, a
  const l = e.length
  for (i = 0; i < l; i++) {
    const u = e[i]
    if (u !== 0) {
      if (((r = n[n.length - 1]), e[r] < u)) {
        ;(t[i] = r), n.push(i)
        continue
      }
      for (s = 0, o = n.length - 1; s < o; ) (a = (s + o) >> 1), e[n[a]] < u ? (s = a + 1) : (o = a)
      u < e[n[s]] && (s > 0 && (t[i] = n[s - 1]), (n[s] = i))
    }
  }
  for (s = n.length, o = n[s - 1]; s-- > 0; ) (n[s] = o), (o = t[o])
  return n
}
function AA(e) {
  const t = e.subTree.component
  if (t) return t.asyncDep && !t.asyncResolved ? t : AA(t)
}
function MI(e) {
  if (e) for (let t = 0; t < e.length; t++) e[t].active = !1
}
const FL = Symbol.for('v-scx'),
  BL = () => je(FL)
function $t(e, t) {
  return Uy(e, null, t)
}
const Ud = {}
function be(e, t, n) {
  return Uy(e, t, n)
}
function Uy(e, t, { immediate: n, deep: i, flush: r, once: s, onTrack: o, onTrigger: a } = Vt) {
  if (t && s) {
    const D = t
    t = (...I) => {
      D(...I), V()
    }
  }
  const l = dn,
    u = (D) => (i === !0 ? D : ms(D, i === !1 ? 1 : void 0))
  let c,
    d = !1,
    f = !1
  if (
    (It(e)
      ? ((c = () => e.value), (d = al(e)))
      : Io(e)
      ? ((c = () => u(e)), (d = !0))
      : Ue(e)
      ? ((f = !0),
        (d = e.some((D) => Io(D) || al(D))),
        (c = () =>
          e.map((D) => {
            if (It(D)) return D.value
            if (Io(D)) return u(D)
            if (qe(D)) return Es(D, l, 2)
          })))
      : qe(e)
      ? t
        ? (c = () => Es(e, l, 2))
        : (c = () => (m && m(), ki(e, l, 3, [p])))
      : (c = Ei),
    t && i)
  ) {
    const D = c
    c = () => ms(D())
  }
  let m,
    p = (D) => {
      m = x.onStop = () => {
        Es(D, l, 4), (m = x.onStop = void 0)
      }
    },
    v
  if ($f)
    if (((p = Ei), t ? n && ki(t, l, 3, [c(), f ? [] : void 0, p]) : c(), r === 'sync')) {
      const D = BL()
      v = D.__watcherHandles || (D.__watcherHandles = [])
    } else return Ei
  let y = f ? new Array(e.length).fill(Ud) : Ud
  const T = () => {
    if (!(!x.active || !x.dirty))
      if (t) {
        const D = x.run()
        ;(i || d || (f ? D.some((I, w) => Vs(I, y[w])) : Vs(D, y))) &&
          (m && m(), ki(t, l, 3, [D, y === Ud ? void 0 : f && y[0] === Ud ? [] : y, p]), (y = D))
      } else x.run()
  }
  T.allowRecurse = !!t
  let A
  r === 'sync'
    ? (A = T)
    : r === 'post'
    ? (A = () => Jn(T, l && l.suspense))
    : ((T.pre = !0), l && (T.id = l.uid), (A = () => xy(T)))
  const x = new Sy(c, Ei, A),
    N = Iy(),
    V = () => {
      x.stop(), N && by(N.effects, x)
    }
  return t ? (n ? T() : (y = x.run())) : r === 'post' ? Jn(x.run.bind(x), l && l.suspense) : x.run(), v && v.push(V), V
}
function $L(e, t, n) {
  const i = this.proxy,
    r = Bt(e) ? (e.includes('.') ? kA(i, e) : () => i[e]) : e.bind(i, i)
  let s
  qe(t) ? (s = t) : ((s = t.handler), (n = t))
  const o = Uc(this),
    a = Uy(r, s.bind(i), n)
  return o(), a
}
function kA(e, t) {
  const n = t.split('.')
  return () => {
    let i = e
    for (let r = 0; r < n.length && i; r++) i = i[n[r]]
    return i
  }
}
function ms(e, t = 1 / 0, n) {
  if (t <= 0 || !St(e) || e.__v_skip || ((n = n || new Set()), n.has(e))) return e
  if ((n.add(e), t--, It(e))) ms(e.value, t, n)
  else if (Ue(e)) for (let i = 0; i < e.length; i++) ms(e[i], t, n)
  else if (IC(e) || Qa(e))
    e.forEach((i) => {
      ms(i, t, n)
    })
  else if (TC(e)) {
    for (const i in e) ms(e[i], t, n)
    for (const i of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, i) && ms(e[i], t, n)
  }
  return e
}
const UL = (e, t) =>
  t === 'modelValue' || t === 'model-value'
    ? e.modelModifiers
    : e[`${t}Modifiers`] || e[`${gi(t)}Modifiers`] || e[`${ta(t)}Modifiers`]
function jL(e, t, ...n) {
  if (e.isUnmounted) return
  const i = e.vnode.props || Vt
  let r = n
  const s = t.startsWith('update:'),
    o = s && UL(i, t.slice(7))
  o && (o.trim && (r = n.map((c) => (Bt(c) ? c.trim() : c))), o.number && (r = n.map(yv)))
  let a,
    l = i[(a = yg(t))] || i[(a = yg(gi(t)))]
  !l && s && (l = i[(a = yg(ta(t)))]), l && ki(l, e, 6, r)
  const u = i[a + 'Once']
  if (u) {
    if (!e.emitted) e.emitted = {}
    else if (e.emitted[a]) return
    ;(e.emitted[a] = !0), ki(u, e, 6, r)
  }
}
function PA(e, t, n = !1) {
  const i = t.emitsCache,
    r = i.get(e)
  if (r !== void 0) return r
  const s = e.emits
  let o = {},
    a = !1
  if (!qe(e)) {
    const l = (u) => {
      const c = PA(u, t, !0)
      c && ((a = !0), rn(o, c))
    }
    !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l)
  }
  return !s && !a
    ? (St(e) && i.set(e, null), null)
    : (Ue(s) ? s.forEach((l) => (o[l] = null)) : rn(o, s), St(e) && i.set(e, o), o)
}
function Ff(e, t) {
  return !e || !kf(t)
    ? !1
    : ((t = t.slice(2).replace(/Once$/, '')), ut(e, t[0].toLowerCase() + t.slice(1)) || ut(e, ta(t)) || ut(e, t))
}
function Sg(e) {
  const {
      type: t,
      vnode: n,
      proxy: i,
      withProxy: r,
      propsOptions: [s],
      slots: o,
      attrs: a,
      emit: l,
      render: u,
      renderCache: c,
      props: d,
      data: f,
      setupState: m,
      ctx: p,
      inheritAttrs: v,
    } = e,
    y = Nh(e)
  let T, A
  try {
    if (n.shapeFlag & 4) {
      const N = r || i,
        V = N
      ;(T = $i(u.call(V, N, c, d, m, f, p))), (A = a)
    } else {
      const N = t
      ;(T = $i(N.length > 1 ? N(d, { attrs: a, slots: o, emit: l }) : N(d, null))), (A = t.props ? a : HL(a))
    }
  } catch (N) {
    ;($u.length = 0), Fc(N, e, 1), (T = g(In))
  }
  let x = T
  if (A && v !== !1) {
    const N = Object.keys(A),
      { shapeFlag: V } = x
    N.length && V & 7 && (s && N.some(_y) && (A = WL(A, s)), (x = Nr(x, A, !1, !0)))
  }
  return (
    n.dirs && ((x = Nr(x, null, !1, !0)), (x.dirs = x.dirs ? x.dirs.concat(n.dirs) : n.dirs)),
    n.transition && (x.transition = n.transition),
    (T = x),
    Nh(y),
    T
  )
}
function zL(e, t = !0) {
  let n
  for (let i = 0; i < e.length; i++) {
    const r = e[i]
    if (cl(r)) {
      if (r.type !== In || r.children === 'v-if') {
        if (n) return
        n = r
      }
    } else return
  }
  return n
}
const HL = (e) => {
    let t
    for (const n in e) (n === 'class' || n === 'style' || kf(n)) && ((t || (t = {}))[n] = e[n])
    return t
  },
  WL = (e, t) => {
    const n = {}
    for (const i in e) (!_y(i) || !(i.slice(9) in t)) && (n[i] = e[i])
    return n
  }
function qL(e, t, n) {
  const { props: i, children: r, component: s } = e,
    { props: o, children: a, patchFlag: l } = t,
    u = s.emitsOptions
  if (t.dirs || t.transition) return !0
  if (n && l >= 0) {
    if (l & 1024) return !0
    if (l & 16) return i ? LI(i, o, u) : !!o
    if (l & 8) {
      const c = t.dynamicProps
      for (let d = 0; d < c.length; d++) {
        const f = c[d]
        if (o[f] !== i[f] && !Ff(u, f)) return !0
      }
    }
  } else return (r || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? (o ? LI(i, o, u) : !0) : !!o
  return !1
}
function LI(e, t, n) {
  const i = Object.keys(t)
  if (i.length !== Object.keys(e).length) return !0
  for (let r = 0; r < i.length; r++) {
    const s = i[r]
    if (t[s] !== e[s] && !Ff(n, s)) return !0
  }
  return !1
}
function jy({ vnode: e, parent: t }, n) {
  for (; t; ) {
    const i = t.subTree
    if ((i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e)) ((e = t.vnode).el = n), (t = t.parent)
    else break
  }
}
const GL = (e) => e.__isSuspense
let Rv = 0
const KL = {
    name: 'Suspense',
    __isSuspense: !0,
    process(e, t, n, i, r, s, o, a, l, u) {
      if (e == null) YL(t, n, i, r, s, o, a, l, u)
      else {
        if (s && s.deps > 0 && !e.suspense.isInFallback) {
          ;(t.suspense = e.suspense), (t.suspense.vnode = t), (t.el = e.el)
          return
        }
        QL(e, t, n, i, r, o, a, l, u)
      }
    },
    hydrate: XL,
    normalize: JL,
  },
  RA = KL
function oc(e, t) {
  const n = e.props && e.props[t]
  qe(n) && n()
}
function YL(e, t, n, i, r, s, o, a, l) {
  const {
      p: u,
      o: { createElement: c },
    } = l,
    d = c('div'),
    f = (e.suspense = xA(e, r, i, t, d, n, s, o, a, l))
  u(null, (f.pendingBranch = e.ssContent), d, null, i, f, s, o),
    f.deps > 0
      ? (oc(e, 'onPending'), oc(e, 'onFallback'), u(null, e.ssFallback, t, n, i, null, s, o), Za(f, e.ssFallback))
      : f.resolve(!1, !0)
}
function QL(e, t, n, i, r, s, o, a, { p: l, um: u, o: { createElement: c } }) {
  const d = (t.suspense = e.suspense)
  ;(d.vnode = t), (t.el = e.el)
  const f = t.ssContent,
    m = t.ssFallback,
    { activeBranch: p, pendingBranch: v, isInFallback: y, isHydrating: T } = d
  if (v)
    (d.pendingBranch = f),
      er(f, v)
        ? (l(v, f, d.hiddenContainer, null, r, d, s, o, a),
          d.deps <= 0 ? d.resolve() : y && (T || (l(p, m, n, i, r, null, s, o, a), Za(d, m))))
        : ((d.pendingId = Rv++),
          T ? ((d.isHydrating = !1), (d.activeBranch = v)) : u(v, r, d),
          (d.deps = 0),
          (d.effects.length = 0),
          (d.hiddenContainer = c('div')),
          y
            ? (l(null, f, d.hiddenContainer, null, r, d, s, o, a),
              d.deps <= 0 ? d.resolve() : (l(p, m, n, i, r, null, s, o, a), Za(d, m)))
            : p && er(f, p)
            ? (l(p, f, n, i, r, d, s, o, a), d.resolve(!0))
            : (l(null, f, d.hiddenContainer, null, r, d, s, o, a), d.deps <= 0 && d.resolve()))
  else if (p && er(f, p)) l(p, f, n, i, r, d, s, o, a), Za(d, f)
  else if (
    (oc(t, 'onPending'),
    (d.pendingBranch = f),
    f.shapeFlag & 512 ? (d.pendingId = f.component.suspenseId) : (d.pendingId = Rv++),
    l(null, f, d.hiddenContainer, null, r, d, s, o, a),
    d.deps <= 0)
  )
    d.resolve()
  else {
    const { timeout: A, pendingId: x } = d
    A > 0
      ? setTimeout(() => {
          d.pendingId === x && d.fallback(m)
        }, A)
      : A === 0 && d.fallback(m)
  }
}
function xA(e, t, n, i, r, s, o, a, l, u, c = !1) {
  const {
    p: d,
    m: f,
    um: m,
    n: p,
    o: { parentNode: v, remove: y },
  } = u
  let T
  const A = eF(e)
  A && t && t.pendingBranch && ((T = t.pendingId), t.deps++)
  const x = e.props ? AC(e.props.timeout) : void 0,
    N = s,
    V = {
      vnode: e,
      parent: t,
      parentComponent: n,
      namespace: o,
      container: i,
      hiddenContainer: r,
      deps: 0,
      pendingId: Rv++,
      timeout: typeof x == 'number' ? x : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !c,
      isHydrating: c,
      isUnmounted: !1,
      effects: [],
      resolve(D = !1, I = !1) {
        const {
          vnode: w,
          activeBranch: _,
          pendingBranch: S,
          pendingId: E,
          effects: C,
          parentComponent: R,
          container: B,
        } = V
        let U = !1
        V.isHydrating
          ? (V.isHydrating = !1)
          : D ||
            ((U = _ && S.transition && S.transition.mode === 'out-in'),
            U &&
              (_.transition.afterLeave = () => {
                E === V.pendingId && (f(S, B, s === N ? p(_) : s, 0), Sv(C))
              }),
            _ && (v(_.el) !== V.hiddenContainer && (s = p(_)), m(_, R, V, !0)),
            U || f(S, B, s, 0)),
          Za(V, S),
          (V.pendingBranch = null),
          (V.isInFallback = !1)
        let $ = V.parent,
          G = !1
        for (; $; ) {
          if ($.pendingBranch) {
            $.effects.push(...C), (G = !0)
            break
          }
          $ = $.parent
        }
        !G && !U && Sv(C),
          (V.effects = []),
          A && t && t.pendingBranch && T === t.pendingId && (t.deps--, t.deps === 0 && !I && t.resolve()),
          oc(w, 'onResolve')
      },
      fallback(D) {
        if (!V.pendingBranch) return
        const { vnode: I, activeBranch: w, parentComponent: _, container: S, namespace: E } = V
        oc(I, 'onFallback')
        const C = p(w),
          R = () => {
            V.isInFallback && (d(null, D, S, C, _, null, E, a, l), Za(V, D))
          },
          B = D.transition && D.transition.mode === 'out-in'
        B && (w.transition.afterLeave = R), (V.isInFallback = !0), m(w, _, null, !0), B || R()
      },
      move(D, I, w) {
        V.activeBranch && f(V.activeBranch, D, I, w), (V.container = D)
      },
      next() {
        return V.activeBranch && p(V.activeBranch)
      },
      registerDep(D, I, w) {
        const _ = !!V.pendingBranch
        _ && V.deps++
        const S = D.vnode.el
        D.asyncDep
          .catch((E) => {
            Fc(E, D, 0)
          })
          .then((E) => {
            if (D.isUnmounted || V.isUnmounted || V.pendingId !== D.suspenseId) return
            D.asyncResolved = !0
            const { vnode: C } = D
            Vv(D, E, !1), S && (C.el = S)
            const R = !S && D.subTree.el
            I(D, C, v(S || D.subTree.el), S ? null : p(D.subTree), V, o, w),
              R && y(R),
              jy(D, C.el),
              _ && --V.deps === 0 && V.resolve()
          })
      },
      unmount(D, I) {
        ;(V.isUnmounted = !0),
          V.activeBranch && m(V.activeBranch, n, D, I),
          V.pendingBranch && m(V.pendingBranch, n, D, I)
      },
    }
  return V
}
function XL(e, t, n, i, r, s, o, a, l) {
  const u = (t.suspense = xA(t, i, n, e.parentNode, document.createElement('div'), null, r, s, o, a, !0)),
    c = l(e, (u.pendingBranch = t.ssContent), n, u, s, o)
  return u.deps === 0 && u.resolve(!1, !0), c
}
function JL(e) {
  const { shapeFlag: t, children: n } = e,
    i = t & 32
  ;(e.ssContent = FI(i ? n.default : n)), (e.ssFallback = i ? FI(n.fallback) : g(In))
}
function FI(e) {
  let t
  if (qe(e)) {
    const n = ul && e._c
    n && ((e._d = !1), Bf()), (e = e()), n && ((e._d = !0), (t = ei), VA())
  }
  return Ue(e) && (e = zL(e)), (e = $i(e)), t && !e.dynamicChildren && (e.dynamicChildren = t.filter((n) => n !== e)), e
}
function ZL(e, t) {
  t && t.pendingBranch ? (Ue(e) ? t.effects.push(...e) : t.effects.push(e)) : Sv(e)
}
function Za(e, t) {
  e.activeBranch = t
  const { vnode: n, parentComponent: i } = e
  let r = t.el
  for (; !r && t.component; ) (t = t.component.subTree), (r = t.el)
  ;(n.el = r), i && i.subTree === n && ((i.vnode.el = r), jy(i, r))
}
function eF(e) {
  const t = e.props && e.props.suspensible
  return t != null && t !== !1
}
const ke = Symbol.for('v-fgt'),
  Bc = Symbol.for('v-txt'),
  In = Symbol.for('v-cmt'),
  Eg = Symbol.for('v-stc'),
  $u = []
let ei = null
function Bf(e = !1) {
  $u.push((ei = e ? null : []))
}
function VA() {
  $u.pop(), (ei = $u[$u.length - 1] || null)
}
let ul = 1
function BI(e) {
  ;(ul += e), e < 0 && ei && (ei.hasOnce = !0)
}
function DA(e) {
  return (e.dynamicChildren = ul > 0 ? ei || Ya : null), VA(), ul > 0 && ei && ei.push(e), e
}
function Mte(e, t, n, i, r, s) {
  return DA(OA(e, t, n, i, r, s, !0))
}
function zy(e, t, n, i, r) {
  return DA(g(e, t, n, i, r, !0))
}
function cl(e) {
  return e ? e.__v_isVNode === !0 : !1
}
function er(e, t) {
  return e.type === t.type && e.key === t.key
}
const NA = ({ key: e }) => e ?? null,
  mh = ({ ref: e, ref_key: t, ref_for: n }) => (
    typeof e == 'number' && (e = '' + e),
    e != null ? (Bt(e) || It(e) || qe(e) ? { i: tn, r: e, k: t, f: !!n } : e) : null
  )
function OA(e, t = null, n = null, i = 0, r = null, s = e === ke ? 0 : 1, o = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && NA(t),
    ref: t && mh(t),
    scopeId: nA,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: i,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: tn,
  }
  return (
    a ? (Hy(l, n), s & 128 && e.normalize(l)) : n && (l.shapeFlag |= Bt(n) ? 8 : 16),
    ul > 0 && !o && ei && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && ei.push(l),
    l
  )
}
const g = tF
function tF(e, t = null, n = null, i = 0, r = null, s = !1) {
  if (((!e || e === hA) && (e = In), cl(e))) {
    const a = Nr(e, t, !0)
    return (
      n && Hy(a, n),
      ul > 0 && !s && ei && (a.shapeFlag & 6 ? (ei[ei.indexOf(e)] = a) : ei.push(a)),
      (a.patchFlag = -2),
      a
    )
  }
  if ((dF(e) && (e = e.__vccOpts), t)) {
    t = nF(t)
    let { class: a, style: l } = t
    a && !Bt(a) && (t.class = Vf(a)), St(l) && (qC(l) && !Ue(l) && (l = rn({}, l)), (t.style = xf(l)))
  }
  const o = Bt(e) ? 1 : GL(e) ? 128 : RL(e) ? 64 : St(e) ? 4 : qe(e) ? 2 : 0
  return OA(e, t, n, i, r, o, s, !0)
}
function nF(e) {
  return e ? (qC(e) || yA(e) ? rn({}, e) : e) : null
}
function Nr(e, t, n = !1, i = !1) {
  const { props: r, ref: s, patchFlag: o, children: a, transition: l } = e,
    u = t ? ae(r || {}, t) : r,
    c = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: u,
      key: u && NA(u),
      ref: t && t.ref ? (n && s ? (Ue(s) ? s.concat(mh(t)) : [s, mh(t)]) : mh(t)) : s,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: a,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== ke ? (o === -1 ? 16 : o | 16) : o,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: l,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && Nr(e.ssContent),
      ssFallback: e.ssFallback && Nr(e.ssFallback),
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce,
    }
  return l && i && ll(c, l.clone(c)), c
}
function Or(e = ' ', t = 0) {
  return g(Bc, null, e, t)
}
function Lte(e = '', t = !1) {
  return t ? (Bf(), zy(In, null, e)) : g(In, null, e)
}
function $i(e) {
  return e == null || typeof e == 'boolean'
    ? g(In)
    : Ue(e)
    ? g(ke, null, e.slice())
    : typeof e == 'object'
    ? hs(e)
    : g(Bc, null, String(e))
}
function hs(e) {
  return (e.el === null && e.patchFlag !== -1) || e.memo ? e : Nr(e)
}
function Hy(e, t) {
  let n = 0
  const { shapeFlag: i } = e
  if (t == null) t = null
  else if (Ue(t)) n = 16
  else if (typeof t == 'object')
    if (i & 65) {
      const r = t.default
      r && (r._c && (r._d = !1), Hy(e, r()), r._c && (r._d = !0))
      return
    } else {
      n = 32
      const r = t._
      !r && !yA(t)
        ? (t._ctx = tn)
        : r === 3 && tn && (tn.slots._ === 1 ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
    }
  else
    qe(t) ? ((t = { default: t, _ctx: tn }), (n = 32)) : ((t = String(t)), i & 64 ? ((n = 16), (t = [Or(t)])) : (n = 8))
  ;(e.children = t), (e.shapeFlag |= n)
}
function ae(...e) {
  const t = {}
  for (let n = 0; n < e.length; n++) {
    const i = e[n]
    for (const r in i)
      if (r === 'class') t.class !== i.class && (t.class = Vf([t.class, i.class]))
      else if (r === 'style') t.style = xf([t.style, i.style])
      else if (kf(r)) {
        const s = t[r],
          o = i[r]
        o && s !== o && !(Ue(s) && s.includes(o)) && (t[r] = s ? [].concat(s, o) : o)
      } else r !== '' && (t[r] = i[r])
  }
  return t
}
function Ji(e, t, n, i = null) {
  ki(e, t, 7, [n, i])
}
const iF = gA()
let rF = 0
function sF(e, t, n) {
  const i = e.type,
    r = (t ? t.appContext : e.appContext) || iF,
    s = {
      uid: rF++,
      vnode: e,
      type: i,
      parent: t,
      appContext: r,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new DC(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(r.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: bA(i, r),
      emitsOptions: PA(i, r),
      emit: null,
      emitted: null,
      propsDefaults: Vt,
      inheritAttrs: i.inheritAttrs,
      ctx: Vt,
      data: Vt,
      props: Vt,
      attrs: Vt,
      slots: Vt,
      refs: Vt,
      setupState: Vt,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null,
    }
  return (s.ctx = { _: s }), (s.root = t ? t.root : s), (s.emit = jL.bind(null, s)), e.ce && e.ce(s), s
}
let dn = null
const $c = () => dn || tn
let Mh, xv
{
  const e = kC(),
    t = (n, i) => {
      let r
      return (
        (r = e[n]) || (r = e[n] = []),
        r.push(i),
        (s) => {
          r.length > 1 ? r.forEach((o) => o(s)) : r[0](s)
        }
      )
    }
  ;(Mh = t('__VUE_INSTANCE_SETTERS__', (n) => (dn = n))), (xv = t('__VUE_SSR_SETTERS__', (n) => ($f = n)))
}
const Uc = (e) => {
    const t = dn
    return (
      Mh(e),
      e.scope.on(),
      () => {
        e.scope.off(), Mh(t)
      }
    )
  },
  $I = () => {
    dn && dn.scope.off(), Mh(null)
  }
function MA(e) {
  return e.vnode.shapeFlag & 4
}
let $f = !1
function oF(e, t = !1, n = !1) {
  t && xv(t)
  const { props: i, children: r } = e.vnode,
    s = MA(e)
  EL(e, i, s, t), kL(e, r, n)
  const o = s ? aF(e, t) : void 0
  return t && xv(!1), o
}
function aF(e, t) {
  const n = e.type
  ;(e.accessCache = Object.create(null)), (e.proxy = new Proxy(e.ctx, gL))
  const { setup: i } = n
  if (i) {
    const r = (e.setupContext = i.length > 1 ? uF(e) : null),
      s = Uc(e)
    $s()
    const o = Es(i, e, 0, [e.props, r])
    if ((Us(), s(), SC(o))) {
      if ((o.then($I, $I), t))
        return o
          .then((a) => {
            Vv(e, a, t)
          })
          .catch((a) => {
            Fc(a, e, 0)
          })
      e.asyncDep = o
    } else Vv(e, o, t)
  } else LA(e, t)
}
function Vv(e, t, n) {
  qe(t) ? (e.type.__ssrInlineRender ? (e.ssrRender = t) : (e.render = t)) : St(t) && (e.setupState = QC(t)), LA(e, n)
}
let UI
function LA(e, t, n) {
  const i = e.type
  if (!e.render) {
    if (!t && UI && !i.render) {
      const r = i.template || Fy(e).template
      if (r) {
        const { isCustomElement: s, compilerOptions: o } = e.appContext.config,
          { delimiters: a, compilerOptions: l } = i,
          u = rn(rn({ isCustomElement: s, delimiters: a }, o), l)
        i.render = UI(r, u)
      }
    }
    e.render = i.render || Ei
  }
  {
    const r = Uc(e)
    $s()
    try {
      vL(e)
    } finally {
      Us(), r()
    }
  }
}
const lF = {
  get(e, t) {
    return ri(e, 'get', ''), e[t]
  },
}
function uF(e) {
  const t = (n) => {
    e.exposed = n || {}
  }
  return { attrs: new Proxy(e.attrs, lF), slots: e.slots, emit: e.emit, expose: t }
}
function Uf(e) {
  return e.exposed
    ? e.exposeProxy ||
        (e.exposeProxy = new Proxy(QC(Nf(e.exposed)), {
          get(t, n) {
            if (n in t) return t[n]
            if (n in Fu) return Fu[n](e)
          },
          has(t, n) {
            return n in t || n in Fu
          },
        }))
    : e.proxy
}
function cF(e, t = !0) {
  return qe(e) ? e.displayName || e.name : e.name || (t && e.__name)
}
function dF(e) {
  return qe(e) && '__vccOpts' in e
}
const k = (e, t) => QM(e, t, $f)
function Yi(e, t, n) {
  const i = arguments.length
  return i === 2
    ? St(t) && !Ue(t)
      ? cl(t)
        ? g(e, null, [t])
        : g(e, t)
      : g(e, null, t)
    : (i > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : i === 3 && cl(n) && (n = [n]), g(e, t, n))
}
const hF = '3.4.33'
/**
 * @vue/runtime-dom v3.4.33
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ const fF = 'http://www.w3.org/2000/svg',
  mF = 'http://www.w3.org/1998/Math/MathML',
  Tr = typeof document < 'u' ? document : null,
  jI = Tr && Tr.createElement('template'),
  gF = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null)
    },
    remove: (e) => {
      const t = e.parentNode
      t && t.removeChild(e)
    },
    createElement: (e, t, n, i) => {
      const r =
        t === 'svg'
          ? Tr.createElementNS(fF, e)
          : t === 'mathml'
          ? Tr.createElementNS(mF, e)
          : n
          ? Tr.createElement(e, { is: n })
          : Tr.createElement(e)
      return e === 'select' && i && i.multiple != null && r.setAttribute('multiple', i.multiple), r
    },
    createText: (e) => Tr.createTextNode(e),
    createComment: (e) => Tr.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t
    },
    setElementText: (e, t) => {
      e.textContent = t
    },
    parentNode: (e) => e.parentNode,
    nextSibling: (e) => e.nextSibling,
    querySelector: (e) => Tr.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, '')
    },
    insertStaticContent(e, t, n, i, r, s) {
      const o = n ? n.previousSibling : t.lastChild
      if (r && (r === s || r.nextSibling))
        for (; t.insertBefore(r.cloneNode(!0), n), !(r === s || !(r = r.nextSibling)); );
      else {
        jI.innerHTML = i === 'svg' ? `<svg>${e}</svg>` : i === 'mathml' ? `<math>${e}</math>` : e
        const a = jI.content
        if (i === 'svg' || i === 'mathml') {
          const l = a.firstChild
          for (; l.firstChild; ) a.appendChild(l.firstChild)
          a.removeChild(l)
        }
        t.insertBefore(a, n)
      }
      return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    },
  },
  is = 'transition',
  du = 'animation',
  dl = Symbol('_vtc'),
  dr = (e, { slots: t }) => Yi(aL, BA(e), t)
dr.displayName = 'Transition'
const FA = {
    name: String,
    type: String,
    css: { type: Boolean, default: !0 },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String,
  },
  vF = (dr.props = rn({}, rA, FA)),
  no = (e, t = []) => {
    Ue(e) ? e.forEach((n) => n(...t)) : e && e(...t)
  },
  zI = (e) => (e ? (Ue(e) ? e.some((t) => t.length > 1) : e.length > 1) : !1)
function BA(e) {
  const t = {}
  for (const C in e) C in FA || (t[C] = e[C])
  if (e.css === !1) return t
  const {
      name: n = 'v',
      type: i,
      duration: r,
      enterFromClass: s = `${n}-enter-from`,
      enterActiveClass: o = `${n}-enter-active`,
      enterToClass: a = `${n}-enter-to`,
      appearFromClass: l = s,
      appearActiveClass: u = o,
      appearToClass: c = a,
      leaveFromClass: d = `${n}-leave-from`,
      leaveActiveClass: f = `${n}-leave-active`,
      leaveToClass: m = `${n}-leave-to`,
    } = e,
    p = pF(r),
    v = p && p[0],
    y = p && p[1],
    {
      onBeforeEnter: T,
      onEnter: A,
      onEnterCancelled: x,
      onLeave: N,
      onLeaveCancelled: V,
      onBeforeAppear: D = T,
      onAppear: I = A,
      onAppearCancelled: w = x,
    } = t,
    _ = (C, R, B) => {
      ls(C, R ? c : a), ls(C, R ? u : o), B && B()
    },
    S = (C, R) => {
      ;(C._isLeaving = !1), ls(C, d), ls(C, m), ls(C, f), R && R()
    },
    E = (C) => (R, B) => {
      const U = C ? I : A,
        $ = () => _(R, C, B)
      no(U, [R, $]),
        HI(() => {
          ls(R, C ? l : s), Sr(R, C ? c : a), zI(U) || WI(R, i, v, $)
        })
    }
  return rn(t, {
    onBeforeEnter(C) {
      no(T, [C]), Sr(C, s), Sr(C, o)
    },
    onBeforeAppear(C) {
      no(D, [C]), Sr(C, l), Sr(C, u)
    },
    onEnter: E(!1),
    onAppear: E(!0),
    onLeave(C, R) {
      C._isLeaving = !0
      const B = () => S(C, R)
      Sr(C, d),
        Sr(C, f),
        UA(),
        HI(() => {
          C._isLeaving && (ls(C, d), Sr(C, m), zI(N) || WI(C, i, y, B))
        }),
        no(N, [C, B])
    },
    onEnterCancelled(C) {
      _(C, !1), no(x, [C])
    },
    onAppearCancelled(C) {
      _(C, !0), no(w, [C])
    },
    onLeaveCancelled(C) {
      S(C), no(V, [C])
    },
  })
}
function pF(e) {
  if (e == null) return null
  if (St(e)) return [Tg(e.enter), Tg(e.leave)]
  {
    const t = Tg(e)
    return [t, t]
  }
}
function Tg(e) {
  return AC(e)
}
function Sr(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e[dl] || (e[dl] = new Set())).add(t)
}
function ls(e, t) {
  t.split(/\s+/).forEach((i) => i && e.classList.remove(i))
  const n = e[dl]
  n && (n.delete(t), n.size || (e[dl] = void 0))
}
function HI(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e)
  })
}
let yF = 0
function WI(e, t, n, i) {
  const r = (e._endId = ++yF),
    s = () => {
      r === e._endId && i()
    }
  if (n) return setTimeout(s, n)
  const { type: o, timeout: a, propCount: l } = $A(e, t)
  if (!o) return i()
  const u = o + 'end'
  let c = 0
  const d = () => {
      e.removeEventListener(u, f), s()
    },
    f = (m) => {
      m.target === e && ++c >= l && d()
    }
  setTimeout(() => {
    c < l && d()
  }, a + 1),
    e.addEventListener(u, f)
}
function $A(e, t) {
  const n = window.getComputedStyle(e),
    i = (p) => (n[p] || '').split(', '),
    r = i(`${is}Delay`),
    s = i(`${is}Duration`),
    o = qI(r, s),
    a = i(`${du}Delay`),
    l = i(`${du}Duration`),
    u = qI(a, l)
  let c = null,
    d = 0,
    f = 0
  t === is
    ? o > 0 && ((c = is), (d = o), (f = s.length))
    : t === du
    ? u > 0 && ((c = du), (d = u), (f = l.length))
    : ((d = Math.max(o, u)), (c = d > 0 ? (o > u ? is : du) : null), (f = c ? (c === is ? s.length : l.length) : 0))
  const m = c === is && /\b(transform|all)(,|$)/.test(i(`${is}Property`).toString())
  return { type: c, timeout: d, propCount: f, hasTransform: m }
}
function qI(e, t) {
  for (; e.length < t.length; ) e = e.concat(e)
  return Math.max(...t.map((n, i) => GI(n) + GI(e[i])))
}
function GI(e) {
  return e === 'auto' ? 0 : Number(e.slice(0, -1).replace(',', '.')) * 1e3
}
function UA() {
  return document.body.offsetHeight
}
function _F(e, t, n) {
  const i = e[dl]
  i && (t = (t ? [t, ...i] : [...i]).join(' ')),
    t == null ? e.removeAttribute('class') : n ? e.setAttribute('class', t) : (e.className = t)
}
const Lh = Symbol('_vod'),
  jA = Symbol('_vsh'),
  Qi = {
    beforeMount(e, { value: t }, { transition: n }) {
      ;(e[Lh] = e.style.display === 'none' ? '' : e.style.display), n && t ? n.beforeEnter(e) : hu(e, t)
    },
    mounted(e, { value: t }, { transition: n }) {
      n && t && n.enter(e)
    },
    updated(e, { value: t, oldValue: n }, { transition: i }) {
      !t != !n &&
        (i
          ? t
            ? (i.beforeEnter(e), hu(e, !0), i.enter(e))
            : i.leave(e, () => {
                hu(e, !1)
              })
          : hu(e, t))
    },
    beforeUnmount(e, { value: t }) {
      hu(e, t)
    },
  }
function hu(e, t) {
  ;(e.style.display = t ? e[Lh] : 'none'), (e[jA] = !t)
}
const bF = Symbol(''),
  wF = /(^|;)\s*display\s*:/
function IF(e, t, n) {
  const i = e.style,
    r = Bt(n)
  let s = !1
  if (n && !r) {
    if (t)
      if (Bt(t))
        for (const o of t.split(';')) {
          const a = o.slice(0, o.indexOf(':')).trim()
          n[a] == null && gh(i, a, '')
        }
      else for (const o in t) n[o] == null && gh(i, o, '')
    for (const o in n) o === 'display' && (s = !0), gh(i, o, n[o])
  } else if (r) {
    if (t !== n) {
      const o = i[bF]
      o && (n += ';' + o), (i.cssText = n), (s = wF.test(n))
    }
  } else t && e.removeAttribute('style')
  Lh in e && ((e[Lh] = s ? i.display : ''), e[jA] && (i.display = 'none'))
}
const KI = /\s*!important$/
function gh(e, t, n) {
  if (Ue(n)) n.forEach((i) => gh(e, t, i))
  else if ((n == null && (n = ''), t.startsWith('--'))) e.setProperty(t, n)
  else {
    const i = SF(e, t)
    KI.test(n) ? e.setProperty(ta(i), n.replace(KI, ''), 'important') : (e[i] = n)
  }
}
const YI = ['Webkit', 'Moz', 'ms'],
  Cg = {}
function SF(e, t) {
  const n = Cg[t]
  if (n) return n
  let i = gi(t)
  if (i !== 'filter' && i in e) return (Cg[t] = i)
  i = gr(i)
  for (let r = 0; r < YI.length; r++) {
    const s = YI[r] + i
    if (s in e) return (Cg[t] = s)
  }
  return t
}
const QI = 'http://www.w3.org/1999/xlink'
function XI(e, t, n, i, r, s = kM(t)) {
  i && t.startsWith('xlink:')
    ? n == null
      ? e.removeAttributeNS(QI, t.slice(6, t.length))
      : e.setAttributeNS(QI, t, n)
    : n == null || (s && !PC(n))
    ? e.removeAttribute(t)
    : e.setAttribute(t, s ? '' : Bs(n) ? String(n) : n)
}
function EF(e, t, n, i) {
  if (t === 'innerHTML' || t === 'textContent') {
    if (n == null) return
    e[t] = n
    return
  }
  const r = e.tagName
  if (t === 'value' && r !== 'PROGRESS' && !r.includes('-')) {
    const o = r === 'OPTION' ? e.getAttribute('value') || '' : e.value,
      a = n == null ? '' : String(n)
    ;(o !== a || !('_value' in e)) && (e.value = a), n == null && e.removeAttribute(t), (e._value = n)
    return
  }
  let s = !1
  if (n === '' || n == null) {
    const o = typeof e[t]
    o === 'boolean'
      ? (n = PC(n))
      : n == null && o === 'string'
      ? ((n = ''), (s = !0))
      : o === 'number' && ((n = 0), (s = !0))
  }
  try {
    e[t] = n
  } catch {}
  s && e.removeAttribute(t)
}
function La(e, t, n, i) {
  e.addEventListener(t, n, i)
}
function TF(e, t, n, i) {
  e.removeEventListener(t, n, i)
}
const JI = Symbol('_vei')
function CF(e, t, n, i, r = null) {
  const s = e[JI] || (e[JI] = {}),
    o = s[t]
  if (i && o) o.value = i
  else {
    const [a, l] = AF(t)
    if (i) {
      const u = (s[t] = RF(i, r))
      La(e, a, u, l)
    } else o && (TF(e, a, o, l), (s[t] = void 0))
  }
}
const ZI = /(?:Once|Passive|Capture)$/
function AF(e) {
  let t
  if (ZI.test(e)) {
    t = {}
    let i
    for (; (i = e.match(ZI)); ) (e = e.slice(0, e.length - i[0].length)), (t[i[0].toLowerCase()] = !0)
  }
  return [e[2] === ':' ? e.slice(3) : ta(e.slice(2)), t]
}
let Ag = 0
const kF = Promise.resolve(),
  PF = () => Ag || (kF.then(() => (Ag = 0)), (Ag = Date.now()))
function RF(e, t) {
  const n = (i) => {
    if (!i._vts) i._vts = Date.now()
    else if (i._vts <= n.attached) return
    ki(xF(i, n.value), t, 5, [i])
  }
  return (n.value = e), (n.attached = PF()), n
}
function xF(e, t) {
  if (Ue(t)) {
    const n = e.stopImmediatePropagation
    return (
      (e.stopImmediatePropagation = () => {
        n.call(e), (e._stopped = !0)
      }),
      t.map((i) => (r) => !r._stopped && i && i(r))
    )
  } else return t
}
const eS = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
  VF = (e, t, n, i, r, s) => {
    const o = r === 'svg'
    t === 'class'
      ? _F(e, i, o)
      : t === 'style'
      ? IF(e, n, i)
      : kf(t)
      ? _y(t) || CF(e, t, n, i, s)
      : (t[0] === '.' ? ((t = t.slice(1)), !0) : t[0] === '^' ? ((t = t.slice(1)), !1) : DF(e, t, i, o))
      ? (EF(e, t, i),
        !e.tagName.includes('-') &&
          (t === 'value' || t === 'checked' || t === 'selected') &&
          XI(e, t, i, o, s, t !== 'value'))
      : (t === 'true-value' ? (e._trueValue = i) : t === 'false-value' && (e._falseValue = i), XI(e, t, i, o))
  }
function DF(e, t, n, i) {
  if (i) return !!(t === 'innerHTML' || t === 'textContent' || (t in e && eS(t) && qe(n)))
  if (
    t === 'spellcheck' ||
    t === 'draggable' ||
    t === 'translate' ||
    t === 'form' ||
    (t === 'list' && e.tagName === 'INPUT') ||
    (t === 'type' && e.tagName === 'TEXTAREA')
  )
    return !1
  if (t === 'width' || t === 'height') {
    const r = e.tagName
    if (r === 'IMG' || r === 'VIDEO' || r === 'CANVAS' || r === 'SOURCE') return !1
  }
  return eS(t) && Bt(n) ? !1 : t in e
}
const zA = new WeakMap(),
  HA = new WeakMap(),
  Fh = Symbol('_moveCb'),
  tS = Symbol('_enterCb'),
  WA = {
    name: 'TransitionGroup',
    props: rn({}, vF, { tag: String, moveClass: String }),
    setup(e, { slots: t }) {
      const n = $c(),
        i = iA()
      let r, s
      return (
        Ny(() => {
          if (!r.length) return
          const o = e.moveClass || `${e.name || 'v'}-move`
          if (!FF(r[0].el, n.vnode.el, o)) return
          r.forEach(OF), r.forEach(MF)
          const a = r.filter(LF)
          UA(),
            a.forEach((l) => {
              const u = l.el,
                c = u.style
              Sr(u, o), (c.transform = c.webkitTransform = c.transitionDuration = '')
              const d = (u[Fh] = (f) => {
                ;(f && f.target !== u) ||
                  ((!f || /transform$/.test(f.propertyName)) &&
                    (u.removeEventListener('transitionend', d), (u[Fh] = null), ls(u, o)))
              })
              u.addEventListener('transitionend', d)
            })
        }),
        () => {
          const o = ze(e),
            a = BA(o)
          let l = o.tag || ke
          if (((r = []), s))
            for (let u = 0; u < s.length; u++) {
              const c = s[u]
              c.el &&
                c.el instanceof Element &&
                (r.push(c), ll(c, sc(c, a, i, n)), zA.set(c, c.el.getBoundingClientRect()))
            }
          s = t.default ? Vy(t.default()) : []
          for (let u = 0; u < s.length; u++) {
            const c = s[u]
            c.key != null && ll(c, sc(c, a, i, n))
          }
          return g(l, null, s)
        }
      )
    },
  },
  NF = (e) => delete e.mode
WA.props
const Wy = WA
function OF(e) {
  const t = e.el
  t[Fh] && t[Fh](), t[tS] && t[tS]()
}
function MF(e) {
  HA.set(e, e.el.getBoundingClientRect())
}
function LF(e) {
  const t = zA.get(e),
    n = HA.get(e),
    i = t.left - n.left,
    r = t.top - n.top
  if (i || r) {
    const s = e.el.style
    return (s.transform = s.webkitTransform = `translate(${i}px,${r}px)`), (s.transitionDuration = '0s'), e
  }
}
function FF(e, t, n) {
  const i = e.cloneNode(),
    r = e[dl]
  r &&
    r.forEach((a) => {
      a.split(/\s+/).forEach((l) => l && i.classList.remove(l))
    }),
    n.split(/\s+/).forEach((a) => a && i.classList.add(a)),
    (i.style.display = 'none')
  const s = t.nodeType === 1 ? t : t.parentNode
  s.appendChild(i)
  const { hasTransform: o } = $A(i)
  return s.removeChild(i), o
}
const nS = (e) => {
  const t = e.props['onUpdate:modelValue'] || !1
  return Ue(t) ? (n) => hh(t, n) : t
}
function BF(e) {
  e.target.composing = !0
}
function iS(e) {
  const t = e.target
  t.composing && ((t.composing = !1), t.dispatchEvent(new Event('input')))
}
const kg = Symbol('_assign'),
  $F = {
    created(e, { modifiers: { lazy: t, trim: n, number: i } }, r) {
      e[kg] = nS(r)
      const s = i || (r.props && r.props.type === 'number')
      La(e, t ? 'change' : 'input', (o) => {
        if (o.target.composing) return
        let a = e.value
        n && (a = a.trim()), s && (a = yv(a)), e[kg](a)
      }),
        n &&
          La(e, 'change', () => {
            e.value = e.value.trim()
          }),
        t || (La(e, 'compositionstart', BF), La(e, 'compositionend', iS), La(e, 'change', iS))
    },
    mounted(e, { value: t }) {
      e.value = t ?? ''
    },
    beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: i, trim: r, number: s } }, o) {
      if (((e[kg] = nS(o)), e.composing)) return
      const a = (s || e.type === 'number') && !/^0\d/.test(e.value) ? yv(e.value) : e.value,
        l = t ?? ''
      a !== l &&
        ((document.activeElement === e && e.type !== 'range' && ((i && t === n) || (r && e.value.trim() === l))) ||
          (e.value = l))
    },
  },
  UF = ['ctrl', 'shift', 'alt', 'meta'],
  jF = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => 'button' in e && e.button !== 0,
    middle: (e) => 'button' in e && e.button !== 1,
    right: (e) => 'button' in e && e.button !== 2,
    exact: (e, t) => UF.some((n) => e[`${n}Key`] && !t.includes(n)),
  },
  rS = (e, t) => {
    const n = e._withMods || (e._withMods = {}),
      i = t.join('.')
    return (
      n[i] ||
      (n[i] = (r, ...s) => {
        for (let o = 0; o < t.length; o++) {
          const a = jF[t[o]]
          if (a && a(r, t)) return
        }
        return e(r, ...s)
      })
    )
  },
  zF = rn({ patchProp: VF }, gF)
let sS
function qA() {
  return sS || (sS = NL(zF))
}
const GA = (...e) => {
    qA().render(...e)
  },
  HF = (...e) => {
    const t = qA().createApp(...e),
      { mount: n } = t
    return (
      (t.mount = (i) => {
        const r = qF(i)
        if (!r) return
        const s = t._component
        !qe(s) && !s.render && !s.template && (s.template = r.innerHTML), (r.innerHTML = '')
        const o = n(r, !1, WF(r))
        return r instanceof Element && (r.removeAttribute('v-cloak'), r.setAttribute('data-v-app', '')), o
      }),
      t
    )
  }
function WF(e) {
  if (e instanceof SVGElement) return 'svg'
  if (typeof MathMLElement == 'function' && e instanceof MathMLElement) return 'mathml'
}
function qF(e) {
  return Bt(e) ? document.querySelector(e) : e
}
var GF = !1
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ let KA
const jf = (e) => (KA = e),
  YA = Symbol()
function Dv(e) {
  return (
    e &&
    typeof e == 'object' &&
    Object.prototype.toString.call(e) === '[object Object]' &&
    typeof e.toJSON != 'function'
  )
}
var Uu
;(function (e) {
  ;(e.direct = 'direct'), (e.patchObject = 'patch object'), (e.patchFunction = 'patch function')
})(Uu || (Uu = {}))
function KF() {
  const e = Nl(!0),
    t = e.run(() => le({}))
  let n = [],
    i = []
  const r = Nf({
    install(s) {
      jf(r), (r._a = s), s.provide(YA, r), (s.config.globalProperties.$pinia = r), i.forEach((o) => n.push(o)), (i = [])
    },
    use(s) {
      return !this._a && !GF ? i.push(s) : n.push(s), this
    },
    _p: n,
    _a: null,
    _e: e,
    _s: new Map(),
    state: t,
  })
  return r
}
const QA = () => {}
function oS(e, t, n, i = QA) {
  e.push(t)
  const r = () => {
    const s = e.indexOf(t)
    s > -1 && (e.splice(s, 1), i())
  }
  return !n && Iy() && gn(r), r
}
function Ca(e, ...t) {
  e.slice().forEach((n) => {
    n(...t)
  })
}
const YF = (e) => e()
function Nv(e, t) {
  e instanceof Map && t instanceof Map && t.forEach((n, i) => e.set(i, n)),
    e instanceof Set && t instanceof Set && t.forEach(e.add, e)
  for (const n in t) {
    if (!t.hasOwnProperty(n)) continue
    const i = t[n],
      r = e[n]
    Dv(r) && Dv(i) && e.hasOwnProperty(n) && !It(i) && !Io(i) ? (e[n] = Nv(r, i)) : (e[n] = i)
  }
  return e
}
const QF = Symbol()
function XF(e) {
  return !Dv(e) || !e.hasOwnProperty(QF)
}
const { assign: us } = Object
function JF(e) {
  return !!(It(e) && e.effect)
}
function ZF(e, t, n, i) {
  const { state: r, actions: s, getters: o } = t,
    a = n.state.value[e]
  let l
  function u() {
    a || (n.state.value[e] = r ? r() : {})
    const c = js(n.state.value[e])
    return us(
      c,
      s,
      Object.keys(o || {}).reduce(
        (d, f) => (
          (d[f] = Nf(
            k(() => {
              jf(n)
              const m = n._s.get(e)
              return o[f].call(m, m)
            })
          )),
          d
        ),
        {}
      )
    )
  }
  return (l = XA(e, u, t, n, i, !0)), l
}
function XA(e, t, n = {}, i, r, s) {
  let o
  const a = us({ actions: {} }, n),
    l = { deep: !0 }
  let u,
    c,
    d = [],
    f = [],
    m
  const p = i.state.value[e]
  !s && !p && (i.state.value[e] = {}), le({})
  let v
  function y(w) {
    let _
    ;(u = c = !1),
      typeof w == 'function'
        ? (w(i.state.value[e]), (_ = { type: Uu.patchFunction, storeId: e, events: m }))
        : (Nv(i.state.value[e], w), (_ = { type: Uu.patchObject, payload: w, storeId: e, events: m }))
    const S = (v = Symbol())
    Xe().then(() => {
      v === S && (u = !0)
    }),
      (c = !0),
      Ca(d, _, i.state.value[e])
  }
  const T = s
    ? function () {
        const { state: _ } = n,
          S = _ ? _() : {}
        this.$patch((E) => {
          us(E, S)
        })
      }
    : QA
  function A() {
    o.stop(), (d = []), (f = []), i._s.delete(e)
  }
  function x(w, _) {
    return function () {
      jf(i)
      const S = Array.from(arguments),
        E = [],
        C = []
      function R($) {
        E.push($)
      }
      function B($) {
        C.push($)
      }
      Ca(f, { args: S, name: w, store: V, after: R, onError: B })
      let U
      try {
        U = _.apply(this && this.$id === e ? this : V, S)
      } catch ($) {
        throw (Ca(C, $), $)
      }
      return U instanceof Promise
        ? U.then(($) => (Ca(E, $), $)).catch(($) => (Ca(C, $), Promise.reject($)))
        : (Ca(E, U), U)
    }
  }
  const N = {
      _p: i,
      $id: e,
      $onAction: oS.bind(null, f),
      $patch: y,
      $reset: T,
      $subscribe(w, _ = {}) {
        const S = oS(d, w, _.detached, () => E()),
          E = o.run(() =>
            be(
              () => i.state.value[e],
              (C) => {
                ;(_.flush === 'sync' ? c : u) && w({ storeId: e, type: Uu.direct, events: m }, C)
              },
              us({}, l, _)
            )
          )
        return S
      },
      $dispose: A,
    },
    V = wn(N)
  i._s.set(e, V)
  const I = ((i._a && i._a.runWithContext) || YF)(() => i._e.run(() => (o = Nl()).run(t)))
  for (const w in I) {
    const _ = I[w]
    if ((It(_) && !JF(_)) || Io(_))
      s || (p && XF(_) && (It(_) ? (_.value = p[w]) : Nv(_, p[w])), (i.state.value[e][w] = _))
    else if (typeof _ == 'function') {
      const S = x(w, _)
      ;(I[w] = S), (a.actions[w] = _)
    }
  }
  return (
    us(V, I),
    us(ze(V), I),
    Object.defineProperty(V, '$state', {
      get: () => i.state.value[e],
      set: (w) => {
        y((_) => {
          us(_, w)
        })
      },
    }),
    i._p.forEach((w) => {
      us(
        V,
        o.run(() => w({ store: V, app: i._a, pinia: i, options: a }))
      )
    }),
    p && s && n.hydrate && n.hydrate(V.$state, p),
    (u = !0),
    (c = !0),
    V
  )
}
function Fte(e, t, n) {
  let i, r
  const s = typeof t == 'function'
  ;(i = e), (r = s ? n : t)
  function o(a, l) {
    const u = SL()
    return (
      (a = a || (u ? je(YA, null) : null)),
      a && jf(a),
      (a = KA),
      a._s.has(i) || (s ? XA(i, t, r, a) : ZF(i, r, a)),
      a._s.get(i)
    )
  }
  return (o.$id = i), o
}
var aS = {}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const JA = { NODE_CLIENT: !1, NODE_ADMIN: !1, SDK_VERSION: '${JSCORE_VERSION}' }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Pe = function (e, t) {
    if (!e) throw Ml(t)
  },
  Ml = function (e) {
    return new Error('Firebase Database (' + JA.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + e)
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ZA = function (e) {
    const t = []
    let n = 0
    for (let i = 0; i < e.length; i++) {
      let r = e.charCodeAt(i)
      r < 128
        ? (t[n++] = r)
        : r < 2048
        ? ((t[n++] = (r >> 6) | 192), (t[n++] = (r & 63) | 128))
        : (r & 64512) === 55296 && i + 1 < e.length && (e.charCodeAt(i + 1) & 64512) === 56320
        ? ((r = 65536 + ((r & 1023) << 10) + (e.charCodeAt(++i) & 1023)),
          (t[n++] = (r >> 18) | 240),
          (t[n++] = ((r >> 12) & 63) | 128),
          (t[n++] = ((r >> 6) & 63) | 128),
          (t[n++] = (r & 63) | 128))
        : ((t[n++] = (r >> 12) | 224), (t[n++] = ((r >> 6) & 63) | 128), (t[n++] = (r & 63) | 128))
    }
    return t
  },
  eB = function (e) {
    const t = []
    let n = 0,
      i = 0
    for (; n < e.length; ) {
      const r = e[n++]
      if (r < 128) t[i++] = String.fromCharCode(r)
      else if (r > 191 && r < 224) {
        const s = e[n++]
        t[i++] = String.fromCharCode(((r & 31) << 6) | (s & 63))
      } else if (r > 239 && r < 365) {
        const s = e[n++],
          o = e[n++],
          a = e[n++],
          l = (((r & 7) << 18) | ((s & 63) << 12) | ((o & 63) << 6) | (a & 63)) - 65536
        ;(t[i++] = String.fromCharCode(55296 + (l >> 10))), (t[i++] = String.fromCharCode(56320 + (l & 1023)))
      } else {
        const s = e[n++],
          o = e[n++]
        t[i++] = String.fromCharCode(((r & 15) << 12) | ((s & 63) << 6) | (o & 63))
      }
    }
    return t.join('')
  },
  zf = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + '+/='
    },
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + '-_.'
    },
    HAS_NATIVE_SUPPORT: typeof atob == 'function',
    encodeByteArray(e, t) {
      if (!Array.isArray(e)) throw Error('encodeByteArray takes an array as a parameter')
      this.init_()
      const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
        i = []
      for (let r = 0; r < e.length; r += 3) {
        const s = e[r],
          o = r + 1 < e.length,
          a = o ? e[r + 1] : 0,
          l = r + 2 < e.length,
          u = l ? e[r + 2] : 0,
          c = s >> 2,
          d = ((s & 3) << 4) | (a >> 4)
        let f = ((a & 15) << 2) | (u >> 6),
          m = u & 63
        l || ((m = 64), o || (f = 64)), i.push(n[c], n[d], n[f], n[m])
      }
      return i.join('')
    },
    encodeString(e, t) {
      return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(ZA(e), t)
    },
    decodeString(e, t) {
      return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : eB(this.decodeStringToByteArray(e, t))
    },
    decodeStringToByteArray(e, t) {
      this.init_()
      const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_,
        i = []
      for (let r = 0; r < e.length; ) {
        const s = n[e.charAt(r++)],
          a = r < e.length ? n[e.charAt(r)] : 0
        ++r
        const u = r < e.length ? n[e.charAt(r)] : 64
        ++r
        const d = r < e.length ? n[e.charAt(r)] : 64
        if ((++r, s == null || a == null || u == null || d == null)) throw new tB()
        const f = (s << 2) | (a >> 4)
        if ((i.push(f), u !== 64)) {
          const m = ((a << 4) & 240) | (u >> 2)
          if ((i.push(m), d !== 64)) {
            const p = ((u << 6) & 192) | d
            i.push(p)
          }
        }
      }
      return i
    },
    init_() {
      if (!this.byteToCharMap_) {
        ;(this.byteToCharMap_ = {}),
          (this.charToByteMap_ = {}),
          (this.byteToCharMapWebSafe_ = {}),
          (this.charToByteMapWebSafe_ = {})
        for (let e = 0; e < this.ENCODED_VALS.length; e++)
          (this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e)),
            (this.charToByteMap_[this.byteToCharMap_[e]] = e),
            (this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e)),
            (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e),
            e >= this.ENCODED_VALS_BASE.length &&
              ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e),
              (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e))
      }
    },
  }
class tB extends Error {
  constructor() {
    super(...arguments), (this.name = 'DecodeBase64StringError')
  }
}
const ek = function (e) {
    const t = ZA(e)
    return zf.encodeByteArray(t, !0)
  },
  Bh = function (e) {
    return ek(e).replace(/\./g, '')
  },
  $h = function (e) {
    try {
      return zf.decodeString(e, !0)
    } catch (t) {
      console.error('base64Decode failed: ', t)
    }
    return null
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function nB(e) {
  return tk(void 0, e)
}
function tk(e, t) {
  if (!(t instanceof Object)) return t
  switch (t.constructor) {
    case Date:
      const n = t
      return new Date(n.getTime())
    case Object:
      e === void 0 && (e = {})
      break
    case Array:
      e = []
      break
    default:
      return t
  }
  for (const n in t) !t.hasOwnProperty(n) || !iB(n) || (e[n] = tk(e[n], t[n]))
  return e
}
function iB(e) {
  return e !== '__proto__'
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function rB() {
  if (typeof self < 'u') return self
  if (typeof window < 'u') return window
  if (typeof global < 'u') return global
  throw new Error('Unable to locate global object.')
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const sB = () => rB().__FIREBASE_DEFAULTS__,
  oB = () => {
    if (typeof process > 'u' || typeof aS > 'u') return
    const e = aS.__FIREBASE_DEFAULTS__
    if (e) return JSON.parse(e)
  },
  aB = () => {
    if (typeof document > 'u') return
    let e
    try {
      e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
    } catch {
      return
    }
    const t = e && $h(e[1])
    return t && JSON.parse(t)
  },
  Hf = () => {
    try {
      return sB() || oB() || aB()
    } catch (e) {
      console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`)
      return
    }
  },
  nk = (e) => {
    var t, n
    return (n = (t = Hf()) === null || t === void 0 ? void 0 : t.emulatorHosts) === null || n === void 0 ? void 0 : n[e]
  },
  lB = (e) => {
    const t = nk(e)
    if (!t) return
    const n = t.lastIndexOf(':')
    if (n <= 0 || n + 1 === t.length) throw new Error(`Invalid host ${t} with no separate hostname and port!`)
    const i = parseInt(t.substring(n + 1), 10)
    return t[0] === '[' ? [t.substring(1, n - 1), i] : [t.substring(0, n), i]
  },
  ik = () => {
    var e
    return (e = Hf()) === null || e === void 0 ? void 0 : e.config
  },
  rk = (e) => {
    var t
    return (t = Hf()) === null || t === void 0 ? void 0 : t[`_${e}`]
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ac {
  constructor() {
    ;(this.reject = () => {}),
      (this.resolve = () => {}),
      (this.promise = new Promise((t, n) => {
        ;(this.resolve = t), (this.reject = n)
      }))
  }
  wrapCallback(t) {
    return (n, i) => {
      n ? this.reject(n) : this.resolve(i),
        typeof t == 'function' && (this.promise.catch(() => {}), t.length === 1 ? t(n) : t(n, i))
    }
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function uB(e, t) {
  if (e.uid)
    throw new Error(
      'The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'
    )
  const n = { alg: 'none', type: 'JWT' },
    i = t || 'demo-project',
    r = e.iat || 0,
    s = e.sub || e.user_id
  if (!s) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!")
  const o = Object.assign(
    {
      iss: `https://securetoken.google.com/${i}`,
      aud: i,
      iat: r,
      exp: r + 3600,
      auth_time: r,
      sub: s,
      user_id: s,
      firebase: { sign_in_provider: 'custom', identities: {} },
    },
    e
  )
  return [Bh(JSON.stringify(n)), Bh(JSON.stringify(o)), ''].join('.')
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Zt() {
  return typeof navigator < 'u' && typeof navigator.userAgent == 'string' ? navigator.userAgent : ''
}
function qy() {
  return (
    typeof window < 'u' &&
    !!(window.cordova || window.phonegap || window.PhoneGap) &&
    /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Zt())
  )
}
function cB() {
  var e
  const t = (e = Hf()) === null || e === void 0 ? void 0 : e.forceEnvironment
  if (t === 'node') return !0
  if (t === 'browser') return !1
  try {
    return Object.prototype.toString.call(global.process) === '[object process]'
  } catch {
    return !1
  }
}
function sk() {
  const e = typeof chrome == 'object' ? chrome.runtime : typeof browser == 'object' ? browser.runtime : void 0
  return typeof e == 'object' && e.id !== void 0
}
function ok() {
  return typeof navigator == 'object' && navigator.product === 'ReactNative'
}
function dB() {
  const e = Zt()
  return e.indexOf('MSIE ') >= 0 || e.indexOf('Trident/') >= 0
}
function ak() {
  return JA.NODE_ADMIN === !0
}
function lk() {
  return (
    !cB() && !!navigator.userAgent && navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome')
  )
}
function jc() {
  try {
    return typeof indexedDB == 'object'
  } catch {
    return !1
  }
}
function Gy() {
  return new Promise((e, t) => {
    try {
      let n = !0
      const i = 'validate-browser-context-for-indexeddb-analytics-module',
        r = self.indexedDB.open(i)
      ;(r.onsuccess = () => {
        r.result.close(), n || self.indexedDB.deleteDatabase(i), e(!0)
      }),
        (r.onupgradeneeded = () => {
          n = !1
        }),
        (r.onerror = () => {
          var s
          t(((s = r.error) === null || s === void 0 ? void 0 : s.message) || '')
        })
    } catch (n) {
      t(n)
    }
  })
}
function uk() {
  return !(typeof navigator > 'u' || !navigator.cookieEnabled)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const hB = 'FirebaseError'
class Di extends Error {
  constructor(t, n, i) {
    super(n),
      (this.code = t),
      (this.customData = i),
      (this.name = hB),
      Object.setPrototypeOf(this, Di.prototype),
      Error.captureStackTrace && Error.captureStackTrace(this, zr.prototype.create)
  }
}
class zr {
  constructor(t, n, i) {
    ;(this.service = t), (this.serviceName = n), (this.errors = i)
  }
  create(t, ...n) {
    const i = n[0] || {},
      r = `${this.service}/${t}`,
      s = this.errors[t],
      o = s ? fB(s, i) : 'Error',
      a = `${this.serviceName}: ${o} (${r}).`
    return new Di(r, a, i)
  }
}
function fB(e, t) {
  return e.replace(mB, (n, i) => {
    const r = t[i]
    return r != null ? String(r) : `<${i}?>`
  })
}
const mB = /\{\$([^}]+)}/g
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function lc(e) {
  return JSON.parse(e)
}
function Sn(e) {
  return JSON.stringify(e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ck = function (e) {
    let t = {},
      n = {},
      i = {},
      r = ''
    try {
      const s = e.split('.')
      ;(t = lc($h(s[0]) || '')), (n = lc($h(s[1]) || '')), (r = s[2]), (i = n.d || {}), delete n.d
    } catch {}
    return { header: t, claims: n, data: i, signature: r }
  },
  gB = function (e) {
    const t = ck(e),
      n = t.claims
    return !!n && typeof n == 'object' && n.hasOwnProperty('iat')
  },
  vB = function (e) {
    const t = ck(e).claims
    return typeof t == 'object' && t.admin === !0
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Hr(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t)
}
function hl(e, t) {
  if (Object.prototype.hasOwnProperty.call(e, t)) return e[t]
}
function Ov(e) {
  for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1
  return !0
}
function Uh(e, t, n) {
  const i = {}
  for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (i[r] = t.call(n, e[r], r, e))
  return i
}
function fl(e, t) {
  if (e === t) return !0
  const n = Object.keys(e),
    i = Object.keys(t)
  for (const r of n) {
    if (!i.includes(r)) return !1
    const s = e[r],
      o = t[r]
    if (lS(s) && lS(o)) {
      if (!fl(s, o)) return !1
    } else if (s !== o) return !1
  }
  for (const r of i) if (!n.includes(r)) return !1
  return !0
}
function lS(e) {
  return e !== null && typeof e == 'object'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Ll(e) {
  const t = []
  for (const [n, i] of Object.entries(e))
    Array.isArray(i)
      ? i.forEach((r) => {
          t.push(encodeURIComponent(n) + '=' + encodeURIComponent(r))
        })
      : t.push(encodeURIComponent(n) + '=' + encodeURIComponent(i))
  return t.length ? '&' + t.join('&') : ''
}
function Cu(e) {
  const t = {}
  return (
    e
      .replace(/^\?/, '')
      .split('&')
      .forEach((i) => {
        if (i) {
          const [r, s] = i.split('=')
          t[decodeURIComponent(r)] = decodeURIComponent(s)
        }
      }),
    t
  )
}
function Au(e) {
  const t = e.indexOf('?')
  if (!t) return ''
  const n = e.indexOf('#', t)
  return e.substring(t, n > 0 ? n : void 0)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class pB {
  constructor() {
    ;(this.chain_ = []),
      (this.buf_ = []),
      (this.W_ = []),
      (this.pad_ = []),
      (this.inbuf_ = 0),
      (this.total_ = 0),
      (this.blockSize = 512 / 8),
      (this.pad_[0] = 128)
    for (let t = 1; t < this.blockSize; ++t) this.pad_[t] = 0
    this.reset()
  }
  reset() {
    ;(this.chain_[0] = 1732584193),
      (this.chain_[1] = 4023233417),
      (this.chain_[2] = 2562383102),
      (this.chain_[3] = 271733878),
      (this.chain_[4] = 3285377520),
      (this.inbuf_ = 0),
      (this.total_ = 0)
  }
  compress_(t, n) {
    n || (n = 0)
    const i = this.W_
    if (typeof t == 'string')
      for (let d = 0; d < 16; d++)
        (i[d] =
          (t.charCodeAt(n) << 24) | (t.charCodeAt(n + 1) << 16) | (t.charCodeAt(n + 2) << 8) | t.charCodeAt(n + 3)),
          (n += 4)
    else for (let d = 0; d < 16; d++) (i[d] = (t[n] << 24) | (t[n + 1] << 16) | (t[n + 2] << 8) | t[n + 3]), (n += 4)
    for (let d = 16; d < 80; d++) {
      const f = i[d - 3] ^ i[d - 8] ^ i[d - 14] ^ i[d - 16]
      i[d] = ((f << 1) | (f >>> 31)) & 4294967295
    }
    let r = this.chain_[0],
      s = this.chain_[1],
      o = this.chain_[2],
      a = this.chain_[3],
      l = this.chain_[4],
      u,
      c
    for (let d = 0; d < 80; d++) {
      d < 40
        ? d < 20
          ? ((u = a ^ (s & (o ^ a))), (c = 1518500249))
          : ((u = s ^ o ^ a), (c = 1859775393))
        : d < 60
        ? ((u = (s & o) | (a & (s | o))), (c = 2400959708))
        : ((u = s ^ o ^ a), (c = 3395469782))
      const f = (((r << 5) | (r >>> 27)) + u + l + c + i[d]) & 4294967295
      ;(l = a), (a = o), (o = ((s << 30) | (s >>> 2)) & 4294967295), (s = r), (r = f)
    }
    ;(this.chain_[0] = (this.chain_[0] + r) & 4294967295),
      (this.chain_[1] = (this.chain_[1] + s) & 4294967295),
      (this.chain_[2] = (this.chain_[2] + o) & 4294967295),
      (this.chain_[3] = (this.chain_[3] + a) & 4294967295),
      (this.chain_[4] = (this.chain_[4] + l) & 4294967295)
  }
  update(t, n) {
    if (t == null) return
    n === void 0 && (n = t.length)
    const i = n - this.blockSize
    let r = 0
    const s = this.buf_
    let o = this.inbuf_
    for (; r < n; ) {
      if (o === 0) for (; r <= i; ) this.compress_(t, r), (r += this.blockSize)
      if (typeof t == 'string') {
        for (; r < n; )
          if (((s[o] = t.charCodeAt(r)), ++o, ++r, o === this.blockSize)) {
            this.compress_(s), (o = 0)
            break
          }
      } else
        for (; r < n; )
          if (((s[o] = t[r]), ++o, ++r, o === this.blockSize)) {
            this.compress_(s), (o = 0)
            break
          }
    }
    ;(this.inbuf_ = o), (this.total_ += n)
  }
  digest() {
    const t = []
    let n = this.total_ * 8
    this.inbuf_ < 56
      ? this.update(this.pad_, 56 - this.inbuf_)
      : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56))
    for (let r = this.blockSize - 1; r >= 56; r--) (this.buf_[r] = n & 255), (n /= 256)
    this.compress_(this.buf_)
    let i = 0
    for (let r = 0; r < 5; r++) for (let s = 24; s >= 0; s -= 8) (t[i] = (this.chain_[r] >> s) & 255), ++i
    return t
  }
}
function yB(e, t) {
  const n = new _B(e, t)
  return n.subscribe.bind(n)
}
class _B {
  constructor(t, n) {
    ;(this.observers = []),
      (this.unsubscribes = []),
      (this.observerCount = 0),
      (this.task = Promise.resolve()),
      (this.finalized = !1),
      (this.onNoObservers = n),
      this.task
        .then(() => {
          t(this)
        })
        .catch((i) => {
          this.error(i)
        })
  }
  next(t) {
    this.forEachObserver((n) => {
      n.next(t)
    })
  }
  error(t) {
    this.forEachObserver((n) => {
      n.error(t)
    }),
      this.close(t)
  }
  complete() {
    this.forEachObserver((t) => {
      t.complete()
    }),
      this.close()
  }
  subscribe(t, n, i) {
    let r
    if (t === void 0 && n === void 0 && i === void 0) throw new Error('Missing Observer.')
    bB(t, ['next', 'error', 'complete']) ? (r = t) : (r = { next: t, error: n, complete: i }),
      r.next === void 0 && (r.next = Pg),
      r.error === void 0 && (r.error = Pg),
      r.complete === void 0 && (r.complete = Pg)
    const s = this.unsubscribeOne.bind(this, this.observers.length)
    return (
      this.finalized &&
        this.task.then(() => {
          try {
            this.finalError ? r.error(this.finalError) : r.complete()
          } catch {}
        }),
      this.observers.push(r),
      s
    )
  }
  unsubscribeOne(t) {
    this.observers === void 0 ||
      this.observers[t] === void 0 ||
      (delete this.observers[t],
      (this.observerCount -= 1),
      this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
  }
  forEachObserver(t) {
    if (!this.finalized) for (let n = 0; n < this.observers.length; n++) this.sendOne(n, t)
  }
  sendOne(t, n) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[t] !== void 0)
        try {
          n(this.observers[t])
        } catch (i) {
          typeof console < 'u' && console.error && console.error(i)
        }
    })
  }
  close(t) {
    this.finalized ||
      ((this.finalized = !0),
      t !== void 0 && (this.finalError = t),
      this.task.then(() => {
        ;(this.observers = void 0), (this.onNoObservers = void 0)
      }))
  }
}
function bB(e, t) {
  if (typeof e != 'object' || e === null) return !1
  for (const n of t) if (n in e && typeof e[n] == 'function') return !0
  return !1
}
function Pg() {}
function wB(e, t) {
  return `${e} failed: ${t} argument `
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const IB = function (e) {
    const t = []
    let n = 0
    for (let i = 0; i < e.length; i++) {
      let r = e.charCodeAt(i)
      if (r >= 55296 && r <= 56319) {
        const s = r - 55296
        i++, Pe(i < e.length, 'Surrogate pair missing trail surrogate.')
        const o = e.charCodeAt(i) - 56320
        r = 65536 + (s << 10) + o
      }
      r < 128
        ? (t[n++] = r)
        : r < 2048
        ? ((t[n++] = (r >> 6) | 192), (t[n++] = (r & 63) | 128))
        : r < 65536
        ? ((t[n++] = (r >> 12) | 224), (t[n++] = ((r >> 6) & 63) | 128), (t[n++] = (r & 63) | 128))
        : ((t[n++] = (r >> 18) | 240),
          (t[n++] = ((r >> 12) & 63) | 128),
          (t[n++] = ((r >> 6) & 63) | 128),
          (t[n++] = (r & 63) | 128))
    }
    return t
  },
  Wf = function (e) {
    let t = 0
    for (let n = 0; n < e.length; n++) {
      const i = e.charCodeAt(n)
      i < 128 ? t++ : i < 2048 ? (t += 2) : i >= 55296 && i <= 56319 ? ((t += 4), n++) : (t += 3)
    }
    return t
  }
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const SB = 1e3,
  EB = 2,
  TB = 4 * 60 * 60 * 1e3,
  CB = 0.5
function uS(e, t = SB, n = EB) {
  const i = t * Math.pow(n, e),
    r = Math.round(CB * i * (Math.random() - 0.5) * 2)
  return Math.min(TB, i + r)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Et(e) {
  return e && e._delegate ? e._delegate : e
}
class $n {
  constructor(t, n, i) {
    ;(this.name = t),
      (this.instanceFactory = n),
      (this.type = i),
      (this.multipleInstances = !1),
      (this.serviceProps = {}),
      (this.instantiationMode = 'LAZY'),
      (this.onInstanceCreated = null)
  }
  setInstantiationMode(t) {
    return (this.instantiationMode = t), this
  }
  setMultipleInstances(t) {
    return (this.multipleInstances = t), this
  }
  setServiceProps(t) {
    return (this.serviceProps = t), this
  }
  setInstanceCreatedCallback(t) {
    return (this.onInstanceCreated = t), this
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ao = '[DEFAULT]'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class AB {
  constructor(t, n) {
    ;(this.name = t),
      (this.container = n),
      (this.component = null),
      (this.instances = new Map()),
      (this.instancesDeferred = new Map()),
      (this.instancesOptions = new Map()),
      (this.onInitCallbacks = new Map())
  }
  get(t) {
    const n = this.normalizeInstanceIdentifier(t)
    if (!this.instancesDeferred.has(n)) {
      const i = new ac()
      if ((this.instancesDeferred.set(n, i), this.isInitialized(n) || this.shouldAutoInitialize()))
        try {
          const r = this.getOrInitializeService({ instanceIdentifier: n })
          r && i.resolve(r)
        } catch {}
    }
    return this.instancesDeferred.get(n).promise
  }
  getImmediate(t) {
    var n
    const i = this.normalizeInstanceIdentifier(t == null ? void 0 : t.identifier),
      r = (n = t == null ? void 0 : t.optional) !== null && n !== void 0 ? n : !1
    if (this.isInitialized(i) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({ instanceIdentifier: i })
      } catch (s) {
        if (r) return null
        throw s
      }
    else {
      if (r) return null
      throw Error(`Service ${this.name} is not available`)
    }
  }
  getComponent() {
    return this.component
  }
  setComponent(t) {
    if (t.name !== this.name) throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`)
    if (this.component) throw Error(`Component for ${this.name} has already been provided`)
    if (((this.component = t), !!this.shouldAutoInitialize())) {
      if (PB(t))
        try {
          this.getOrInitializeService({ instanceIdentifier: ao })
        } catch {}
      for (const [n, i] of this.instancesDeferred.entries()) {
        const r = this.normalizeInstanceIdentifier(n)
        try {
          const s = this.getOrInitializeService({ instanceIdentifier: r })
          i.resolve(s)
        } catch {}
      }
    }
  }
  clearInstance(t = ao) {
    this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t)
  }
  async delete() {
    const t = Array.from(this.instances.values())
    await Promise.all([
      ...t.filter((n) => 'INTERNAL' in n).map((n) => n.INTERNAL.delete()),
      ...t.filter((n) => '_delete' in n).map((n) => n._delete()),
    ])
  }
  isComponentSet() {
    return this.component != null
  }
  isInitialized(t = ao) {
    return this.instances.has(t)
  }
  getOptions(t = ao) {
    return this.instancesOptions.get(t) || {}
  }
  initialize(t = {}) {
    const { options: n = {} } = t,
      i = this.normalizeInstanceIdentifier(t.instanceIdentifier)
    if (this.isInitialized(i)) throw Error(`${this.name}(${i}) has already been initialized`)
    if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`)
    const r = this.getOrInitializeService({ instanceIdentifier: i, options: n })
    for (const [s, o] of this.instancesDeferred.entries()) {
      const a = this.normalizeInstanceIdentifier(s)
      i === a && o.resolve(r)
    }
    return r
  }
  onInit(t, n) {
    var i
    const r = this.normalizeInstanceIdentifier(n),
      s = (i = this.onInitCallbacks.get(r)) !== null && i !== void 0 ? i : new Set()
    s.add(t), this.onInitCallbacks.set(r, s)
    const o = this.instances.get(r)
    return (
      o && t(o, r),
      () => {
        s.delete(t)
      }
    )
  }
  invokeOnInitCallbacks(t, n) {
    const i = this.onInitCallbacks.get(n)
    if (i)
      for (const r of i)
        try {
          r(t, n)
        } catch {}
  }
  getOrInitializeService({ instanceIdentifier: t, options: n = {} }) {
    let i = this.instances.get(t)
    if (
      !i &&
      this.component &&
      ((i = this.component.instanceFactory(this.container, { instanceIdentifier: kB(t), options: n })),
      this.instances.set(t, i),
      this.instancesOptions.set(t, n),
      this.invokeOnInitCallbacks(i, t),
      this.component.onInstanceCreated)
    )
      try {
        this.component.onInstanceCreated(this.container, t, i)
      } catch {}
    return i || null
  }
  normalizeInstanceIdentifier(t = ao) {
    return this.component ? (this.component.multipleInstances ? t : ao) : t
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== 'EXPLICIT'
  }
}
function kB(e) {
  return e === ao ? void 0 : e
}
function PB(e) {
  return e.instantiationMode === 'EAGER'
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class RB {
  constructor(t) {
    ;(this.name = t), (this.providers = new Map())
  }
  addComponent(t) {
    const n = this.getProvider(t.name)
    if (n.isComponentSet()) throw new Error(`Component ${t.name} has already been registered with ${this.name}`)
    n.setComponent(t)
  }
  addOrOverwriteComponent(t) {
    this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t)
  }
  getProvider(t) {
    if (this.providers.has(t)) return this.providers.get(t)
    const n = new AB(t, this)
    return this.providers.set(t, n), n
  }
  getProviders() {
    return Array.from(this.providers.values())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Je
;(function (e) {
  ;(e[(e.DEBUG = 0)] = 'DEBUG'),
    (e[(e.VERBOSE = 1)] = 'VERBOSE'),
    (e[(e.INFO = 2)] = 'INFO'),
    (e[(e.WARN = 3)] = 'WARN'),
    (e[(e.ERROR = 4)] = 'ERROR'),
    (e[(e.SILENT = 5)] = 'SILENT')
})(Je || (Je = {}))
const xB = { debug: Je.DEBUG, verbose: Je.VERBOSE, info: Je.INFO, warn: Je.WARN, error: Je.ERROR, silent: Je.SILENT },
  VB = Je.INFO,
  DB = { [Je.DEBUG]: 'log', [Je.VERBOSE]: 'log', [Je.INFO]: 'info', [Je.WARN]: 'warn', [Je.ERROR]: 'error' },
  NB = (e, t, ...n) => {
    if (t < e.logLevel) return
    const i = new Date().toISOString(),
      r = DB[t]
    if (r) console[r](`[${i}]  ${e.name}:`, ...n)
    else throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`)
  }
class na {
  constructor(t) {
    ;(this.name = t), (this._logLevel = VB), (this._logHandler = NB), (this._userLogHandler = null)
  }
  get logLevel() {
    return this._logLevel
  }
  set logLevel(t) {
    if (!(t in Je)) throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``)
    this._logLevel = t
  }
  setLogLevel(t) {
    this._logLevel = typeof t == 'string' ? xB[t] : t
  }
  get logHandler() {
    return this._logHandler
  }
  set logHandler(t) {
    if (typeof t != 'function') throw new TypeError('Value assigned to `logHandler` must be a function')
    this._logHandler = t
  }
  get userLogHandler() {
    return this._userLogHandler
  }
  set userLogHandler(t) {
    this._userLogHandler = t
  }
  debug(...t) {
    this._userLogHandler && this._userLogHandler(this, Je.DEBUG, ...t), this._logHandler(this, Je.DEBUG, ...t)
  }
  log(...t) {
    this._userLogHandler && this._userLogHandler(this, Je.VERBOSE, ...t), this._logHandler(this, Je.VERBOSE, ...t)
  }
  info(...t) {
    this._userLogHandler && this._userLogHandler(this, Je.INFO, ...t), this._logHandler(this, Je.INFO, ...t)
  }
  warn(...t) {
    this._userLogHandler && this._userLogHandler(this, Je.WARN, ...t), this._logHandler(this, Je.WARN, ...t)
  }
  error(...t) {
    this._userLogHandler && this._userLogHandler(this, Je.ERROR, ...t), this._logHandler(this, Je.ERROR, ...t)
  }
}
const OB = (e, t) => t.some((n) => e instanceof n)
let cS, dS
function MB() {
  return cS || (cS = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}
function LB() {
  return (
    dS || (dS = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
  )
}
const dk = new WeakMap(),
  Mv = new WeakMap(),
  hk = new WeakMap(),
  Rg = new WeakMap(),
  Ky = new WeakMap()
function FB(e) {
  const t = new Promise((n, i) => {
    const r = () => {
        e.removeEventListener('success', s), e.removeEventListener('error', o)
      },
      s = () => {
        n(Ts(e.result)), r()
      },
      o = () => {
        i(e.error), r()
      }
    e.addEventListener('success', s), e.addEventListener('error', o)
  })
  return (
    t
      .then((n) => {
        n instanceof IDBCursor && dk.set(n, e)
      })
      .catch(() => {}),
    Ky.set(t, e),
    t
  )
}
function BB(e) {
  if (Mv.has(e)) return
  const t = new Promise((n, i) => {
    const r = () => {
        e.removeEventListener('complete', s), e.removeEventListener('error', o), e.removeEventListener('abort', o)
      },
      s = () => {
        n(), r()
      },
      o = () => {
        i(e.error || new DOMException('AbortError', 'AbortError')), r()
      }
    e.addEventListener('complete', s), e.addEventListener('error', o), e.addEventListener('abort', o)
  })
  Mv.set(e, t)
}
let Lv = {
  get(e, t, n) {
    if (e instanceof IDBTransaction) {
      if (t === 'done') return Mv.get(e)
      if (t === 'objectStoreNames') return e.objectStoreNames || hk.get(e)
      if (t === 'store') return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
    }
    return Ts(e[t])
  },
  set(e, t, n) {
    return (e[t] = n), !0
  },
  has(e, t) {
    return e instanceof IDBTransaction && (t === 'done' || t === 'store') ? !0 : t in e
  },
}
function $B(e) {
  Lv = e(Lv)
}
function UB(e) {
  return e === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)
    ? function (t, ...n) {
        const i = e.call(xg(this), t, ...n)
        return hk.set(i, t.sort ? t.sort() : [t]), Ts(i)
      }
    : LB().includes(e)
    ? function (...t) {
        return e.apply(xg(this), t), Ts(dk.get(this))
      }
    : function (...t) {
        return Ts(e.apply(xg(this), t))
      }
}
function jB(e) {
  return typeof e == 'function' ? UB(e) : (e instanceof IDBTransaction && BB(e), OB(e, MB()) ? new Proxy(e, Lv) : e)
}
function Ts(e) {
  if (e instanceof IDBRequest) return FB(e)
  if (Rg.has(e)) return Rg.get(e)
  const t = jB(e)
  return t !== e && (Rg.set(e, t), Ky.set(t, e)), t
}
const xg = (e) => Ky.get(e)
function fk(e, t, { blocked: n, upgrade: i, blocking: r, terminated: s } = {}) {
  const o = indexedDB.open(e, t),
    a = Ts(o)
  return (
    i &&
      o.addEventListener('upgradeneeded', (l) => {
        i(Ts(o.result), l.oldVersion, l.newVersion, Ts(o.transaction), l)
      }),
    n && o.addEventListener('blocked', (l) => n(l.oldVersion, l.newVersion, l)),
    a
      .then((l) => {
        s && l.addEventListener('close', () => s()),
          r && l.addEventListener('versionchange', (u) => r(u.oldVersion, u.newVersion, u))
      })
      .catch(() => {}),
    a
  )
}
const zB = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'],
  HB = ['put', 'add', 'delete', 'clear'],
  Vg = new Map()
function hS(e, t) {
  if (!(e instanceof IDBDatabase && !(t in e) && typeof t == 'string')) return
  if (Vg.get(t)) return Vg.get(t)
  const n = t.replace(/FromIndex$/, ''),
    i = t !== n,
    r = HB.includes(n)
  if (!(n in (i ? IDBIndex : IDBObjectStore).prototype) || !(r || zB.includes(n))) return
  const s = async function (o, ...a) {
    const l = this.transaction(o, r ? 'readwrite' : 'readonly')
    let u = l.store
    return i && (u = u.index(a.shift())), (await Promise.all([u[n](...a), r && l.done]))[0]
  }
  return Vg.set(t, s), s
}
$B((e) => ({ ...e, get: (t, n, i) => hS(t, n) || e.get(t, n, i), has: (t, n) => !!hS(t, n) || e.has(t, n) }))
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class WB {
  constructor(t) {
    this.container = t
  }
  getPlatformInfoString() {
    return this.container
      .getProviders()
      .map((n) => {
        if (qB(n)) {
          const i = n.getImmediate()
          return `${i.library}/${i.version}`
        } else return null
      })
      .filter((n) => n)
      .join(' ')
  }
}
function qB(e) {
  const t = e.getComponent()
  return (t == null ? void 0 : t.type) === 'VERSION'
}
const Fv = '@firebase/app',
  fS = '0.10.7'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const xo = new na('@firebase/app'),
  GB = '@firebase/app-compat',
  KB = '@firebase/analytics-compat',
  YB = '@firebase/analytics',
  QB = '@firebase/app-check-compat',
  XB = '@firebase/app-check',
  JB = '@firebase/auth',
  ZB = '@firebase/auth-compat',
  e2 = '@firebase/database',
  t2 = '@firebase/database-compat',
  n2 = '@firebase/functions',
  i2 = '@firebase/functions-compat',
  r2 = '@firebase/installations',
  s2 = '@firebase/installations-compat',
  o2 = '@firebase/messaging',
  a2 = '@firebase/messaging-compat',
  l2 = '@firebase/performance',
  u2 = '@firebase/performance-compat',
  c2 = '@firebase/remote-config',
  d2 = '@firebase/remote-config-compat',
  h2 = '@firebase/storage',
  f2 = '@firebase/storage-compat',
  m2 = '@firebase/firestore',
  g2 = '@firebase/vertexai-preview',
  v2 = '@firebase/firestore-compat',
  p2 = 'firebase',
  y2 = '10.12.4'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Bv = '[DEFAULT]',
  _2 = {
    [Fv]: 'fire-core',
    [GB]: 'fire-core-compat',
    [YB]: 'fire-analytics',
    [KB]: 'fire-analytics-compat',
    [XB]: 'fire-app-check',
    [QB]: 'fire-app-check-compat',
    [JB]: 'fire-auth',
    [ZB]: 'fire-auth-compat',
    [e2]: 'fire-rtdb',
    [t2]: 'fire-rtdb-compat',
    [n2]: 'fire-fn',
    [i2]: 'fire-fn-compat',
    [r2]: 'fire-iid',
    [s2]: 'fire-iid-compat',
    [o2]: 'fire-fcm',
    [a2]: 'fire-fcm-compat',
    [l2]: 'fire-perf',
    [u2]: 'fire-perf-compat',
    [c2]: 'fire-rc',
    [d2]: 'fire-rc-compat',
    [h2]: 'fire-gcs',
    [f2]: 'fire-gcs-compat',
    [m2]: 'fire-fst',
    [v2]: 'fire-fst-compat',
    [g2]: 'fire-vertex',
    'fire-js': 'fire-js',
    [p2]: 'fire-js-all',
  }
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const jh = new Map(),
  b2 = new Map(),
  $v = new Map()
function mS(e, t) {
  try {
    e.container.addComponent(t)
  } catch (n) {
    xo.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n)
  }
}
function Xn(e) {
  const t = e.name
  if ($v.has(t)) return xo.debug(`There were multiple attempts to register component ${t}.`), !1
  $v.set(t, e)
  for (const n of jh.values()) mS(n, e)
  for (const n of b2.values()) mS(n, e)
  return !0
}
function Wr(e, t) {
  const n = e.container.getProvider('heartbeat').getImmediate({ optional: !0 })
  return n && n.triggerHeartbeat(), e.container.getProvider(t)
}
function Cr(e) {
  return e.settings !== void 0
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const w2 = {
    'no-app': "No Firebase App '{$appName}' has been created - call initializeApp() first",
    'bad-app-name': "Illegal App name: '{$appName}'",
    'duplicate-app': "Firebase App named '{$appName}' already exists with different options or config",
    'app-deleted': "Firebase App named '{$appName}' already deleted",
    'server-app-deleted': 'Firebase Server App has been deleted',
    'no-options': 'Need to provide options, when not being deployed to hosting via source.',
    'invalid-app-argument': 'firebase.{$appName}() takes either no argument or a Firebase App instance.',
    'invalid-log-argument': 'First argument to `onLog` must be null or a function.',
    'idb-open': 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
    'idb-get': 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
    'idb-set': 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
    'idb-delete': 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',
    'finalization-registry-not-supported':
      'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',
    'invalid-server-app-environment': 'FirebaseServerApp is not for use in browser environments.',
  },
  Cs = new zr('app', 'Firebase', w2)
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class I2 {
  constructor(t, n, i) {
    ;(this._isDeleted = !1),
      (this._options = Object.assign({}, t)),
      (this._config = Object.assign({}, n)),
      (this._name = n.name),
      (this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled),
      (this._container = i),
      this.container.addComponent(new $n('app', () => this, 'PUBLIC'))
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled
  }
  set automaticDataCollectionEnabled(t) {
    this.checkDestroyed(), (this._automaticDataCollectionEnabled = t)
  }
  get name() {
    return this.checkDestroyed(), this._name
  }
  get options() {
    return this.checkDestroyed(), this._options
  }
  get config() {
    return this.checkDestroyed(), this._config
  }
  get container() {
    return this._container
  }
  get isDeleted() {
    return this._isDeleted
  }
  set isDeleted(t) {
    this._isDeleted = t
  }
  checkDestroyed() {
    if (this.isDeleted) throw Cs.create('app-deleted', { appName: this._name })
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const zs = y2
function mk(e, t = {}) {
  let n = e
  typeof t != 'object' && (t = { name: t })
  const i = Object.assign({ name: Bv, automaticDataCollectionEnabled: !1 }, t),
    r = i.name
  if (typeof r != 'string' || !r) throw Cs.create('bad-app-name', { appName: String(r) })
  if ((n || (n = ik()), !n)) throw Cs.create('no-options')
  const s = jh.get(r)
  if (s) {
    if (fl(n, s.options) && fl(i, s.config)) return s
    throw Cs.create('duplicate-app', { appName: r })
  }
  const o = new RB(r)
  for (const l of $v.values()) o.addComponent(l)
  const a = new I2(n, i, o)
  return jh.set(r, a), a
}
function zc(e = Bv) {
  const t = jh.get(e)
  if (!t && e === Bv && ik()) return mk()
  if (!t) throw Cs.create('no-app', { appName: e })
  return t
}
function nn(e, t, n) {
  var i
  let r = (i = _2[e]) !== null && i !== void 0 ? i : e
  n && (r += `-${n}`)
  const s = r.match(/\s|\//),
    o = t.match(/\s|\//)
  if (s || o) {
    const a = [`Unable to register library "${r}" with version "${t}":`]
    s && a.push(`library name "${r}" contains illegal characters (whitespace or "/")`),
      s && o && a.push('and'),
      o && a.push(`version name "${t}" contains illegal characters (whitespace or "/")`),
      xo.warn(a.join(' '))
    return
  }
  Xn(new $n(`${r}-version`, () => ({ library: r, version: t }), 'VERSION'))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const S2 = 'firebase-heartbeat-database',
  E2 = 1,
  uc = 'firebase-heartbeat-store'
let Dg = null
function gk() {
  return (
    Dg ||
      (Dg = fk(S2, E2, {
        upgrade: (e, t) => {
          switch (t) {
            case 0:
              try {
                e.createObjectStore(uc)
              } catch (n) {
                console.warn(n)
              }
          }
        },
      }).catch((e) => {
        throw Cs.create('idb-open', { originalErrorMessage: e.message })
      })),
    Dg
  )
}
async function T2(e) {
  try {
    const n = (await gk()).transaction(uc),
      i = await n.objectStore(uc).get(vk(e))
    return await n.done, i
  } catch (t) {
    if (t instanceof Di) xo.warn(t.message)
    else {
      const n = Cs.create('idb-get', { originalErrorMessage: t == null ? void 0 : t.message })
      xo.warn(n.message)
    }
  }
}
async function gS(e, t) {
  try {
    const i = (await gk()).transaction(uc, 'readwrite')
    await i.objectStore(uc).put(t, vk(e)), await i.done
  } catch (n) {
    if (n instanceof Di) xo.warn(n.message)
    else {
      const i = Cs.create('idb-set', { originalErrorMessage: n == null ? void 0 : n.message })
      xo.warn(i.message)
    }
  }
}
function vk(e) {
  return `${e.name}!${e.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const C2 = 1024,
  A2 = 30 * 24 * 60 * 60 * 1e3
class k2 {
  constructor(t) {
    ;(this.container = t), (this._heartbeatsCache = null)
    const n = this.container.getProvider('app').getImmediate()
    ;(this._storage = new R2(n)),
      (this._heartbeatsCachePromise = this._storage.read().then((i) => ((this._heartbeatsCache = i), i)))
  }
  async triggerHeartbeat() {
    var t, n
    const r = this.container.getProvider('platform-logger').getImmediate().getPlatformInfoString(),
      s = vS()
    if (
      !(
        ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null &&
        ((this._heartbeatsCache = await this._heartbeatsCachePromise),
        ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null)
      ) &&
      !(this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some((o) => o.date === s))
    )
      return (
        this._heartbeatsCache.heartbeats.push({ date: s, agent: r }),
        (this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((o) => {
          const a = new Date(o.date).valueOf()
          return Date.now() - a <= A2
        })),
        this._storage.overwrite(this._heartbeatsCache)
      )
  }
  async getHeartbeatsHeader() {
    var t
    if (
      (this._heartbeatsCache === null && (await this._heartbeatsCachePromise),
      ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null ||
        this._heartbeatsCache.heartbeats.length === 0)
    )
      return ''
    const n = vS(),
      { heartbeatsToSend: i, unsentEntries: r } = P2(this._heartbeatsCache.heartbeats),
      s = Bh(JSON.stringify({ version: 2, heartbeats: i }))
    return (
      (this._heartbeatsCache.lastSentHeartbeatDate = n),
      r.length > 0
        ? ((this._heartbeatsCache.heartbeats = r), await this._storage.overwrite(this._heartbeatsCache))
        : ((this._heartbeatsCache.heartbeats = []), this._storage.overwrite(this._heartbeatsCache)),
      s
    )
  }
}
function vS() {
  return new Date().toISOString().substring(0, 10)
}
function P2(e, t = C2) {
  const n = []
  let i = e.slice()
  for (const r of e) {
    const s = n.find((o) => o.agent === r.agent)
    if (s) {
      if ((s.dates.push(r.date), pS(n) > t)) {
        s.dates.pop()
        break
      }
    } else if ((n.push({ agent: r.agent, dates: [r.date] }), pS(n) > t)) {
      n.pop()
      break
    }
    i = i.slice(1)
  }
  return { heartbeatsToSend: n, unsentEntries: i }
}
class R2 {
  constructor(t) {
    ;(this.app = t), (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck())
  }
  async runIndexedDBEnvironmentCheck() {
    return jc()
      ? Gy()
          .then(() => !0)
          .catch(() => !1)
      : !1
  }
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const n = await T2(this.app)
      return n != null && n.heartbeats ? n : { heartbeats: [] }
    } else return { heartbeats: [] }
  }
  async overwrite(t) {
    var n
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read()
      return gS(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
        heartbeats: t.heartbeats,
      })
    } else return
  }
  async add(t) {
    var n
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read()
      return gS(this.app, {
        lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
        heartbeats: [...r.heartbeats, ...t.heartbeats],
      })
    } else return
  }
}
function pS(e) {
  return Bh(JSON.stringify({ version: 2, heartbeats: e })).length
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function x2(e) {
  Xn(new $n('platform-logger', (t) => new WB(t), 'PRIVATE')),
    Xn(new $n('heartbeat', (t) => new k2(t), 'PRIVATE')),
    nn(Fv, fS, e),
    nn(Fv, fS, 'esm2017'),
    nn('fire-js', '')
}
x2('')
function Yy(e, t) {
  var n = {}
  for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
      t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]])
  return n
}
function pk() {
  return {
    'dependent-sdk-initialized-before-auth':
      'Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.',
  }
}
const V2 = pk,
  yk = new zr('auth', 'Firebase', pk())
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const zh = new na('@firebase/auth')
function D2(e, ...t) {
  zh.logLevel <= Je.WARN && zh.warn(`Auth (${zs}): ${e}`, ...t)
}
function vh(e, ...t) {
  zh.logLevel <= Je.ERROR && zh.error(`Auth (${zs}): ${e}`, ...t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Wi(e, ...t) {
  throw Qy(e, ...t)
}
function lr(e, ...t) {
  return Qy(e, ...t)
}
function _k(e, t, n) {
  const i = Object.assign(Object.assign({}, V2()), { [t]: n })
  return new zr('auth', 'Firebase', i).create(t, { appName: e.name })
}
function As(e) {
  return _k(
    e,
    'operation-not-supported-in-this-environment',
    'Operations that alter the current user are not supported in conjunction with FirebaseServerApp'
  )
}
function Qy(e, ...t) {
  if (typeof e != 'string') {
    const n = t[0],
      i = [...t.slice(1)]
    return i[0] && (i[0].appName = e.name), e._errorFactory.create(n, ...i)
  }
  return yk.create(e, ...t)
}
function We(e, t, ...n) {
  if (!e) throw Qy(t, ...n)
}
function Ar(e) {
  const t = 'INTERNAL ASSERTION FAILED: ' + e
  throw (vh(t), new Error(t))
}
function Mr(e, t) {
  e || Ar(t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Uv() {
  var e
  return (typeof self < 'u' && ((e = self.location) === null || e === void 0 ? void 0 : e.href)) || ''
}
function N2() {
  return yS() === 'http:' || yS() === 'https:'
}
function yS() {
  var e
  return (typeof self < 'u' && ((e = self.location) === null || e === void 0 ? void 0 : e.protocol)) || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function O2() {
  return typeof navigator < 'u' &&
    navigator &&
    'onLine' in navigator &&
    typeof navigator.onLine == 'boolean' &&
    (N2() || sk() || 'connection' in navigator)
    ? navigator.onLine
    : !0
}
function M2() {
  if (typeof navigator > 'u') return null
  const e = navigator
  return (e.languages && e.languages[0]) || e.language || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Hc {
  constructor(t, n) {
    ;(this.shortDelay = t),
      (this.longDelay = n),
      Mr(n > t, 'Short delay should be less than long delay!'),
      (this.isMobile = qy() || ok())
  }
  get() {
    return O2() ? (this.isMobile ? this.longDelay : this.shortDelay) : Math.min(5e3, this.shortDelay)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Xy(e, t) {
  Mr(e.emulator, 'Emulator should always be set here')
  const { url: n } = e.emulator
  return t ? `${n}${t.startsWith('/') ? t.slice(1) : t}` : n
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class bk {
  static initialize(t, n, i) {
    ;(this.fetchImpl = t), n && (this.headersImpl = n), i && (this.responseImpl = i)
  }
  static fetch() {
    if (this.fetchImpl) return this.fetchImpl
    if (typeof self < 'u' && 'fetch' in self) return self.fetch
    if (typeof globalThis < 'u' && globalThis.fetch) return globalThis.fetch
    if (typeof fetch < 'u') return fetch
    Ar(
      'Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill'
    )
  }
  static headers() {
    if (this.headersImpl) return this.headersImpl
    if (typeof self < 'u' && 'Headers' in self) return self.Headers
    if (typeof globalThis < 'u' && globalThis.Headers) return globalThis.Headers
    if (typeof Headers < 'u') return Headers
    Ar(
      'Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill'
    )
  }
  static response() {
    if (this.responseImpl) return this.responseImpl
    if (typeof self < 'u' && 'Response' in self) return self.Response
    if (typeof globalThis < 'u' && globalThis.Response) return globalThis.Response
    if (typeof Response < 'u') return Response
    Ar(
      'Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill'
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const L2 = {
  CREDENTIAL_MISMATCH: 'custom-token-mismatch',
  MISSING_CUSTOM_TOKEN: 'internal-error',
  INVALID_IDENTIFIER: 'invalid-email',
  MISSING_CONTINUE_URI: 'internal-error',
  INVALID_PASSWORD: 'wrong-password',
  MISSING_PASSWORD: 'missing-password',
  INVALID_LOGIN_CREDENTIALS: 'invalid-credential',
  EMAIL_EXISTS: 'email-already-in-use',
  PASSWORD_LOGIN_DISABLED: 'operation-not-allowed',
  INVALID_IDP_RESPONSE: 'invalid-credential',
  INVALID_PENDING_TOKEN: 'invalid-credential',
  FEDERATED_USER_ID_ALREADY_LINKED: 'credential-already-in-use',
  MISSING_REQ_TYPE: 'internal-error',
  EMAIL_NOT_FOUND: 'user-not-found',
  RESET_PASSWORD_EXCEED_LIMIT: 'too-many-requests',
  EXPIRED_OOB_CODE: 'expired-action-code',
  INVALID_OOB_CODE: 'invalid-action-code',
  MISSING_OOB_CODE: 'internal-error',
  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'requires-recent-login',
  INVALID_ID_TOKEN: 'invalid-user-token',
  TOKEN_EXPIRED: 'user-token-expired',
  USER_NOT_FOUND: 'user-token-expired',
  TOO_MANY_ATTEMPTS_TRY_LATER: 'too-many-requests',
  PASSWORD_DOES_NOT_MEET_REQUIREMENTS: 'password-does-not-meet-requirements',
  INVALID_CODE: 'invalid-verification-code',
  INVALID_SESSION_INFO: 'invalid-verification-id',
  INVALID_TEMPORARY_PROOF: 'invalid-credential',
  MISSING_SESSION_INFO: 'missing-verification-id',
  SESSION_EXPIRED: 'code-expired',
  MISSING_ANDROID_PACKAGE_NAME: 'missing-android-pkg-name',
  UNAUTHORIZED_DOMAIN: 'unauthorized-continue-uri',
  INVALID_OAUTH_CLIENT_ID: 'invalid-oauth-client-id',
  ADMIN_ONLY_OPERATION: 'admin-restricted-operation',
  INVALID_MFA_PENDING_CREDENTIAL: 'invalid-multi-factor-session',
  MFA_ENROLLMENT_NOT_FOUND: 'multi-factor-info-not-found',
  MISSING_MFA_ENROLLMENT_ID: 'missing-multi-factor-info',
  MISSING_MFA_PENDING_CREDENTIAL: 'missing-multi-factor-session',
  SECOND_FACTOR_EXISTS: 'second-factor-already-in-use',
  SECOND_FACTOR_LIMIT_EXCEEDED: 'maximum-second-factor-count-exceeded',
  BLOCKING_FUNCTION_ERROR_RESPONSE: 'internal-error',
  RECAPTCHA_NOT_ENABLED: 'recaptcha-not-enabled',
  MISSING_RECAPTCHA_TOKEN: 'missing-recaptcha-token',
  INVALID_RECAPTCHA_TOKEN: 'invalid-recaptcha-token',
  INVALID_RECAPTCHA_ACTION: 'invalid-recaptcha-action',
  MISSING_CLIENT_TYPE: 'missing-client-type',
  MISSING_RECAPTCHA_VERSION: 'missing-recaptcha-version',
  INVALID_RECAPTCHA_VERSION: 'invalid-recaptcha-version',
  INVALID_REQ_TYPE: 'invalid-req-type',
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const F2 = new Hc(3e4, 6e4)
function Hs(e, t) {
  return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), { tenantId: e.tenantId }) : t
}
async function qr(e, t, n, i, r = {}) {
  return wk(e, r, async () => {
    let s = {},
      o = {}
    i && (t === 'GET' ? (o = i) : (s = { body: JSON.stringify(i) }))
    const a = Ll(Object.assign({ key: e.config.apiKey }, o)).slice(1),
      l = await e._getAdditionalHeaders()
    return (
      (l['Content-Type'] = 'application/json'),
      e.languageCode && (l['X-Firebase-Locale'] = e.languageCode),
      bk.fetch()(
        Ik(e, e.config.apiHost, n, a),
        Object.assign({ method: t, headers: l, referrerPolicy: 'no-referrer' }, s)
      )
    )
  })
}
async function wk(e, t, n) {
  e._canInitEmulator = !1
  const i = Object.assign(Object.assign({}, L2), t)
  try {
    const r = new $2(e),
      s = await Promise.race([n(), r.promise])
    r.clearNetworkTimeout()
    const o = await s.json()
    if ('needConfirmation' in o) throw jd(e, 'account-exists-with-different-credential', o)
    if (s.ok && !('errorMessage' in o)) return o
    {
      const a = s.ok ? o.errorMessage : o.error.message,
        [l, u] = a.split(' : ')
      if (l === 'FEDERATED_USER_ID_ALREADY_LINKED') throw jd(e, 'credential-already-in-use', o)
      if (l === 'EMAIL_EXISTS') throw jd(e, 'email-already-in-use', o)
      if (l === 'USER_DISABLED') throw jd(e, 'user-disabled', o)
      const c = i[l] || l.toLowerCase().replace(/[_\s]+/g, '-')
      if (u) throw _k(e, c, u)
      Wi(e, c)
    }
  } catch (r) {
    if (r instanceof Di) throw r
    Wi(e, 'network-request-failed', { message: String(r) })
  }
}
async function qf(e, t, n, i, r = {}) {
  const s = await qr(e, t, n, i, r)
  return 'mfaPendingCredential' in s && Wi(e, 'multi-factor-auth-required', { _serverResponse: s }), s
}
function Ik(e, t, n, i) {
  const r = `${t}${n}?${i}`
  return e.config.emulator ? Xy(e.config, r) : `${e.config.apiScheme}://${r}`
}
function B2(e) {
  switch (e) {
    case 'ENFORCE':
      return 'ENFORCE'
    case 'AUDIT':
      return 'AUDIT'
    case 'OFF':
      return 'OFF'
    default:
      return 'ENFORCEMENT_STATE_UNSPECIFIED'
  }
}
class $2 {
  constructor(t) {
    ;(this.auth = t),
      (this.timer = null),
      (this.promise = new Promise((n, i) => {
        this.timer = setTimeout(() => i(lr(this.auth, 'network-request-failed')), F2.get())
      }))
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer)
  }
}
function jd(e, t, n) {
  const i = { appName: e.name }
  n.email && (i.email = n.email), n.phoneNumber && (i.phoneNumber = n.phoneNumber)
  const r = lr(e, t, i)
  return (r.customData._tokenResponse = n), r
}
function _S(e) {
  return e !== void 0 && e.enterprise !== void 0
}
class U2 {
  constructor(t) {
    if (((this.siteKey = ''), (this.recaptchaEnforcementState = []), t.recaptchaKey === void 0))
      throw new Error('recaptchaKey undefined')
    ;(this.siteKey = t.recaptchaKey.split('/')[3]), (this.recaptchaEnforcementState = t.recaptchaEnforcementState)
  }
  getProviderEnforcementState(t) {
    if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0) return null
    for (const n of this.recaptchaEnforcementState) if (n.provider && n.provider === t) return B2(n.enforcementState)
    return null
  }
  isProviderEnabled(t) {
    return this.getProviderEnforcementState(t) === 'ENFORCE' || this.getProviderEnforcementState(t) === 'AUDIT'
  }
}
async function j2(e, t) {
  return qr(e, 'GET', '/v2/recaptchaConfig', Hs(e, t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function z2(e, t) {
  return qr(e, 'POST', '/v1/accounts:delete', t)
}
async function Sk(e, t) {
  return qr(e, 'POST', '/v1/accounts:lookup', t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ju(e) {
  if (e)
    try {
      const t = new Date(Number(e))
      if (!isNaN(t.getTime())) return t.toUTCString()
    } catch {}
}
async function H2(e, t = !1) {
  const n = Et(e),
    i = await n.getIdToken(t),
    r = Jy(i)
  We(r && r.exp && r.auth_time && r.iat, n.auth, 'internal-error')
  const s = typeof r.firebase == 'object' ? r.firebase : void 0,
    o = s == null ? void 0 : s.sign_in_provider
  return {
    claims: r,
    token: i,
    authTime: ju(Ng(r.auth_time)),
    issuedAtTime: ju(Ng(r.iat)),
    expirationTime: ju(Ng(r.exp)),
    signInProvider: o || null,
    signInSecondFactor: (s == null ? void 0 : s.sign_in_second_factor) || null,
  }
}
function Ng(e) {
  return Number(e) * 1e3
}
function Jy(e) {
  const [t, n, i] = e.split('.')
  if (t === void 0 || n === void 0 || i === void 0) return vh('JWT malformed, contained fewer than 3 sections'), null
  try {
    const r = $h(n)
    return r ? JSON.parse(r) : (vh('Failed to decode base64 JWT payload'), null)
  } catch (r) {
    return vh('Caught error parsing JWT payload as JSON', r == null ? void 0 : r.toString()), null
  }
}
function bS(e) {
  const t = Jy(e)
  return (
    We(t, 'internal-error'),
    We(typeof t.exp < 'u', 'internal-error'),
    We(typeof t.iat < 'u', 'internal-error'),
    Number(t.exp) - Number(t.iat)
  )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function cc(e, t, n = !1) {
  if (n) return t
  try {
    return await t
  } catch (i) {
    throw (i instanceof Di && W2(i) && e.auth.currentUser === e && (await e.auth.signOut()), i)
  }
}
function W2({ code: e }) {
  return e === 'auth/user-disabled' || e === 'auth/user-token-expired'
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class q2 {
  constructor(t) {
    ;(this.user = t), (this.isRunning = !1), (this.timerId = null), (this.errorBackoff = 3e4)
  }
  _start() {
    this.isRunning || ((this.isRunning = !0), this.schedule())
  }
  _stop() {
    this.isRunning && ((this.isRunning = !1), this.timerId !== null && clearTimeout(this.timerId))
  }
  getInterval(t) {
    var n
    if (t) {
      const i = this.errorBackoff
      return (this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4)), i
    } else {
      this.errorBackoff = 3e4
      const r = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5
      return Math.max(0, r)
    }
  }
  schedule(t = !1) {
    if (!this.isRunning) return
    const n = this.getInterval(t)
    this.timerId = setTimeout(async () => {
      await this.iteration()
    }, n)
  }
  async iteration() {
    try {
      await this.user.getIdToken(!0)
    } catch (t) {
      ;(t == null ? void 0 : t.code) === 'auth/network-request-failed' && this.schedule(!0)
      return
    }
    this.schedule()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class jv {
  constructor(t, n) {
    ;(this.createdAt = t), (this.lastLoginAt = n), this._initializeTime()
  }
  _initializeTime() {
    ;(this.lastSignInTime = ju(this.lastLoginAt)), (this.creationTime = ju(this.createdAt))
  }
  _copy(t) {
    ;(this.createdAt = t.createdAt), (this.lastLoginAt = t.lastLoginAt), this._initializeTime()
  }
  toJSON() {
    return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Hh(e) {
  var t
  const n = e.auth,
    i = await e.getIdToken(),
    r = await cc(e, Sk(n, { idToken: i }))
  We(r == null ? void 0 : r.users.length, n, 'internal-error')
  const s = r.users[0]
  e._notifyReloadListener(s)
  const o = !((t = s.providerUserInfo) === null || t === void 0) && t.length ? Ek(s.providerUserInfo) : [],
    a = K2(e.providerData, o),
    l = e.isAnonymous,
    u = !(e.email && s.passwordHash) && !(a != null && a.length),
    c = l ? u : !1,
    d = {
      uid: s.localId,
      displayName: s.displayName || null,
      photoURL: s.photoUrl || null,
      email: s.email || null,
      emailVerified: s.emailVerified || !1,
      phoneNumber: s.phoneNumber || null,
      tenantId: s.tenantId || null,
      providerData: a,
      metadata: new jv(s.createdAt, s.lastLoginAt),
      isAnonymous: c,
    }
  Object.assign(e, d)
}
async function G2(e) {
  const t = Et(e)
  await Hh(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t)
}
function K2(e, t) {
  return [...e.filter((i) => !t.some((r) => r.providerId === i.providerId)), ...t]
}
function Ek(e) {
  return e.map((t) => {
    var { providerId: n } = t,
      i = Yy(t, ['providerId'])
    return {
      providerId: n,
      uid: i.rawId || '',
      displayName: i.displayName || null,
      email: i.email || null,
      phoneNumber: i.phoneNumber || null,
      photoURL: i.photoUrl || null,
    }
  })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Y2(e, t) {
  const n = await wk(e, {}, async () => {
    const i = Ll({ grant_type: 'refresh_token', refresh_token: t }).slice(1),
      { tokenApiHost: r, apiKey: s } = e.config,
      o = Ik(e, r, '/v1/token', `key=${s}`),
      a = await e._getAdditionalHeaders()
    return (
      (a['Content-Type'] = 'application/x-www-form-urlencoded'), bk.fetch()(o, { method: 'POST', headers: a, body: i })
    )
  })
  return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token }
}
async function Q2(e, t) {
  return qr(e, 'POST', '/v2/accounts:revokeToken', Hs(e, t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class el {
  constructor() {
    ;(this.refreshToken = null), (this.accessToken = null), (this.expirationTime = null)
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4
  }
  updateFromServerResponse(t) {
    We(t.idToken, 'internal-error'),
      We(typeof t.idToken < 'u', 'internal-error'),
      We(typeof t.refreshToken < 'u', 'internal-error')
    const n = 'expiresIn' in t && typeof t.expiresIn < 'u' ? Number(t.expiresIn) : bS(t.idToken)
    this.updateTokensAndExpiration(t.idToken, t.refreshToken, n)
  }
  updateFromIdToken(t) {
    We(t.length !== 0, 'internal-error')
    const n = bS(t)
    this.updateTokensAndExpiration(t, null, n)
  }
  async getToken(t, n = !1) {
    return !n && this.accessToken && !this.isExpired
      ? this.accessToken
      : (We(this.refreshToken, t, 'user-token-expired'),
        this.refreshToken ? (await this.refresh(t, this.refreshToken), this.accessToken) : null)
  }
  clearRefreshToken() {
    this.refreshToken = null
  }
  async refresh(t, n) {
    const { accessToken: i, refreshToken: r, expiresIn: s } = await Y2(t, n)
    this.updateTokensAndExpiration(i, r, Number(s))
  }
  updateTokensAndExpiration(t, n, i) {
    ;(this.refreshToken = n || null), (this.accessToken = t || null), (this.expirationTime = Date.now() + i * 1e3)
  }
  static fromJSON(t, n) {
    const { refreshToken: i, accessToken: r, expirationTime: s } = n,
      o = new el()
    return (
      i && (We(typeof i == 'string', 'internal-error', { appName: t }), (o.refreshToken = i)),
      r && (We(typeof r == 'string', 'internal-error', { appName: t }), (o.accessToken = r)),
      s && (We(typeof s == 'number', 'internal-error', { appName: t }), (o.expirationTime = s)),
      o
    )
  }
  toJSON() {
    return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime }
  }
  _assign(t) {
    ;(this.accessToken = t.accessToken), (this.refreshToken = t.refreshToken), (this.expirationTime = t.expirationTime)
  }
  _clone() {
    return Object.assign(new el(), this.toJSON())
  }
  _performRefresh() {
    return Ar('not implemented')
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function rs(e, t) {
  We(typeof e == 'string' || typeof e > 'u', 'internal-error', { appName: t })
}
class kr {
  constructor(t) {
    var { uid: n, auth: i, stsTokenManager: r } = t,
      s = Yy(t, ['uid', 'auth', 'stsTokenManager'])
    ;(this.providerId = 'firebase'),
      (this.proactiveRefresh = new q2(this)),
      (this.reloadUserInfo = null),
      (this.reloadListener = null),
      (this.uid = n),
      (this.auth = i),
      (this.stsTokenManager = r),
      (this.accessToken = r.accessToken),
      (this.displayName = s.displayName || null),
      (this.email = s.email || null),
      (this.emailVerified = s.emailVerified || !1),
      (this.phoneNumber = s.phoneNumber || null),
      (this.photoURL = s.photoURL || null),
      (this.isAnonymous = s.isAnonymous || !1),
      (this.tenantId = s.tenantId || null),
      (this.providerData = s.providerData ? [...s.providerData] : []),
      (this.metadata = new jv(s.createdAt || void 0, s.lastLoginAt || void 0))
  }
  async getIdToken(t) {
    const n = await cc(this, this.stsTokenManager.getToken(this.auth, t))
    return (
      We(n, this.auth, 'internal-error'),
      this.accessToken !== n &&
        ((this.accessToken = n),
        await this.auth._persistUserIfCurrent(this),
        this.auth._notifyListenersIfCurrent(this)),
      n
    )
  }
  getIdTokenResult(t) {
    return H2(this, t)
  }
  reload() {
    return G2(this)
  }
  _assign(t) {
    this !== t &&
      (We(this.uid === t.uid, this.auth, 'internal-error'),
      (this.displayName = t.displayName),
      (this.photoURL = t.photoURL),
      (this.email = t.email),
      (this.emailVerified = t.emailVerified),
      (this.phoneNumber = t.phoneNumber),
      (this.isAnonymous = t.isAnonymous),
      (this.tenantId = t.tenantId),
      (this.providerData = t.providerData.map((n) => Object.assign({}, n))),
      this.metadata._copy(t.metadata),
      this.stsTokenManager._assign(t.stsTokenManager))
  }
  _clone(t) {
    const n = new kr(
      Object.assign(Object.assign({}, this), { auth: t, stsTokenManager: this.stsTokenManager._clone() })
    )
    return n.metadata._copy(this.metadata), n
  }
  _onReload(t) {
    We(!this.reloadListener, this.auth, 'internal-error'),
      (this.reloadListener = t),
      this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), (this.reloadUserInfo = null))
  }
  _notifyReloadListener(t) {
    this.reloadListener ? this.reloadListener(t) : (this.reloadUserInfo = t)
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start()
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop()
  }
  async _updateTokensIfNecessary(t, n = !1) {
    let i = !1
    t.idToken &&
      t.idToken !== this.stsTokenManager.accessToken &&
      (this.stsTokenManager.updateFromServerResponse(t), (i = !0)),
      n && (await Hh(this)),
      await this.auth._persistUserIfCurrent(this),
      i && this.auth._notifyListenersIfCurrent(this)
  }
  async delete() {
    if (Cr(this.auth.app)) return Promise.reject(As(this.auth))
    const t = await this.getIdToken()
    return await cc(this, z2(this.auth, { idToken: t })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut()
  }
  toJSON() {
    return Object.assign(
      Object.assign(
        {
          uid: this.uid,
          email: this.email || void 0,
          emailVerified: this.emailVerified,
          displayName: this.displayName || void 0,
          isAnonymous: this.isAnonymous,
          photoURL: this.photoURL || void 0,
          phoneNumber: this.phoneNumber || void 0,
          tenantId: this.tenantId || void 0,
          providerData: this.providerData.map((t) => Object.assign({}, t)),
          stsTokenManager: this.stsTokenManager.toJSON(),
          _redirectEventId: this._redirectEventId,
        },
        this.metadata.toJSON()
      ),
      { apiKey: this.auth.config.apiKey, appName: this.auth.name }
    )
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || ''
  }
  static _fromJSON(t, n) {
    var i, r, s, o, a, l, u, c
    const d = (i = n.displayName) !== null && i !== void 0 ? i : void 0,
      f = (r = n.email) !== null && r !== void 0 ? r : void 0,
      m = (s = n.phoneNumber) !== null && s !== void 0 ? s : void 0,
      p = (o = n.photoURL) !== null && o !== void 0 ? o : void 0,
      v = (a = n.tenantId) !== null && a !== void 0 ? a : void 0,
      y = (l = n._redirectEventId) !== null && l !== void 0 ? l : void 0,
      T = (u = n.createdAt) !== null && u !== void 0 ? u : void 0,
      A = (c = n.lastLoginAt) !== null && c !== void 0 ? c : void 0,
      { uid: x, emailVerified: N, isAnonymous: V, providerData: D, stsTokenManager: I } = n
    We(x && I, t, 'internal-error')
    const w = el.fromJSON(this.name, I)
    We(typeof x == 'string', t, 'internal-error'),
      rs(d, t.name),
      rs(f, t.name),
      We(typeof N == 'boolean', t, 'internal-error'),
      We(typeof V == 'boolean', t, 'internal-error'),
      rs(m, t.name),
      rs(p, t.name),
      rs(v, t.name),
      rs(y, t.name),
      rs(T, t.name),
      rs(A, t.name)
    const _ = new kr({
      uid: x,
      auth: t,
      email: f,
      emailVerified: N,
      displayName: d,
      isAnonymous: V,
      photoURL: p,
      phoneNumber: m,
      tenantId: v,
      stsTokenManager: w,
      createdAt: T,
      lastLoginAt: A,
    })
    return (
      D && Array.isArray(D) && (_.providerData = D.map((S) => Object.assign({}, S))), y && (_._redirectEventId = y), _
    )
  }
  static async _fromIdTokenResponse(t, n, i = !1) {
    const r = new el()
    r.updateFromServerResponse(n)
    const s = new kr({ uid: n.localId, auth: t, stsTokenManager: r, isAnonymous: i })
    return await Hh(s), s
  }
  static async _fromGetAccountInfoResponse(t, n, i) {
    const r = n.users[0]
    We(r.localId !== void 0, 'internal-error')
    const s = r.providerUserInfo !== void 0 ? Ek(r.providerUserInfo) : [],
      o = !(r.email && r.passwordHash) && !(s != null && s.length),
      a = new el()
    a.updateFromIdToken(i)
    const l = new kr({ uid: r.localId, auth: t, stsTokenManager: a, isAnonymous: o }),
      u = {
        uid: r.localId,
        displayName: r.displayName || null,
        photoURL: r.photoUrl || null,
        email: r.email || null,
        emailVerified: r.emailVerified || !1,
        phoneNumber: r.phoneNumber || null,
        tenantId: r.tenantId || null,
        providerData: s,
        metadata: new jv(r.createdAt, r.lastLoginAt),
        isAnonymous: !(r.email && r.passwordHash) && !(s != null && s.length),
      }
    return Object.assign(l, u), l
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const wS = new Map()
function Pr(e) {
  Mr(e instanceof Function, 'Expected a class definition')
  let t = wS.get(e)
  return t
    ? (Mr(t instanceof e, 'Instance stored in cache mismatched with class'), t)
    : ((t = new e()), wS.set(e, t), t)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Tk {
  constructor() {
    ;(this.type = 'NONE'), (this.storage = {})
  }
  async _isAvailable() {
    return !0
  }
  async _set(t, n) {
    this.storage[t] = n
  }
  async _get(t) {
    const n = this.storage[t]
    return n === void 0 ? null : n
  }
  async _remove(t) {
    delete this.storage[t]
  }
  _addListener(t, n) {}
  _removeListener(t, n) {}
}
Tk.type = 'NONE'
const IS = Tk
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ph(e, t, n) {
  return `firebase:${e}:${t}:${n}`
}
class tl {
  constructor(t, n, i) {
    ;(this.persistence = t), (this.auth = n), (this.userKey = i)
    const { config: r, name: s } = this.auth
    ;(this.fullUserKey = ph(this.userKey, r.apiKey, s)),
      (this.fullPersistenceKey = ph('persistence', r.apiKey, s)),
      (this.boundEventHandler = n._onStorageEvent.bind(n)),
      this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
  }
  setCurrentUser(t) {
    return this.persistence._set(this.fullUserKey, t.toJSON())
  }
  async getCurrentUser() {
    const t = await this.persistence._get(this.fullUserKey)
    return t ? kr._fromJSON(this.auth, t) : null
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey)
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
  }
  async setPersistence(t) {
    if (this.persistence === t) return
    const n = await this.getCurrentUser()
    if ((await this.removeCurrentUser(), (this.persistence = t), n)) return this.setCurrentUser(n)
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
  }
  static async create(t, n, i = 'authUser') {
    if (!n.length) return new tl(Pr(IS), t, i)
    const r = (
      await Promise.all(
        n.map(async (u) => {
          if (await u._isAvailable()) return u
        })
      )
    ).filter((u) => u)
    let s = r[0] || Pr(IS)
    const o = ph(i, t.config.apiKey, t.name)
    let a = null
    for (const u of n)
      try {
        const c = await u._get(o)
        if (c) {
          const d = kr._fromJSON(t, c)
          u !== s && (a = d), (s = u)
          break
        }
      } catch {}
    const l = r.filter((u) => u._shouldAllowMigration)
    return !s._shouldAllowMigration || !l.length
      ? new tl(s, t, i)
      : ((s = l[0]),
        a && (await s._set(o, a.toJSON())),
        await Promise.all(
          n.map(async (u) => {
            if (u !== s)
              try {
                await u._remove(o)
              } catch {}
          })
        ),
        new tl(s, t, i))
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function SS(e) {
  const t = e.toLowerCase()
  if (t.includes('opera/') || t.includes('opr/') || t.includes('opios/')) return 'Opera'
  if (kk(t)) return 'IEMobile'
  if (t.includes('msie') || t.includes('trident/')) return 'IE'
  if (t.includes('edge/')) return 'Edge'
  if (Ck(t)) return 'Firefox'
  if (t.includes('silk/')) return 'Silk'
  if (Rk(t)) return 'Blackberry'
  if (xk(t)) return 'Webos'
  if (Zy(t)) return 'Safari'
  if ((t.includes('chrome/') || Ak(t)) && !t.includes('edge/')) return 'Chrome'
  if (Pk(t)) return 'Android'
  {
    const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
      i = e.match(n)
    if ((i == null ? void 0 : i.length) === 2) return i[1]
  }
  return 'Other'
}
function Ck(e = Zt()) {
  return /firefox\//i.test(e)
}
function Zy(e = Zt()) {
  const t = e.toLowerCase()
  return t.includes('safari/') && !t.includes('chrome/') && !t.includes('crios/') && !t.includes('android')
}
function Ak(e = Zt()) {
  return /crios\//i.test(e)
}
function kk(e = Zt()) {
  return /iemobile/i.test(e)
}
function Pk(e = Zt()) {
  return /android/i.test(e)
}
function Rk(e = Zt()) {
  return /blackberry/i.test(e)
}
function xk(e = Zt()) {
  return /webos/i.test(e)
}
function Gf(e = Zt()) {
  return /iphone|ipad|ipod/i.test(e) || (/macintosh/i.test(e) && /mobile/i.test(e))
}
function X2(e = Zt()) {
  var t
  return Gf(e) && !!(!((t = window.navigator) === null || t === void 0) && t.standalone)
}
function J2() {
  return dB() && document.documentMode === 10
}
function Vk(e = Zt()) {
  return Gf(e) || Pk(e) || xk(e) || Rk(e) || /windows phone/i.test(e) || kk(e)
}
function Z2() {
  try {
    return !!(window && window !== window.top)
  } catch {
    return !1
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Dk(e, t = []) {
  let n
  switch (e) {
    case 'Browser':
      n = SS(Zt())
      break
    case 'Worker':
      n = `${SS(Zt())}-${e}`
      break
    default:
      n = e
  }
  const i = t.length ? t.join(',') : 'FirebaseCore-web'
  return `${n}/JsCore/${zs}/${i}`
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class e$ {
  constructor(t) {
    ;(this.auth = t), (this.queue = [])
  }
  pushCallback(t, n) {
    const i = (s) =>
      new Promise((o, a) => {
        try {
          const l = t(s)
          o(l)
        } catch (l) {
          a(l)
        }
      })
    ;(i.onAbort = n), this.queue.push(i)
    const r = this.queue.length - 1
    return () => {
      this.queue[r] = () => Promise.resolve()
    }
  }
  async runMiddleware(t) {
    if (this.auth.currentUser === t) return
    const n = []
    try {
      for (const i of this.queue) await i(t), i.onAbort && n.push(i.onAbort)
    } catch (i) {
      n.reverse()
      for (const r of n)
        try {
          r()
        } catch {}
      throw this.auth._errorFactory.create('login-blocked', { originalMessage: i == null ? void 0 : i.message })
    }
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function t$(e, t = {}) {
  return qr(e, 'GET', '/v2/passwordPolicy', Hs(e, t))
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const n$ = 6
class i$ {
  constructor(t) {
    var n, i, r, s
    const o = t.customStrengthOptions
    ;(this.customStrengthOptions = {}),
      (this.customStrengthOptions.minPasswordLength = (n = o.minPasswordLength) !== null && n !== void 0 ? n : n$),
      o.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = o.maxPasswordLength),
      o.containsLowercaseCharacter !== void 0 &&
        (this.customStrengthOptions.containsLowercaseLetter = o.containsLowercaseCharacter),
      o.containsUppercaseCharacter !== void 0 &&
        (this.customStrengthOptions.containsUppercaseLetter = o.containsUppercaseCharacter),
      o.containsNumericCharacter !== void 0 &&
        (this.customStrengthOptions.containsNumericCharacter = o.containsNumericCharacter),
      o.containsNonAlphanumericCharacter !== void 0 &&
        (this.customStrengthOptions.containsNonAlphanumericCharacter = o.containsNonAlphanumericCharacter),
      (this.enforcementState = t.enforcementState),
      this.enforcementState === 'ENFORCEMENT_STATE_UNSPECIFIED' && (this.enforcementState = 'OFF'),
      (this.allowedNonAlphanumericCharacters =
        (r = (i = t.allowedNonAlphanumericCharacters) === null || i === void 0 ? void 0 : i.join('')) !== null &&
        r !== void 0
          ? r
          : ''),
      (this.forceUpgradeOnSignin = (s = t.forceUpgradeOnSignin) !== null && s !== void 0 ? s : !1),
      (this.schemaVersion = t.schemaVersion)
  }
  validatePassword(t) {
    var n, i, r, s, o, a
    const l = { isValid: !0, passwordPolicy: this }
    return (
      this.validatePasswordLengthOptions(t, l),
      this.validatePasswordCharacterOptions(t, l),
      l.isValid && (l.isValid = (n = l.meetsMinPasswordLength) !== null && n !== void 0 ? n : !0),
      l.isValid && (l.isValid = (i = l.meetsMaxPasswordLength) !== null && i !== void 0 ? i : !0),
      l.isValid && (l.isValid = (r = l.containsLowercaseLetter) !== null && r !== void 0 ? r : !0),
      l.isValid && (l.isValid = (s = l.containsUppercaseLetter) !== null && s !== void 0 ? s : !0),
      l.isValid && (l.isValid = (o = l.containsNumericCharacter) !== null && o !== void 0 ? o : !0),
      l.isValid && (l.isValid = (a = l.containsNonAlphanumericCharacter) !== null && a !== void 0 ? a : !0),
      l
    )
  }
  validatePasswordLengthOptions(t, n) {
    const i = this.customStrengthOptions.minPasswordLength,
      r = this.customStrengthOptions.maxPasswordLength
    i && (n.meetsMinPasswordLength = t.length >= i), r && (n.meetsMaxPasswordLength = t.length <= r)
  }
  validatePasswordCharacterOptions(t, n) {
    this.updatePasswordCharacterOptionsStatuses(n, !1, !1, !1, !1)
    let i
    for (let r = 0; r < t.length; r++)
      (i = t.charAt(r)),
        this.updatePasswordCharacterOptionsStatuses(
          n,
          i >= 'a' && i <= 'z',
          i >= 'A' && i <= 'Z',
          i >= '0' && i <= '9',
          this.allowedNonAlphanumericCharacters.includes(i)
        )
  }
  updatePasswordCharacterOptionsStatuses(t, n, i, r, s) {
    this.customStrengthOptions.containsLowercaseLetter &&
      (t.containsLowercaseLetter || (t.containsLowercaseLetter = n)),
      this.customStrengthOptions.containsUppercaseLetter &&
        (t.containsUppercaseLetter || (t.containsUppercaseLetter = i)),
      this.customStrengthOptions.containsNumericCharacter &&
        (t.containsNumericCharacter || (t.containsNumericCharacter = r)),
      this.customStrengthOptions.containsNonAlphanumericCharacter &&
        (t.containsNonAlphanumericCharacter || (t.containsNonAlphanumericCharacter = s))
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class r$ {
  constructor(t, n, i, r) {
    ;(this.app = t),
      (this.heartbeatServiceProvider = n),
      (this.appCheckServiceProvider = i),
      (this.config = r),
      (this.currentUser = null),
      (this.emulatorConfig = null),
      (this.operations = Promise.resolve()),
      (this.authStateSubscription = new ES(this)),
      (this.idTokenSubscription = new ES(this)),
      (this.beforeStateQueue = new e$(this)),
      (this.redirectUser = null),
      (this.isProactiveRefreshEnabled = !1),
      (this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1),
      (this._canInitEmulator = !0),
      (this._isInitialized = !1),
      (this._deleted = !1),
      (this._initializationPromise = null),
      (this._popupRedirectResolver = null),
      (this._errorFactory = yk),
      (this._agentRecaptchaConfig = null),
      (this._tenantRecaptchaConfigs = {}),
      (this._projectPasswordPolicy = null),
      (this._tenantPasswordPolicies = {}),
      (this.lastNotifiedUid = void 0),
      (this.languageCode = null),
      (this.tenantId = null),
      (this.settings = { appVerificationDisabledForTesting: !1 }),
      (this.frameworks = []),
      (this.name = t.name),
      (this.clientVersion = r.sdkClientVersion)
  }
  _initializeWithPersistence(t, n) {
    return (
      n && (this._popupRedirectResolver = Pr(n)),
      (this._initializationPromise = this.queue(async () => {
        var i, r
        if (!this._deleted && ((this.persistenceManager = await tl.create(this, t)), !this._deleted)) {
          if (!((i = this._popupRedirectResolver) === null || i === void 0) && i._shouldInitProactively)
            try {
              await this._popupRedirectResolver._initialize(this)
            } catch {}
          await this.initializeCurrentUser(n),
            (this.lastNotifiedUid = ((r = this.currentUser) === null || r === void 0 ? void 0 : r.uid) || null),
            !this._deleted && (this._isInitialized = !0)
        }
      })),
      this._initializationPromise
    )
  }
  async _onStorageEvent() {
    if (this._deleted) return
    const t = await this.assertedPersistence.getCurrentUser()
    if (!(!this.currentUser && !t)) {
      if (this.currentUser && t && this.currentUser.uid === t.uid) {
        this._currentUser._assign(t), await this.currentUser.getIdToken()
        return
      }
      await this._updateCurrentUser(t, !0)
    }
  }
  async initializeCurrentUserFromIdToken(t) {
    try {
      const n = await Sk(this, { idToken: t }),
        i = await kr._fromGetAccountInfoResponse(this, n, t)
      await this.directlySetCurrentUser(i)
    } catch (n) {
      console.warn('FirebaseServerApp could not login user with provided authIdToken: ', n),
        await this.directlySetCurrentUser(null)
    }
  }
  async initializeCurrentUser(t) {
    var n
    if (Cr(this.app)) {
      const o = this.app.settings.authIdToken
      return o
        ? new Promise((a) => {
            setTimeout(() => this.initializeCurrentUserFromIdToken(o).then(a, a))
          })
        : this.directlySetCurrentUser(null)
    }
    const i = await this.assertedPersistence.getCurrentUser()
    let r = i,
      s = !1
    if (t && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager()
      const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId,
        a = r == null ? void 0 : r._redirectEventId,
        l = await this.tryRedirectSignIn(t)
      ;(!o || o === a) && l != null && l.user && ((r = l.user), (s = !0))
    }
    if (!r) return this.directlySetCurrentUser(null)
    if (!r._redirectEventId) {
      if (s)
        try {
          await this.beforeStateQueue.runMiddleware(r)
        } catch (o) {
          ;(r = i), this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o))
        }
      return r ? this.reloadAndSetCurrentUserOrClear(r) : this.directlySetCurrentUser(null)
    }
    return (
      We(this._popupRedirectResolver, this, 'argument-error'),
      await this.getOrInitRedirectPersistenceManager(),
      this.redirectUser && this.redirectUser._redirectEventId === r._redirectEventId
        ? this.directlySetCurrentUser(r)
        : this.reloadAndSetCurrentUserOrClear(r)
    )
  }
  async tryRedirectSignIn(t) {
    let n = null
    try {
      n = await this._popupRedirectResolver._completeRedirectFn(this, t, !0)
    } catch {
      await this._setRedirectUser(null)
    }
    return n
  }
  async reloadAndSetCurrentUserOrClear(t) {
    try {
      await Hh(t)
    } catch (n) {
      if ((n == null ? void 0 : n.code) !== 'auth/network-request-failed') return this.directlySetCurrentUser(null)
    }
    return this.directlySetCurrentUser(t)
  }
  useDeviceLanguage() {
    this.languageCode = M2()
  }
  async _delete() {
    this._deleted = !0
  }
  async updateCurrentUser(t) {
    if (Cr(this.app)) return Promise.reject(As(this))
    const n = t ? Et(t) : null
    return (
      n && We(n.auth.config.apiKey === this.config.apiKey, this, 'invalid-user-token'),
      this._updateCurrentUser(n && n._clone(this))
    )
  }
  async _updateCurrentUser(t, n = !1) {
    if (!this._deleted)
      return (
        t && We(this.tenantId === t.tenantId, this, 'tenant-id-mismatch'),
        n || (await this.beforeStateQueue.runMiddleware(t)),
        this.queue(async () => {
          await this.directlySetCurrentUser(t), this.notifyAuthListeners()
        })
      )
  }
  async signOut() {
    return Cr(this.app)
      ? Promise.reject(As(this))
      : (await this.beforeStateQueue.runMiddleware(null),
        (this.redirectPersistenceManager || this._popupRedirectResolver) && (await this._setRedirectUser(null)),
        this._updateCurrentUser(null, !0))
  }
  setPersistence(t) {
    return Cr(this.app)
      ? Promise.reject(As(this))
      : this.queue(async () => {
          await this.assertedPersistence.setPersistence(Pr(t))
        })
  }
  _getRecaptchaConfig() {
    return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
  }
  async validatePassword(t) {
    this._getPasswordPolicyInternal() || (await this._updatePasswordPolicy())
    const n = this._getPasswordPolicyInternal()
    return n.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION
      ? Promise.reject(this._errorFactory.create('unsupported-password-policy-schema-version', {}))
      : n.validatePassword(t)
  }
  _getPasswordPolicyInternal() {
    return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId]
  }
  async _updatePasswordPolicy() {
    const t = await t$(this),
      n = new i$(t)
    this.tenantId === null ? (this._projectPasswordPolicy = n) : (this._tenantPasswordPolicies[this.tenantId] = n)
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type
  }
  _updateErrorMap(t) {
    this._errorFactory = new zr('auth', 'Firebase', t())
  }
  onAuthStateChanged(t, n, i) {
    return this.registerStateListener(this.authStateSubscription, t, n, i)
  }
  beforeAuthStateChanged(t, n) {
    return this.beforeStateQueue.pushCallback(t, n)
  }
  onIdTokenChanged(t, n, i) {
    return this.registerStateListener(this.idTokenSubscription, t, n, i)
  }
  authStateReady() {
    return new Promise((t, n) => {
      if (this.currentUser) t()
      else {
        const i = this.onAuthStateChanged(() => {
          i(), t()
        }, n)
      }
    })
  }
  async revokeAccessToken(t) {
    if (this.currentUser) {
      const n = await this.currentUser.getIdToken(),
        i = { providerId: 'apple.com', tokenType: 'ACCESS_TOKEN', token: t, idToken: n }
      this.tenantId != null && (i.tenantId = this.tenantId), await Q2(this, i)
    }
  }
  toJSON() {
    var t
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (t = this._currentUser) === null || t === void 0 ? void 0 : t.toJSON(),
    }
  }
  async _setRedirectUser(t, n) {
    const i = await this.getOrInitRedirectPersistenceManager(n)
    return t === null ? i.removeCurrentUser() : i.setCurrentUser(t)
  }
  async getOrInitRedirectPersistenceManager(t) {
    if (!this.redirectPersistenceManager) {
      const n = (t && Pr(t)) || this._popupRedirectResolver
      We(n, this, 'argument-error'),
        (this.redirectPersistenceManager = await tl.create(this, [Pr(n._redirectPersistence)], 'redirectUser')),
        (this.redirectUser = await this.redirectPersistenceManager.getCurrentUser())
    }
    return this.redirectPersistenceManager
  }
  async _redirectUserForId(t) {
    var n, i
    return (
      this._isInitialized && (await this.queue(async () => {})),
      ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === t
        ? this._currentUser
        : ((i = this.redirectUser) === null || i === void 0 ? void 0 : i._redirectEventId) === t
        ? this.redirectUser
        : null
    )
  }
  async _persistUserIfCurrent(t) {
    if (t === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(t))
  }
  _notifyListenersIfCurrent(t) {
    t === this.currentUser && this.notifyAuthListeners()
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
  }
  _startProactiveRefresh() {
    ;(this.isProactiveRefreshEnabled = !0), this.currentUser && this._currentUser._startProactiveRefresh()
  }
  _stopProactiveRefresh() {
    ;(this.isProactiveRefreshEnabled = !1), this.currentUser && this._currentUser._stopProactiveRefresh()
  }
  get _currentUser() {
    return this.currentUser
  }
  notifyAuthListeners() {
    var t, n
    if (!this._isInitialized) return
    this.idTokenSubscription.next(this.currentUser)
    const i = (n = (t = this.currentUser) === null || t === void 0 ? void 0 : t.uid) !== null && n !== void 0 ? n : null
    this.lastNotifiedUid !== i && ((this.lastNotifiedUid = i), this.authStateSubscription.next(this.currentUser))
  }
  registerStateListener(t, n, i, r) {
    if (this._deleted) return () => {}
    const s = typeof n == 'function' ? n : n.next.bind(n)
    let o = !1
    const a = this._isInitialized ? Promise.resolve() : this._initializationPromise
    if (
      (We(a, this, 'internal-error'),
      a.then(() => {
        o || s(this.currentUser)
      }),
      typeof n == 'function')
    ) {
      const l = t.addObserver(n, i, r)
      return () => {
        ;(o = !0), l()
      }
    } else {
      const l = t.addObserver(n)
      return () => {
        ;(o = !0), l()
      }
    }
  }
  async directlySetCurrentUser(t) {
    this.currentUser && this.currentUser !== t && this._currentUser._stopProactiveRefresh(),
      t && this.isProactiveRefreshEnabled && t._startProactiveRefresh(),
      (this.currentUser = t),
      t ? await this.assertedPersistence.setCurrentUser(t) : await this.assertedPersistence.removeCurrentUser()
  }
  queue(t) {
    return (this.operations = this.operations.then(t, t)), this.operations
  }
  get assertedPersistence() {
    return We(this.persistenceManager, this, 'internal-error'), this.persistenceManager
  }
  _logFramework(t) {
    !t ||
      this.frameworks.includes(t) ||
      (this.frameworks.push(t),
      this.frameworks.sort(),
      (this.clientVersion = Dk(this.config.clientPlatform, this._getFrameworks())))
  }
  _getFrameworks() {
    return this.frameworks
  }
  async _getAdditionalHeaders() {
    var t
    const n = { 'X-Client-Version': this.clientVersion }
    this.app.options.appId && (n['X-Firebase-gmpid'] = this.app.options.appId)
    const i = await ((t = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) === null || t === void 0
      ? void 0
      : t.getHeartbeatsHeader())
    i && (n['X-Firebase-Client'] = i)
    const r = await this._getAppCheckToken()
    return r && (n['X-Firebase-AppCheck'] = r), n
  }
  async _getAppCheckToken() {
    var t
    const n = await ((t = this.appCheckServiceProvider.getImmediate({ optional: !0 })) === null || t === void 0
      ? void 0
      : t.getToken())
    return (
      n != null && n.error && D2(`Error while retrieving App Check token: ${n.error}`), n == null ? void 0 : n.token
    )
  }
}
function ia(e) {
  return Et(e)
}
class ES {
  constructor(t) {
    ;(this.auth = t), (this.observer = null), (this.addObserver = yB((n) => (this.observer = n)))
  }
  get next() {
    return We(this.observer, this.auth, 'internal-error'), this.observer.next.bind(this.observer)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Kf = {
  async loadJS() {
    throw new Error('Unable to load external scripts')
  },
  recaptchaV2Script: '',
  recaptchaEnterpriseScript: '',
  gapiScript: '',
}
function s$(e) {
  Kf = e
}
function Nk(e) {
  return Kf.loadJS(e)
}
function o$() {
  return Kf.recaptchaEnterpriseScript
}
function a$() {
  return Kf.gapiScript
}
function l$(e) {
  return `__${e}${Math.floor(Math.random() * 1e6)}`
}
const u$ = 'recaptcha-enterprise',
  c$ = 'NO_RECAPTCHA'
class d$ {
  constructor(t) {
    ;(this.type = u$), (this.auth = ia(t))
  }
  async verify(t = 'verify', n = !1) {
    async function i(s) {
      if (!n) {
        if (s.tenantId == null && s._agentRecaptchaConfig != null) return s._agentRecaptchaConfig.siteKey
        if (s.tenantId != null && s._tenantRecaptchaConfigs[s.tenantId] !== void 0)
          return s._tenantRecaptchaConfigs[s.tenantId].siteKey
      }
      return new Promise(async (o, a) => {
        j2(s, { clientType: 'CLIENT_TYPE_WEB', version: 'RECAPTCHA_ENTERPRISE' })
          .then((l) => {
            if (l.recaptchaKey === void 0) a(new Error('recaptcha Enterprise site key undefined'))
            else {
              const u = new U2(l)
              return (
                s.tenantId == null ? (s._agentRecaptchaConfig = u) : (s._tenantRecaptchaConfigs[s.tenantId] = u),
                o(u.siteKey)
              )
            }
          })
          .catch((l) => {
            a(l)
          })
      })
    }
    function r(s, o, a) {
      const l = window.grecaptcha
      _S(l)
        ? l.enterprise.ready(() => {
            l.enterprise
              .execute(s, { action: t })
              .then((u) => {
                o(u)
              })
              .catch(() => {
                o(c$)
              })
          })
        : a(Error('No reCAPTCHA enterprise script loaded.'))
    }
    return new Promise((s, o) => {
      i(this.auth)
        .then((a) => {
          if (!n && _S(window.grecaptcha)) r(a, s, o)
          else {
            if (typeof window > 'u') {
              o(new Error('RecaptchaVerifier is only supported in browser'))
              return
            }
            let l = o$()
            l.length !== 0 && (l += a),
              Nk(l)
                .then(() => {
                  r(a, s, o)
                })
                .catch((u) => {
                  o(u)
                })
          }
        })
        .catch((a) => {
          o(a)
        })
    })
  }
}
async function TS(e, t, n, i = !1) {
  const r = new d$(e)
  let s
  try {
    s = await r.verify(n)
  } catch {
    s = await r.verify(n, !0)
  }
  const o = Object.assign({}, t)
  return (
    i ? Object.assign(o, { captchaResp: s }) : Object.assign(o, { captchaResponse: s }),
    Object.assign(o, { clientType: 'CLIENT_TYPE_WEB' }),
    Object.assign(o, { recaptchaVersion: 'RECAPTCHA_ENTERPRISE' }),
    o
  )
}
async function zv(e, t, n, i) {
  var r
  if (!((r = e._getRecaptchaConfig()) === null || r === void 0) && r.isProviderEnabled('EMAIL_PASSWORD_PROVIDER')) {
    const s = await TS(e, t, n, n === 'getOobCode')
    return i(e, s)
  } else
    return i(e, t).catch(async (s) => {
      if (s.code === 'auth/missing-recaptcha-token') {
        console.log(
          `${n} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`
        )
        const o = await TS(e, t, n, n === 'getOobCode')
        return i(e, o)
      } else return Promise.reject(s)
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Ok(e, t) {
  const n = Wr(e, 'auth')
  if (n.isInitialized()) {
    const r = n.getImmediate(),
      s = n.getOptions()
    if (fl(s, t ?? {})) return r
    Wi(r, 'already-initialized')
  }
  return n.initialize({ options: t })
}
function h$(e, t) {
  const n = (t == null ? void 0 : t.persistence) || [],
    i = (Array.isArray(n) ? n : [n]).map(Pr)
  t != null && t.errorMap && e._updateErrorMap(t.errorMap),
    e._initializeWithPersistence(i, t == null ? void 0 : t.popupRedirectResolver)
}
function f$(e, t, n) {
  const i = ia(e)
  We(i._canInitEmulator, i, 'emulator-config-failed'), We(/^https?:\/\//.test(t), i, 'invalid-emulator-scheme')
  const r = !1,
    s = Mk(t),
    { host: o, port: a } = m$(t),
    l = a === null ? '' : `:${a}`
  ;(i.config.emulator = { url: `${s}//${o}${l}/` }),
    (i.settings.appVerificationDisabledForTesting = !0),
    (i.emulatorConfig = Object.freeze({
      host: o,
      port: a,
      protocol: s.replace(':', ''),
      options: Object.freeze({ disableWarnings: r }),
    })),
    g$()
}
function Mk(e) {
  const t = e.indexOf(':')
  return t < 0 ? '' : e.substr(0, t + 1)
}
function m$(e) {
  const t = Mk(e),
    n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length))
  if (!n) return { host: '', port: null }
  const i = n[2].split('@').pop() || '',
    r = /^(\[[^\]]+\])(:|$)/.exec(i)
  if (r) {
    const s = r[1]
    return { host: s, port: CS(i.substr(s.length + 1)) }
  } else {
    const [s, o] = i.split(':')
    return { host: s, port: CS(o) }
  }
}
function CS(e) {
  if (!e) return null
  const t = Number(e)
  return isNaN(t) ? null : t
}
function g$() {
  function e() {
    const t = document.createElement('p'),
      n = t.style
    ;(t.innerText = 'Running in emulator mode. Do not use with production credentials.'),
      (n.position = 'fixed'),
      (n.width = '100%'),
      (n.backgroundColor = '#ffffff'),
      (n.border = '.1em solid #000000'),
      (n.color = '#b50000'),
      (n.bottom = '0px'),
      (n.left = '0px'),
      (n.margin = '0px'),
      (n.zIndex = '10000'),
      (n.textAlign = 'center'),
      t.classList.add('firebase-emulator-warning'),
      document.body.appendChild(t)
  }
  typeof console < 'u' &&
    typeof console.info == 'function' &&
    console.info(
      'WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.'
    ),
    typeof window < 'u' &&
      typeof document < 'u' &&
      (document.readyState === 'loading' ? window.addEventListener('DOMContentLoaded', e) : e())
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class e_ {
  constructor(t, n) {
    ;(this.providerId = t), (this.signInMethod = n)
  }
  toJSON() {
    return Ar('not implemented')
  }
  _getIdTokenResponse(t) {
    return Ar('not implemented')
  }
  _linkToIdToken(t, n) {
    return Ar('not implemented')
  }
  _getReauthenticationResolver(t) {
    return Ar('not implemented')
  }
}
async function v$(e, t) {
  return qr(e, 'POST', '/v1/accounts:signUp', t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function p$(e, t) {
  return qf(e, 'POST', '/v1/accounts:signInWithPassword', Hs(e, t))
}
async function y$(e, t) {
  return qr(e, 'POST', '/v1/accounts:sendOobCode', Hs(e, t))
}
async function _$(e, t) {
  return y$(e, t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function b$(e, t) {
  return qf(e, 'POST', '/v1/accounts:signInWithEmailLink', Hs(e, t))
}
async function w$(e, t) {
  return qf(e, 'POST', '/v1/accounts:signInWithEmailLink', Hs(e, t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class dc extends e_ {
  constructor(t, n, i, r = null) {
    super('password', i), (this._email = t), (this._password = n), (this._tenantId = r)
  }
  static _fromEmailAndPassword(t, n) {
    return new dc(t, n, 'password')
  }
  static _fromEmailAndCode(t, n, i = null) {
    return new dc(t, n, 'emailLink', i)
  }
  toJSON() {
    return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId }
  }
  static fromJSON(t) {
    const n = typeof t == 'string' ? JSON.parse(t) : t
    if (n != null && n.email && n != null && n.password) {
      if (n.signInMethod === 'password') return this._fromEmailAndPassword(n.email, n.password)
      if (n.signInMethod === 'emailLink') return this._fromEmailAndCode(n.email, n.password, n.tenantId)
    }
    return null
  }
  async _getIdTokenResponse(t) {
    switch (this.signInMethod) {
      case 'password':
        const n = { returnSecureToken: !0, email: this._email, password: this._password, clientType: 'CLIENT_TYPE_WEB' }
        return zv(t, n, 'signInWithPassword', p$)
      case 'emailLink':
        return b$(t, { email: this._email, oobCode: this._password })
      default:
        Wi(t, 'internal-error')
    }
  }
  async _linkToIdToken(t, n) {
    switch (this.signInMethod) {
      case 'password':
        const i = {
          idToken: n,
          returnSecureToken: !0,
          email: this._email,
          password: this._password,
          clientType: 'CLIENT_TYPE_WEB',
        }
        return zv(t, i, 'signUpPassword', v$)
      case 'emailLink':
        return w$(t, { idToken: n, email: this._email, oobCode: this._password })
      default:
        Wi(t, 'internal-error')
    }
  }
  _getReauthenticationResolver(t) {
    return this._getIdTokenResponse(t)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function nl(e, t) {
  return qf(e, 'POST', '/v1/accounts:signInWithIdp', Hs(e, t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const I$ = 'http://localhost'
class Vo extends e_ {
  constructor() {
    super(...arguments), (this.pendingToken = null)
  }
  static _fromParams(t) {
    const n = new Vo(t.providerId, t.signInMethod)
    return (
      t.idToken || t.accessToken
        ? (t.idToken && (n.idToken = t.idToken),
          t.accessToken && (n.accessToken = t.accessToken),
          t.nonce && !t.pendingToken && (n.nonce = t.nonce),
          t.pendingToken && (n.pendingToken = t.pendingToken))
        : t.oauthToken && t.oauthTokenSecret
        ? ((n.accessToken = t.oauthToken), (n.secret = t.oauthTokenSecret))
        : Wi('argument-error'),
      n
    )
  }
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod,
    }
  }
  static fromJSON(t) {
    const n = typeof t == 'string' ? JSON.parse(t) : t,
      { providerId: i, signInMethod: r } = n,
      s = Yy(n, ['providerId', 'signInMethod'])
    if (!i || !r) return null
    const o = new Vo(i, r)
    return (
      (o.idToken = s.idToken || void 0),
      (o.accessToken = s.accessToken || void 0),
      (o.secret = s.secret),
      (o.nonce = s.nonce),
      (o.pendingToken = s.pendingToken || null),
      o
    )
  }
  _getIdTokenResponse(t) {
    const n = this.buildRequest()
    return nl(t, n)
  }
  _linkToIdToken(t, n) {
    const i = this.buildRequest()
    return (i.idToken = n), nl(t, i)
  }
  _getReauthenticationResolver(t) {
    const n = this.buildRequest()
    return (n.autoCreate = !1), nl(t, n)
  }
  buildRequest() {
    const t = { requestUri: I$, returnSecureToken: !0 }
    if (this.pendingToken) t.pendingToken = this.pendingToken
    else {
      const n = {}
      this.idToken && (n.id_token = this.idToken),
        this.accessToken && (n.access_token = this.accessToken),
        this.secret && (n.oauth_token_secret = this.secret),
        (n.providerId = this.providerId),
        this.nonce && !this.pendingToken && (n.nonce = this.nonce),
        (t.postBody = Ll(n))
    }
    return t
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function S$(e) {
  switch (e) {
    case 'recoverEmail':
      return 'RECOVER_EMAIL'
    case 'resetPassword':
      return 'PASSWORD_RESET'
    case 'signIn':
      return 'EMAIL_SIGNIN'
    case 'verifyEmail':
      return 'VERIFY_EMAIL'
    case 'verifyAndChangeEmail':
      return 'VERIFY_AND_CHANGE_EMAIL'
    case 'revertSecondFactorAddition':
      return 'REVERT_SECOND_FACTOR_ADDITION'
    default:
      return null
  }
}
function E$(e) {
  const t = Cu(Au(e)).link,
    n = t ? Cu(Au(t)).deep_link_id : null,
    i = Cu(Au(e)).deep_link_id
  return (i ? Cu(Au(i)).link : null) || i || n || t || e
}
class t_ {
  constructor(t) {
    var n, i, r, s, o, a
    const l = Cu(Au(t)),
      u = (n = l.apiKey) !== null && n !== void 0 ? n : null,
      c = (i = l.oobCode) !== null && i !== void 0 ? i : null,
      d = S$((r = l.mode) !== null && r !== void 0 ? r : null)
    We(u && c && d, 'argument-error'),
      (this.apiKey = u),
      (this.operation = d),
      (this.code = c),
      (this.continueUrl = (s = l.continueUrl) !== null && s !== void 0 ? s : null),
      (this.languageCode = (o = l.languageCode) !== null && o !== void 0 ? o : null),
      (this.tenantId = (a = l.tenantId) !== null && a !== void 0 ? a : null)
  }
  static parseLink(t) {
    const n = E$(t)
    try {
      return new t_(n)
    } catch {
      return null
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Fl {
  constructor() {
    this.providerId = Fl.PROVIDER_ID
  }
  static credential(t, n) {
    return dc._fromEmailAndPassword(t, n)
  }
  static credentialWithLink(t, n) {
    const i = t_.parseLink(n)
    return We(i, 'argument-error'), dc._fromEmailAndCode(t, i.code, i.tenantId)
  }
}
Fl.PROVIDER_ID = 'password'
Fl.EMAIL_PASSWORD_SIGN_IN_METHOD = 'password'
Fl.EMAIL_LINK_SIGN_IN_METHOD = 'emailLink'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Lk {
  constructor(t) {
    ;(this.providerId = t), (this.defaultLanguageCode = null), (this.customParameters = {})
  }
  setDefaultLanguage(t) {
    this.defaultLanguageCode = t
  }
  setCustomParameters(t) {
    return (this.customParameters = t), this
  }
  getCustomParameters() {
    return this.customParameters
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Wc extends Lk {
  constructor() {
    super(...arguments), (this.scopes = [])
  }
  addScope(t) {
    return this.scopes.includes(t) || this.scopes.push(t), this
  }
  getScopes() {
    return [...this.scopes]
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class gs extends Wc {
  constructor() {
    super('facebook.com')
  }
  static credential(t) {
    return Vo._fromParams({ providerId: gs.PROVIDER_ID, signInMethod: gs.FACEBOOK_SIGN_IN_METHOD, accessToken: t })
  }
  static credentialFromResult(t) {
    return gs.credentialFromTaggedObject(t)
  }
  static credentialFromError(t) {
    return gs.credentialFromTaggedObject(t.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t || !('oauthAccessToken' in t) || !t.oauthAccessToken) return null
    try {
      return gs.credential(t.oauthAccessToken)
    } catch {
      return null
    }
  }
}
gs.FACEBOOK_SIGN_IN_METHOD = 'facebook.com'
gs.PROVIDER_ID = 'facebook.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vs extends Wc {
  constructor() {
    super('google.com'), this.addScope('profile')
  }
  static credential(t, n) {
    return Vo._fromParams({
      providerId: vs.PROVIDER_ID,
      signInMethod: vs.GOOGLE_SIGN_IN_METHOD,
      idToken: t,
      accessToken: n,
    })
  }
  static credentialFromResult(t) {
    return vs.credentialFromTaggedObject(t)
  }
  static credentialFromError(t) {
    return vs.credentialFromTaggedObject(t.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t) return null
    const { oauthIdToken: n, oauthAccessToken: i } = t
    if (!n && !i) return null
    try {
      return vs.credential(n, i)
    } catch {
      return null
    }
  }
}
vs.GOOGLE_SIGN_IN_METHOD = 'google.com'
vs.PROVIDER_ID = 'google.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ps extends Wc {
  constructor() {
    super('github.com')
  }
  static credential(t) {
    return Vo._fromParams({ providerId: ps.PROVIDER_ID, signInMethod: ps.GITHUB_SIGN_IN_METHOD, accessToken: t })
  }
  static credentialFromResult(t) {
    return ps.credentialFromTaggedObject(t)
  }
  static credentialFromError(t) {
    return ps.credentialFromTaggedObject(t.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t || !('oauthAccessToken' in t) || !t.oauthAccessToken) return null
    try {
      return ps.credential(t.oauthAccessToken)
    } catch {
      return null
    }
  }
}
ps.GITHUB_SIGN_IN_METHOD = 'github.com'
ps.PROVIDER_ID = 'github.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ys extends Wc {
  constructor() {
    super('twitter.com')
  }
  static credential(t, n) {
    return Vo._fromParams({
      providerId: ys.PROVIDER_ID,
      signInMethod: ys.TWITTER_SIGN_IN_METHOD,
      oauthToken: t,
      oauthTokenSecret: n,
    })
  }
  static credentialFromResult(t) {
    return ys.credentialFromTaggedObject(t)
  }
  static credentialFromError(t) {
    return ys.credentialFromTaggedObject(t.customData || {})
  }
  static credentialFromTaggedObject({ _tokenResponse: t }) {
    if (!t) return null
    const { oauthAccessToken: n, oauthTokenSecret: i } = t
    if (!n || !i) return null
    try {
      return ys.credential(n, i)
    } catch {
      return null
    }
  }
}
ys.TWITTER_SIGN_IN_METHOD = 'twitter.com'
ys.PROVIDER_ID = 'twitter.com'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ml {
  constructor(t) {
    ;(this.user = t.user),
      (this.providerId = t.providerId),
      (this._tokenResponse = t._tokenResponse),
      (this.operationType = t.operationType)
  }
  static async _fromIdTokenResponse(t, n, i, r = !1) {
    const s = await kr._fromIdTokenResponse(t, i, r),
      o = AS(i)
    return new ml({ user: s, providerId: o, _tokenResponse: i, operationType: n })
  }
  static async _forOperation(t, n, i) {
    await t._updateTokensIfNecessary(i, !0)
    const r = AS(i)
    return new ml({ user: t, providerId: r, _tokenResponse: i, operationType: n })
  }
}
function AS(e) {
  return e.providerId ? e.providerId : 'phoneNumber' in e ? 'phone' : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Wh extends Di {
  constructor(t, n, i, r) {
    var s
    super(n.code, n.message),
      (this.operationType = i),
      (this.user = r),
      Object.setPrototypeOf(this, Wh.prototype),
      (this.customData = {
        appName: t.name,
        tenantId: (s = t.tenantId) !== null && s !== void 0 ? s : void 0,
        _serverResponse: n.customData._serverResponse,
        operationType: i,
      })
  }
  static _fromErrorAndOperation(t, n, i, r) {
    return new Wh(t, n, i, r)
  }
}
function Fk(e, t, n, i) {
  return (t === 'reauthenticate' ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch((s) => {
    throw s.code === 'auth/multi-factor-auth-required' ? Wh._fromErrorAndOperation(e, s, t, i) : s
  })
}
async function T$(e, t, n = !1) {
  const i = await cc(e, t._linkToIdToken(e.auth, await e.getIdToken()), n)
  return ml._forOperation(e, 'link', i)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function C$(e, t, n = !1) {
  const { auth: i } = e
  if (Cr(i.app)) return Promise.reject(As(i))
  const r = 'reauthenticate'
  try {
    const s = await cc(e, Fk(i, r, t, e), n)
    We(s.idToken, i, 'internal-error')
    const o = Jy(s.idToken)
    We(o, i, 'internal-error')
    const { sub: a } = o
    return We(e.uid === a, i, 'user-mismatch'), ml._forOperation(e, r, s)
  } catch (s) {
    throw ((s == null ? void 0 : s.code) === 'auth/user-not-found' && Wi(i, 'user-mismatch'), s)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Bk(e, t, n = !1) {
  if (Cr(e.app)) return Promise.reject(As(e))
  const i = 'signIn',
    r = await Fk(e, i, t),
    s = await ml._fromIdTokenResponse(e, i, r)
  return n || (await e._updateCurrentUser(s.user)), s
}
async function A$(e, t) {
  return Bk(ia(e), t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function k$(e) {
  const t = ia(e)
  t._getPasswordPolicyInternal() && (await t._updatePasswordPolicy())
}
async function Bte(e, t, n) {
  const i = ia(e)
  await zv(i, { requestType: 'PASSWORD_RESET', email: t, clientType: 'CLIENT_TYPE_WEB' }, 'getOobCode', _$)
}
function $te(e, t, n) {
  return Cr(e.app)
    ? Promise.reject(As(e))
    : A$(Et(e), Fl.credential(t, n)).catch(async (i) => {
        throw (i.code === 'auth/password-does-not-meet-requirements' && k$(e), i)
      })
}
function $k(e, t, n, i) {
  return Et(e).onIdTokenChanged(t, n, i)
}
function P$(e, t, n) {
  return Et(e).beforeAuthStateChanged(t, n)
}
function Ute(e, t, n, i) {
  return Et(e).onAuthStateChanged(t, n, i)
}
function jte(e) {
  return Et(e).signOut()
}
const qh = '__sak'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Uk {
  constructor(t, n) {
    ;(this.storageRetriever = t), (this.type = n)
  }
  _isAvailable() {
    try {
      return this.storage
        ? (this.storage.setItem(qh, '1'), this.storage.removeItem(qh), Promise.resolve(!0))
        : Promise.resolve(!1)
    } catch {
      return Promise.resolve(!1)
    }
  }
  _set(t, n) {
    return this.storage.setItem(t, JSON.stringify(n)), Promise.resolve()
  }
  _get(t) {
    const n = this.storage.getItem(t)
    return Promise.resolve(n ? JSON.parse(n) : null)
  }
  _remove(t) {
    return this.storage.removeItem(t), Promise.resolve()
  }
  get storage() {
    return this.storageRetriever()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function R$() {
  const e = Zt()
  return Zy(e) || Gf(e)
}
const x$ = 1e3,
  V$ = 10
class jk extends Uk {
  constructor() {
    super(() => window.localStorage, 'LOCAL'),
      (this.boundEventHandler = (t, n) => this.onStorageEvent(t, n)),
      (this.listeners = {}),
      (this.localCache = {}),
      (this.pollTimer = null),
      (this.safariLocalStorageNotSynced = R$() && Z2()),
      (this.fallbackToPolling = Vk()),
      (this._shouldAllowMigration = !0)
  }
  forAllChangedKeys(t) {
    for (const n of Object.keys(this.listeners)) {
      const i = this.storage.getItem(n),
        r = this.localCache[n]
      i !== r && t(n, r, i)
    }
  }
  onStorageEvent(t, n = !1) {
    if (!t.key) {
      this.forAllChangedKeys((o, a, l) => {
        this.notifyListeners(o, l)
      })
      return
    }
    const i = t.key
    if ((n ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced)) {
      const o = this.storage.getItem(i)
      if (t.newValue !== o) t.newValue !== null ? this.storage.setItem(i, t.newValue) : this.storage.removeItem(i)
      else if (this.localCache[i] === t.newValue && !n) return
    }
    const r = () => {
        const o = this.storage.getItem(i)
        ;(!n && this.localCache[i] === o) || this.notifyListeners(i, o)
      },
      s = this.storage.getItem(i)
    J2() && s !== t.newValue && t.newValue !== t.oldValue ? setTimeout(r, V$) : r()
  }
  notifyListeners(t, n) {
    this.localCache[t] = n
    const i = this.listeners[t]
    if (i) for (const r of Array.from(i)) r(n && JSON.parse(n))
  }
  startPolling() {
    this.stopPolling(),
      (this.pollTimer = setInterval(() => {
        this.forAllChangedKeys((t, n, i) => {
          this.onStorageEvent(new StorageEvent('storage', { key: t, oldValue: n, newValue: i }), !0)
        })
      }, x$))
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null))
  }
  attachListener() {
    window.addEventListener('storage', this.boundEventHandler)
  }
  detachListener() {
    window.removeEventListener('storage', this.boundEventHandler)
  }
  _addListener(t, n) {
    Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
      this.listeners[t] || ((this.listeners[t] = new Set()), (this.localCache[t] = this.storage.getItem(t))),
      this.listeners[t].add(n)
  }
  _removeListener(t, n) {
    this.listeners[t] && (this.listeners[t].delete(n), this.listeners[t].size === 0 && delete this.listeners[t]),
      Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling())
  }
  async _set(t, n) {
    await super._set(t, n), (this.localCache[t] = JSON.stringify(n))
  }
  async _get(t) {
    const n = await super._get(t)
    return (this.localCache[t] = JSON.stringify(n)), n
  }
  async _remove(t) {
    await super._remove(t), delete this.localCache[t]
  }
}
jk.type = 'LOCAL'
const zk = jk
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Hk extends Uk {
  constructor() {
    super(() => window.sessionStorage, 'SESSION')
  }
  _addListener(t, n) {}
  _removeListener(t, n) {}
}
Hk.type = 'SESSION'
const n_ = Hk
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function D$(e) {
  return Promise.all(
    e.map(async (t) => {
      try {
        return { fulfilled: !0, value: await t }
      } catch (n) {
        return { fulfilled: !1, reason: n }
      }
    })
  )
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Yf {
  constructor(t) {
    ;(this.eventTarget = t), (this.handlersMap = {}), (this.boundEventHandler = this.handleEvent.bind(this))
  }
  static _getInstance(t) {
    const n = this.receivers.find((r) => r.isListeningto(t))
    if (n) return n
    const i = new Yf(t)
    return this.receivers.push(i), i
  }
  isListeningto(t) {
    return this.eventTarget === t
  }
  async handleEvent(t) {
    const n = t,
      { eventId: i, eventType: r, data: s } = n.data,
      o = this.handlersMap[r]
    if (!(o != null && o.size)) return
    n.ports[0].postMessage({ status: 'ack', eventId: i, eventType: r })
    const a = Array.from(o).map(async (u) => u(n.origin, s)),
      l = await D$(a)
    n.ports[0].postMessage({ status: 'done', eventId: i, eventType: r, response: l })
  }
  _subscribe(t, n) {
    Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener('message', this.boundEventHandler),
      this.handlersMap[t] || (this.handlersMap[t] = new Set()),
      this.handlersMap[t].add(n)
  }
  _unsubscribe(t, n) {
    this.handlersMap[t] && n && this.handlersMap[t].delete(n),
      (!n || this.handlersMap[t].size === 0) && delete this.handlersMap[t],
      Object.keys(this.handlersMap).length === 0 &&
        this.eventTarget.removeEventListener('message', this.boundEventHandler)
  }
}
Yf.receivers = []
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function i_(e = '', t = 10) {
  let n = ''
  for (let i = 0; i < t; i++) n += Math.floor(Math.random() * 10)
  return e + n
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class N$ {
  constructor(t) {
    ;(this.target = t), (this.handlers = new Set())
  }
  removeMessageHandler(t) {
    t.messageChannel &&
      (t.messageChannel.port1.removeEventListener('message', t.onMessage), t.messageChannel.port1.close()),
      this.handlers.delete(t)
  }
  async _send(t, n, i = 50) {
    const r = typeof MessageChannel < 'u' ? new MessageChannel() : null
    if (!r) throw new Error('connection_unavailable')
    let s, o
    return new Promise((a, l) => {
      const u = i_('', 20)
      r.port1.start()
      const c = setTimeout(() => {
        l(new Error('unsupported_event'))
      }, i)
      ;(o = {
        messageChannel: r,
        onMessage(d) {
          const f = d
          if (f.data.eventId === u)
            switch (f.data.status) {
              case 'ack':
                clearTimeout(c),
                  (s = setTimeout(() => {
                    l(new Error('timeout'))
                  }, 3e3))
                break
              case 'done':
                clearTimeout(s), a(f.data.response)
                break
              default:
                clearTimeout(c), clearTimeout(s), l(new Error('invalid_response'))
                break
            }
        },
      }),
        this.handlers.add(o),
        r.port1.addEventListener('message', o.onMessage),
        this.target.postMessage({ eventType: t, eventId: u, data: n }, [r.port2])
    }).finally(() => {
      o && this.removeMessageHandler(o)
    })
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function ur() {
  return window
}
function O$(e) {
  ur().location.href = e
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Wk() {
  return typeof ur().WorkerGlobalScope < 'u' && typeof ur().importScripts == 'function'
}
async function M$() {
  if (!(navigator != null && navigator.serviceWorker)) return null
  try {
    return (await navigator.serviceWorker.ready).active
  } catch {
    return null
  }
}
function L$() {
  var e
  return (
    ((e = navigator == null ? void 0 : navigator.serviceWorker) === null || e === void 0 ? void 0 : e.controller) ||
    null
  )
}
function F$() {
  return Wk() ? self : null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const qk = 'firebaseLocalStorageDb',
  B$ = 1,
  Gh = 'firebaseLocalStorage',
  Gk = 'fbase_key'
class qc {
  constructor(t) {
    this.request = t
  }
  toPromise() {
    return new Promise((t, n) => {
      this.request.addEventListener('success', () => {
        t(this.request.result)
      }),
        this.request.addEventListener('error', () => {
          n(this.request.error)
        })
    })
  }
}
function Qf(e, t) {
  return e.transaction([Gh], t ? 'readwrite' : 'readonly').objectStore(Gh)
}
function $$() {
  const e = indexedDB.deleteDatabase(qk)
  return new qc(e).toPromise()
}
function Hv() {
  const e = indexedDB.open(qk, B$)
  return new Promise((t, n) => {
    e.addEventListener('error', () => {
      n(e.error)
    }),
      e.addEventListener('upgradeneeded', () => {
        const i = e.result
        try {
          i.createObjectStore(Gh, { keyPath: Gk })
        } catch (r) {
          n(r)
        }
      }),
      e.addEventListener('success', async () => {
        const i = e.result
        i.objectStoreNames.contains(Gh) ? t(i) : (i.close(), await $$(), t(await Hv()))
      })
  })
}
async function kS(e, t, n) {
  const i = Qf(e, !0).put({ [Gk]: t, value: n })
  return new qc(i).toPromise()
}
async function U$(e, t) {
  const n = Qf(e, !1).get(t),
    i = await new qc(n).toPromise()
  return i === void 0 ? null : i.value
}
function PS(e, t) {
  const n = Qf(e, !0).delete(t)
  return new qc(n).toPromise()
}
const j$ = 800,
  z$ = 3
class Kk {
  constructor() {
    ;(this.type = 'LOCAL'),
      (this._shouldAllowMigration = !0),
      (this.listeners = {}),
      (this.localCache = {}),
      (this.pollTimer = null),
      (this.pendingWrites = 0),
      (this.receiver = null),
      (this.sender = null),
      (this.serviceWorkerReceiverAvailable = !1),
      (this.activeServiceWorker = null),
      (this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(
        () => {},
        () => {}
      ))
  }
  async _openDb() {
    return this.db ? this.db : ((this.db = await Hv()), this.db)
  }
  async _withRetries(t) {
    let n = 0
    for (;;)
      try {
        const i = await this._openDb()
        return await t(i)
      } catch (i) {
        if (n++ > z$) throw i
        this.db && (this.db.close(), (this.db = void 0))
      }
  }
  async initializeServiceWorkerMessaging() {
    return Wk() ? this.initializeReceiver() : this.initializeSender()
  }
  async initializeReceiver() {
    ;(this.receiver = Yf._getInstance(F$())),
      this.receiver._subscribe('keyChanged', async (t, n) => ({ keyProcessed: (await this._poll()).includes(n.key) })),
      this.receiver._subscribe('ping', async (t, n) => ['keyChanged'])
  }
  async initializeSender() {
    var t, n
    if (((this.activeServiceWorker = await M$()), !this.activeServiceWorker)) return
    this.sender = new N$(this.activeServiceWorker)
    const i = await this.sender._send('ping', {}, 800)
    i &&
      !((t = i[0]) === null || t === void 0) &&
      t.fulfilled &&
      !((n = i[0]) === null || n === void 0) &&
      n.value.includes('keyChanged') &&
      (this.serviceWorkerReceiverAvailable = !0)
  }
  async notifyServiceWorker(t) {
    if (!(!this.sender || !this.activeServiceWorker || L$() !== this.activeServiceWorker))
      try {
        await this.sender._send('keyChanged', { key: t }, this.serviceWorkerReceiverAvailable ? 800 : 50)
      } catch {}
  }
  async _isAvailable() {
    try {
      if (!indexedDB) return !1
      const t = await Hv()
      return await kS(t, qh, '1'), await PS(t, qh), !0
    } catch {}
    return !1
  }
  async _withPendingWrite(t) {
    this.pendingWrites++
    try {
      await t()
    } finally {
      this.pendingWrites--
    }
  }
  async _set(t, n) {
    return this._withPendingWrite(
      async () => (await this._withRetries((i) => kS(i, t, n)), (this.localCache[t] = n), this.notifyServiceWorker(t))
    )
  }
  async _get(t) {
    const n = await this._withRetries((i) => U$(i, t))
    return (this.localCache[t] = n), n
  }
  async _remove(t) {
    return this._withPendingWrite(
      async () => (await this._withRetries((n) => PS(n, t)), delete this.localCache[t], this.notifyServiceWorker(t))
    )
  }
  async _poll() {
    const t = await this._withRetries((r) => {
      const s = Qf(r, !1).getAll()
      return new qc(s).toPromise()
    })
    if (!t) return []
    if (this.pendingWrites !== 0) return []
    const n = [],
      i = new Set()
    if (t.length !== 0)
      for (const { fbase_key: r, value: s } of t)
        i.add(r), JSON.stringify(this.localCache[r]) !== JSON.stringify(s) && (this.notifyListeners(r, s), n.push(r))
    for (const r of Object.keys(this.localCache))
      this.localCache[r] && !i.has(r) && (this.notifyListeners(r, null), n.push(r))
    return n
  }
  notifyListeners(t, n) {
    this.localCache[t] = n
    const i = this.listeners[t]
    if (i) for (const r of Array.from(i)) r(n)
  }
  startPolling() {
    this.stopPolling(), (this.pollTimer = setInterval(async () => this._poll(), j$))
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null))
  }
  _addListener(t, n) {
    Object.keys(this.listeners).length === 0 && this.startPolling(),
      this.listeners[t] || ((this.listeners[t] = new Set()), this._get(t)),
      this.listeners[t].add(n)
  }
  _removeListener(t, n) {
    this.listeners[t] && (this.listeners[t].delete(n), this.listeners[t].size === 0 && delete this.listeners[t]),
      Object.keys(this.listeners).length === 0 && this.stopPolling()
  }
}
Kk.type = 'LOCAL'
const Yk = Kk
new Hc(3e4, 6e4)
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function H$(e, t) {
  return t ? Pr(t) : (We(e._popupRedirectResolver, e, 'argument-error'), e._popupRedirectResolver)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class r_ extends e_ {
  constructor(t) {
    super('custom', 'custom'), (this.params = t)
  }
  _getIdTokenResponse(t) {
    return nl(t, this._buildIdpRequest())
  }
  _linkToIdToken(t, n) {
    return nl(t, this._buildIdpRequest(n))
  }
  _getReauthenticationResolver(t) {
    return nl(t, this._buildIdpRequest())
  }
  _buildIdpRequest(t) {
    const n = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: !0,
      returnIdpCredential: !0,
    }
    return t && (n.idToken = t), n
  }
}
function W$(e) {
  return Bk(e.auth, new r_(e), e.bypassAuthState)
}
function q$(e) {
  const { auth: t, user: n } = e
  return We(n, t, 'internal-error'), C$(n, new r_(e), e.bypassAuthState)
}
async function G$(e) {
  const { auth: t, user: n } = e
  return We(n, t, 'internal-error'), T$(n, new r_(e), e.bypassAuthState)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Qk {
  constructor(t, n, i, r, s = !1) {
    ;(this.auth = t),
      (this.resolver = i),
      (this.user = r),
      (this.bypassAuthState = s),
      (this.pendingPromise = null),
      (this.eventManager = null),
      (this.filter = Array.isArray(n) ? n : [n])
  }
  execute() {
    return new Promise(async (t, n) => {
      this.pendingPromise = { resolve: t, reject: n }
      try {
        ;(this.eventManager = await this.resolver._initialize(this.auth)),
          await this.onExecution(),
          this.eventManager.registerConsumer(this)
      } catch (i) {
        this.reject(i)
      }
    })
  }
  async onAuthEvent(t) {
    const { urlResponse: n, sessionId: i, postBody: r, tenantId: s, error: o, type: a } = t
    if (o) {
      this.reject(o)
      return
    }
    const l = {
      auth: this.auth,
      requestUri: n,
      sessionId: i,
      tenantId: s || void 0,
      postBody: r || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState,
    }
    try {
      this.resolve(await this.getIdpTask(a)(l))
    } catch (u) {
      this.reject(u)
    }
  }
  onError(t) {
    this.reject(t)
  }
  getIdpTask(t) {
    switch (t) {
      case 'signInViaPopup':
      case 'signInViaRedirect':
        return W$
      case 'linkViaPopup':
      case 'linkViaRedirect':
        return G$
      case 'reauthViaPopup':
      case 'reauthViaRedirect':
        return q$
      default:
        Wi(this.auth, 'internal-error')
    }
  }
  resolve(t) {
    Mr(this.pendingPromise, 'Pending promise was never set'),
      this.pendingPromise.resolve(t),
      this.unregisterAndCleanUp()
  }
  reject(t) {
    Mr(this.pendingPromise, 'Pending promise was never set'), this.pendingPromise.reject(t), this.unregisterAndCleanUp()
  }
  unregisterAndCleanUp() {
    this.eventManager && this.eventManager.unregisterConsumer(this), (this.pendingPromise = null), this.cleanUp()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const K$ = new Hc(2e3, 1e4)
class Ha extends Qk {
  constructor(t, n, i, r, s) {
    super(t, n, r, s),
      (this.provider = i),
      (this.authWindow = null),
      (this.pollId = null),
      Ha.currentPopupAction && Ha.currentPopupAction.cancel(),
      (Ha.currentPopupAction = this)
  }
  async executeNotNull() {
    const t = await this.execute()
    return We(t, this.auth, 'internal-error'), t
  }
  async onExecution() {
    Mr(this.filter.length === 1, 'Popup operations only handle one event')
    const t = i_()
    ;(this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], t)),
      (this.authWindow.associatedEvent = t),
      this.resolver._originValidation(this.auth).catch((n) => {
        this.reject(n)
      }),
      this.resolver._isIframeWebStorageSupported(this.auth, (n) => {
        n || this.reject(lr(this.auth, 'web-storage-unsupported'))
      }),
      this.pollUserCancellation()
  }
  get eventId() {
    var t
    return ((t = this.authWindow) === null || t === void 0 ? void 0 : t.associatedEvent) || null
  }
  cancel() {
    this.reject(lr(this.auth, 'cancelled-popup-request'))
  }
  cleanUp() {
    this.authWindow && this.authWindow.close(),
      this.pollId && window.clearTimeout(this.pollId),
      (this.authWindow = null),
      (this.pollId = null),
      (Ha.currentPopupAction = null)
  }
  pollUserCancellation() {
    const t = () => {
      var n, i
      if (
        !((i = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || i === void 0) &&
        i.closed
      ) {
        this.pollId = window.setTimeout(() => {
          ;(this.pollId = null), this.reject(lr(this.auth, 'popup-closed-by-user'))
        }, 8e3)
        return
      }
      this.pollId = window.setTimeout(t, K$.get())
    }
    t()
  }
}
Ha.currentPopupAction = null
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Y$ = 'pendingRedirect',
  yh = new Map()
class Q$ extends Qk {
  constructor(t, n, i = !1) {
    super(t, ['signInViaRedirect', 'linkViaRedirect', 'reauthViaRedirect', 'unknown'], n, void 0, i),
      (this.eventId = null)
  }
  async execute() {
    let t = yh.get(this.auth._key())
    if (!t) {
      try {
        const i = (await X$(this.resolver, this.auth)) ? await super.execute() : null
        t = () => Promise.resolve(i)
      } catch (n) {
        t = () => Promise.reject(n)
      }
      yh.set(this.auth._key(), t)
    }
    return this.bypassAuthState || yh.set(this.auth._key(), () => Promise.resolve(null)), t()
  }
  async onAuthEvent(t) {
    if (t.type === 'signInViaRedirect') return super.onAuthEvent(t)
    if (t.type === 'unknown') {
      this.resolve(null)
      return
    }
    if (t.eventId) {
      const n = await this.auth._redirectUserForId(t.eventId)
      if (n) return (this.user = n), super.onAuthEvent(t)
      this.resolve(null)
    }
  }
  async onExecution() {}
  cleanUp() {}
}
async function X$(e, t) {
  const n = eU(t),
    i = Z$(e)
  if (!(await i._isAvailable())) return !1
  const r = (await i._get(n)) === 'true'
  return await i._remove(n), r
}
function J$(e, t) {
  yh.set(e._key(), t)
}
function Z$(e) {
  return Pr(e._redirectPersistence)
}
function eU(e) {
  return ph(Y$, e.config.apiKey, e.name)
}
async function tU(e, t, n = !1) {
  if (Cr(e.app)) return Promise.reject(As(e))
  const i = ia(e),
    r = H$(i, t),
    o = await new Q$(i, r, n).execute()
  return (
    o &&
      !n &&
      (delete o.user._redirectEventId, await i._persistUserIfCurrent(o.user), await i._setRedirectUser(null, t)),
    o
  )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const nU = 10 * 60 * 1e3
class iU {
  constructor(t) {
    ;(this.auth = t),
      (this.cachedEventUids = new Set()),
      (this.consumers = new Set()),
      (this.queuedRedirectEvent = null),
      (this.hasHandledPotentialRedirect = !1),
      (this.lastProcessedEventTime = Date.now())
  }
  registerConsumer(t) {
    this.consumers.add(t),
      this.queuedRedirectEvent &&
        this.isEventForConsumer(this.queuedRedirectEvent, t) &&
        (this.sendToConsumer(this.queuedRedirectEvent, t),
        this.saveEventToCache(this.queuedRedirectEvent),
        (this.queuedRedirectEvent = null))
  }
  unregisterConsumer(t) {
    this.consumers.delete(t)
  }
  onEvent(t) {
    if (this.hasEventBeenHandled(t)) return !1
    let n = !1
    return (
      this.consumers.forEach((i) => {
        this.isEventForConsumer(t, i) && ((n = !0), this.sendToConsumer(t, i), this.saveEventToCache(t))
      }),
      this.hasHandledPotentialRedirect ||
        !rU(t) ||
        ((this.hasHandledPotentialRedirect = !0), n || ((this.queuedRedirectEvent = t), (n = !0))),
      n
    )
  }
  sendToConsumer(t, n) {
    var i
    if (t.error && !Xk(t)) {
      const r = ((i = t.error.code) === null || i === void 0 ? void 0 : i.split('auth/')[1]) || 'internal-error'
      n.onError(lr(this.auth, r))
    } else n.onAuthEvent(t)
  }
  isEventForConsumer(t, n) {
    const i = n.eventId === null || (!!t.eventId && t.eventId === n.eventId)
    return n.filter.includes(t.type) && i
  }
  hasEventBeenHandled(t) {
    return (
      Date.now() - this.lastProcessedEventTime >= nU && this.cachedEventUids.clear(), this.cachedEventUids.has(RS(t))
    )
  }
  saveEventToCache(t) {
    this.cachedEventUids.add(RS(t)), (this.lastProcessedEventTime = Date.now())
  }
}
function RS(e) {
  return [e.type, e.eventId, e.sessionId, e.tenantId].filter((t) => t).join('-')
}
function Xk({ type: e, error: t }) {
  return e === 'unknown' && (t == null ? void 0 : t.code) === 'auth/no-auth-event'
}
function rU(e) {
  switch (e.type) {
    case 'signInViaRedirect':
    case 'linkViaRedirect':
    case 'reauthViaRedirect':
      return !0
    case 'unknown':
      return Xk(e)
    default:
      return !1
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function sU(e, t = {}) {
  return qr(e, 'GET', '/v1/projects', t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const oU = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
  aU = /^https?/
async function lU(e) {
  if (e.config.emulator) return
  const { authorizedDomains: t } = await sU(e)
  for (const n of t)
    try {
      if (uU(n)) return
    } catch {}
  Wi(e, 'unauthorized-domain')
}
function uU(e) {
  const t = Uv(),
    { protocol: n, hostname: i } = new URL(t)
  if (e.startsWith('chrome-extension://')) {
    const o = new URL(e)
    return o.hostname === '' && i === ''
      ? n === 'chrome-extension:' && e.replace('chrome-extension://', '') === t.replace('chrome-extension://', '')
      : n === 'chrome-extension:' && o.hostname === i
  }
  if (!aU.test(n)) return !1
  if (oU.test(e)) return i === e
  const r = e.replace(/\./g, '\\.')
  return new RegExp('^(.+\\.' + r + '|' + r + ')$', 'i').test(i)
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const cU = new Hc(3e4, 6e4)
function xS() {
  const e = ur().___jsl
  if (e != null && e.H) {
    for (const t of Object.keys(e.H))
      if (((e.H[t].r = e.H[t].r || []), (e.H[t].L = e.H[t].L || []), (e.H[t].r = [...e.H[t].L]), e.CP))
        for (let n = 0; n < e.CP.length; n++) e.CP[n] = null
  }
}
function dU(e) {
  return new Promise((t, n) => {
    var i, r, s
    function o() {
      xS(),
        gapi.load('gapi.iframes', {
          callback: () => {
            t(gapi.iframes.getContext())
          },
          ontimeout: () => {
            xS(), n(lr(e, 'network-request-failed'))
          },
          timeout: cU.get(),
        })
    }
    if (!((r = (i = ur().gapi) === null || i === void 0 ? void 0 : i.iframes) === null || r === void 0) && r.Iframe)
      t(gapi.iframes.getContext())
    else if (!((s = ur().gapi) === null || s === void 0) && s.load) o()
    else {
      const a = l$('iframefcb')
      return (
        (ur()[a] = () => {
          gapi.load ? o() : n(lr(e, 'network-request-failed'))
        }),
        Nk(`${a$()}?onload=${a}`).catch((l) => n(l))
      )
    }
  }).catch((t) => {
    throw ((_h = null), t)
  })
}
let _h = null
function hU(e) {
  return (_h = _h || dU(e)), _h
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const fU = new Hc(5e3, 15e3),
  mU = '__/auth/iframe',
  gU = 'emulator/auth/iframe',
  vU = {
    style: { position: 'absolute', top: '-100px', width: '1px', height: '1px' },
    'aria-hidden': 'true',
    tabindex: '-1',
  },
  pU = new Map([
    ['identitytoolkit.googleapis.com', 'p'],
    ['staging-identitytoolkit.sandbox.googleapis.com', 's'],
    ['test-identitytoolkit.sandbox.googleapis.com', 't'],
  ])
function yU(e) {
  const t = e.config
  We(t.authDomain, e, 'auth-domain-config-required')
  const n = t.emulator ? Xy(t, gU) : `https://${e.config.authDomain}/${mU}`,
    i = { apiKey: t.apiKey, appName: e.name, v: zs },
    r = pU.get(e.config.apiHost)
  r && (i.eid = r)
  const s = e._getFrameworks()
  return s.length && (i.fw = s.join(',')), `${n}?${Ll(i).slice(1)}`
}
async function _U(e) {
  const t = await hU(e),
    n = ur().gapi
  return (
    We(n, e, 'internal-error'),
    t.open(
      {
        where: document.body,
        url: yU(e),
        messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: vU,
        dontclear: !0,
      },
      (i) =>
        new Promise(async (r, s) => {
          await i.restyle({ setHideOnLeave: !1 })
          const o = lr(e, 'network-request-failed'),
            a = ur().setTimeout(() => {
              s(o)
            }, fU.get())
          function l() {
            ur().clearTimeout(a), r(i)
          }
          i.ping(l).then(l, () => {
            s(o)
          })
        })
    )
  )
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const bU = { location: 'yes', resizable: 'yes', statusbar: 'yes', toolbar: 'no' },
  wU = 500,
  IU = 600,
  SU = '_blank',
  EU = 'http://localhost'
class VS {
  constructor(t) {
    ;(this.window = t), (this.associatedEvent = null)
  }
  close() {
    if (this.window)
      try {
        this.window.close()
      } catch {}
  }
}
function TU(e, t, n, i = wU, r = IU) {
  const s = Math.max((window.screen.availHeight - r) / 2, 0).toString(),
    o = Math.max((window.screen.availWidth - i) / 2, 0).toString()
  let a = ''
  const l = Object.assign(Object.assign({}, bU), { width: i.toString(), height: r.toString(), top: s, left: o }),
    u = Zt().toLowerCase()
  n && (a = Ak(u) ? SU : n), Ck(u) && ((t = t || EU), (l.scrollbars = 'yes'))
  const c = Object.entries(l).reduce((f, [m, p]) => `${f}${m}=${p},`, '')
  if (X2(u) && a !== '_self') return CU(t || '', a), new VS(null)
  const d = window.open(t || '', a, c)
  We(d, e, 'popup-blocked')
  try {
    d.focus()
  } catch {}
  return new VS(d)
}
function CU(e, t) {
  const n = document.createElement('a')
  ;(n.href = e), (n.target = t)
  const i = document.createEvent('MouseEvent')
  i.initMouseEvent('click', !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(i)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const AU = '__/auth/handler',
  kU = 'emulator/auth/handler',
  PU = encodeURIComponent('fac')
async function DS(e, t, n, i, r, s) {
  We(e.config.authDomain, e, 'auth-domain-config-required'), We(e.config.apiKey, e, 'invalid-api-key')
  const o = { apiKey: e.config.apiKey, appName: e.name, authType: n, redirectUrl: i, v: zs, eventId: r }
  if (t instanceof Lk) {
    t.setDefaultLanguage(e.languageCode),
      (o.providerId = t.providerId || ''),
      Ov(t.getCustomParameters()) || (o.customParameters = JSON.stringify(t.getCustomParameters()))
    for (const [c, d] of Object.entries({})) o[c] = d
  }
  if (t instanceof Wc) {
    const c = t.getScopes().filter((d) => d !== '')
    c.length > 0 && (o.scopes = c.join(','))
  }
  e.tenantId && (o.tid = e.tenantId)
  const a = o
  for (const c of Object.keys(a)) a[c] === void 0 && delete a[c]
  const l = await e._getAppCheckToken(),
    u = l ? `#${PU}=${encodeURIComponent(l)}` : ''
  return `${RU(e)}?${Ll(a).slice(1)}${u}`
}
function RU({ config: e }) {
  return e.emulator ? Xy(e, kU) : `https://${e.authDomain}/${AU}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Og = 'webStorageSupport'
class xU {
  constructor() {
    ;(this.eventManagers = {}),
      (this.iframes = {}),
      (this.originValidationPromises = {}),
      (this._redirectPersistence = n_),
      (this._completeRedirectFn = tU),
      (this._overrideRedirectResult = J$)
  }
  async _openPopup(t, n, i, r) {
    var s
    Mr(
      (s = this.eventManagers[t._key()]) === null || s === void 0 ? void 0 : s.manager,
      '_initialize() not called before _openPopup()'
    )
    const o = await DS(t, n, i, Uv(), r)
    return TU(t, o, i_())
  }
  async _openRedirect(t, n, i, r) {
    await this._originValidation(t)
    const s = await DS(t, n, i, Uv(), r)
    return O$(s), new Promise(() => {})
  }
  _initialize(t) {
    const n = t._key()
    if (this.eventManagers[n]) {
      const { manager: r, promise: s } = this.eventManagers[n]
      return r ? Promise.resolve(r) : (Mr(s, 'If manager is not set, promise should be'), s)
    }
    const i = this.initAndGetManager(t)
    return (
      (this.eventManagers[n] = { promise: i }),
      i.catch(() => {
        delete this.eventManagers[n]
      }),
      i
    )
  }
  async initAndGetManager(t) {
    const n = await _U(t),
      i = new iU(t)
    return (
      n.register(
        'authEvent',
        (r) => (
          We(r == null ? void 0 : r.authEvent, t, 'invalid-auth-event'),
          { status: i.onEvent(r.authEvent) ? 'ACK' : 'ERROR' }
        ),
        gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER
      ),
      (this.eventManagers[t._key()] = { manager: i }),
      (this.iframes[t._key()] = n),
      i
    )
  }
  _isIframeWebStorageSupported(t, n) {
    this.iframes[t._key()].send(
      Og,
      { type: Og },
      (r) => {
        var s
        const o = (s = r == null ? void 0 : r[0]) === null || s === void 0 ? void 0 : s[Og]
        o !== void 0 && n(!!o), Wi(t, 'internal-error')
      },
      gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER
    )
  }
  _originValidation(t) {
    const n = t._key()
    return (
      this.originValidationPromises[n] || (this.originValidationPromises[n] = lU(t)), this.originValidationPromises[n]
    )
  }
  get _shouldInitProactively() {
    return Vk() || Zy() || Gf()
  }
}
const Jk = xU
var NS = '@firebase/auth',
  OS = '1.7.5'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class VU {
  constructor(t) {
    ;(this.auth = t), (this.internalListeners = new Map())
  }
  getUid() {
    var t
    return this.assertAuthConfigured(), ((t = this.auth.currentUser) === null || t === void 0 ? void 0 : t.uid) || null
  }
  async getToken(t) {
    return (
      this.assertAuthConfigured(),
      await this.auth._initializationPromise,
      this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(t) } : null
    )
  }
  addAuthTokenListener(t) {
    if ((this.assertAuthConfigured(), this.internalListeners.has(t))) return
    const n = this.auth.onIdTokenChanged((i) => {
      t((i == null ? void 0 : i.stsTokenManager.accessToken) || null)
    })
    this.internalListeners.set(t, n), this.updateProactiveRefresh()
  }
  removeAuthTokenListener(t) {
    this.assertAuthConfigured()
    const n = this.internalListeners.get(t)
    n && (this.internalListeners.delete(t), n(), this.updateProactiveRefresh())
  }
  assertAuthConfigured() {
    We(this.auth._initializationPromise, 'dependent-sdk-initialized-before-auth')
  }
  updateProactiveRefresh() {
    this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function DU(e) {
  switch (e) {
    case 'Node':
      return 'node'
    case 'ReactNative':
      return 'rn'
    case 'Worker':
      return 'webworker'
    case 'Cordova':
      return 'cordova'
    case 'WebExtension':
      return 'web-extension'
    default:
      return
  }
}
function NU(e) {
  Xn(
    new $n(
      'auth',
      (t, { options: n }) => {
        const i = t.getProvider('app').getImmediate(),
          r = t.getProvider('heartbeat'),
          s = t.getProvider('app-check-internal'),
          { apiKey: o, authDomain: a } = i.options
        We(o && !o.includes(':'), 'invalid-api-key', { appName: i.name })
        const l = {
            apiKey: o,
            authDomain: a,
            clientPlatform: e,
            apiHost: 'identitytoolkit.googleapis.com',
            tokenApiHost: 'securetoken.googleapis.com',
            apiScheme: 'https',
            sdkClientVersion: Dk(e),
          },
          u = new r$(i, r, s, l)
        return h$(u, n), u
      },
      'PUBLIC'
    )
      .setInstantiationMode('EXPLICIT')
      .setInstanceCreatedCallback((t, n, i) => {
        t.getProvider('auth-internal').initialize()
      })
  ),
    Xn(
      new $n(
        'auth-internal',
        (t) => {
          const n = ia(t.getProvider('auth').getImmediate())
          return ((i) => new VU(i))(n)
        },
        'PRIVATE'
      ).setInstantiationMode('EXPLICIT')
    ),
    nn(NS, OS, DU(e)),
    nn(NS, OS, 'esm2017')
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const OU = 5 * 60,
  MU = rk('authIdTokenMaxAge') || OU
let MS = null
const LU = (e) => async (t) => {
  const n = t && (await t.getIdTokenResult()),
    i = n && (new Date().getTime() - Date.parse(n.issuedAtTime)) / 1e3
  if (i && i > MU) return
  const r = n == null ? void 0 : n.token
  MS !== r &&
    ((MS = r), await fetch(e, { method: r ? 'POST' : 'DELETE', headers: r ? { Authorization: `Bearer ${r}` } : {} }))
}
function FU(e = zc()) {
  const t = Wr(e, 'auth')
  if (t.isInitialized()) return t.getImmediate()
  const n = Ok(e, { popupRedirectResolver: Jk, persistence: [Yk, zk, n_] }),
    i = rk('authTokenSyncURL')
  if (i && typeof isSecureContext == 'boolean' && isSecureContext) {
    const s = new URL(i, location.origin)
    if (location.origin === s.origin) {
      const o = LU(s.toString())
      P$(n, o, () => o(n.currentUser)), $k(n, (a) => o(a))
    }
  }
  const r = nk('auth')
  return r && f$(n, `http://${r}`), n
}
function BU() {
  var e, t
  return (t = (e = document.getElementsByTagName('head')) === null || e === void 0 ? void 0 : e[0]) !== null &&
    t !== void 0
    ? t
    : document
}
s$({
  loadJS(e) {
    return new Promise((t, n) => {
      const i = document.createElement('script')
      i.setAttribute('src', e),
        (i.onload = t),
        (i.onerror = (r) => {
          const s = lr('internal-error')
          ;(s.customData = r), n(s)
        }),
        (i.type = 'text/javascript'),
        (i.charset = 'UTF-8'),
        BU().appendChild(i)
    })
  },
  gapiScript: 'https://apis.google.com/js/api.js',
  recaptchaV2Script: 'https://www.google.com/recaptcha/api.js',
  recaptchaEnterpriseScript: 'https://www.google.com/recaptcha/enterprise.js?render=',
})
NU('Browser')
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */ const $U = {}
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */ function zd(e) {
  return Object.isFrozen(e) && Object.isFrozen(e.raw)
}
function Hd(e) {
  return e.toString().indexOf('`') === -1
}
Hd((e) => e``) || Hd((e) => e`\0`) || Hd((e) => e`\n`) || Hd((e) => e`\u0000`)
zd`` && zd`\0` && zd`\n` && zd`\u0000`
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */ let Zk = 'google#safe'
function UU() {
  if (typeof window < 'u') return window.trustedTypes
}
function eP() {
  var e
  return Zk !== '' && (e = UU()) !== null && e !== void 0 ? e : null
}
let Wd
function jU() {
  var e, t
  if (Wd === void 0)
    try {
      Wd =
        (t =
          (e = eP()) === null || e === void 0
            ? void 0
            : e.createPolicy(Zk, { createHTML: (n) => n, createScript: (n) => n, createScriptURL: (n) => n })) !==
          null && t !== void 0
          ? t
          : null
    } catch {
      Wd = null
    }
  return Wd
}
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */ class tP {
  constructor(t, n) {
    this.privateDoNotAccessOrElseWrappedResourceUrl = t
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedResourceUrl.toString()
  }
}
function LS(e) {
  var t
  const n = e,
    i = (t = jU()) === null || t === void 0 ? void 0 : t.createScriptURL(n)
  return i ?? new tP(n, $U)
}
function zU(e) {
  var t
  if (!((t = eP()) === null || t === void 0) && t.isScriptURL(e)) return e
  if (e instanceof tP) return e.privateDoNotAccessOrElseWrappedResourceUrl
  {
    let n = ''
    throw new Error(n)
  }
}
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */ function HU(e, ...t) {
  if (t.length === 0) return LS(e[0])
  e[0].toLowerCase()
  let n = e[0]
  for (let i = 0; i < t.length; i++) n += encodeURIComponent(t[i]) + e[i + 1]
  return LS(n)
}
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */ function WU(e) {
  return qU('script', e)
}
function qU(e, t) {
  var n
  const i = t.document,
    r = (n = i.querySelector) === null || n === void 0 ? void 0 : n.call(i, `${e}[nonce]`)
  return (r && (r.nonce || r.getAttribute('nonce'))) || ''
}
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */ function GU(e) {
  const t = e.ownerDocument && e.ownerDocument.defaultView,
    n = WU(t || window)
  n && e.setAttribute('nonce', n)
}
function KU(e, t, n) {
  ;(e.src = zU(t)), GU(e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const YU = new Map(),
  QU = { activated: !1, tokenObservers: [] }
function qi(e) {
  return YU.get(e) || Object.assign({}, QU)
}
const FS = { OFFSET_DURATION: 5 * 60 * 1e3, RETRIAL_MIN_WAIT: 30 * 1e3, RETRIAL_MAX_WAIT: 16 * 60 * 1e3 }
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class XU {
  constructor(t, n, i, r, s) {
    if (
      ((this.operation = t),
      (this.retryPolicy = n),
      (this.getWaitDuration = i),
      (this.lowerBound = r),
      (this.upperBound = s),
      (this.pending = null),
      (this.nextErrorWaitInterval = r),
      r > s)
    )
      throw new Error('Proactive refresh lower bound greater than upper bound!')
  }
  start() {
    ;(this.nextErrorWaitInterval = this.lowerBound), this.process(!0).catch(() => {})
  }
  stop() {
    this.pending && (this.pending.reject('cancelled'), (this.pending = null))
  }
  isRunning() {
    return !!this.pending
  }
  async process(t) {
    this.stop()
    try {
      ;(this.pending = new ac()),
        this.pending.promise.catch((n) => {}),
        await JU(this.getNextRun(t)),
        this.pending.resolve(),
        await this.pending.promise,
        (this.pending = new ac()),
        this.pending.promise.catch((n) => {}),
        await this.operation(),
        this.pending.resolve(),
        await this.pending.promise,
        this.process(!0).catch(() => {})
    } catch (n) {
      this.retryPolicy(n) ? this.process(!1).catch(() => {}) : this.stop()
    }
  }
  getNextRun(t) {
    if (t) return (this.nextErrorWaitInterval = this.lowerBound), this.getWaitDuration()
    {
      const n = this.nextErrorWaitInterval
      return (
        (this.nextErrorWaitInterval *= 2),
        this.nextErrorWaitInterval > this.upperBound && (this.nextErrorWaitInterval = this.upperBound),
        n
      )
    }
  }
}
function JU(e) {
  return new Promise((t) => {
    setTimeout(t, e)
  })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ZU = {
    'already-initialized':
      'You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.',
    'use-before-activation':
      'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.',
    'fetch-network-error':
      'Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.',
    'fetch-parse-error': 'Fetch client could not parse response. Original error: {$originalErrorMessage}.',
    'fetch-status-error': 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',
    'storage-open': 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',
    'storage-get': 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',
    'storage-set': 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',
    'recaptcha-error': 'ReCAPTCHA error.',
    throttled: 'Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}',
  },
  Kh = new zr('appCheck', 'AppCheck', ZU)
function nP(e) {
  if (!qi(e).activated) throw Kh.create('use-before-activation', { appName: e.name })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const e4 = 'firebase-app-check-database',
  t4 = 1,
  Wv = 'firebase-app-check-store'
let qd = null
function n4() {
  return (
    qd ||
    ((qd = new Promise((e, t) => {
      try {
        const n = indexedDB.open(e4, t4)
        ;(n.onsuccess = (i) => {
          e(i.target.result)
        }),
          (n.onerror = (i) => {
            var r
            t(
              Kh.create('storage-open', {
                originalErrorMessage: (r = i.target.error) === null || r === void 0 ? void 0 : r.message,
              })
            )
          }),
          (n.onupgradeneeded = (i) => {
            const r = i.target.result
            switch (i.oldVersion) {
              case 0:
                r.createObjectStore(Wv, { keyPath: 'compositeKey' })
            }
          })
      } catch (n) {
        t(Kh.create('storage-open', { originalErrorMessage: n == null ? void 0 : n.message }))
      }
    })),
    qd)
  )
}
function i4(e, t) {
  return r4(s4(e), t)
}
async function r4(e, t) {
  const i = (await n4()).transaction(Wv, 'readwrite'),
    s = i.objectStore(Wv).put({ compositeKey: e, value: t })
  return new Promise((o, a) => {
    ;(s.onsuccess = (l) => {
      o()
    }),
      (i.onerror = (l) => {
        var u
        a(
          Kh.create('storage-set', {
            originalErrorMessage: (u = l.target.error) === null || u === void 0 ? void 0 : u.message,
          })
        )
      })
  })
}
function s4(e) {
  return `${e.options.appId}-${e.name}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const qv = new na('@firebase/app-check')
function BS(e, t) {
  return jc()
    ? i4(e, t).catch((n) => {
        qv.warn(`Failed to write token to IndexedDB. Error: ${n}`)
      })
    : Promise.resolve()
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const o4 = { error: 'UNKNOWN_ERROR' }
function a4(e) {
  return zf.encodeString(JSON.stringify(e), !1)
}
async function Gv(e, t = !1) {
  const n = e.app
  nP(n)
  const i = qi(n)
  let r = i.token,
    s
  if ((r && !ku(r) && ((i.token = void 0), (r = void 0)), !r)) {
    const l = await i.cachedTokenPromise
    l && (ku(l) ? (r = l) : await BS(n, void 0))
  }
  if (!t && r && ku(r)) return { token: r.token }
  let o = !1
  try {
    i.exchangeTokenPromise ||
      ((i.exchangeTokenPromise = i.provider.getToken().finally(() => {
        i.exchangeTokenPromise = void 0
      })),
      (o = !0)),
      (r = await qi(n).exchangeTokenPromise)
  } catch (l) {
    l.code === 'appCheck/throttled' ? qv.warn(l.message) : qv.error(l), (s = l)
  }
  let a
  return (
    r
      ? s
        ? ku(r)
          ? (a = { token: r.token, internalError: s })
          : (a = US(s))
        : ((a = { token: r.token }), (i.token = r), await BS(n, r))
      : (a = US(s)),
    o && d4(n, a),
    a
  )
}
async function l4(e) {
  const t = e.app
  nP(t)
  const { provider: n } = qi(t)
  {
    const { token: i } = await n.getToken()
    return { token: i }
  }
}
function u4(e, t, n, i) {
  const { app: r } = e,
    s = qi(r),
    o = { next: n, error: i, type: t }
  if (((s.tokenObservers = [...s.tokenObservers, o]), s.token && ku(s.token))) {
    const a = s.token
    Promise.resolve()
      .then(() => {
        n({ token: a.token }), $S(e)
      })
      .catch(() => {})
  }
  s.cachedTokenPromise.then(() => $S(e))
}
function iP(e, t) {
  const n = qi(e),
    i = n.tokenObservers.filter((r) => r.next !== t)
  i.length === 0 && n.tokenRefresher && n.tokenRefresher.isRunning() && n.tokenRefresher.stop(), (n.tokenObservers = i)
}
function $S(e) {
  const { app: t } = e,
    n = qi(t)
  let i = n.tokenRefresher
  i || ((i = c4(e)), (n.tokenRefresher = i)), !i.isRunning() && n.isTokenAutoRefreshEnabled && i.start()
}
function c4(e) {
  const { app: t } = e
  return new XU(
    async () => {
      const n = qi(t)
      let i
      if ((n.token ? (i = await Gv(e, !0)) : (i = await Gv(e)), i.error)) throw i.error
      if (i.internalError) throw i.internalError
    },
    () => !0,
    () => {
      const n = qi(t)
      if (n.token) {
        let i = n.token.issuedAtTimeMillis + (n.token.expireTimeMillis - n.token.issuedAtTimeMillis) * 0.5 + 3e5
        const r = n.token.expireTimeMillis - 5 * 60 * 1e3
        return (i = Math.min(i, r)), Math.max(0, i - Date.now())
      } else return 0
    },
    FS.RETRIAL_MIN_WAIT,
    FS.RETRIAL_MAX_WAIT
  )
}
function d4(e, t) {
  const n = qi(e).tokenObservers
  for (const i of n)
    try {
      i.type === 'EXTERNAL' && t.error != null ? i.error(t.error) : i.next(t)
    } catch {}
}
function ku(e) {
  return e.expireTimeMillis - Date.now() > 0
}
function US(e) {
  return { token: a4(o4), error: e }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class h4 {
  constructor(t, n) {
    ;(this.app = t), (this.heartbeatServiceProvider = n)
  }
  _delete() {
    const { tokenObservers: t } = qi(this.app)
    for (const n of t) iP(this.app, n.next)
    return Promise.resolve()
  }
}
function f4(e, t) {
  return new h4(e, t)
}
function m4(e) {
  return {
    getToken: (t) => Gv(e, t),
    getLimitedUseToken: () => l4(e),
    addTokenListener: (t) => u4(e, 'INTERNAL', t),
    removeTokenListener: (t) => iP(e.app, t),
  }
}
const g4 = '@firebase/app-check',
  v4 = '0.8.6',
  p4 = 'app-check',
  jS = 'app-check-internal'
function y4() {
  Xn(
    new $n(
      p4,
      (e) => {
        const t = e.getProvider('app').getImmediate(),
          n = e.getProvider('heartbeat')
        return f4(t, n)
      },
      'PUBLIC'
    )
      .setInstantiationMode('EXPLICIT')
      .setInstanceCreatedCallback((e, t, n) => {
        e.getProvider(jS).initialize()
      })
  ),
    Xn(
      new $n(
        jS,
        (e) => {
          const t = e.getProvider('app-check').getImmediate()
          return m4(t)
        },
        'PUBLIC'
      ).setInstantiationMode('EXPLICIT')
    ),
    nn(g4, v4)
}
y4()
var _4 = 'firebase',
  b4 = '10.12.4'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ nn(_4, b4, 'app')
const rP = Symbol('firebaseApp')
function s_(e) {
  return ($c() && je(rP, null)) || zc(e)
}
const tr = () => {}
function o_(e, t) {
  return t.split('.').reduce((n, i) => n && n[i], e)
}
function w4(e, t, n) {
  const i = ('' + t).split('.'),
    r = i.pop(),
    s = i.reduce((o, a) => o && o[a], e)
  if (s != null) return Array.isArray(s) ? s.splice(Number(r), 1, n) : (s[r] = n)
}
function ra(e) {
  return !!e && typeof e == 'object'
}
const I4 = Object.prototype
function S4(e) {
  return ra(e) && Object.getPrototypeOf(e) === I4
}
function a_(e) {
  return ra(e) && e.type === 'document'
}
function E4(e) {
  return ra(e) && e.type === 'collection'
}
function T4(e) {
  return a_(e) || E4(e)
}
function C4(e) {
  return ra(e) && e.type === 'query'
}
function A4(e) {
  return ra(e) && 'ref' in e
}
function k4(e) {
  return ra(e) && typeof e.bucket == 'string'
}
function P4(e, t) {
  let n
  return () => {
    if (!n) return (n = !0), e(t())
  }
}
const R4 = Symbol.for('v-scx')
function x4() {
  return !!je(R4, 0)
}
const Gd = new WeakMap()
function V4(e, t) {
  if (!Gd.has(e)) {
    const n = Nl(!0)
    Gd.set(e, n)
    const { unmount: i } = t
    t.unmount = () => {
      i.call(t), n.stop(), Gd.delete(e)
    }
  }
  return Gd.get(e)
}
const D4 = new WeakMap(),
  Kd = new WeakMap()
function N4(e) {
  const t = s_(e)
  if (!Kd.has(t)) {
    let n
    const r = [
      new Promise((s) => {
        n = s
      }),
      (s) => {
        Kd.set(t, s), n(s.value)
      },
    ]
    Kd.set(t, r)
  }
  return Kd.get(t)
}
function O4(e, t) {
  $k(t, (n) => {
    const i = N4()
    ;(e.value = n), Array.isArray(i) && i[1](e)
  })
}
var zS = {}
const HS = '@firebase/database',
  WS = '1.0.6'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let sP = ''
function M4(e) {
  sP = e
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class L4 {
  constructor(t) {
    ;(this.domStorage_ = t), (this.prefix_ = 'firebase:')
  }
  set(t, n) {
    n == null
      ? this.domStorage_.removeItem(this.prefixedName_(t))
      : this.domStorage_.setItem(this.prefixedName_(t), Sn(n))
  }
  get(t) {
    const n = this.domStorage_.getItem(this.prefixedName_(t))
    return n == null ? null : lc(n)
  }
  remove(t) {
    this.domStorage_.removeItem(this.prefixedName_(t))
  }
  prefixedName_(t) {
    return this.prefix_ + t
  }
  toString() {
    return this.domStorage_.toString()
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class F4 {
  constructor() {
    ;(this.cache_ = {}), (this.isInMemoryStorage = !0)
  }
  set(t, n) {
    n == null ? delete this.cache_[t] : (this.cache_[t] = n)
  }
  get(t) {
    return Hr(this.cache_, t) ? this.cache_[t] : null
  }
  remove(t) {
    delete this.cache_[t]
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const oP = function (e) {
    try {
      if (typeof window < 'u' && typeof window[e] < 'u') {
        const t = window[e]
        return t.setItem('firebase:sentinel', 'cache'), t.removeItem('firebase:sentinel'), new L4(t)
      }
    } catch {}
    return new F4()
  },
  vo = oP('localStorage'),
  B4 = oP('sessionStorage')
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const il = new na('@firebase/database'),
  $4 = (function () {
    let e = 1
    return function () {
      return e++
    }
  })(),
  aP = function (e) {
    const t = IB(e),
      n = new pB()
    n.update(t)
    const i = n.digest()
    return zf.encodeByteArray(i)
  },
  Gc = function (...e) {
    let t = ''
    for (let n = 0; n < e.length; n++) {
      const i = e[n]
      Array.isArray(i) || (i && typeof i == 'object' && typeof i.length == 'number')
        ? (t += Gc.apply(null, i))
        : typeof i == 'object'
        ? (t += Sn(i))
        : (t += i),
        (t += ' ')
    }
    return t
  }
let zu = null,
  qS = !0
const U4 = function (e, t) {
    Pe(!t, "Can't turn on custom loggers persistently."), (il.logLevel = Je.VERBOSE), (zu = il.log.bind(il))
  },
  Dn = function (...e) {
    if ((qS === !0 && ((qS = !1), zu === null && B4.get('logging_enabled') === !0 && U4()), zu)) {
      const t = Gc.apply(null, e)
      zu(t)
    }
  },
  Kc = function (e) {
    return function (...t) {
      Dn(e, ...t)
    }
  },
  Kv = function (...e) {
    const t = 'FIREBASE INTERNAL ERROR: ' + Gc(...e)
    il.error(t)
  },
  Do = function (...e) {
    const t = `FIREBASE FATAL ERROR: ${Gc(...e)}`
    throw (il.error(t), new Error(t))
  },
  fi = function (...e) {
    const t = 'FIREBASE WARNING: ' + Gc(...e)
    il.warn(t)
  },
  j4 = function () {
    typeof window < 'u' &&
      window.location &&
      window.location.protocol &&
      window.location.protocol.indexOf('https:') !== -1 &&
      fi('Insecure Firebase access from a secure page. Please use https in calls to new Firebase().')
  },
  lP = function (e) {
    return typeof e == 'number' && (e !== e || e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY)
  },
  z4 = function (e) {
    if (document.readyState === 'complete') e()
    else {
      let t = !1
      const n = function () {
        if (!document.body) {
          setTimeout(n, Math.floor(10))
          return
        }
        t || ((t = !0), e())
      }
      document.addEventListener
        ? (document.addEventListener('DOMContentLoaded', n, !1), window.addEventListener('load', n, !1))
        : document.attachEvent &&
          (document.attachEvent('onreadystatechange', () => {
            document.readyState === 'complete' && n()
          }),
          window.attachEvent('onload', n))
    }
  },
  gl = '[MIN_NAME]',
  No = '[MAX_NAME]',
  Bl = function (e, t) {
    if (e === t) return 0
    if (e === gl || t === No) return -1
    if (t === gl || e === No) return 1
    {
      const n = GS(e),
        i = GS(t)
      return n !== null
        ? i !== null
          ? n - i === 0
            ? e.length - t.length
            : n - i
          : -1
        : i !== null
        ? 1
        : e < t
        ? -1
        : 1
    }
  },
  H4 = function (e, t) {
    return e === t ? 0 : e < t ? -1 : 1
  },
  fu = function (e, t) {
    if (t && e in t) return t[e]
    throw new Error('Missing required key (' + e + ') in object: ' + Sn(t))
  },
  l_ = function (e) {
    if (typeof e != 'object' || e === null) return Sn(e)
    const t = []
    for (const i in e) t.push(i)
    t.sort()
    let n = '{'
    for (let i = 0; i < t.length; i++) i !== 0 && (n += ','), (n += Sn(t[i])), (n += ':'), (n += l_(e[t[i]]))
    return (n += '}'), n
  },
  uP = function (e, t) {
    const n = e.length
    if (n <= t) return [e]
    const i = []
    for (let r = 0; r < n; r += t) r + t > n ? i.push(e.substring(r, n)) : i.push(e.substring(r, r + t))
    return i
  }
function xi(e, t) {
  for (const n in e) e.hasOwnProperty(n) && t(n, e[n])
}
const cP = function (e) {
    Pe(!lP(e), 'Invalid JSON number')
    const t = 11,
      n = 52,
      i = (1 << (t - 1)) - 1
    let r, s, o, a, l
    e === 0
      ? ((s = 0), (o = 0), (r = 1 / e === -1 / 0 ? 1 : 0))
      : ((r = e < 0),
        (e = Math.abs(e)),
        e >= Math.pow(2, 1 - i)
          ? ((a = Math.min(Math.floor(Math.log(e) / Math.LN2), i)),
            (s = a + i),
            (o = Math.round(e * Math.pow(2, n - a) - Math.pow(2, n))))
          : ((s = 0), (o = Math.round(e / Math.pow(2, 1 - i - n)))))
    const u = []
    for (l = n; l; l -= 1) u.push(o % 2 ? 1 : 0), (o = Math.floor(o / 2))
    for (l = t; l; l -= 1) u.push(s % 2 ? 1 : 0), (s = Math.floor(s / 2))
    u.push(r ? 1 : 0), u.reverse()
    const c = u.join('')
    let d = ''
    for (l = 0; l < 64; l += 8) {
      let f = parseInt(c.substr(l, 8), 2).toString(16)
      f.length === 1 && (f = '0' + f), (d = d + f)
    }
    return d.toLowerCase()
  },
  W4 = function () {
    return !!(
      typeof window == 'object' &&
      window.chrome &&
      window.chrome.extension &&
      !/^chrome/.test(window.location.href)
    )
  },
  q4 = function () {
    return typeof Windows == 'object' && typeof Windows.UI == 'object'
  },
  G4 = new RegExp('^-?(0*)\\d{1,10}$'),
  K4 = -2147483648,
  Y4 = 2147483647,
  GS = function (e) {
    if (G4.test(e)) {
      const t = Number(e)
      if (t >= K4 && t <= Y4) return t
    }
    return null
  },
  Yc = function (e) {
    try {
      e()
    } catch (t) {
      setTimeout(() => {
        const n = t.stack || ''
        throw (fi('Exception was thrown by user callback.', n), t)
      }, Math.floor(0))
    }
  },
  Q4 = function () {
    return (
      ((typeof window == 'object' && window.navigator && window.navigator.userAgent) || '').search(
        /googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i
      ) >= 0
    )
  },
  Hu = function (e, t) {
    const n = setTimeout(e, t)
    return (
      typeof n == 'number' && typeof Deno < 'u' && Deno.unrefTimer
        ? Deno.unrefTimer(n)
        : typeof n == 'object' && n.unref && n.unref(),
      n
    )
  }
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class X4 {
  constructor(t, n) {
    ;(this.appName_ = t),
      (this.appCheckProvider = n),
      (this.appCheck = n == null ? void 0 : n.getImmediate({ optional: !0 })),
      this.appCheck || n == null || n.get().then((i) => (this.appCheck = i))
  }
  getToken(t) {
    return this.appCheck
      ? this.appCheck.getToken(t)
      : new Promise((n, i) => {
          setTimeout(() => {
            this.appCheck ? this.getToken(t).then(n, i) : n(null)
          }, 0)
        })
  }
  addTokenChangeListener(t) {
    var n
    ;(n = this.appCheckProvider) === null || n === void 0 || n.get().then((i) => i.addTokenListener(t))
  }
  notifyForInvalidToken() {
    fi(
      `Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class J4 {
  constructor(t, n, i) {
    ;(this.appName_ = t),
      (this.firebaseOptions_ = n),
      (this.authProvider_ = i),
      (this.auth_ = null),
      (this.auth_ = i.getImmediate({ optional: !0 })),
      this.auth_ || i.onInit((r) => (this.auth_ = r))
  }
  getToken(t) {
    return this.auth_
      ? this.auth_
          .getToken(t)
          .catch((n) =>
            n && n.code === 'auth/token-not-initialized'
              ? (Dn('Got auth/token-not-initialized error.  Treating as null token.'), null)
              : Promise.reject(n)
          )
      : new Promise((n, i) => {
          setTimeout(() => {
            this.auth_ ? this.getToken(t).then(n, i) : n(null)
          }, 0)
        })
  }
  addTokenChangeListener(t) {
    this.auth_ ? this.auth_.addAuthTokenListener(t) : this.authProvider_.get().then((n) => n.addAuthTokenListener(t))
  }
  removeTokenChangeListener(t) {
    this.authProvider_.get().then((n) => n.removeAuthTokenListener(t))
  }
  notifyForInvalidToken() {
    let t =
      'Provided authentication credentials for the app named "' +
      this.appName_ +
      '" are invalid. This usually indicates your app was not initialized correctly. '
    'credential' in this.firebaseOptions_
      ? (t +=
          'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
      : 'serviceAccount' in this.firebaseOptions_
      ? (t +=
          'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.')
      : (t +=
          'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.'),
      fi(t)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const u_ = '5',
  dP = 'v',
  hP = 's',
  fP = 'r',
  mP = 'f',
  gP = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,
  vP = 'ls',
  pP = 'p',
  Yv = 'ac',
  yP = 'websocket',
  _P = 'long_polling'
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Z4 {
  constructor(t, n, i, r, s = !1, o = '', a = !1, l = !1) {
    ;(this.secure = n),
      (this.namespace = i),
      (this.webSocketOnly = r),
      (this.nodeAdmin = s),
      (this.persistenceKey = o),
      (this.includeNamespaceInQueryParams = a),
      (this.isUsingEmulator = l),
      (this._host = t.toLowerCase()),
      (this._domain = this._host.substr(this._host.indexOf('.') + 1)),
      (this.internalHost = vo.get('host:' + t) || this._host)
  }
  isCacheableHost() {
    return this.internalHost.substr(0, 2) === 's-'
  }
  isCustomHost() {
    return this._domain !== 'firebaseio.com' && this._domain !== 'firebaseio-demo.com'
  }
  get host() {
    return this._host
  }
  set host(t) {
    t !== this.internalHost &&
      ((this.internalHost = t), this.isCacheableHost() && vo.set('host:' + this._host, this.internalHost))
  }
  toString() {
    let t = this.toURLString()
    return this.persistenceKey && (t += '<' + this.persistenceKey + '>'), t
  }
  toURLString() {
    const t = this.secure ? 'https://' : 'http://',
      n = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : ''
    return `${t}${this.host}/${n}`
  }
}
function ej(e) {
  return e.host !== e.internalHost || e.isCustomHost() || e.includeNamespaceInQueryParams
}
function bP(e, t, n) {
  Pe(typeof t == 'string', 'typeof type must == string'), Pe(typeof n == 'object', 'typeof params must == object')
  let i
  if (t === yP) i = (e.secure ? 'wss://' : 'ws://') + e.internalHost + '/.ws?'
  else if (t === _P) i = (e.secure ? 'https://' : 'http://') + e.internalHost + '/.lp?'
  else throw new Error('Unknown connection type: ' + t)
  ej(e) && (n.ns = e.namespace)
  const r = []
  return (
    xi(n, (s, o) => {
      r.push(s + '=' + o)
    }),
    i + r.join('&')
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class tj {
  constructor() {
    this.counters_ = {}
  }
  incrementCounter(t, n = 1) {
    Hr(this.counters_, t) || (this.counters_[t] = 0), (this.counters_[t] += n)
  }
  get() {
    return nB(this.counters_)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Mg = {},
  Lg = {}
function c_(e) {
  const t = e.toString()
  return Mg[t] || (Mg[t] = new tj()), Mg[t]
}
function nj(e, t) {
  const n = e.toString()
  return Lg[n] || (Lg[n] = t()), Lg[n]
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ij {
  constructor(t) {
    ;(this.onMessage_ = t),
      (this.pendingResponses = []),
      (this.currentResponseNum = 0),
      (this.closeAfterResponse = -1),
      (this.onClose = null)
  }
  closeAfter(t, n) {
    ;(this.closeAfterResponse = t),
      (this.onClose = n),
      this.closeAfterResponse < this.currentResponseNum && (this.onClose(), (this.onClose = null))
  }
  handleResponse(t, n) {
    for (this.pendingResponses[t] = n; this.pendingResponses[this.currentResponseNum]; ) {
      const i = this.pendingResponses[this.currentResponseNum]
      delete this.pendingResponses[this.currentResponseNum]
      for (let r = 0; r < i.length; ++r)
        i[r] &&
          Yc(() => {
            this.onMessage_(i[r])
          })
      if (this.currentResponseNum === this.closeAfterResponse) {
        this.onClose && (this.onClose(), (this.onClose = null))
        break
      }
      this.currentResponseNum++
    }
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const KS = 'start',
  rj = 'close',
  sj = 'pLPCommand',
  oj = 'pRTLPCB',
  wP = 'id',
  IP = 'pw',
  SP = 'ser',
  aj = 'cb',
  lj = 'seg',
  uj = 'ts',
  cj = 'd',
  dj = 'dframe',
  EP = 1870,
  TP = 30,
  hj = EP - TP,
  fj = 25e3,
  mj = 3e4
class Wa {
  constructor(t, n, i, r, s, o, a) {
    ;(this.connId = t),
      (this.repoInfo = n),
      (this.applicationId = i),
      (this.appCheckToken = r),
      (this.authToken = s),
      (this.transportSessionId = o),
      (this.lastSessionId = a),
      (this.bytesSent = 0),
      (this.bytesReceived = 0),
      (this.everConnected_ = !1),
      (this.log_ = Kc(t)),
      (this.stats_ = c_(n)),
      (this.urlFn = (l) => (this.appCheckToken && (l[Yv] = this.appCheckToken), bP(n, _P, l)))
  }
  open(t, n) {
    ;(this.curSegmentNum = 0),
      (this.onDisconnect_ = n),
      (this.myPacketOrderer = new ij(t)),
      (this.isClosed_ = !1),
      (this.connectTimeoutTimer_ = setTimeout(() => {
        this.log_('Timed out trying to connect.'), this.onClosed_(), (this.connectTimeoutTimer_ = null)
      }, Math.floor(mj))),
      z4(() => {
        if (this.isClosed_) return
        this.scriptTagHolder = new d_(
          (...s) => {
            const [o, a, l, u, c] = s
            if ((this.incrementIncomingBytes_(s), !!this.scriptTagHolder))
              if (
                (this.connectTimeoutTimer_ &&
                  (clearTimeout(this.connectTimeoutTimer_), (this.connectTimeoutTimer_ = null)),
                (this.everConnected_ = !0),
                o === KS)
              )
                (this.id = a), (this.password = l)
              else if (o === rj)
                a
                  ? ((this.scriptTagHolder.sendNewPolls = !1),
                    this.myPacketOrderer.closeAfter(a, () => {
                      this.onClosed_()
                    }))
                  : this.onClosed_()
              else throw new Error('Unrecognized command received: ' + o)
          },
          (...s) => {
            const [o, a] = s
            this.incrementIncomingBytes_(s), this.myPacketOrderer.handleResponse(o, a)
          },
          () => {
            this.onClosed_()
          },
          this.urlFn
        )
        const i = {}
        ;(i[KS] = 't'),
          (i[SP] = Math.floor(Math.random() * 1e8)),
          this.scriptTagHolder.uniqueCallbackIdentifier && (i[aj] = this.scriptTagHolder.uniqueCallbackIdentifier),
          (i[dP] = u_),
          this.transportSessionId && (i[hP] = this.transportSessionId),
          this.lastSessionId && (i[vP] = this.lastSessionId),
          this.applicationId && (i[pP] = this.applicationId),
          this.appCheckToken && (i[Yv] = this.appCheckToken),
          typeof location < 'u' && location.hostname && gP.test(location.hostname) && (i[fP] = mP)
        const r = this.urlFn(i)
        this.log_('Connecting via long-poll to ' + r), this.scriptTagHolder.addTag(r, () => {})
      })
  }
  start() {
    this.scriptTagHolder.startLongPoll(this.id, this.password), this.addDisconnectPingFrame(this.id, this.password)
  }
  static forceAllow() {
    Wa.forceAllow_ = !0
  }
  static forceDisallow() {
    Wa.forceDisallow_ = !0
  }
  static isAvailable() {
    return Wa.forceAllow_
      ? !0
      : !Wa.forceDisallow_ && typeof document < 'u' && document.createElement != null && !W4() && !q4()
  }
  markConnectionHealthy() {}
  shutdown_() {
    ;(this.isClosed_ = !0),
      this.scriptTagHolder && (this.scriptTagHolder.close(), (this.scriptTagHolder = null)),
      this.myDisconnFrame && (document.body.removeChild(this.myDisconnFrame), (this.myDisconnFrame = null)),
      this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), (this.connectTimeoutTimer_ = null))
  }
  onClosed_() {
    this.isClosed_ ||
      (this.log_('Longpoll is closing itself'),
      this.shutdown_(),
      this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), (this.onDisconnect_ = null)))
  }
  close() {
    this.isClosed_ || (this.log_('Longpoll is being closed.'), this.shutdown_())
  }
  send(t) {
    const n = Sn(t)
    ;(this.bytesSent += n.length), this.stats_.incrementCounter('bytes_sent', n.length)
    const i = ek(n),
      r = uP(i, hj)
    for (let s = 0; s < r.length; s++)
      this.scriptTagHolder.enqueueSegment(this.curSegmentNum, r.length, r[s]), this.curSegmentNum++
  }
  addDisconnectPingFrame(t, n) {
    this.myDisconnFrame = document.createElement('iframe')
    const i = {}
    ;(i[dj] = 't'),
      (i[wP] = t),
      (i[IP] = n),
      (this.myDisconnFrame.src = this.urlFn(i)),
      (this.myDisconnFrame.style.display = 'none'),
      document.body.appendChild(this.myDisconnFrame)
  }
  incrementIncomingBytes_(t) {
    const n = Sn(t).length
    ;(this.bytesReceived += n), this.stats_.incrementCounter('bytes_received', n)
  }
}
class d_ {
  constructor(t, n, i, r) {
    ;(this.onDisconnect = i),
      (this.urlFn = r),
      (this.outstandingRequests = new Set()),
      (this.pendingSegs = []),
      (this.currentSerial = Math.floor(Math.random() * 1e8)),
      (this.sendNewPolls = !0)
    {
      ;(this.uniqueCallbackIdentifier = $4()),
        (window[sj + this.uniqueCallbackIdentifier] = t),
        (window[oj + this.uniqueCallbackIdentifier] = n),
        (this.myIFrame = d_.createIFrame_())
      let s = ''
      this.myIFrame.src &&
        this.myIFrame.src.substr(0, 11) === 'javascript:' &&
        (s = '<script>document.domain="' + document.domain + '";</script>')
      const o = '<html><body>' + s + '</body></html>'
      try {
        this.myIFrame.doc.open(), this.myIFrame.doc.write(o), this.myIFrame.doc.close()
      } catch (a) {
        Dn('frame writing exception'), a.stack && Dn(a.stack), Dn(a)
      }
    }
  }
  static createIFrame_() {
    const t = document.createElement('iframe')
    if (((t.style.display = 'none'), document.body)) {
      document.body.appendChild(t)
      try {
        t.contentWindow.document || Dn('No IE domain setting required')
      } catch {
        const i = document.domain
        t.src = "javascript:void((function(){document.open();document.domain='" + i + "';document.close();})())"
      }
    } else throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.'
    return (
      t.contentDocument
        ? (t.doc = t.contentDocument)
        : t.contentWindow
        ? (t.doc = t.contentWindow.document)
        : t.document && (t.doc = t.document),
      t
    )
  }
  close() {
    ;(this.alive = !1),
      this.myIFrame &&
        ((this.myIFrame.doc.body.textContent = ''),
        setTimeout(() => {
          this.myIFrame !== null && (document.body.removeChild(this.myIFrame), (this.myIFrame = null))
        }, Math.floor(0)))
    const t = this.onDisconnect
    t && ((this.onDisconnect = null), t())
  }
  startLongPoll(t, n) {
    for (this.myID = t, this.myPW = n, this.alive = !0; this.newRequest_(); );
  }
  newRequest_() {
    if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
      this.currentSerial++
      const t = {}
      ;(t[wP] = this.myID), (t[IP] = this.myPW), (t[SP] = this.currentSerial)
      let n = this.urlFn(t),
        i = '',
        r = 0
      for (; this.pendingSegs.length > 0 && this.pendingSegs[0].d.length + TP + i.length <= EP; ) {
        const o = this.pendingSegs.shift()
        ;(i = i + '&' + lj + r + '=' + o.seg + '&' + uj + r + '=' + o.ts + '&' + cj + r + '=' + o.d), r++
      }
      return (n = n + i), this.addLongPollTag_(n, this.currentSerial), !0
    } else return !1
  }
  enqueueSegment(t, n, i) {
    this.pendingSegs.push({ seg: t, ts: n, d: i }), this.alive && this.newRequest_()
  }
  addLongPollTag_(t, n) {
    this.outstandingRequests.add(n)
    const i = () => {
        this.outstandingRequests.delete(n), this.newRequest_()
      },
      r = setTimeout(i, Math.floor(fj)),
      s = () => {
        clearTimeout(r), i()
      }
    this.addTag(t, s)
  }
  addTag(t, n) {
    setTimeout(() => {
      try {
        if (!this.sendNewPolls) return
        const i = this.myIFrame.doc.createElement('script')
        ;(i.type = 'text/javascript'),
          (i.async = !0),
          (i.src = t),
          (i.onload = i.onreadystatechange =
            function () {
              const r = i.readyState
              ;(!r || r === 'loaded' || r === 'complete') &&
                ((i.onload = i.onreadystatechange = null), i.parentNode && i.parentNode.removeChild(i), n())
            }),
          (i.onerror = () => {
            Dn('Long-poll script failed to load: ' + t), (this.sendNewPolls = !1), this.close()
          }),
          this.myIFrame.doc.body.appendChild(i)
      } catch {}
    }, Math.floor(1))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const gj = 16384,
  vj = 45e3
let Yh = null
typeof MozWebSocket < 'u' ? (Yh = MozWebSocket) : typeof WebSocket < 'u' && (Yh = WebSocket)
class Ui {
  constructor(t, n, i, r, s, o, a) {
    ;(this.connId = t),
      (this.applicationId = i),
      (this.appCheckToken = r),
      (this.authToken = s),
      (this.keepaliveTimer = null),
      (this.frames = null),
      (this.totalFrames = 0),
      (this.bytesSent = 0),
      (this.bytesReceived = 0),
      (this.log_ = Kc(this.connId)),
      (this.stats_ = c_(n)),
      (this.connURL = Ui.connectionURL_(n, o, a, r, i)),
      (this.nodeAdmin = n.nodeAdmin)
  }
  static connectionURL_(t, n, i, r, s) {
    const o = {}
    return (
      (o[dP] = u_),
      typeof location < 'u' && location.hostname && gP.test(location.hostname) && (o[fP] = mP),
      n && (o[hP] = n),
      i && (o[vP] = i),
      r && (o[Yv] = r),
      s && (o[pP] = s),
      bP(t, yP, o)
    )
  }
  open(t, n) {
    ;(this.onDisconnect = n),
      (this.onMessage = t),
      this.log_('Websocket connecting to ' + this.connURL),
      (this.everConnected_ = !1),
      vo.set('previous_websocket_failure', !0)
    try {
      let i
      ak(), (this.mySock = new Yh(this.connURL, [], i))
    } catch (i) {
      this.log_('Error instantiating WebSocket.')
      const r = i.message || i.data
      r && this.log_(r), this.onClosed_()
      return
    }
    ;(this.mySock.onopen = () => {
      this.log_('Websocket connected.'), (this.everConnected_ = !0)
    }),
      (this.mySock.onclose = () => {
        this.log_('Websocket connection was disconnected.'), (this.mySock = null), this.onClosed_()
      }),
      (this.mySock.onmessage = (i) => {
        this.handleIncomingFrame(i)
      }),
      (this.mySock.onerror = (i) => {
        this.log_('WebSocket error.  Closing connection.')
        const r = i.message || i.data
        r && this.log_(r), this.onClosed_()
      })
  }
  start() {}
  static forceDisallow() {
    Ui.forceDisallow_ = !0
  }
  static isAvailable() {
    let t = !1
    if (typeof navigator < 'u' && navigator.userAgent) {
      const n = /Android ([0-9]{0,}\.[0-9]{0,})/,
        i = navigator.userAgent.match(n)
      i && i.length > 1 && parseFloat(i[1]) < 4.4 && (t = !0)
    }
    return !t && Yh !== null && !Ui.forceDisallow_
  }
  static previouslyFailed() {
    return vo.isInMemoryStorage || vo.get('previous_websocket_failure') === !0
  }
  markConnectionHealthy() {
    vo.remove('previous_websocket_failure')
  }
  appendFrame_(t) {
    if ((this.frames.push(t), this.frames.length === this.totalFrames)) {
      const n = this.frames.join('')
      this.frames = null
      const i = lc(n)
      this.onMessage(i)
    }
  }
  handleNewFrameCount_(t) {
    ;(this.totalFrames = t), (this.frames = [])
  }
  extractFrameCount_(t) {
    if ((Pe(this.frames === null, 'We already have a frame buffer'), t.length <= 6)) {
      const n = Number(t)
      if (!isNaN(n)) return this.handleNewFrameCount_(n), null
    }
    return this.handleNewFrameCount_(1), t
  }
  handleIncomingFrame(t) {
    if (this.mySock === null) return
    const n = t.data
    if (
      ((this.bytesReceived += n.length),
      this.stats_.incrementCounter('bytes_received', n.length),
      this.resetKeepAlive(),
      this.frames !== null)
    )
      this.appendFrame_(n)
    else {
      const i = this.extractFrameCount_(n)
      i !== null && this.appendFrame_(i)
    }
  }
  send(t) {
    this.resetKeepAlive()
    const n = Sn(t)
    ;(this.bytesSent += n.length), this.stats_.incrementCounter('bytes_sent', n.length)
    const i = uP(n, gj)
    i.length > 1 && this.sendString_(String(i.length))
    for (let r = 0; r < i.length; r++) this.sendString_(i[r])
  }
  shutdown_() {
    ;(this.isClosed_ = !0),
      this.keepaliveTimer && (clearInterval(this.keepaliveTimer), (this.keepaliveTimer = null)),
      this.mySock && (this.mySock.close(), (this.mySock = null))
  }
  onClosed_() {
    this.isClosed_ ||
      (this.log_('WebSocket is closing itself'),
      this.shutdown_(),
      this.onDisconnect && (this.onDisconnect(this.everConnected_), (this.onDisconnect = null)))
  }
  close() {
    this.isClosed_ || (this.log_('WebSocket is being closed'), this.shutdown_())
  }
  resetKeepAlive() {
    clearInterval(this.keepaliveTimer),
      (this.keepaliveTimer = setInterval(() => {
        this.mySock && this.sendString_('0'), this.resetKeepAlive()
      }, Math.floor(vj)))
  }
  sendString_(t) {
    try {
      this.mySock.send(t)
    } catch (n) {
      this.log_('Exception thrown from WebSocket.send():', n.message || n.data, 'Closing connection.'),
        setTimeout(this.onClosed_.bind(this), 0)
    }
  }
}
Ui.responsesRequiredToBeHealthy = 2
Ui.healthyTimeout = 3e4
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hc {
  constructor(t) {
    this.initTransports_(t)
  }
  static get ALL_TRANSPORTS() {
    return [Wa, Ui]
  }
  static get IS_TRANSPORT_INITIALIZED() {
    return this.globalTransportInitialized_
  }
  initTransports_(t) {
    const n = Ui && Ui.isAvailable()
    let i = n && !Ui.previouslyFailed()
    if (
      (t.webSocketOnly &&
        (n || fi("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), (i = !0)),
      i)
    )
      this.transports_ = [Ui]
    else {
      const r = (this.transports_ = [])
      for (const s of hc.ALL_TRANSPORTS) s && s.isAvailable() && r.push(s)
      hc.globalTransportInitialized_ = !0
    }
  }
  initialTransport() {
    if (this.transports_.length > 0) return this.transports_[0]
    throw new Error('No transports available')
  }
  upgradeTransport() {
    return this.transports_.length > 1 ? this.transports_[1] : null
  }
}
hc.globalTransportInitialized_ = !1
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const pj = 6e4,
  yj = 5e3,
  _j = 10 * 1024,
  bj = 100 * 1024,
  Fg = 't',
  YS = 'd',
  wj = 's',
  QS = 'r',
  Ij = 'e',
  XS = 'o',
  JS = 'a',
  ZS = 'n',
  eE = 'p',
  Sj = 'h'
class Ej {
  constructor(t, n, i, r, s, o, a, l, u, c) {
    ;(this.id = t),
      (this.repoInfo_ = n),
      (this.applicationId_ = i),
      (this.appCheckToken_ = r),
      (this.authToken_ = s),
      (this.onMessage_ = o),
      (this.onReady_ = a),
      (this.onDisconnect_ = l),
      (this.onKill_ = u),
      (this.lastSessionId = c),
      (this.connectionCount = 0),
      (this.pendingDataMessages = []),
      (this.state_ = 0),
      (this.log_ = Kc('c:' + this.id + ':')),
      (this.transportManager_ = new hc(n)),
      this.log_('Connection created'),
      this.start_()
  }
  start_() {
    const t = this.transportManager_.initialTransport()
    ;(this.conn_ = new t(
      this.nextTransportId_(),
      this.repoInfo_,
      this.applicationId_,
      this.appCheckToken_,
      this.authToken_,
      null,
      this.lastSessionId
    )),
      (this.primaryResponsesRequired_ = t.responsesRequiredToBeHealthy || 0)
    const n = this.connReceiver_(this.conn_),
      i = this.disconnReceiver_(this.conn_)
    ;(this.tx_ = this.conn_),
      (this.rx_ = this.conn_),
      (this.secondaryConn_ = null),
      (this.isHealthy_ = !1),
      setTimeout(() => {
        this.conn_ && this.conn_.open(n, i)
      }, Math.floor(0))
    const r = t.healthyTimeout || 0
    r > 0 &&
      (this.healthyTimeout_ = Hu(() => {
        ;(this.healthyTimeout_ = null),
          this.isHealthy_ ||
            (this.conn_ && this.conn_.bytesReceived > bj
              ? (this.log_(
                  'Connection exceeded healthy timeout but has received ' +
                    this.conn_.bytesReceived +
                    ' bytes.  Marking connection healthy.'
                ),
                (this.isHealthy_ = !0),
                this.conn_.markConnectionHealthy())
              : this.conn_ && this.conn_.bytesSent > _j
              ? this.log_(
                  'Connection exceeded healthy timeout but has sent ' +
                    this.conn_.bytesSent +
                    ' bytes.  Leaving connection alive.'
                )
              : (this.log_('Closing unhealthy connection after timeout.'), this.close()))
      }, Math.floor(r)))
  }
  nextTransportId_() {
    return 'c:' + this.id + ':' + this.connectionCount++
  }
  disconnReceiver_(t) {
    return (n) => {
      t === this.conn_
        ? this.onConnectionLost_(n)
        : t === this.secondaryConn_
        ? (this.log_('Secondary connection lost.'), this.onSecondaryConnectionLost_())
        : this.log_('closing an old connection')
    }
  }
  connReceiver_(t) {
    return (n) => {
      this.state_ !== 2 &&
        (t === this.rx_
          ? this.onPrimaryMessageReceived_(n)
          : t === this.secondaryConn_
          ? this.onSecondaryMessageReceived_(n)
          : this.log_('message on old connection'))
    }
  }
  sendRequest(t) {
    const n = { t: 'd', d: t }
    this.sendData_(n)
  }
  tryCleanupConnection() {
    this.tx_ === this.secondaryConn_ &&
      this.rx_ === this.secondaryConn_ &&
      (this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId),
      (this.conn_ = this.secondaryConn_),
      (this.secondaryConn_ = null))
  }
  onSecondaryControl_(t) {
    if (Fg in t) {
      const n = t[Fg]
      n === JS
        ? this.upgradeIfSecondaryHealthy_()
        : n === QS
        ? (this.log_('Got a reset on secondary, closing it'),
          this.secondaryConn_.close(),
          (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) && this.close())
        : n === XS &&
          (this.log_('got pong on secondary.'), this.secondaryResponsesRequired_--, this.upgradeIfSecondaryHealthy_())
    }
  }
  onSecondaryMessageReceived_(t) {
    const n = fu('t', t),
      i = fu('d', t)
    if (n === 'c') this.onSecondaryControl_(i)
    else if (n === 'd') this.pendingDataMessages.push(i)
    else throw new Error('Unknown protocol layer: ' + n)
  }
  upgradeIfSecondaryHealthy_() {
    this.secondaryResponsesRequired_ <= 0
      ? (this.log_('Secondary connection is healthy.'),
        (this.isHealthy_ = !0),
        this.secondaryConn_.markConnectionHealthy(),
        this.proceedWithUpgrade_())
      : (this.log_('sending ping on secondary.'), this.secondaryConn_.send({ t: 'c', d: { t: eE, d: {} } }))
  }
  proceedWithUpgrade_() {
    this.secondaryConn_.start(),
      this.log_('sending client ack on secondary'),
      this.secondaryConn_.send({ t: 'c', d: { t: JS, d: {} } }),
      this.log_('Ending transmission on primary'),
      this.conn_.send({ t: 'c', d: { t: ZS, d: {} } }),
      (this.tx_ = this.secondaryConn_),
      this.tryCleanupConnection()
  }
  onPrimaryMessageReceived_(t) {
    const n = fu('t', t),
      i = fu('d', t)
    n === 'c' ? this.onControl_(i) : n === 'd' && this.onDataMessage_(i)
  }
  onDataMessage_(t) {
    this.onPrimaryResponse_(), this.onMessage_(t)
  }
  onPrimaryResponse_() {
    this.isHealthy_ ||
      (this.primaryResponsesRequired_--,
      this.primaryResponsesRequired_ <= 0 &&
        (this.log_('Primary connection is healthy.'), (this.isHealthy_ = !0), this.conn_.markConnectionHealthy()))
  }
  onControl_(t) {
    const n = fu(Fg, t)
    if (YS in t) {
      const i = t[YS]
      if (n === Sj) {
        const r = Object.assign({}, i)
        this.repoInfo_.isUsingEmulator && (r.h = this.repoInfo_.host), this.onHandshake_(r)
      } else if (n === ZS) {
        this.log_('recvd end transmission on primary'), (this.rx_ = this.secondaryConn_)
        for (let r = 0; r < this.pendingDataMessages.length; ++r) this.onDataMessage_(this.pendingDataMessages[r])
        ;(this.pendingDataMessages = []), this.tryCleanupConnection()
      } else
        n === wj
          ? this.onConnectionShutdown_(i)
          : n === QS
          ? this.onReset_(i)
          : n === Ij
          ? Kv('Server Error: ' + i)
          : n === XS
          ? (this.log_('got pong on primary.'), this.onPrimaryResponse_(), this.sendPingOnPrimaryIfNecessary_())
          : Kv('Unknown control packet command: ' + n)
    }
  }
  onHandshake_(t) {
    const n = t.ts,
      i = t.v,
      r = t.h
    ;(this.sessionId = t.s),
      (this.repoInfo_.host = r),
      this.state_ === 0 &&
        (this.conn_.start(),
        this.onConnectionEstablished_(this.conn_, n),
        u_ !== i && fi('Protocol version mismatch detected'),
        this.tryStartUpgrade_())
  }
  tryStartUpgrade_() {
    const t = this.transportManager_.upgradeTransport()
    t && this.startUpgrade_(t)
  }
  startUpgrade_(t) {
    ;(this.secondaryConn_ = new t(
      this.nextTransportId_(),
      this.repoInfo_,
      this.applicationId_,
      this.appCheckToken_,
      this.authToken_,
      this.sessionId
    )),
      (this.secondaryResponsesRequired_ = t.responsesRequiredToBeHealthy || 0)
    const n = this.connReceiver_(this.secondaryConn_),
      i = this.disconnReceiver_(this.secondaryConn_)
    this.secondaryConn_.open(n, i),
      Hu(() => {
        this.secondaryConn_ && (this.log_('Timed out trying to upgrade.'), this.secondaryConn_.close())
      }, Math.floor(pj))
  }
  onReset_(t) {
    this.log_('Reset packet received.  New host: ' + t),
      (this.repoInfo_.host = t),
      this.state_ === 1 ? this.close() : (this.closeConnections_(), this.start_())
  }
  onConnectionEstablished_(t, n) {
    this.log_('Realtime connection established.'),
      (this.conn_ = t),
      (this.state_ = 1),
      this.onReady_ && (this.onReady_(n, this.sessionId), (this.onReady_ = null)),
      this.primaryResponsesRequired_ === 0
        ? (this.log_('Primary connection is healthy.'), (this.isHealthy_ = !0))
        : Hu(() => {
            this.sendPingOnPrimaryIfNecessary_()
          }, Math.floor(yj))
  }
  sendPingOnPrimaryIfNecessary_() {
    !this.isHealthy_ &&
      this.state_ === 1 &&
      (this.log_('sending ping on primary.'), this.sendData_({ t: 'c', d: { t: eE, d: {} } }))
  }
  onSecondaryConnectionLost_() {
    const t = this.secondaryConn_
    ;(this.secondaryConn_ = null), (this.tx_ === t || this.rx_ === t) && this.close()
  }
  onConnectionLost_(t) {
    ;(this.conn_ = null),
      !t && this.state_ === 0
        ? (this.log_('Realtime connection failed.'),
          this.repoInfo_.isCacheableHost() &&
            (vo.remove('host:' + this.repoInfo_.host), (this.repoInfo_.internalHost = this.repoInfo_.host)))
        : this.state_ === 1 && this.log_('Realtime connection lost.'),
      this.close()
  }
  onConnectionShutdown_(t) {
    this.log_('Connection shutdown command received. Shutting down...'),
      this.onKill_ && (this.onKill_(t), (this.onKill_ = null)),
      (this.onDisconnect_ = null),
      this.close()
  }
  sendData_(t) {
    if (this.state_ !== 1) throw 'Connection is not connected'
    this.tx_.send(t)
  }
  close() {
    this.state_ !== 2 &&
      (this.log_('Closing realtime connection.'),
      (this.state_ = 2),
      this.closeConnections_(),
      this.onDisconnect_ && (this.onDisconnect_(), (this.onDisconnect_ = null)))
  }
  closeConnections_() {
    this.log_('Shutting down all connections'),
      this.conn_ && (this.conn_.close(), (this.conn_ = null)),
      this.secondaryConn_ && (this.secondaryConn_.close(), (this.secondaryConn_ = null)),
      this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), (this.healthyTimeout_ = null))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class CP {
  put(t, n, i, r) {}
  merge(t, n, i, r) {}
  refreshAuthToken(t) {}
  refreshAppCheckToken(t) {}
  onDisconnectPut(t, n, i) {}
  onDisconnectMerge(t, n, i) {}
  onDisconnectCancel(t, n) {}
  reportStats(t) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class AP {
  constructor(t) {
    ;(this.allowedEvents_ = t),
      (this.listeners_ = {}),
      Pe(Array.isArray(t) && t.length > 0, 'Requires a non-empty array')
  }
  trigger(t, ...n) {
    if (Array.isArray(this.listeners_[t])) {
      const i = [...this.listeners_[t]]
      for (let r = 0; r < i.length; r++) i[r].callback.apply(i[r].context, n)
    }
  }
  on(t, n, i) {
    this.validateEventType_(t),
      (this.listeners_[t] = this.listeners_[t] || []),
      this.listeners_[t].push({ callback: n, context: i })
    const r = this.getInitialEvent(t)
    r && n.apply(i, r)
  }
  off(t, n, i) {
    this.validateEventType_(t)
    const r = this.listeners_[t] || []
    for (let s = 0; s < r.length; s++)
      if (r[s].callback === n && (!i || i === r[s].context)) {
        r.splice(s, 1)
        return
      }
  }
  validateEventType_(t) {
    Pe(
      this.allowedEvents_.find((n) => n === t),
      'Unknown event: ' + t
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Qh extends AP {
  constructor() {
    super(['online']),
      (this.online_ = !0),
      typeof window < 'u' &&
        typeof window.addEventListener < 'u' &&
        !qy() &&
        (window.addEventListener(
          'online',
          () => {
            this.online_ || ((this.online_ = !0), this.trigger('online', !0))
          },
          !1
        ),
        window.addEventListener(
          'offline',
          () => {
            this.online_ && ((this.online_ = !1), this.trigger('online', !1))
          },
          !1
        ))
  }
  static getInstance() {
    return new Qh()
  }
  getInitialEvent(t) {
    return Pe(t === 'online', 'Unknown event type: ' + t), [this.online_]
  }
  currentlyOnline() {
    return this.online_
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const tE = 32,
  nE = 768
class xt {
  constructor(t, n) {
    if (n === void 0) {
      this.pieces_ = t.split('/')
      let i = 0
      for (let r = 0; r < this.pieces_.length; r++)
        this.pieces_[r].length > 0 && ((this.pieces_[i] = this.pieces_[r]), i++)
      ;(this.pieces_.length = i), (this.pieceNum_ = 0)
    } else (this.pieces_ = t), (this.pieceNum_ = n)
  }
  toString() {
    let t = ''
    for (let n = this.pieceNum_; n < this.pieces_.length; n++) this.pieces_[n] !== '' && (t += '/' + this.pieces_[n])
    return t || '/'
  }
}
function yt() {
  return new xt('')
}
function it(e) {
  return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_]
}
function Ds(e) {
  return e.pieces_.length - e.pieceNum_
}
function kt(e) {
  let t = e.pieceNum_
  return t < e.pieces_.length && t++, new xt(e.pieces_, t)
}
function kP(e) {
  return e.pieceNum_ < e.pieces_.length ? e.pieces_[e.pieces_.length - 1] : null
}
function Tj(e) {
  let t = ''
  for (let n = e.pieceNum_; n < e.pieces_.length; n++)
    e.pieces_[n] !== '' && (t += '/' + encodeURIComponent(String(e.pieces_[n])))
  return t || '/'
}
function PP(e, t = 0) {
  return e.pieces_.slice(e.pieceNum_ + t)
}
function RP(e) {
  if (e.pieceNum_ >= e.pieces_.length) return null
  const t = []
  for (let n = e.pieceNum_; n < e.pieces_.length - 1; n++) t.push(e.pieces_[n])
  return new xt(t, 0)
}
function hn(e, t) {
  const n = []
  for (let i = e.pieceNum_; i < e.pieces_.length; i++) n.push(e.pieces_[i])
  if (t instanceof xt) for (let i = t.pieceNum_; i < t.pieces_.length; i++) n.push(t.pieces_[i])
  else {
    const i = t.split('/')
    for (let r = 0; r < i.length; r++) i[r].length > 0 && n.push(i[r])
  }
  return new xt(n, 0)
}
function et(e) {
  return e.pieceNum_ >= e.pieces_.length
}
function Ti(e, t) {
  const n = it(e),
    i = it(t)
  if (n === null) return t
  if (n === i) return Ti(kt(e), kt(t))
  throw new Error('INTERNAL ERROR: innerPath (' + t + ') is not within outerPath (' + e + ')')
}
function xP(e, t) {
  if (Ds(e) !== Ds(t)) return !1
  for (let n = e.pieceNum_, i = t.pieceNum_; n <= e.pieces_.length; n++, i++)
    if (e.pieces_[n] !== t.pieces_[i]) return !1
  return !0
}
function ji(e, t) {
  let n = e.pieceNum_,
    i = t.pieceNum_
  if (Ds(e) > Ds(t)) return !1
  for (; n < e.pieces_.length; ) {
    if (e.pieces_[n] !== t.pieces_[i]) return !1
    ++n, ++i
  }
  return !0
}
class Cj {
  constructor(t, n) {
    ;(this.errorPrefix_ = n), (this.parts_ = PP(t, 0)), (this.byteLength_ = Math.max(1, this.parts_.length))
    for (let i = 0; i < this.parts_.length; i++) this.byteLength_ += Wf(this.parts_[i])
    VP(this)
  }
}
function Aj(e, t) {
  e.parts_.length > 0 && (e.byteLength_ += 1), e.parts_.push(t), (e.byteLength_ += Wf(t)), VP(e)
}
function kj(e) {
  const t = e.parts_.pop()
  ;(e.byteLength_ -= Wf(t)), e.parts_.length > 0 && (e.byteLength_ -= 1)
}
function VP(e) {
  if (e.byteLength_ > nE)
    throw new Error(e.errorPrefix_ + 'has a key path longer than ' + nE + ' bytes (' + e.byteLength_ + ').')
  if (e.parts_.length > tE)
    throw new Error(
      e.errorPrefix_ +
        'path specified exceeds the maximum depth that can be written (' +
        tE +
        ') or object contains a cycle ' +
        lo(e)
    )
}
function lo(e) {
  return e.parts_.length === 0 ? '' : "in property '" + e.parts_.join('.') + "'"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class h_ extends AP {
  constructor() {
    super(['visible'])
    let t, n
    typeof document < 'u' &&
      typeof document.addEventListener < 'u' &&
      (typeof document.hidden < 'u'
        ? ((n = 'visibilitychange'), (t = 'hidden'))
        : typeof document.mozHidden < 'u'
        ? ((n = 'mozvisibilitychange'), (t = 'mozHidden'))
        : typeof document.msHidden < 'u'
        ? ((n = 'msvisibilitychange'), (t = 'msHidden'))
        : typeof document.webkitHidden < 'u' && ((n = 'webkitvisibilitychange'), (t = 'webkitHidden'))),
      (this.visible_ = !0),
      n &&
        document.addEventListener(
          n,
          () => {
            const i = !document[t]
            i !== this.visible_ && ((this.visible_ = i), this.trigger('visible', i))
          },
          !1
        )
  }
  static getInstance() {
    return new h_()
  }
  getInitialEvent(t) {
    return Pe(t === 'visible', 'Unknown event type: ' + t), [this.visible_]
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const mu = 1e3,
  Pj = 60 * 5 * 1e3,
  iE = 30 * 1e3,
  Rj = 1.3,
  xj = 3e4,
  Vj = 'server_kill',
  rE = 3
class Dr extends CP {
  constructor(t, n, i, r, s, o, a, l) {
    if (
      (super(),
      (this.repoInfo_ = t),
      (this.applicationId_ = n),
      (this.onDataUpdate_ = i),
      (this.onConnectStatus_ = r),
      (this.onServerInfoUpdate_ = s),
      (this.authTokenProvider_ = o),
      (this.appCheckTokenProvider_ = a),
      (this.authOverride_ = l),
      (this.id = Dr.nextPersistentConnectionId_++),
      (this.log_ = Kc('p:' + this.id + ':')),
      (this.interruptReasons_ = {}),
      (this.listens = new Map()),
      (this.outstandingPuts_ = []),
      (this.outstandingGets_ = []),
      (this.outstandingPutCount_ = 0),
      (this.outstandingGetCount_ = 0),
      (this.onDisconnectRequestQueue_ = []),
      (this.connected_ = !1),
      (this.reconnectDelay_ = mu),
      (this.maxReconnectDelay_ = Pj),
      (this.securityDebugCallback_ = null),
      (this.lastSessionId = null),
      (this.establishConnectionTimer_ = null),
      (this.visible_ = !1),
      (this.requestCBHash_ = {}),
      (this.requestNumber_ = 0),
      (this.realtime_ = null),
      (this.authToken_ = null),
      (this.appCheckToken_ = null),
      (this.forceTokenRefresh_ = !1),
      (this.invalidAuthTokenCount_ = 0),
      (this.invalidAppCheckTokenCount_ = 0),
      (this.firstConnection_ = !0),
      (this.lastConnectionAttemptTime_ = null),
      (this.lastConnectionEstablishedTime_ = null),
      l && !ak())
    )
      throw new Error('Auth override specified in options, but not supported on non Node.js platforms')
    h_.getInstance().on('visible', this.onVisible_, this),
      t.host.indexOf('fblocal') === -1 && Qh.getInstance().on('online', this.onOnline_, this)
  }
  sendRequest(t, n, i) {
    const r = ++this.requestNumber_,
      s = { r, a: t, b: n }
    this.log_(Sn(s)),
      Pe(this.connected_, "sendRequest call when we're not connected not allowed."),
      this.realtime_.sendRequest(s),
      i && (this.requestCBHash_[r] = i)
  }
  get(t) {
    this.initConnection_()
    const n = new ac(),
      r = {
        action: 'g',
        request: { p: t._path.toString(), q: t._queryObject },
        onComplete: (o) => {
          const a = o.d
          o.s === 'ok' ? n.resolve(a) : n.reject(a)
        },
      }
    this.outstandingGets_.push(r), this.outstandingGetCount_++
    const s = this.outstandingGets_.length - 1
    return this.connected_ && this.sendGet_(s), n.promise
  }
  listen(t, n, i, r) {
    this.initConnection_()
    const s = t._queryIdentifier,
      o = t._path.toString()
    this.log_('Listen called for ' + o + ' ' + s),
      this.listens.has(o) || this.listens.set(o, new Map()),
      Pe(
        t._queryParams.isDefault() || !t._queryParams.loadsAllData(),
        'listen() called for non-default but complete query'
      ),
      Pe(!this.listens.get(o).has(s), 'listen() called twice for same path/queryId.')
    const a = { onComplete: r, hashFn: n, query: t, tag: i }
    this.listens.get(o).set(s, a), this.connected_ && this.sendListen_(a)
  }
  sendGet_(t) {
    const n = this.outstandingGets_[t]
    this.sendRequest('g', n.request, (i) => {
      delete this.outstandingGets_[t],
        this.outstandingGetCount_--,
        this.outstandingGetCount_ === 0 && (this.outstandingGets_ = []),
        n.onComplete && n.onComplete(i)
    })
  }
  sendListen_(t) {
    const n = t.query,
      i = n._path.toString(),
      r = n._queryIdentifier
    this.log_('Listen on ' + i + ' for ' + r)
    const s = { p: i },
      o = 'q'
    t.tag && ((s.q = n._queryObject), (s.t = t.tag)),
      (s.h = t.hashFn()),
      this.sendRequest(o, s, (a) => {
        const l = a.d,
          u = a.s
        Dr.warnOnListenWarnings_(l, n),
          (this.listens.get(i) && this.listens.get(i).get(r)) === t &&
            (this.log_('listen response', a),
            u !== 'ok' && this.removeListen_(i, r),
            t.onComplete && t.onComplete(u, l))
      })
  }
  static warnOnListenWarnings_(t, n) {
    if (t && typeof t == 'object' && Hr(t, 'w')) {
      const i = hl(t, 'w')
      if (Array.isArray(i) && ~i.indexOf('no_index')) {
        const r = '".indexOn": "' + n._queryParams.getIndex().toString() + '"',
          s = n._path.toString()
        fi(
          `Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${r} at ${s} to your security rules for better performance.`
        )
      }
    }
  }
  refreshAuthToken(t) {
    ;(this.authToken_ = t),
      this.log_('Auth token refreshed'),
      this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest('unauth', {}, () => {}),
      this.reduceReconnectDelayIfAdminCredential_(t)
  }
  reduceReconnectDelayIfAdminCredential_(t) {
    ;((t && t.length === 40) || vB(t)) &&
      (this.log_('Admin auth credential detected.  Reducing max reconnect time.'), (this.maxReconnectDelay_ = iE))
  }
  refreshAppCheckToken(t) {
    ;(this.appCheckToken_ = t),
      this.log_('App check token refreshed'),
      this.appCheckToken_ ? this.tryAppCheck() : this.connected_ && this.sendRequest('unappeck', {}, () => {})
  }
  tryAuth() {
    if (this.connected_ && this.authToken_) {
      const t = this.authToken_,
        n = gB(t) ? 'auth' : 'gauth',
        i = { cred: t }
      this.authOverride_ === null
        ? (i.noauth = !0)
        : typeof this.authOverride_ == 'object' && (i.authvar = this.authOverride_),
        this.sendRequest(n, i, (r) => {
          const s = r.s,
            o = r.d || 'error'
          this.authToken_ === t && (s === 'ok' ? (this.invalidAuthTokenCount_ = 0) : this.onAuthRevoked_(s, o))
        })
    }
  }
  tryAppCheck() {
    this.connected_ &&
      this.appCheckToken_ &&
      this.sendRequest('appcheck', { token: this.appCheckToken_ }, (t) => {
        const n = t.s,
          i = t.d || 'error'
        n === 'ok' ? (this.invalidAppCheckTokenCount_ = 0) : this.onAppCheckRevoked_(n, i)
      })
  }
  unlisten(t, n) {
    const i = t._path.toString(),
      r = t._queryIdentifier
    this.log_('Unlisten called for ' + i + ' ' + r),
      Pe(
        t._queryParams.isDefault() || !t._queryParams.loadsAllData(),
        'unlisten() called for non-default but complete query'
      ),
      this.removeListen_(i, r) && this.connected_ && this.sendUnlisten_(i, r, t._queryObject, n)
  }
  sendUnlisten_(t, n, i, r) {
    this.log_('Unlisten on ' + t + ' for ' + n)
    const s = { p: t },
      o = 'n'
    r && ((s.q = i), (s.t = r)), this.sendRequest(o, s)
  }
  onDisconnectPut(t, n, i) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_('o', t, n, i)
        : this.onDisconnectRequestQueue_.push({ pathString: t, action: 'o', data: n, onComplete: i })
  }
  onDisconnectMerge(t, n, i) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_('om', t, n, i)
        : this.onDisconnectRequestQueue_.push({ pathString: t, action: 'om', data: n, onComplete: i })
  }
  onDisconnectCancel(t, n) {
    this.initConnection_(),
      this.connected_
        ? this.sendOnDisconnect_('oc', t, null, n)
        : this.onDisconnectRequestQueue_.push({ pathString: t, action: 'oc', data: null, onComplete: n })
  }
  sendOnDisconnect_(t, n, i, r) {
    const s = { p: n, d: i }
    this.log_('onDisconnect ' + t, s),
      this.sendRequest(t, s, (o) => {
        r &&
          setTimeout(() => {
            r(o.s, o.d)
          }, Math.floor(0))
      })
  }
  put(t, n, i, r) {
    this.putInternal('p', t, n, i, r)
  }
  merge(t, n, i, r) {
    this.putInternal('m', t, n, i, r)
  }
  putInternal(t, n, i, r, s) {
    this.initConnection_()
    const o = { p: n, d: i }
    s !== void 0 && (o.h = s),
      this.outstandingPuts_.push({ action: t, request: o, onComplete: r }),
      this.outstandingPutCount_++
    const a = this.outstandingPuts_.length - 1
    this.connected_ ? this.sendPut_(a) : this.log_('Buffering put: ' + n)
  }
  sendPut_(t) {
    const n = this.outstandingPuts_[t].action,
      i = this.outstandingPuts_[t].request,
      r = this.outstandingPuts_[t].onComplete
    ;(this.outstandingPuts_[t].queued = this.connected_),
      this.sendRequest(n, i, (s) => {
        this.log_(n + ' response', s),
          delete this.outstandingPuts_[t],
          this.outstandingPutCount_--,
          this.outstandingPutCount_ === 0 && (this.outstandingPuts_ = []),
          r && r(s.s, s.d)
      })
  }
  reportStats(t) {
    if (this.connected_) {
      const n = { c: t }
      this.log_('reportStats', n),
        this.sendRequest('s', n, (i) => {
          if (i.s !== 'ok') {
            const s = i.d
            this.log_('reportStats', 'Error sending stats: ' + s)
          }
        })
    }
  }
  onDataMessage_(t) {
    if ('r' in t) {
      this.log_('from server: ' + Sn(t))
      const n = t.r,
        i = this.requestCBHash_[n]
      i && (delete this.requestCBHash_[n], i(t.b))
    } else {
      if ('error' in t) throw 'A server-side error has occurred: ' + t.error
      'a' in t && this.onDataPush_(t.a, t.b)
    }
  }
  onDataPush_(t, n) {
    this.log_('handleServerMessage', t, n),
      t === 'd'
        ? this.onDataUpdate_(n.p, n.d, !1, n.t)
        : t === 'm'
        ? this.onDataUpdate_(n.p, n.d, !0, n.t)
        : t === 'c'
        ? this.onListenRevoked_(n.p, n.q)
        : t === 'ac'
        ? this.onAuthRevoked_(n.s, n.d)
        : t === 'apc'
        ? this.onAppCheckRevoked_(n.s, n.d)
        : t === 'sd'
        ? this.onSecurityDebugPacket_(n)
        : Kv(
            'Unrecognized action received from server: ' +
              Sn(t) +
              `
Are you using the latest client?`
          )
  }
  onReady_(t, n) {
    this.log_('connection ready'),
      (this.connected_ = !0),
      (this.lastConnectionEstablishedTime_ = new Date().getTime()),
      this.handleTimestamp_(t),
      (this.lastSessionId = n),
      this.firstConnection_ && this.sendConnectStats_(),
      this.restoreState_(),
      (this.firstConnection_ = !1),
      this.onConnectStatus_(!0)
  }
  scheduleConnect_(t) {
    Pe(!this.realtime_, "Scheduling a connect when we're already connected/ing?"),
      this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_),
      (this.establishConnectionTimer_ = setTimeout(() => {
        ;(this.establishConnectionTimer_ = null), this.establishConnection_()
      }, Math.floor(t)))
  }
  initConnection_() {
    !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0)
  }
  onVisible_(t) {
    t &&
      !this.visible_ &&
      this.reconnectDelay_ === this.maxReconnectDelay_ &&
      (this.log_('Window became visible.  Reducing delay.'),
      (this.reconnectDelay_ = mu),
      this.realtime_ || this.scheduleConnect_(0)),
      (this.visible_ = t)
  }
  onOnline_(t) {
    t
      ? (this.log_('Browser went online.'), (this.reconnectDelay_ = mu), this.realtime_ || this.scheduleConnect_(0))
      : (this.log_('Browser went offline.  Killing connection.'), this.realtime_ && this.realtime_.close())
  }
  onRealtimeDisconnect_() {
    if (
      (this.log_('data client disconnected'),
      (this.connected_ = !1),
      (this.realtime_ = null),
      this.cancelSentTransactions_(),
      (this.requestCBHash_ = {}),
      this.shouldReconnect_())
    ) {
      this.visible_
        ? this.lastConnectionEstablishedTime_ &&
          (new Date().getTime() - this.lastConnectionEstablishedTime_ > xj && (this.reconnectDelay_ = mu),
          (this.lastConnectionEstablishedTime_ = null))
        : (this.log_("Window isn't visible.  Delaying reconnect."),
          (this.reconnectDelay_ = this.maxReconnectDelay_),
          (this.lastConnectionAttemptTime_ = new Date().getTime()))
      const t = new Date().getTime() - this.lastConnectionAttemptTime_
      let n = Math.max(0, this.reconnectDelay_ - t)
      ;(n = Math.random() * n),
        this.log_('Trying to reconnect in ' + n + 'ms'),
        this.scheduleConnect_(n),
        (this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * Rj))
    }
    this.onConnectStatus_(!1)
  }
  async establishConnection_() {
    if (this.shouldReconnect_()) {
      this.log_('Making a connection attempt'),
        (this.lastConnectionAttemptTime_ = new Date().getTime()),
        (this.lastConnectionEstablishedTime_ = null)
      const t = this.onDataMessage_.bind(this),
        n = this.onReady_.bind(this),
        i = this.onRealtimeDisconnect_.bind(this),
        r = this.id + ':' + Dr.nextConnectionId_++,
        s = this.lastSessionId
      let o = !1,
        a = null
      const l = function () {
          a ? a.close() : ((o = !0), i())
        },
        u = function (d) {
          Pe(a, "sendRequest call when we're not connected not allowed."), a.sendRequest(d)
        }
      this.realtime_ = { close: l, sendRequest: u }
      const c = this.forceTokenRefresh_
      this.forceTokenRefresh_ = !1
      try {
        const [d, f] = await Promise.all([this.authTokenProvider_.getToken(c), this.appCheckTokenProvider_.getToken(c)])
        o
          ? Dn('getToken() completed but was canceled')
          : (Dn('getToken() completed. Creating connection.'),
            (this.authToken_ = d && d.accessToken),
            (this.appCheckToken_ = f && f.token),
            (a = new Ej(
              r,
              this.repoInfo_,
              this.applicationId_,
              this.appCheckToken_,
              this.authToken_,
              t,
              n,
              i,
              (m) => {
                fi(m + ' (' + this.repoInfo_.toString() + ')'), this.interrupt(Vj)
              },
              s
            )))
      } catch (d) {
        this.log_('Failed to get token: ' + d), o || (this.repoInfo_.nodeAdmin && fi(d), l())
      }
    }
  }
  interrupt(t) {
    Dn('Interrupting connection for reason: ' + t),
      (this.interruptReasons_[t] = !0),
      this.realtime_
        ? this.realtime_.close()
        : (this.establishConnectionTimer_ &&
            (clearTimeout(this.establishConnectionTimer_), (this.establishConnectionTimer_ = null)),
          this.connected_ && this.onRealtimeDisconnect_())
  }
  resume(t) {
    Dn('Resuming connection for reason: ' + t),
      delete this.interruptReasons_[t],
      Ov(this.interruptReasons_) && ((this.reconnectDelay_ = mu), this.realtime_ || this.scheduleConnect_(0))
  }
  handleTimestamp_(t) {
    const n = t - new Date().getTime()
    this.onServerInfoUpdate_({ serverTimeOffset: n })
  }
  cancelSentTransactions_() {
    for (let t = 0; t < this.outstandingPuts_.length; t++) {
      const n = this.outstandingPuts_[t]
      n &&
        'h' in n.request &&
        n.queued &&
        (n.onComplete && n.onComplete('disconnect'), delete this.outstandingPuts_[t], this.outstandingPutCount_--)
    }
    this.outstandingPutCount_ === 0 && (this.outstandingPuts_ = [])
  }
  onListenRevoked_(t, n) {
    let i
    n ? (i = n.map((s) => l_(s)).join('$')) : (i = 'default')
    const r = this.removeListen_(t, i)
    r && r.onComplete && r.onComplete('permission_denied')
  }
  removeListen_(t, n) {
    const i = new xt(t).toString()
    let r
    if (this.listens.has(i)) {
      const s = this.listens.get(i)
      ;(r = s.get(n)), s.delete(n), s.size === 0 && this.listens.delete(i)
    } else r = void 0
    return r
  }
  onAuthRevoked_(t, n) {
    Dn('Auth token revoked: ' + t + '/' + n),
      (this.authToken_ = null),
      (this.forceTokenRefresh_ = !0),
      this.realtime_.close(),
      (t === 'invalid_token' || t === 'permission_denied') &&
        (this.invalidAuthTokenCount_++,
        this.invalidAuthTokenCount_ >= rE &&
          ((this.reconnectDelay_ = iE), this.authTokenProvider_.notifyForInvalidToken()))
  }
  onAppCheckRevoked_(t, n) {
    Dn('App check token revoked: ' + t + '/' + n),
      (this.appCheckToken_ = null),
      (this.forceTokenRefresh_ = !0),
      (t === 'invalid_token' || t === 'permission_denied') &&
        (this.invalidAppCheckTokenCount_++,
        this.invalidAppCheckTokenCount_ >= rE && this.appCheckTokenProvider_.notifyForInvalidToken())
  }
  onSecurityDebugPacket_(t) {
    this.securityDebugCallback_
      ? this.securityDebugCallback_(t)
      : 'msg' in t &&
        console.log(
          'FIREBASE: ' +
            t.msg.replace(
              `
`,
              `
FIREBASE: `
            )
        )
  }
  restoreState_() {
    this.tryAuth(), this.tryAppCheck()
    for (const t of this.listens.values()) for (const n of t.values()) this.sendListen_(n)
    for (let t = 0; t < this.outstandingPuts_.length; t++) this.outstandingPuts_[t] && this.sendPut_(t)
    for (; this.onDisconnectRequestQueue_.length; ) {
      const t = this.onDisconnectRequestQueue_.shift()
      this.sendOnDisconnect_(t.action, t.pathString, t.data, t.onComplete)
    }
    for (let t = 0; t < this.outstandingGets_.length; t++) this.outstandingGets_[t] && this.sendGet_(t)
  }
  sendConnectStats_() {
    const t = {}
    let n = 'js'
    ;(t['sdk.' + n + '.' + sP.replace(/\./g, '-')] = 1),
      qy() ? (t['framework.cordova'] = 1) : ok() && (t['framework.reactnative'] = 1),
      this.reportStats(t)
  }
  shouldReconnect_() {
    const t = Qh.getInstance().currentlyOnline()
    return Ov(this.interruptReasons_) && t
  }
}
Dr.nextPersistentConnectionId_ = 0
Dr.nextConnectionId_ = 0
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class rt {
  constructor(t, n) {
    ;(this.name = t), (this.node = n)
  }
  static Wrap(t, n) {
    return new rt(t, n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Xf {
  getCompare() {
    return this.compare.bind(this)
  }
  indexedValueChanged(t, n) {
    const i = new rt(gl, t),
      r = new rt(gl, n)
    return this.compare(i, r) !== 0
  }
  minPost() {
    return rt.MIN
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Yd
class DP extends Xf {
  static get __EMPTY_NODE() {
    return Yd
  }
  static set __EMPTY_NODE(t) {
    Yd = t
  }
  compare(t, n) {
    return Bl(t.name, n.name)
  }
  isDefinedOn(t) {
    throw Ml('KeyIndex.isDefinedOn not expected to be called.')
  }
  indexedValueChanged(t, n) {
    return !1
  }
  minPost() {
    return rt.MIN
  }
  maxPost() {
    return new rt(No, Yd)
  }
  makePost(t, n) {
    return Pe(typeof t == 'string', 'KeyIndex indexValue must always be a string.'), new rt(t, Yd)
  }
  toString() {
    return '.key'
  }
}
const rl = new DP()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Qd = class {
    constructor(t, n, i, r, s = null) {
      ;(this.isReverse_ = r), (this.resultGenerator_ = s), (this.nodeStack_ = [])
      let o = 1
      for (; !t.isEmpty(); )
        if (((t = t), (o = n ? i(t.key, n) : 1), r && (o *= -1), o < 0)) this.isReverse_ ? (t = t.left) : (t = t.right)
        else if (o === 0) {
          this.nodeStack_.push(t)
          break
        } else this.nodeStack_.push(t), this.isReverse_ ? (t = t.right) : (t = t.left)
    }
    getNext() {
      if (this.nodeStack_.length === 0) return null
      let t = this.nodeStack_.pop(),
        n
      if (
        (this.resultGenerator_ ? (n = this.resultGenerator_(t.key, t.value)) : (n = { key: t.key, value: t.value }),
        this.isReverse_)
      )
        for (t = t.left; !t.isEmpty(); ) this.nodeStack_.push(t), (t = t.right)
      else for (t = t.right; !t.isEmpty(); ) this.nodeStack_.push(t), (t = t.left)
      return n
    }
    hasNext() {
      return this.nodeStack_.length > 0
    }
    peek() {
      if (this.nodeStack_.length === 0) return null
      const t = this.nodeStack_[this.nodeStack_.length - 1]
      return this.resultGenerator_ ? this.resultGenerator_(t.key, t.value) : { key: t.key, value: t.value }
    }
  },
  li = class Pu {
    constructor(t, n, i, r, s) {
      ;(this.key = t),
        (this.value = n),
        (this.color = i ?? Pu.RED),
        (this.left = r ?? nr.EMPTY_NODE),
        (this.right = s ?? nr.EMPTY_NODE)
    }
    copy(t, n, i, r, s) {
      return new Pu(t ?? this.key, n ?? this.value, i ?? this.color, r ?? this.left, s ?? this.right)
    }
    count() {
      return this.left.count() + 1 + this.right.count()
    }
    isEmpty() {
      return !1
    }
    inorderTraversal(t) {
      return this.left.inorderTraversal(t) || !!t(this.key, this.value) || this.right.inorderTraversal(t)
    }
    reverseTraversal(t) {
      return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t)
    }
    min_() {
      return this.left.isEmpty() ? this : this.left.min_()
    }
    minKey() {
      return this.min_().key
    }
    maxKey() {
      return this.right.isEmpty() ? this.key : this.right.maxKey()
    }
    insert(t, n, i) {
      let r = this
      const s = i(t, r.key)
      return (
        s < 0
          ? (r = r.copy(null, null, null, r.left.insert(t, n, i), null))
          : s === 0
          ? (r = r.copy(null, n, null, null, null))
          : (r = r.copy(null, null, null, null, r.right.insert(t, n, i))),
        r.fixUp_()
      )
    }
    removeMin_() {
      if (this.left.isEmpty()) return nr.EMPTY_NODE
      let t = this
      return (
        !t.left.isRed_() && !t.left.left.isRed_() && (t = t.moveRedLeft_()),
        (t = t.copy(null, null, null, t.left.removeMin_(), null)),
        t.fixUp_()
      )
    }
    remove(t, n) {
      let i, r
      if (((i = this), n(t, i.key) < 0))
        !i.left.isEmpty() && !i.left.isRed_() && !i.left.left.isRed_() && (i = i.moveRedLeft_()),
          (i = i.copy(null, null, null, i.left.remove(t, n), null))
      else {
        if (
          (i.left.isRed_() && (i = i.rotateRight_()),
          !i.right.isEmpty() && !i.right.isRed_() && !i.right.left.isRed_() && (i = i.moveRedRight_()),
          n(t, i.key) === 0)
        ) {
          if (i.right.isEmpty()) return nr.EMPTY_NODE
          ;(r = i.right.min_()), (i = i.copy(r.key, r.value, null, null, i.right.removeMin_()))
        }
        i = i.copy(null, null, null, null, i.right.remove(t, n))
      }
      return i.fixUp_()
    }
    isRed_() {
      return this.color
    }
    fixUp_() {
      let t = this
      return (
        t.right.isRed_() && !t.left.isRed_() && (t = t.rotateLeft_()),
        t.left.isRed_() && t.left.left.isRed_() && (t = t.rotateRight_()),
        t.left.isRed_() && t.right.isRed_() && (t = t.colorFlip_()),
        t
      )
    }
    moveRedLeft_() {
      let t = this.colorFlip_()
      return (
        t.right.left.isRed_() &&
          ((t = t.copy(null, null, null, null, t.right.rotateRight_())), (t = t.rotateLeft_()), (t = t.colorFlip_())),
        t
      )
    }
    moveRedRight_() {
      let t = this.colorFlip_()
      return t.left.left.isRed_() && ((t = t.rotateRight_()), (t = t.colorFlip_())), t
    }
    rotateLeft_() {
      const t = this.copy(null, null, Pu.RED, null, this.right.left)
      return this.right.copy(null, null, this.color, t, null)
    }
    rotateRight_() {
      const t = this.copy(null, null, Pu.RED, this.left.right, null)
      return this.left.copy(null, null, this.color, null, t)
    }
    colorFlip_() {
      const t = this.left.copy(null, null, !this.left.color, null, null),
        n = this.right.copy(null, null, !this.right.color, null, null)
      return this.copy(null, null, !this.color, t, n)
    }
    checkMaxDepth_() {
      const t = this.check_()
      return Math.pow(2, t) <= this.count() + 1
    }
    check_() {
      if (this.isRed_() && this.left.isRed_())
        throw new Error('Red node has red child(' + this.key + ',' + this.value + ')')
      if (this.right.isRed_()) throw new Error('Right child of (' + this.key + ',' + this.value + ') is red')
      const t = this.left.check_()
      if (t !== this.right.check_()) throw new Error('Black depths differ')
      return t + (this.isRed_() ? 0 : 1)
    }
  }
li.RED = !0
li.BLACK = !1
class Dj {
  copy(t, n, i, r, s) {
    return this
  }
  insert(t, n, i) {
    return new li(t, n, null)
  }
  remove(t, n) {
    return this
  }
  count() {
    return 0
  }
  isEmpty() {
    return !0
  }
  inorderTraversal(t) {
    return !1
  }
  reverseTraversal(t) {
    return !1
  }
  minKey() {
    return null
  }
  maxKey() {
    return null
  }
  check_() {
    return 0
  }
  isRed_() {
    return !1
  }
}
let nr = class bh {
  constructor(t, n = bh.EMPTY_NODE) {
    ;(this.comparator_ = t), (this.root_ = n)
  }
  insert(t, n) {
    return new bh(this.comparator_, this.root_.insert(t, n, this.comparator_).copy(null, null, li.BLACK, null, null))
  }
  remove(t) {
    return new bh(this.comparator_, this.root_.remove(t, this.comparator_).copy(null, null, li.BLACK, null, null))
  }
  get(t) {
    let n,
      i = this.root_
    for (; !i.isEmpty(); ) {
      if (((n = this.comparator_(t, i.key)), n === 0)) return i.value
      n < 0 ? (i = i.left) : n > 0 && (i = i.right)
    }
    return null
  }
  getPredecessorKey(t) {
    let n,
      i = this.root_,
      r = null
    for (; !i.isEmpty(); )
      if (((n = this.comparator_(t, i.key)), n === 0)) {
        if (i.left.isEmpty()) return r ? r.key : null
        for (i = i.left; !i.right.isEmpty(); ) i = i.right
        return i.key
      } else n < 0 ? (i = i.left) : n > 0 && ((r = i), (i = i.right))
    throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?')
  }
  isEmpty() {
    return this.root_.isEmpty()
  }
  count() {
    return this.root_.count()
  }
  minKey() {
    return this.root_.minKey()
  }
  maxKey() {
    return this.root_.maxKey()
  }
  inorderTraversal(t) {
    return this.root_.inorderTraversal(t)
  }
  reverseTraversal(t) {
    return this.root_.reverseTraversal(t)
  }
  getIterator(t) {
    return new Qd(this.root_, null, this.comparator_, !1, t)
  }
  getIteratorFrom(t, n) {
    return new Qd(this.root_, t, this.comparator_, !1, n)
  }
  getReverseIteratorFrom(t, n) {
    return new Qd(this.root_, t, this.comparator_, !0, n)
  }
  getReverseIterator(t) {
    return new Qd(this.root_, null, this.comparator_, !0, t)
  }
}
nr.EMPTY_NODE = new Dj()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Nj(e, t) {
  return Bl(e.name, t.name)
}
function f_(e, t) {
  return Bl(e, t)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Qv
function Oj(e) {
  Qv = e
}
const NP = function (e) {
    return typeof e == 'number' ? 'number:' + cP(e) : 'string:' + e
  },
  OP = function (e) {
    if (e.isLeafNode()) {
      const t = e.val()
      Pe(
        typeof t == 'string' || typeof t == 'number' || (typeof t == 'object' && Hr(t, '.sv')),
        'Priority must be a string or number.'
      )
    } else Pe(e === Qv || e.isEmpty(), 'priority of unexpected type.')
    Pe(e === Qv || e.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.")
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let sE
class un {
  constructor(t, n = un.__childrenNodeConstructor.EMPTY_NODE) {
    ;(this.value_ = t),
      (this.priorityNode_ = n),
      (this.lazyHash_ = null),
      Pe(this.value_ !== void 0 && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value."),
      OP(this.priorityNode_)
  }
  static set __childrenNodeConstructor(t) {
    sE = t
  }
  static get __childrenNodeConstructor() {
    return sE
  }
  isLeafNode() {
    return !0
  }
  getPriority() {
    return this.priorityNode_
  }
  updatePriority(t) {
    return new un(this.value_, t)
  }
  getImmediateChild(t) {
    return t === '.priority' ? this.priorityNode_ : un.__childrenNodeConstructor.EMPTY_NODE
  }
  getChild(t) {
    return et(t) ? this : it(t) === '.priority' ? this.priorityNode_ : un.__childrenNodeConstructor.EMPTY_NODE
  }
  hasChild() {
    return !1
  }
  getPredecessorChildName(t, n) {
    return null
  }
  updateImmediateChild(t, n) {
    return t === '.priority'
      ? this.updatePriority(n)
      : n.isEmpty() && t !== '.priority'
      ? this
      : un.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(t, n).updatePriority(this.priorityNode_)
  }
  updateChild(t, n) {
    const i = it(t)
    return i === null
      ? n
      : n.isEmpty() && i !== '.priority'
      ? this
      : (Pe(i !== '.priority' || Ds(t) === 1, '.priority must be the last token in a path'),
        this.updateImmediateChild(i, un.__childrenNodeConstructor.EMPTY_NODE.updateChild(kt(t), n)))
  }
  isEmpty() {
    return !1
  }
  numChildren() {
    return 0
  }
  forEachChild(t, n) {
    return !1
  }
  val(t) {
    return t && !this.getPriority().isEmpty()
      ? { '.value': this.getValue(), '.priority': this.getPriority().val() }
      : this.getValue()
  }
  hash() {
    if (this.lazyHash_ === null) {
      let t = ''
      this.priorityNode_.isEmpty() || (t += 'priority:' + NP(this.priorityNode_.val()) + ':')
      const n = typeof this.value_
      ;(t += n + ':'), n === 'number' ? (t += cP(this.value_)) : (t += this.value_), (this.lazyHash_ = aP(t))
    }
    return this.lazyHash_
  }
  getValue() {
    return this.value_
  }
  compareTo(t) {
    return t === un.__childrenNodeConstructor.EMPTY_NODE
      ? 1
      : t instanceof un.__childrenNodeConstructor
      ? -1
      : (Pe(t.isLeafNode(), 'Unknown node type'), this.compareToLeafNode_(t))
  }
  compareToLeafNode_(t) {
    const n = typeof t.value_,
      i = typeof this.value_,
      r = un.VALUE_TYPE_ORDER.indexOf(n),
      s = un.VALUE_TYPE_ORDER.indexOf(i)
    return (
      Pe(r >= 0, 'Unknown leaf type: ' + n),
      Pe(s >= 0, 'Unknown leaf type: ' + i),
      r === s ? (i === 'object' ? 0 : this.value_ < t.value_ ? -1 : this.value_ === t.value_ ? 0 : 1) : s - r
    )
  }
  withIndex() {
    return this
  }
  isIndexed() {
    return !0
  }
  equals(t) {
    if (t === this) return !0
    if (t.isLeafNode()) {
      const n = t
      return this.value_ === n.value_ && this.priorityNode_.equals(n.priorityNode_)
    } else return !1
  }
}
un.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string']
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let MP, LP
function Mj(e) {
  MP = e
}
function Lj(e) {
  LP = e
}
class Fj extends Xf {
  compare(t, n) {
    const i = t.node.getPriority(),
      r = n.node.getPriority(),
      s = i.compareTo(r)
    return s === 0 ? Bl(t.name, n.name) : s
  }
  isDefinedOn(t) {
    return !t.getPriority().isEmpty()
  }
  indexedValueChanged(t, n) {
    return !t.getPriority().equals(n.getPriority())
  }
  minPost() {
    return rt.MIN
  }
  maxPost() {
    return new rt(No, new un('[PRIORITY-POST]', LP))
  }
  makePost(t, n) {
    const i = MP(t)
    return new rt(n, new un('[PRIORITY-POST]', i))
  }
  toString() {
    return '.priority'
  }
}
const Ln = new Fj()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Bj = Math.log(2)
class $j {
  constructor(t) {
    const n = (s) => parseInt(Math.log(s) / Bj, 10),
      i = (s) => parseInt(Array(s + 1).join('1'), 2)
    ;(this.count = n(t + 1)), (this.current_ = this.count - 1)
    const r = i(this.count)
    this.bits_ = (t + 1) & r
  }
  nextBitIsOne() {
    const t = !(this.bits_ & (1 << this.current_))
    return this.current_--, t
  }
}
const Xh = function (e, t, n, i) {
  e.sort(t)
  const r = function (l, u) {
      const c = u - l
      let d, f
      if (c === 0) return null
      if (c === 1) return (d = e[l]), (f = n ? n(d) : d), new li(f, d.node, li.BLACK, null, null)
      {
        const m = parseInt(c / 2, 10) + l,
          p = r(l, m),
          v = r(m + 1, u)
        return (d = e[m]), (f = n ? n(d) : d), new li(f, d.node, li.BLACK, p, v)
      }
    },
    s = function (l) {
      let u = null,
        c = null,
        d = e.length
      const f = function (p, v) {
          const y = d - p,
            T = d
          d -= p
          const A = r(y + 1, T),
            x = e[y],
            N = n ? n(x) : x
          m(new li(N, x.node, v, null, A))
        },
        m = function (p) {
          u ? ((u.left = p), (u = p)) : ((c = p), (u = p))
        }
      for (let p = 0; p < l.count; ++p) {
        const v = l.nextBitIsOne(),
          y = Math.pow(2, l.count - (p + 1))
        v ? f(y, li.BLACK) : (f(y, li.BLACK), f(y, li.RED))
      }
      return c
    },
    o = new $j(e.length),
    a = s(o)
  return new nr(i || t, a)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Bg
const Aa = {}
class Rr {
  constructor(t, n) {
    ;(this.indexes_ = t), (this.indexSet_ = n)
  }
  static get Default() {
    return (
      Pe(Aa && Ln, 'ChildrenNode.ts has not been loaded'),
      (Bg = Bg || new Rr({ '.priority': Aa }, { '.priority': Ln })),
      Bg
    )
  }
  get(t) {
    const n = hl(this.indexes_, t)
    if (!n) throw new Error('No index defined for ' + t)
    return n instanceof nr ? n : null
  }
  hasIndex(t) {
    return Hr(this.indexSet_, t.toString())
  }
  addIndex(t, n) {
    Pe(t !== rl, "KeyIndex always exists and isn't meant to be added to the IndexMap.")
    const i = []
    let r = !1
    const s = n.getIterator(rt.Wrap)
    let o = s.getNext()
    for (; o; ) (r = r || t.isDefinedOn(o.node)), i.push(o), (o = s.getNext())
    let a
    r ? (a = Xh(i, t.getCompare())) : (a = Aa)
    const l = t.toString(),
      u = Object.assign({}, this.indexSet_)
    u[l] = t
    const c = Object.assign({}, this.indexes_)
    return (c[l] = a), new Rr(c, u)
  }
  addToIndexes(t, n) {
    const i = Uh(this.indexes_, (r, s) => {
      const o = hl(this.indexSet_, s)
      if ((Pe(o, 'Missing index implementation for ' + s), r === Aa))
        if (o.isDefinedOn(t.node)) {
          const a = [],
            l = n.getIterator(rt.Wrap)
          let u = l.getNext()
          for (; u; ) u.name !== t.name && a.push(u), (u = l.getNext())
          return a.push(t), Xh(a, o.getCompare())
        } else return Aa
      else {
        const a = n.get(t.name)
        let l = r
        return a && (l = l.remove(new rt(t.name, a))), l.insert(t, t.node)
      }
    })
    return new Rr(i, this.indexSet_)
  }
  removeFromIndexes(t, n) {
    const i = Uh(this.indexes_, (r) => {
      if (r === Aa) return r
      {
        const s = n.get(t.name)
        return s ? r.remove(new rt(t.name, s)) : r
      }
    })
    return new Rr(i, this.indexSet_)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let gu
class ft {
  constructor(t, n, i) {
    ;(this.children_ = t),
      (this.priorityNode_ = n),
      (this.indexMap_ = i),
      (this.lazyHash_ = null),
      this.priorityNode_ && OP(this.priorityNode_),
      this.children_.isEmpty() &&
        Pe(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority')
  }
  static get EMPTY_NODE() {
    return gu || (gu = new ft(new nr(f_), null, Rr.Default))
  }
  isLeafNode() {
    return !1
  }
  getPriority() {
    return this.priorityNode_ || gu
  }
  updatePriority(t) {
    return this.children_.isEmpty() ? this : new ft(this.children_, t, this.indexMap_)
  }
  getImmediateChild(t) {
    if (t === '.priority') return this.getPriority()
    {
      const n = this.children_.get(t)
      return n === null ? gu : n
    }
  }
  getChild(t) {
    const n = it(t)
    return n === null ? this : this.getImmediateChild(n).getChild(kt(t))
  }
  hasChild(t) {
    return this.children_.get(t) !== null
  }
  updateImmediateChild(t, n) {
    if ((Pe(n, 'We should always be passing snapshot nodes'), t === '.priority')) return this.updatePriority(n)
    {
      const i = new rt(t, n)
      let r, s
      n.isEmpty()
        ? ((r = this.children_.remove(t)), (s = this.indexMap_.removeFromIndexes(i, this.children_)))
        : ((r = this.children_.insert(t, n)), (s = this.indexMap_.addToIndexes(i, this.children_)))
      const o = r.isEmpty() ? gu : this.priorityNode_
      return new ft(r, o, s)
    }
  }
  updateChild(t, n) {
    const i = it(t)
    if (i === null) return n
    {
      Pe(it(t) !== '.priority' || Ds(t) === 1, '.priority must be the last token in a path')
      const r = this.getImmediateChild(i).updateChild(kt(t), n)
      return this.updateImmediateChild(i, r)
    }
  }
  isEmpty() {
    return this.children_.isEmpty()
  }
  numChildren() {
    return this.children_.count()
  }
  val(t) {
    if (this.isEmpty()) return null
    const n = {}
    let i = 0,
      r = 0,
      s = !0
    if (
      (this.forEachChild(Ln, (o, a) => {
        ;(n[o] = a.val(t)), i++, s && ft.INTEGER_REGEXP_.test(o) ? (r = Math.max(r, Number(o))) : (s = !1)
      }),
      !t && s && r < 2 * i)
    ) {
      const o = []
      for (const a in n) o[a] = n[a]
      return o
    } else return t && !this.getPriority().isEmpty() && (n['.priority'] = this.getPriority().val()), n
  }
  hash() {
    if (this.lazyHash_ === null) {
      let t = ''
      this.getPriority().isEmpty() || (t += 'priority:' + NP(this.getPriority().val()) + ':'),
        this.forEachChild(Ln, (n, i) => {
          const r = i.hash()
          r !== '' && (t += ':' + n + ':' + r)
        }),
        (this.lazyHash_ = t === '' ? '' : aP(t))
    }
    return this.lazyHash_
  }
  getPredecessorChildName(t, n, i) {
    const r = this.resolveIndex_(i)
    if (r) {
      const s = r.getPredecessorKey(new rt(t, n))
      return s ? s.name : null
    } else return this.children_.getPredecessorKey(t)
  }
  getFirstChildName(t) {
    const n = this.resolveIndex_(t)
    if (n) {
      const i = n.minKey()
      return i && i.name
    } else return this.children_.minKey()
  }
  getFirstChild(t) {
    const n = this.getFirstChildName(t)
    return n ? new rt(n, this.children_.get(n)) : null
  }
  getLastChildName(t) {
    const n = this.resolveIndex_(t)
    if (n) {
      const i = n.maxKey()
      return i && i.name
    } else return this.children_.maxKey()
  }
  getLastChild(t) {
    const n = this.getLastChildName(t)
    return n ? new rt(n, this.children_.get(n)) : null
  }
  forEachChild(t, n) {
    const i = this.resolveIndex_(t)
    return i ? i.inorderTraversal((r) => n(r.name, r.node)) : this.children_.inorderTraversal(n)
  }
  getIterator(t) {
    return this.getIteratorFrom(t.minPost(), t)
  }
  getIteratorFrom(t, n) {
    const i = this.resolveIndex_(n)
    if (i) return i.getIteratorFrom(t, (r) => r)
    {
      const r = this.children_.getIteratorFrom(t.name, rt.Wrap)
      let s = r.peek()
      for (; s != null && n.compare(s, t) < 0; ) r.getNext(), (s = r.peek())
      return r
    }
  }
  getReverseIterator(t) {
    return this.getReverseIteratorFrom(t.maxPost(), t)
  }
  getReverseIteratorFrom(t, n) {
    const i = this.resolveIndex_(n)
    if (i) return i.getReverseIteratorFrom(t, (r) => r)
    {
      const r = this.children_.getReverseIteratorFrom(t.name, rt.Wrap)
      let s = r.peek()
      for (; s != null && n.compare(s, t) > 0; ) r.getNext(), (s = r.peek())
      return r
    }
  }
  compareTo(t) {
    return this.isEmpty() ? (t.isEmpty() ? 0 : -1) : t.isLeafNode() || t.isEmpty() ? 1 : t === Qc ? -1 : 0
  }
  withIndex(t) {
    if (t === rl || this.indexMap_.hasIndex(t)) return this
    {
      const n = this.indexMap_.addIndex(t, this.children_)
      return new ft(this.children_, this.priorityNode_, n)
    }
  }
  isIndexed(t) {
    return t === rl || this.indexMap_.hasIndex(t)
  }
  equals(t) {
    if (t === this) return !0
    if (t.isLeafNode()) return !1
    {
      const n = t
      if (this.getPriority().equals(n.getPriority()))
        if (this.children_.count() === n.children_.count()) {
          const i = this.getIterator(Ln),
            r = n.getIterator(Ln)
          let s = i.getNext(),
            o = r.getNext()
          for (; s && o; ) {
            if (s.name !== o.name || !s.node.equals(o.node)) return !1
            ;(s = i.getNext()), (o = r.getNext())
          }
          return s === null && o === null
        } else return !1
      else return !1
    }
  }
  resolveIndex_(t) {
    return t === rl ? null : this.indexMap_.get(t.toString())
  }
}
ft.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/
class Uj extends ft {
  constructor() {
    super(new nr(f_), ft.EMPTY_NODE, Rr.Default)
  }
  compareTo(t) {
    return t === this ? 0 : 1
  }
  equals(t) {
    return t === this
  }
  getPriority() {
    return this
  }
  getImmediateChild(t) {
    return ft.EMPTY_NODE
  }
  isEmpty() {
    return !1
  }
}
const Qc = new Uj()
Object.defineProperties(rt, { MIN: { value: new rt(gl, ft.EMPTY_NODE) }, MAX: { value: new rt(No, Qc) } })
DP.__EMPTY_NODE = ft.EMPTY_NODE
un.__childrenNodeConstructor = ft
Oj(Qc)
Lj(Qc)
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const jj = !0
function Nn(e, t = null) {
  if (e === null) return ft.EMPTY_NODE
  if (
    (typeof e == 'object' && '.priority' in e && (t = e['.priority']),
    Pe(
      t === null || typeof t == 'string' || typeof t == 'number' || (typeof t == 'object' && '.sv' in t),
      'Invalid priority type found: ' + typeof t
    ),
    typeof e == 'object' && '.value' in e && e['.value'] !== null && (e = e['.value']),
    typeof e != 'object' || '.sv' in e)
  ) {
    const n = e
    return new un(n, Nn(t))
  }
  if (!(e instanceof Array) && jj) {
    const n = []
    let i = !1
    if (
      (xi(e, (o, a) => {
        if (o.substring(0, 1) !== '.') {
          const l = Nn(a)
          l.isEmpty() || ((i = i || !l.getPriority().isEmpty()), n.push(new rt(o, l)))
        }
      }),
      n.length === 0)
    )
      return ft.EMPTY_NODE
    const s = Xh(n, Nj, (o) => o.name, f_)
    if (i) {
      const o = Xh(n, Ln.getCompare())
      return new ft(s, Nn(t), new Rr({ '.priority': o }, { '.priority': Ln }))
    } else return new ft(s, Nn(t), Rr.Default)
  } else {
    let n = ft.EMPTY_NODE
    return (
      xi(e, (i, r) => {
        if (Hr(e, i) && i.substring(0, 1) !== '.') {
          const s = Nn(r)
          ;(s.isLeafNode() || !s.isEmpty()) && (n = n.updateImmediateChild(i, s))
        }
      }),
      n.updatePriority(Nn(t))
    )
  }
}
Mj(Nn)
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class zj extends Xf {
  constructor(t) {
    super(),
      (this.indexPath_ = t),
      Pe(!et(t) && it(t) !== '.priority', "Can't create PathIndex with empty path or .priority key")
  }
  extractChild(t) {
    return t.getChild(this.indexPath_)
  }
  isDefinedOn(t) {
    return !t.getChild(this.indexPath_).isEmpty()
  }
  compare(t, n) {
    const i = this.extractChild(t.node),
      r = this.extractChild(n.node),
      s = i.compareTo(r)
    return s === 0 ? Bl(t.name, n.name) : s
  }
  makePost(t, n) {
    const i = Nn(t),
      r = ft.EMPTY_NODE.updateChild(this.indexPath_, i)
    return new rt(n, r)
  }
  maxPost() {
    const t = ft.EMPTY_NODE.updateChild(this.indexPath_, Qc)
    return new rt(No, t)
  }
  toString() {
    return PP(this.indexPath_, 0).join('/')
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Hj extends Xf {
  compare(t, n) {
    const i = t.node.compareTo(n.node)
    return i === 0 ? Bl(t.name, n.name) : i
  }
  isDefinedOn(t) {
    return !0
  }
  indexedValueChanged(t, n) {
    return !t.equals(n)
  }
  minPost() {
    return rt.MIN
  }
  maxPost() {
    return rt.MAX
  }
  makePost(t, n) {
    const i = Nn(t)
    return new rt(n, i)
  }
  toString() {
    return '.value'
  }
}
const Wj = new Hj()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function qj(e) {
  return { type: 'value', snapshotNode: e }
}
function Gj(e, t) {
  return { type: 'child_added', snapshotNode: t, childName: e }
}
function Kj(e, t) {
  return { type: 'child_removed', snapshotNode: t, childName: e }
}
function oE(e, t, n) {
  return { type: 'child_changed', snapshotNode: t, childName: e, oldSnap: n }
}
function Yj(e, t) {
  return { type: 'child_moved', snapshotNode: t, childName: e }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class m_ {
  constructor() {
    ;(this.limitSet_ = !1),
      (this.startSet_ = !1),
      (this.startNameSet_ = !1),
      (this.startAfterSet_ = !1),
      (this.endSet_ = !1),
      (this.endNameSet_ = !1),
      (this.endBeforeSet_ = !1),
      (this.limit_ = 0),
      (this.viewFrom_ = ''),
      (this.indexStartValue_ = null),
      (this.indexStartName_ = ''),
      (this.indexEndValue_ = null),
      (this.indexEndName_ = ''),
      (this.index_ = Ln)
  }
  hasStart() {
    return this.startSet_
  }
  isViewFromLeft() {
    return this.viewFrom_ === '' ? this.startSet_ : this.viewFrom_ === 'l'
  }
  getIndexStartValue() {
    return Pe(this.startSet_, 'Only valid if start has been set'), this.indexStartValue_
  }
  getIndexStartName() {
    return Pe(this.startSet_, 'Only valid if start has been set'), this.startNameSet_ ? this.indexStartName_ : gl
  }
  hasEnd() {
    return this.endSet_
  }
  getIndexEndValue() {
    return Pe(this.endSet_, 'Only valid if end has been set'), this.indexEndValue_
  }
  getIndexEndName() {
    return Pe(this.endSet_, 'Only valid if end has been set'), this.endNameSet_ ? this.indexEndName_ : No
  }
  hasLimit() {
    return this.limitSet_
  }
  hasAnchoredLimit() {
    return this.limitSet_ && this.viewFrom_ !== ''
  }
  getLimit() {
    return Pe(this.limitSet_, 'Only valid if limit has been set'), this.limit_
  }
  getIndex() {
    return this.index_
  }
  loadsAllData() {
    return !(this.startSet_ || this.endSet_ || this.limitSet_)
  }
  isDefault() {
    return this.loadsAllData() && this.index_ === Ln
  }
  copy() {
    const t = new m_()
    return (
      (t.limitSet_ = this.limitSet_),
      (t.limit_ = this.limit_),
      (t.startSet_ = this.startSet_),
      (t.startAfterSet_ = this.startAfterSet_),
      (t.indexStartValue_ = this.indexStartValue_),
      (t.startNameSet_ = this.startNameSet_),
      (t.indexStartName_ = this.indexStartName_),
      (t.endSet_ = this.endSet_),
      (t.endBeforeSet_ = this.endBeforeSet_),
      (t.indexEndValue_ = this.indexEndValue_),
      (t.endNameSet_ = this.endNameSet_),
      (t.indexEndName_ = this.indexEndName_),
      (t.index_ = this.index_),
      (t.viewFrom_ = this.viewFrom_),
      t
    )
  }
}
function aE(e) {
  const t = {}
  if (e.isDefault()) return t
  let n
  if (
    (e.index_ === Ln
      ? (n = '$priority')
      : e.index_ === Wj
      ? (n = '$value')
      : e.index_ === rl
      ? (n = '$key')
      : (Pe(e.index_ instanceof zj, 'Unrecognized index type!'), (n = e.index_.toString())),
    (t.orderBy = Sn(n)),
    e.startSet_)
  ) {
    const i = e.startAfterSet_ ? 'startAfter' : 'startAt'
    ;(t[i] = Sn(e.indexStartValue_)), e.startNameSet_ && (t[i] += ',' + Sn(e.indexStartName_))
  }
  if (e.endSet_) {
    const i = e.endBeforeSet_ ? 'endBefore' : 'endAt'
    ;(t[i] = Sn(e.indexEndValue_)), e.endNameSet_ && (t[i] += ',' + Sn(e.indexEndName_))
  }
  return e.limitSet_ && (e.isViewFromLeft() ? (t.limitToFirst = e.limit_) : (t.limitToLast = e.limit_)), t
}
function lE(e) {
  const t = {}
  if (
    (e.startSet_ &&
      ((t.sp = e.indexStartValue_), e.startNameSet_ && (t.sn = e.indexStartName_), (t.sin = !e.startAfterSet_)),
    e.endSet_ && ((t.ep = e.indexEndValue_), e.endNameSet_ && (t.en = e.indexEndName_), (t.ein = !e.endBeforeSet_)),
    e.limitSet_)
  ) {
    t.l = e.limit_
    let n = e.viewFrom_
    n === '' && (e.isViewFromLeft() ? (n = 'l') : (n = 'r')), (t.vf = n)
  }
  return e.index_ !== Ln && (t.i = e.index_.toString()), t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Jh extends CP {
  constructor(t, n, i, r) {
    super(),
      (this.repoInfo_ = t),
      (this.onDataUpdate_ = n),
      (this.authTokenProvider_ = i),
      (this.appCheckTokenProvider_ = r),
      (this.log_ = Kc('p:rest:')),
      (this.listens_ = {})
  }
  reportStats(t) {
    throw new Error('Method not implemented.')
  }
  static getListenId_(t, n) {
    return n !== void 0
      ? 'tag$' + n
      : (Pe(t._queryParams.isDefault(), "should have a tag if it's not a default query."), t._path.toString())
  }
  listen(t, n, i, r) {
    const s = t._path.toString()
    this.log_('Listen called for ' + s + ' ' + t._queryIdentifier)
    const o = Jh.getListenId_(t, i),
      a = {}
    this.listens_[o] = a
    const l = aE(t._queryParams)
    this.restRequest_(s + '.json', l, (u, c) => {
      let d = c
      if (
        (u === 404 && ((d = null), (u = null)),
        u === null && this.onDataUpdate_(s, d, !1, i),
        hl(this.listens_, o) === a)
      ) {
        let f
        u ? (u === 401 ? (f = 'permission_denied') : (f = 'rest_error:' + u)) : (f = 'ok'), r(f, null)
      }
    })
  }
  unlisten(t, n) {
    const i = Jh.getListenId_(t, n)
    delete this.listens_[i]
  }
  get(t) {
    const n = aE(t._queryParams),
      i = t._path.toString(),
      r = new ac()
    return (
      this.restRequest_(i + '.json', n, (s, o) => {
        let a = o
        s === 404 && ((a = null), (s = null)),
          s === null ? (this.onDataUpdate_(i, a, !1, null), r.resolve(a)) : r.reject(new Error(a))
      }),
      r.promise
    )
  }
  refreshAuthToken(t) {}
  restRequest_(t, n = {}, i) {
    return (
      (n.format = 'export'),
      Promise.all([this.authTokenProvider_.getToken(!1), this.appCheckTokenProvider_.getToken(!1)]).then(([r, s]) => {
        r && r.accessToken && (n.auth = r.accessToken), s && s.token && (n.ac = s.token)
        const o =
          (this.repoInfo_.secure ? 'https://' : 'http://') +
          this.repoInfo_.host +
          t +
          '?ns=' +
          this.repoInfo_.namespace +
          Ll(n)
        this.log_('Sending REST request for ' + o)
        const a = new XMLHttpRequest()
        ;(a.onreadystatechange = () => {
          if (i && a.readyState === 4) {
            this.log_('REST Response for ' + o + ' received. status:', a.status, 'response:', a.responseText)
            let l = null
            if (a.status >= 200 && a.status < 300) {
              try {
                l = lc(a.responseText)
              } catch {
                fi('Failed to parse JSON response for ' + o + ': ' + a.responseText)
              }
              i(null, l)
            } else
              a.status !== 401 &&
                a.status !== 404 &&
                fi('Got unsuccessful REST response for ' + o + ' Status: ' + a.status),
                i(a.status)
            i = null
          }
        }),
          a.open('GET', o, !0),
          a.send()
      })
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Qj {
  constructor() {
    this.rootNode_ = ft.EMPTY_NODE
  }
  getNode(t) {
    return this.rootNode_.getChild(t)
  }
  updateSnapshot(t, n) {
    this.rootNode_ = this.rootNode_.updateChild(t, n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Zh() {
  return { value: null, children: new Map() }
}
function FP(e, t, n) {
  if (et(t)) (e.value = n), e.children.clear()
  else if (e.value !== null) e.value = e.value.updateChild(t, n)
  else {
    const i = it(t)
    e.children.has(i) || e.children.set(i, Zh())
    const r = e.children.get(i)
    ;(t = kt(t)), FP(r, t, n)
  }
}
function Xv(e, t, n) {
  e.value !== null
    ? n(t, e.value)
    : Xj(e, (i, r) => {
        const s = new xt(t.toString() + '/' + i)
        Xv(r, s, n)
      })
}
function Xj(e, t) {
  e.children.forEach((n, i) => {
    t(i, n)
  })
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Jj {
  constructor(t) {
    ;(this.collection_ = t), (this.last_ = null)
  }
  get() {
    const t = this.collection_.get(),
      n = Object.assign({}, t)
    return (
      this.last_ &&
        xi(this.last_, (i, r) => {
          n[i] = n[i] - r
        }),
      (this.last_ = t),
      n
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const uE = 10 * 1e3,
  Zj = 30 * 1e3,
  ez = 5 * 60 * 1e3
class tz {
  constructor(t, n) {
    ;(this.server_ = n), (this.statsToReport_ = {}), (this.statsListener_ = new Jj(t))
    const i = uE + (Zj - uE) * Math.random()
    Hu(this.reportStats_.bind(this), Math.floor(i))
  }
  reportStats_() {
    const t = this.statsListener_.get(),
      n = {}
    let i = !1
    xi(t, (r, s) => {
      s > 0 && Hr(this.statsToReport_, r) && ((n[r] = s), (i = !0))
    }),
      i && this.server_.reportStats(n),
      Hu(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * ez))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var ir
;(function (e) {
  ;(e[(e.OVERWRITE = 0)] = 'OVERWRITE'),
    (e[(e.MERGE = 1)] = 'MERGE'),
    (e[(e.ACK_USER_WRITE = 2)] = 'ACK_USER_WRITE'),
    (e[(e.LISTEN_COMPLETE = 3)] = 'LISTEN_COMPLETE')
})(ir || (ir = {}))
function BP() {
  return { fromUser: !0, fromServer: !1, queryId: null, tagged: !1 }
}
function $P() {
  return { fromUser: !1, fromServer: !0, queryId: null, tagged: !1 }
}
function UP(e) {
  return { fromUser: !1, fromServer: !0, queryId: e, tagged: !0 }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ef {
  constructor(t, n, i) {
    ;(this.path = t), (this.affectedTree = n), (this.revert = i), (this.type = ir.ACK_USER_WRITE), (this.source = BP())
  }
  operationForChild(t) {
    if (et(this.path)) {
      if (this.affectedTree.value != null)
        return (
          Pe(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.'), this
        )
      {
        const n = this.affectedTree.subtree(new xt(t))
        return new ef(yt(), n, this.revert)
      }
    } else
      return (
        Pe(it(this.path) === t, 'operationForChild called for unrelated child.'),
        new ef(kt(this.path), this.affectedTree, this.revert)
      )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Oo {
  constructor(t, n, i) {
    ;(this.source = t), (this.path = n), (this.snap = i), (this.type = ir.OVERWRITE)
  }
  operationForChild(t) {
    return et(this.path)
      ? new Oo(this.source, yt(), this.snap.getImmediateChild(t))
      : new Oo(this.source, kt(this.path), this.snap)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class fc {
  constructor(t, n, i) {
    ;(this.source = t), (this.path = n), (this.children = i), (this.type = ir.MERGE)
  }
  operationForChild(t) {
    if (et(this.path)) {
      const n = this.children.subtree(new xt(t))
      return n.isEmpty() ? null : n.value ? new Oo(this.source, yt(), n.value) : new fc(this.source, yt(), n)
    } else
      return (
        Pe(it(this.path) === t, "Can't get a merge for a child not on the path of the operation"),
        new fc(this.source, kt(this.path), this.children)
      )
  }
  toString() {
    return 'Operation(' + this.path + ': ' + this.source.toString() + ' merge: ' + this.children.toString() + ')'
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class g_ {
  constructor(t, n, i) {
    ;(this.node_ = t), (this.fullyInitialized_ = n), (this.filtered_ = i)
  }
  isFullyInitialized() {
    return this.fullyInitialized_
  }
  isFiltered() {
    return this.filtered_
  }
  isCompleteForPath(t) {
    if (et(t)) return this.isFullyInitialized() && !this.filtered_
    const n = it(t)
    return this.isCompleteForChild(n)
  }
  isCompleteForChild(t) {
    return (this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(t)
  }
  getNode() {
    return this.node_
  }
}
function nz(e, t, n, i) {
  const r = [],
    s = []
  return (
    t.forEach((o) => {
      o.type === 'child_changed' &&
        e.index_.indexedValueChanged(o.oldSnap, o.snapshotNode) &&
        s.push(Yj(o.childName, o.snapshotNode))
    }),
    vu(e, r, 'child_removed', t, i, n),
    vu(e, r, 'child_added', t, i, n),
    vu(e, r, 'child_moved', s, i, n),
    vu(e, r, 'child_changed', t, i, n),
    vu(e, r, 'value', t, i, n),
    r
  )
}
function vu(e, t, n, i, r, s) {
  const o = i.filter((a) => a.type === n)
  o.sort((a, l) => rz(e, a, l)),
    o.forEach((a) => {
      const l = iz(e, a, s)
      r.forEach((u) => {
        u.respondsTo(a.type) && t.push(u.createEvent(l, e.query_))
      })
    })
}
function iz(e, t, n) {
  return (
    t.type === 'value' ||
      t.type === 'child_removed' ||
      (t.prevName = n.getPredecessorChildName(t.childName, t.snapshotNode, e.index_)),
    t
  )
}
function rz(e, t, n) {
  if (t.childName == null || n.childName == null) throw Ml('Should only compare child_ events.')
  const i = new rt(t.childName, t.snapshotNode),
    r = new rt(n.childName, n.snapshotNode)
  return e.index_.compare(i, r)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function jP(e, t) {
  return { eventCache: e, serverCache: t }
}
function Wu(e, t, n, i) {
  return jP(new g_(t, n, i), e.serverCache)
}
function zP(e, t, n, i) {
  return jP(e.eventCache, new g_(t, n, i))
}
function Jv(e) {
  return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null
}
function Mo(e) {
  return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let $g
const sz = () => ($g || ($g = new nr(H4)), $g)
class At {
  constructor(t, n = sz()) {
    ;(this.value = t), (this.children = n)
  }
  static fromObject(t) {
    let n = new At(null)
    return (
      xi(t, (i, r) => {
        n = n.set(new xt(i), r)
      }),
      n
    )
  }
  isEmpty() {
    return this.value === null && this.children.isEmpty()
  }
  findRootMostMatchingPathAndValue(t, n) {
    if (this.value != null && n(this.value)) return { path: yt(), value: this.value }
    if (et(t)) return null
    {
      const i = it(t),
        r = this.children.get(i)
      if (r !== null) {
        const s = r.findRootMostMatchingPathAndValue(kt(t), n)
        return s != null ? { path: hn(new xt(i), s.path), value: s.value } : null
      } else return null
    }
  }
  findRootMostValueAndPath(t) {
    return this.findRootMostMatchingPathAndValue(t, () => !0)
  }
  subtree(t) {
    if (et(t)) return this
    {
      const n = it(t),
        i = this.children.get(n)
      return i !== null ? i.subtree(kt(t)) : new At(null)
    }
  }
  set(t, n) {
    if (et(t)) return new At(n, this.children)
    {
      const i = it(t),
        s = (this.children.get(i) || new At(null)).set(kt(t), n),
        o = this.children.insert(i, s)
      return new At(this.value, o)
    }
  }
  remove(t) {
    if (et(t)) return this.children.isEmpty() ? new At(null) : new At(null, this.children)
    {
      const n = it(t),
        i = this.children.get(n)
      if (i) {
        const r = i.remove(kt(t))
        let s
        return (
          r.isEmpty() ? (s = this.children.remove(n)) : (s = this.children.insert(n, r)),
          this.value === null && s.isEmpty() ? new At(null) : new At(this.value, s)
        )
      } else return this
    }
  }
  get(t) {
    if (et(t)) return this.value
    {
      const n = it(t),
        i = this.children.get(n)
      return i ? i.get(kt(t)) : null
    }
  }
  setTree(t, n) {
    if (et(t)) return n
    {
      const i = it(t),
        s = (this.children.get(i) || new At(null)).setTree(kt(t), n)
      let o
      return s.isEmpty() ? (o = this.children.remove(i)) : (o = this.children.insert(i, s)), new At(this.value, o)
    }
  }
  fold(t) {
    return this.fold_(yt(), t)
  }
  fold_(t, n) {
    const i = {}
    return (
      this.children.inorderTraversal((r, s) => {
        i[r] = s.fold_(hn(t, r), n)
      }),
      n(t, this.value, i)
    )
  }
  findOnPath(t, n) {
    return this.findOnPath_(t, yt(), n)
  }
  findOnPath_(t, n, i) {
    const r = this.value ? i(n, this.value) : !1
    if (r) return r
    if (et(t)) return null
    {
      const s = it(t),
        o = this.children.get(s)
      return o ? o.findOnPath_(kt(t), hn(n, s), i) : null
    }
  }
  foreachOnPath(t, n) {
    return this.foreachOnPath_(t, yt(), n)
  }
  foreachOnPath_(t, n, i) {
    if (et(t)) return this
    {
      this.value && i(n, this.value)
      const r = it(t),
        s = this.children.get(r)
      return s ? s.foreachOnPath_(kt(t), hn(n, r), i) : new At(null)
    }
  }
  foreach(t) {
    this.foreach_(yt(), t)
  }
  foreach_(t, n) {
    this.children.inorderTraversal((i, r) => {
      r.foreach_(hn(t, i), n)
    }),
      this.value && n(t, this.value)
  }
  foreachChild(t) {
    this.children.inorderTraversal((n, i) => {
      i.value && t(n, i.value)
    })
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class zi {
  constructor(t) {
    this.writeTree_ = t
  }
  static empty() {
    return new zi(new At(null))
  }
}
function qu(e, t, n) {
  if (et(t)) return new zi(new At(n))
  {
    const i = e.writeTree_.findRootMostValueAndPath(t)
    if (i != null) {
      const r = i.path
      let s = i.value
      const o = Ti(r, t)
      return (s = s.updateChild(o, n)), new zi(e.writeTree_.set(r, s))
    } else {
      const r = new At(n),
        s = e.writeTree_.setTree(t, r)
      return new zi(s)
    }
  }
}
function cE(e, t, n) {
  let i = e
  return (
    xi(n, (r, s) => {
      i = qu(i, hn(t, r), s)
    }),
    i
  )
}
function dE(e, t) {
  if (et(t)) return zi.empty()
  {
    const n = e.writeTree_.setTree(t, new At(null))
    return new zi(n)
  }
}
function Zv(e, t) {
  return sa(e, t) != null
}
function sa(e, t) {
  const n = e.writeTree_.findRootMostValueAndPath(t)
  return n != null ? e.writeTree_.get(n.path).getChild(Ti(n.path, t)) : null
}
function hE(e) {
  const t = [],
    n = e.writeTree_.value
  return (
    n != null
      ? n.isLeafNode() ||
        n.forEachChild(Ln, (i, r) => {
          t.push(new rt(i, r))
        })
      : e.writeTree_.children.inorderTraversal((i, r) => {
          r.value != null && t.push(new rt(i, r.value))
        }),
    t
  )
}
function ks(e, t) {
  if (et(t)) return e
  {
    const n = sa(e, t)
    return n != null ? new zi(new At(n)) : new zi(e.writeTree_.subtree(t))
  }
}
function ep(e) {
  return e.writeTree_.isEmpty()
}
function vl(e, t) {
  return HP(yt(), e.writeTree_, t)
}
function HP(e, t, n) {
  if (t.value != null) return n.updateChild(e, t.value)
  {
    let i = null
    return (
      t.children.inorderTraversal((r, s) => {
        r === '.priority'
          ? (Pe(s.value !== null, 'Priority writes must always be leaf nodes'), (i = s.value))
          : (n = HP(hn(e, r), s, n))
      }),
      !n.getChild(e).isEmpty() && i !== null && (n = n.updateChild(hn(e, '.priority'), i)),
      n
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function WP(e, t) {
  return QP(t, e)
}
function oz(e, t, n, i, r) {
  Pe(i > e.lastWriteId, 'Stacking an older write on top of newer ones'),
    r === void 0 && (r = !0),
    e.allWrites.push({ path: t, snap: n, writeId: i, visible: r }),
    r && (e.visibleWrites = qu(e.visibleWrites, t, n)),
    (e.lastWriteId = i)
}
function az(e, t) {
  for (let n = 0; n < e.allWrites.length; n++) {
    const i = e.allWrites[n]
    if (i.writeId === t) return i
  }
  return null
}
function lz(e, t) {
  const n = e.allWrites.findIndex((a) => a.writeId === t)
  Pe(n >= 0, 'removeWrite called with nonexistent writeId.')
  const i = e.allWrites[n]
  e.allWrites.splice(n, 1)
  let r = i.visible,
    s = !1,
    o = e.allWrites.length - 1
  for (; r && o >= 0; ) {
    const a = e.allWrites[o]
    a.visible && (o >= n && uz(a, i.path) ? (r = !1) : ji(i.path, a.path) && (s = !0)), o--
  }
  if (r) {
    if (s) return cz(e), !0
    if (i.snap) e.visibleWrites = dE(e.visibleWrites, i.path)
    else {
      const a = i.children
      xi(a, (l) => {
        e.visibleWrites = dE(e.visibleWrites, hn(i.path, l))
      })
    }
    return !0
  } else return !1
}
function uz(e, t) {
  if (e.snap) return ji(e.path, t)
  for (const n in e.children) if (e.children.hasOwnProperty(n) && ji(hn(e.path, n), t)) return !0
  return !1
}
function cz(e) {
  ;(e.visibleWrites = qP(e.allWrites, dz, yt())),
    e.allWrites.length > 0 ? (e.lastWriteId = e.allWrites[e.allWrites.length - 1].writeId) : (e.lastWriteId = -1)
}
function dz(e) {
  return e.visible
}
function qP(e, t, n) {
  let i = zi.empty()
  for (let r = 0; r < e.length; ++r) {
    const s = e[r]
    if (t(s)) {
      const o = s.path
      let a
      if (s.snap)
        ji(n, o)
          ? ((a = Ti(n, o)), (i = qu(i, a, s.snap)))
          : ji(o, n) && ((a = Ti(o, n)), (i = qu(i, yt(), s.snap.getChild(a))))
      else if (s.children) {
        if (ji(n, o)) (a = Ti(n, o)), (i = cE(i, a, s.children))
        else if (ji(o, n))
          if (((a = Ti(o, n)), et(a))) i = cE(i, yt(), s.children)
          else {
            const l = hl(s.children, it(a))
            if (l) {
              const u = l.getChild(kt(a))
              i = qu(i, yt(), u)
            }
          }
      } else throw Ml('WriteRecord should have .snap or .children')
    }
  }
  return i
}
function GP(e, t, n, i, r) {
  if (!i && !r) {
    const s = sa(e.visibleWrites, t)
    if (s != null) return s
    {
      const o = ks(e.visibleWrites, t)
      if (ep(o)) return n
      if (n == null && !Zv(o, yt())) return null
      {
        const a = n || ft.EMPTY_NODE
        return vl(o, a)
      }
    }
  } else {
    const s = ks(e.visibleWrites, t)
    if (!r && ep(s)) return n
    if (!r && n == null && !Zv(s, yt())) return null
    {
      const o = function (u) {
          return (u.visible || r) && (!i || !~i.indexOf(u.writeId)) && (ji(u.path, t) || ji(t, u.path))
        },
        a = qP(e.allWrites, o, t),
        l = n || ft.EMPTY_NODE
      return vl(a, l)
    }
  }
}
function hz(e, t, n) {
  let i = ft.EMPTY_NODE
  const r = sa(e.visibleWrites, t)
  if (r)
    return (
      r.isLeafNode() ||
        r.forEachChild(Ln, (s, o) => {
          i = i.updateImmediateChild(s, o)
        }),
      i
    )
  if (n) {
    const s = ks(e.visibleWrites, t)
    return (
      n.forEachChild(Ln, (o, a) => {
        const l = vl(ks(s, new xt(o)), a)
        i = i.updateImmediateChild(o, l)
      }),
      hE(s).forEach((o) => {
        i = i.updateImmediateChild(o.name, o.node)
      }),
      i
    )
  } else {
    const s = ks(e.visibleWrites, t)
    return (
      hE(s).forEach((o) => {
        i = i.updateImmediateChild(o.name, o.node)
      }),
      i
    )
  }
}
function fz(e, t, n, i, r) {
  Pe(i || r, 'Either existingEventSnap or existingServerSnap must exist')
  const s = hn(t, n)
  if (Zv(e.visibleWrites, s)) return null
  {
    const o = ks(e.visibleWrites, s)
    return ep(o) ? r.getChild(n) : vl(o, r.getChild(n))
  }
}
function mz(e, t, n, i) {
  const r = hn(t, n),
    s = sa(e.visibleWrites, r)
  if (s != null) return s
  if (i.isCompleteForChild(n)) {
    const o = ks(e.visibleWrites, r)
    return vl(o, i.getNode().getImmediateChild(n))
  } else return null
}
function gz(e, t) {
  return sa(e.visibleWrites, t)
}
function vz(e, t, n, i, r, s, o) {
  let a
  const l = ks(e.visibleWrites, t),
    u = sa(l, yt())
  if (u != null) a = u
  else if (n != null) a = vl(l, n)
  else return []
  if (((a = a.withIndex(o)), !a.isEmpty() && !a.isLeafNode())) {
    const c = [],
      d = o.getCompare(),
      f = s ? a.getReverseIteratorFrom(i, o) : a.getIteratorFrom(i, o)
    let m = f.getNext()
    for (; m && c.length < r; ) d(m, i) !== 0 && c.push(m), (m = f.getNext())
    return c
  } else return []
}
function pz() {
  return { visibleWrites: zi.empty(), allWrites: [], lastWriteId: -1 }
}
function tp(e, t, n, i) {
  return GP(e.writeTree, e.treePath, t, n, i)
}
function KP(e, t) {
  return hz(e.writeTree, e.treePath, t)
}
function fE(e, t, n, i) {
  return fz(e.writeTree, e.treePath, t, n, i)
}
function tf(e, t) {
  return gz(e.writeTree, hn(e.treePath, t))
}
function yz(e, t, n, i, r, s) {
  return vz(e.writeTree, e.treePath, t, n, i, r, s)
}
function v_(e, t, n) {
  return mz(e.writeTree, e.treePath, t, n)
}
function YP(e, t) {
  return QP(hn(e.treePath, t), e.writeTree)
}
function QP(e, t) {
  return { treePath: e, writeTree: t }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _z {
  constructor() {
    this.changeMap = new Map()
  }
  trackChildChange(t) {
    const n = t.type,
      i = t.childName
    Pe(
      n === 'child_added' || n === 'child_changed' || n === 'child_removed',
      'Only child changes supported for tracking'
    ),
      Pe(i !== '.priority', 'Only non-priority child changes can be tracked.')
    const r = this.changeMap.get(i)
    if (r) {
      const s = r.type
      if (n === 'child_added' && s === 'child_removed') this.changeMap.set(i, oE(i, t.snapshotNode, r.snapshotNode))
      else if (n === 'child_removed' && s === 'child_added') this.changeMap.delete(i)
      else if (n === 'child_removed' && s === 'child_changed') this.changeMap.set(i, Kj(i, r.oldSnap))
      else if (n === 'child_changed' && s === 'child_added') this.changeMap.set(i, Gj(i, t.snapshotNode))
      else if (n === 'child_changed' && s === 'child_changed') this.changeMap.set(i, oE(i, t.snapshotNode, r.oldSnap))
      else throw Ml('Illegal combination of changes: ' + t + ' occurred after ' + r)
    } else this.changeMap.set(i, t)
  }
  getChanges() {
    return Array.from(this.changeMap.values())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class bz {
  getCompleteChild(t) {
    return null
  }
  getChildAfterChild(t, n, i) {
    return null
  }
}
const XP = new bz()
class p_ {
  constructor(t, n, i = null) {
    ;(this.writes_ = t), (this.viewCache_ = n), (this.optCompleteServerCache_ = i)
  }
  getCompleteChild(t) {
    const n = this.viewCache_.eventCache
    if (n.isCompleteForChild(t)) return n.getNode().getImmediateChild(t)
    {
      const i =
        this.optCompleteServerCache_ != null
          ? new g_(this.optCompleteServerCache_, !0, !1)
          : this.viewCache_.serverCache
      return v_(this.writes_, t, i)
    }
  }
  getChildAfterChild(t, n, i) {
    const r = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : Mo(this.viewCache_),
      s = yz(this.writes_, r, n, 1, i, t)
    return s.length === 0 ? null : s[0]
  }
}
function wz(e, t) {
  Pe(t.eventCache.getNode().isIndexed(e.filter.getIndex()), 'Event snap not indexed'),
    Pe(t.serverCache.getNode().isIndexed(e.filter.getIndex()), 'Server snap not indexed')
}
function Iz(e, t, n, i, r) {
  const s = new _z()
  let o, a
  if (n.type === ir.OVERWRITE) {
    const u = n
    u.source.fromUser
      ? (o = np(e, t, u.path, u.snap, i, r, s))
      : (Pe(u.source.fromServer, 'Unknown source.'),
        (a = u.source.tagged || (t.serverCache.isFiltered() && !et(u.path))),
        (o = nf(e, t, u.path, u.snap, i, r, a, s)))
  } else if (n.type === ir.MERGE) {
    const u = n
    u.source.fromUser
      ? (o = Ez(e, t, u.path, u.children, i, r, s))
      : (Pe(u.source.fromServer, 'Unknown source.'),
        (a = u.source.tagged || t.serverCache.isFiltered()),
        (o = ip(e, t, u.path, u.children, i, r, a, s)))
  } else if (n.type === ir.ACK_USER_WRITE) {
    const u = n
    u.revert ? (o = Az(e, t, u.path, i, r, s)) : (o = Tz(e, t, u.path, u.affectedTree, i, r, s))
  } else if (n.type === ir.LISTEN_COMPLETE) o = Cz(e, t, n.path, i, s)
  else throw Ml('Unknown operation type: ' + n.type)
  const l = s.getChanges()
  return Sz(t, o, l), { viewCache: o, changes: l }
}
function Sz(e, t, n) {
  const i = t.eventCache
  if (i.isFullyInitialized()) {
    const r = i.getNode().isLeafNode() || i.getNode().isEmpty(),
      s = Jv(e)
    ;(n.length > 0 ||
      !e.eventCache.isFullyInitialized() ||
      (r && !i.getNode().equals(s)) ||
      !i.getNode().getPriority().equals(s.getPriority())) &&
      n.push(qj(Jv(t)))
  }
}
function JP(e, t, n, i, r, s) {
  const o = t.eventCache
  if (tf(i, n) != null) return t
  {
    let a, l
    if (et(n))
      if (
        (Pe(t.serverCache.isFullyInitialized(), 'If change path is empty, we must have complete server data'),
        t.serverCache.isFiltered())
      ) {
        const u = Mo(t),
          c = u instanceof ft ? u : ft.EMPTY_NODE,
          d = KP(i, c)
        a = e.filter.updateFullNode(t.eventCache.getNode(), d, s)
      } else {
        const u = tp(i, Mo(t))
        a = e.filter.updateFullNode(t.eventCache.getNode(), u, s)
      }
    else {
      const u = it(n)
      if (u === '.priority') {
        Pe(Ds(n) === 1, "Can't have a priority with additional path components")
        const c = o.getNode()
        l = t.serverCache.getNode()
        const d = fE(i, n, c, l)
        d != null ? (a = e.filter.updatePriority(c, d)) : (a = o.getNode())
      } else {
        const c = kt(n)
        let d
        if (o.isCompleteForChild(u)) {
          l = t.serverCache.getNode()
          const f = fE(i, n, o.getNode(), l)
          f != null ? (d = o.getNode().getImmediateChild(u).updateChild(c, f)) : (d = o.getNode().getImmediateChild(u))
        } else d = v_(i, u, t.serverCache)
        d != null ? (a = e.filter.updateChild(o.getNode(), u, d, c, r, s)) : (a = o.getNode())
      }
    }
    return Wu(t, a, o.isFullyInitialized() || et(n), e.filter.filtersNodes())
  }
}
function nf(e, t, n, i, r, s, o, a) {
  const l = t.serverCache
  let u
  const c = o ? e.filter : e.filter.getIndexedFilter()
  if (et(n)) u = c.updateFullNode(l.getNode(), i, null)
  else if (c.filtersNodes() && !l.isFiltered()) {
    const m = l.getNode().updateChild(n, i)
    u = c.updateFullNode(l.getNode(), m, null)
  } else {
    const m = it(n)
    if (!l.isCompleteForPath(n) && Ds(n) > 1) return t
    const p = kt(n),
      y = l.getNode().getImmediateChild(m).updateChild(p, i)
    m === '.priority' ? (u = c.updatePriority(l.getNode(), y)) : (u = c.updateChild(l.getNode(), m, y, p, XP, null))
  }
  const d = zP(t, u, l.isFullyInitialized() || et(n), c.filtersNodes()),
    f = new p_(r, d, s)
  return JP(e, d, n, r, f, a)
}
function np(e, t, n, i, r, s, o) {
  const a = t.eventCache
  let l, u
  const c = new p_(r, t, s)
  if (et(n)) (u = e.filter.updateFullNode(t.eventCache.getNode(), i, o)), (l = Wu(t, u, !0, e.filter.filtersNodes()))
  else {
    const d = it(n)
    if (d === '.priority')
      (u = e.filter.updatePriority(t.eventCache.getNode(), i)), (l = Wu(t, u, a.isFullyInitialized(), a.isFiltered()))
    else {
      const f = kt(n),
        m = a.getNode().getImmediateChild(d)
      let p
      if (et(f)) p = i
      else {
        const v = c.getCompleteChild(d)
        v != null
          ? kP(f) === '.priority' && v.getChild(RP(f)).isEmpty()
            ? (p = v)
            : (p = v.updateChild(f, i))
          : (p = ft.EMPTY_NODE)
      }
      if (m.equals(p)) l = t
      else {
        const v = e.filter.updateChild(a.getNode(), d, p, f, c, o)
        l = Wu(t, v, a.isFullyInitialized(), e.filter.filtersNodes())
      }
    }
  }
  return l
}
function mE(e, t) {
  return e.eventCache.isCompleteForChild(t)
}
function Ez(e, t, n, i, r, s, o) {
  let a = t
  return (
    i.foreach((l, u) => {
      const c = hn(n, l)
      mE(t, it(c)) && (a = np(e, a, c, u, r, s, o))
    }),
    i.foreach((l, u) => {
      const c = hn(n, l)
      mE(t, it(c)) || (a = np(e, a, c, u, r, s, o))
    }),
    a
  )
}
function gE(e, t, n) {
  return (
    n.foreach((i, r) => {
      t = t.updateChild(i, r)
    }),
    t
  )
}
function ip(e, t, n, i, r, s, o, a) {
  if (t.serverCache.getNode().isEmpty() && !t.serverCache.isFullyInitialized()) return t
  let l = t,
    u
  et(n) ? (u = i) : (u = new At(null).setTree(n, i))
  const c = t.serverCache.getNode()
  return (
    u.children.inorderTraversal((d, f) => {
      if (c.hasChild(d)) {
        const m = t.serverCache.getNode().getImmediateChild(d),
          p = gE(e, m, f)
        l = nf(e, l, new xt(d), p, r, s, o, a)
      }
    }),
    u.children.inorderTraversal((d, f) => {
      const m = !t.serverCache.isCompleteForChild(d) && f.value === null
      if (!c.hasChild(d) && !m) {
        const p = t.serverCache.getNode().getImmediateChild(d),
          v = gE(e, p, f)
        l = nf(e, l, new xt(d), v, r, s, o, a)
      }
    }),
    l
  )
}
function Tz(e, t, n, i, r, s, o) {
  if (tf(r, n) != null) return t
  const a = t.serverCache.isFiltered(),
    l = t.serverCache
  if (i.value != null) {
    if ((et(n) && l.isFullyInitialized()) || l.isCompleteForPath(n))
      return nf(e, t, n, l.getNode().getChild(n), r, s, a, o)
    if (et(n)) {
      let u = new At(null)
      return (
        l.getNode().forEachChild(rl, (c, d) => {
          u = u.set(new xt(c), d)
        }),
        ip(e, t, n, u, r, s, a, o)
      )
    } else return t
  } else {
    let u = new At(null)
    return (
      i.foreach((c, d) => {
        const f = hn(n, c)
        l.isCompleteForPath(f) && (u = u.set(c, l.getNode().getChild(f)))
      }),
      ip(e, t, n, u, r, s, a, o)
    )
  }
}
function Cz(e, t, n, i, r) {
  const s = t.serverCache,
    o = zP(t, s.getNode(), s.isFullyInitialized() || et(n), s.isFiltered())
  return JP(e, o, n, i, XP, r)
}
function Az(e, t, n, i, r, s) {
  let o
  if (tf(i, n) != null) return t
  {
    const a = new p_(i, t, r),
      l = t.eventCache.getNode()
    let u
    if (et(n) || it(n) === '.priority') {
      let c
      if (t.serverCache.isFullyInitialized()) c = tp(i, Mo(t))
      else {
        const d = t.serverCache.getNode()
        Pe(d instanceof ft, 'serverChildren would be complete if leaf node'), (c = KP(i, d))
      }
      ;(c = c), (u = e.filter.updateFullNode(l, c, s))
    } else {
      const c = it(n)
      let d = v_(i, c, t.serverCache)
      d == null && t.serverCache.isCompleteForChild(c) && (d = l.getImmediateChild(c)),
        d != null
          ? (u = e.filter.updateChild(l, c, d, kt(n), a, s))
          : t.eventCache.getNode().hasChild(c)
          ? (u = e.filter.updateChild(l, c, ft.EMPTY_NODE, kt(n), a, s))
          : (u = l),
        u.isEmpty() &&
          t.serverCache.isFullyInitialized() &&
          ((o = tp(i, Mo(t))), o.isLeafNode() && (u = e.filter.updateFullNode(u, o, s)))
    }
    return (o = t.serverCache.isFullyInitialized() || tf(i, yt()) != null), Wu(t, u, o, e.filter.filtersNodes())
  }
}
function kz(e, t) {
  const n = Mo(e.viewCache_)
  return n && (e.query._queryParams.loadsAllData() || (!et(t) && !n.getImmediateChild(it(t)).isEmpty()))
    ? n.getChild(t)
    : null
}
function vE(e, t, n, i) {
  t.type === ir.MERGE &&
    t.source.queryId !== null &&
    (Pe(Mo(e.viewCache_), 'We should always have a full cache before handling merges'),
    Pe(Jv(e.viewCache_), 'Missing event cache, even though we have a server cache'))
  const r = e.viewCache_,
    s = Iz(e.processor_, r, t, n, i)
  return (
    wz(e.processor_, s.viewCache),
    Pe(
      s.viewCache.serverCache.isFullyInitialized() || !r.serverCache.isFullyInitialized(),
      'Once a server snap is complete, it should never go back'
    ),
    (e.viewCache_ = s.viewCache),
    Pz(e, s.changes, s.viewCache.eventCache.getNode())
  )
}
function Pz(e, t, n, i) {
  const r = e.eventRegistrations_
  return nz(e.eventGenerator_, t, n, r)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let pE
function Rz(e) {
  Pe(!pE, '__referenceConstructor has already been defined'), (pE = e)
}
function y_(e, t, n, i) {
  const r = t.source.queryId
  if (r !== null) {
    const s = e.views.get(r)
    return Pe(s != null, 'SyncTree gave us an op for an invalid query.'), vE(s, t, n, i)
  } else {
    let s = []
    for (const o of e.views.values()) s = s.concat(vE(o, t, n, i))
    return s
  }
}
function __(e, t) {
  let n = null
  for (const i of e.views.values()) n = n || kz(i, t)
  return n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let yE
function xz(e) {
  Pe(!yE, '__referenceConstructor has already been defined'), (yE = e)
}
class _E {
  constructor(t) {
    ;(this.listenProvider_ = t),
      (this.syncPointTree_ = new At(null)),
      (this.pendingWriteTree_ = pz()),
      (this.tagToQueryMap = new Map()),
      (this.queryToTagMap = new Map())
  }
}
function Vz(e, t, n, i, r) {
  return oz(e.pendingWriteTree_, t, n, i, r), r ? Zf(e, new Oo(BP(), t, n)) : []
}
function qa(e, t, n = !1) {
  const i = az(e.pendingWriteTree_, t)
  if (lz(e.pendingWriteTree_, t)) {
    let s = new At(null)
    return (
      i.snap != null
        ? (s = s.set(yt(), !0))
        : xi(i.children, (o) => {
            s = s.set(new xt(o), !0)
          }),
      Zf(e, new ef(i.path, s, n))
    )
  } else return []
}
function Jf(e, t, n) {
  return Zf(e, new Oo($P(), t, n))
}
function Dz(e, t, n) {
  const i = At.fromObject(n)
  return Zf(e, new fc($P(), t, i))
}
function Nz(e, t, n, i) {
  const r = nR(e, i)
  if (r != null) {
    const s = iR(r),
      o = s.path,
      a = s.queryId,
      l = Ti(o, t),
      u = new Oo(UP(a), l, n)
    return rR(e, o, u)
  } else return []
}
function Oz(e, t, n, i) {
  const r = nR(e, i)
  if (r) {
    const s = iR(r),
      o = s.path,
      a = s.queryId,
      l = Ti(o, t),
      u = At.fromObject(n),
      c = new fc(UP(a), l, u)
    return rR(e, o, c)
  } else return []
}
function ZP(e, t, n) {
  const r = e.pendingWriteTree_,
    s = e.syncPointTree_.findOnPath(t, (o, a) => {
      const l = Ti(o, t),
        u = __(a, l)
      if (u) return u
    })
  return GP(r, t, s, n, !0)
}
function Zf(e, t) {
  return eR(t, e.syncPointTree_, null, WP(e.pendingWriteTree_, yt()))
}
function eR(e, t, n, i) {
  if (et(e.path)) return tR(e, t, n, i)
  {
    const r = t.get(yt())
    n == null && r != null && (n = __(r, yt()))
    let s = []
    const o = it(e.path),
      a = e.operationForChild(o),
      l = t.children.get(o)
    if (l && a) {
      const u = n ? n.getImmediateChild(o) : null,
        c = YP(i, o)
      s = s.concat(eR(a, l, u, c))
    }
    return r && (s = s.concat(y_(r, e, i, n))), s
  }
}
function tR(e, t, n, i) {
  const r = t.get(yt())
  n == null && r != null && (n = __(r, yt()))
  let s = []
  return (
    t.children.inorderTraversal((o, a) => {
      const l = n ? n.getImmediateChild(o) : null,
        u = YP(i, o),
        c = e.operationForChild(o)
      c && (s = s.concat(tR(c, a, l, u)))
    }),
    r && (s = s.concat(y_(r, e, i, n))),
    s
  )
}
function nR(e, t) {
  return e.tagToQueryMap.get(t)
}
function iR(e) {
  const t = e.indexOf('$')
  return Pe(t !== -1 && t < e.length - 1, 'Bad queryKey.'), { queryId: e.substr(t + 1), path: new xt(e.substr(0, t)) }
}
function rR(e, t, n) {
  const i = e.syncPointTree_.get(t)
  Pe(i, "Missing sync point for query tag that we're tracking")
  const r = WP(e.pendingWriteTree_, t)
  return y_(i, n, r, null)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class b_ {
  constructor(t) {
    this.node_ = t
  }
  getImmediateChild(t) {
    const n = this.node_.getImmediateChild(t)
    return new b_(n)
  }
  node() {
    return this.node_
  }
}
class w_ {
  constructor(t, n) {
    ;(this.syncTree_ = t), (this.path_ = n)
  }
  getImmediateChild(t) {
    const n = hn(this.path_, t)
    return new w_(this.syncTree_, n)
  }
  node() {
    return ZP(this.syncTree_, this.path_)
  }
}
const Mz = function (e) {
    return (e = e || {}), (e.timestamp = e.timestamp || new Date().getTime()), e
  },
  bE = function (e, t, n) {
    if (!e || typeof e != 'object') return e
    if ((Pe('.sv' in e, 'Unexpected leaf node or priority contents'), typeof e['.sv'] == 'string'))
      return Lz(e['.sv'], t, n)
    if (typeof e['.sv'] == 'object') return Fz(e['.sv'], t)
    Pe(!1, 'Unexpected server value: ' + JSON.stringify(e, null, 2))
  },
  Lz = function (e, t, n) {
    switch (e) {
      case 'timestamp':
        return n.timestamp
      default:
        Pe(!1, 'Unexpected server value: ' + e)
    }
  },
  Fz = function (e, t, n) {
    e.hasOwnProperty('increment') || Pe(!1, 'Unexpected server value: ' + JSON.stringify(e, null, 2))
    const i = e.increment
    typeof i != 'number' && Pe(!1, 'Unexpected increment value: ' + i)
    const r = t.node()
    if ((Pe(r !== null && typeof r < 'u', 'Expected ChildrenNode.EMPTY_NODE for nulls'), !r.isLeafNode())) return i
    const o = r.getValue()
    return typeof o != 'number' ? i : o + i
  },
  Bz = function (e, t, n, i) {
    return I_(t, new w_(n, e), i)
  },
  $z = function (e, t, n) {
    return I_(e, new b_(t), n)
  }
function I_(e, t, n) {
  const i = e.getPriority().val(),
    r = bE(i, t.getImmediateChild('.priority'), n)
  let s
  if (e.isLeafNode()) {
    const o = e,
      a = bE(o.getValue(), t, n)
    return a !== o.getValue() || r !== o.getPriority().val() ? new un(a, Nn(r)) : e
  } else {
    const o = e
    return (
      (s = o),
      r !== o.getPriority().val() && (s = s.updatePriority(new un(r))),
      o.forEachChild(Ln, (a, l) => {
        const u = I_(l, t.getImmediateChild(a), n)
        u !== l && (s = s.updateImmediateChild(a, u))
      }),
      s
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class S_ {
  constructor(t = '', n = null, i = { children: {}, childCount: 0 }) {
    ;(this.name = t), (this.parent = n), (this.node = i)
  }
}
function E_(e, t) {
  let n = t instanceof xt ? t : new xt(t),
    i = e,
    r = it(n)
  for (; r !== null; ) {
    const s = hl(i.node.children, r) || { children: {}, childCount: 0 }
    ;(i = new S_(r, i, s)), (n = kt(n)), (r = it(n))
  }
  return i
}
function $l(e) {
  return e.node.value
}
function sR(e, t) {
  ;(e.node.value = t), rp(e)
}
function oR(e) {
  return e.node.childCount > 0
}
function Uz(e) {
  return $l(e) === void 0 && !oR(e)
}
function em(e, t) {
  xi(e.node.children, (n, i) => {
    t(new S_(n, e, i))
  })
}
function aR(e, t, n, i) {
  n && !i && t(e),
    em(e, (r) => {
      aR(r, t, !0, i)
    }),
    n && i && t(e)
}
function jz(e, t, n) {
  let i = e.parent
  for (; i !== null; ) {
    if (t(i)) return !0
    i = i.parent
  }
  return !1
}
function Xc(e) {
  return new xt(e.parent === null ? e.name : Xc(e.parent) + '/' + e.name)
}
function rp(e) {
  e.parent !== null && zz(e.parent, e.name, e)
}
function zz(e, t, n) {
  const i = Uz(n),
    r = Hr(e.node.children, t)
  i && r
    ? (delete e.node.children[t], e.node.childCount--, rp(e))
    : !i && !r && ((e.node.children[t] = n.node), e.node.childCount++, rp(e))
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Hz = /[\[\].#$\/\u0000-\u001F\u007F]/,
  Wz = /[\[\].#$\u0000-\u001F\u007F]/,
  Ug = 10 * 1024 * 1024,
  lR = function (e) {
    return typeof e == 'string' && e.length !== 0 && !Hz.test(e)
  },
  qz = function (e) {
    return typeof e == 'string' && e.length !== 0 && !Wz.test(e)
  },
  Gz = function (e) {
    return e && (e = e.replace(/^\/*\.info(\/|$)/, '/')), qz(e)
  },
  uR = function (e, t, n) {
    const i = n instanceof xt ? new Cj(n, e) : n
    if (t === void 0) throw new Error(e + 'contains undefined ' + lo(i))
    if (typeof t == 'function') throw new Error(e + 'contains a function ' + lo(i) + ' with contents = ' + t.toString())
    if (lP(t)) throw new Error(e + 'contains ' + t.toString() + ' ' + lo(i))
    if (typeof t == 'string' && t.length > Ug / 3 && Wf(t) > Ug)
      throw new Error(
        e + 'contains a string greater than ' + Ug + ' utf8 bytes ' + lo(i) + " ('" + t.substring(0, 50) + "...')"
      )
    if (t && typeof t == 'object') {
      let r = !1,
        s = !1
      if (
        (xi(t, (o, a) => {
          if (o === '.value') r = !0
          else if (o !== '.priority' && o !== '.sv' && ((s = !0), !lR(o)))
            throw new Error(
              e +
                ' contains an invalid key (' +
                o +
                ') ' +
                lo(i) +
                `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`
            )
          Aj(i, o), uR(e, a, i), kj(i)
        }),
        r && s)
      )
        throw new Error(e + ' contains ".value" child ' + lo(i) + ' in addition to actual children.')
    }
  },
  Kz = function (e, t) {
    const n = t.path.toString()
    if (
      typeof t.repoInfo.host != 'string' ||
      t.repoInfo.host.length === 0 ||
      (!lR(t.repoInfo.namespace) && t.repoInfo.host.split(':')[0] !== 'localhost') ||
      (n.length !== 0 && !Gz(n))
    )
      throw new Error(
        wB(e, 'url') + `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`
      )
  }
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Yz {
  constructor() {
    ;(this.eventLists_ = []), (this.recursionDepth_ = 0)
  }
}
function Qz(e, t) {
  let n = null
  for (let i = 0; i < t.length; i++) {
    const r = t[i],
      s = r.getPath()
    n !== null && !xP(s, n.path) && (e.eventLists_.push(n), (n = null)),
      n === null && (n = { events: [], path: s }),
      n.events.push(r)
  }
  n && e.eventLists_.push(n)
}
function oa(e, t, n) {
  Qz(e, n), Xz(e, (i) => ji(i, t) || ji(t, i))
}
function Xz(e, t) {
  e.recursionDepth_++
  let n = !0
  for (let i = 0; i < e.eventLists_.length; i++) {
    const r = e.eventLists_[i]
    if (r) {
      const s = r.path
      t(s) ? (Jz(e.eventLists_[i]), (e.eventLists_[i] = null)) : (n = !1)
    }
  }
  n && (e.eventLists_ = []), e.recursionDepth_--
}
function Jz(e) {
  for (let t = 0; t < e.events.length; t++) {
    const n = e.events[t]
    if (n !== null) {
      e.events[t] = null
      const i = n.getEventRunner()
      zu && Dn('event: ' + n.toString()), Yc(i)
    }
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Zz = 'repo_interrupt',
  eH = 25
class tH {
  constructor(t, n, i, r) {
    ;(this.repoInfo_ = t),
      (this.forceRestClient_ = n),
      (this.authTokenProvider_ = i),
      (this.appCheckProvider_ = r),
      (this.dataUpdateCount = 0),
      (this.statsListener_ = null),
      (this.eventQueue_ = new Yz()),
      (this.nextWriteId_ = 1),
      (this.interceptServerDataCallback_ = null),
      (this.onDisconnect_ = Zh()),
      (this.transactionQueueTree_ = new S_()),
      (this.persistentConnection_ = null),
      (this.key = this.repoInfo_.toURLString())
  }
  toString() {
    return (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host
  }
}
function nH(e, t, n) {
  if (((e.stats_ = c_(e.repoInfo_)), e.forceRestClient_ || Q4()))
    (e.server_ = new Jh(
      e.repoInfo_,
      (i, r, s, o) => {
        wE(e, i, r, s, o)
      },
      e.authTokenProvider_,
      e.appCheckProvider_
    )),
      setTimeout(() => IE(e, !0), 0)
  else {
    if (typeof n < 'u' && n !== null) {
      if (typeof n != 'object') throw new Error('Only objects are supported for option databaseAuthVariableOverride')
      try {
        Sn(n)
      } catch (i) {
        throw new Error('Invalid authOverride provided: ' + i)
      }
    }
    ;(e.persistentConnection_ = new Dr(
      e.repoInfo_,
      t,
      (i, r, s, o) => {
        wE(e, i, r, s, o)
      },
      (i) => {
        IE(e, i)
      },
      (i) => {
        rH(e, i)
      },
      e.authTokenProvider_,
      e.appCheckProvider_,
      n
    )),
      (e.server_ = e.persistentConnection_)
  }
  e.authTokenProvider_.addTokenChangeListener((i) => {
    e.server_.refreshAuthToken(i)
  }),
    e.appCheckProvider_.addTokenChangeListener((i) => {
      e.server_.refreshAppCheckToken(i.token)
    }),
    (e.statsReporter_ = nj(e.repoInfo_, () => new tz(e.stats_, e.server_))),
    (e.infoData_ = new Qj()),
    (e.infoSyncTree_ = new _E({
      startListening: (i, r, s, o) => {
        let a = []
        const l = e.infoData_.getNode(i._path)
        return (
          l.isEmpty() ||
            ((a = Jf(e.infoSyncTree_, i._path, l)),
            setTimeout(() => {
              o('ok')
            }, 0)),
          a
        )
      },
      stopListening: () => {},
    })),
    T_(e, 'connected', !1),
    (e.serverSyncTree_ = new _E({
      startListening: (i, r, s, o) => (
        e.server_.listen(i, s, r, (a, l) => {
          const u = o(a, l)
          oa(e.eventQueue_, i._path, u)
        }),
        []
      ),
      stopListening: (i, r) => {
        e.server_.unlisten(i, r)
      },
    }))
}
function iH(e) {
  const n = e.infoData_.getNode(new xt('.info/serverTimeOffset')).val() || 0
  return new Date().getTime() + n
}
function cR(e) {
  return Mz({ timestamp: iH(e) })
}
function wE(e, t, n, i, r) {
  e.dataUpdateCount++
  const s = new xt(t)
  n = e.interceptServerDataCallback_ ? e.interceptServerDataCallback_(t, n) : n
  let o = []
  if (r)
    if (i) {
      const l = Uh(n, (u) => Nn(u))
      o = Oz(e.serverSyncTree_, s, l, r)
    } else {
      const l = Nn(n)
      o = Nz(e.serverSyncTree_, s, l, r)
    }
  else if (i) {
    const l = Uh(n, (u) => Nn(u))
    o = Dz(e.serverSyncTree_, s, l)
  } else {
    const l = Nn(n)
    o = Jf(e.serverSyncTree_, s, l)
  }
  let a = s
  o.length > 0 && (a = A_(e, s)), oa(e.eventQueue_, a, o)
}
function IE(e, t) {
  T_(e, 'connected', t), t === !1 && oH(e)
}
function rH(e, t) {
  xi(t, (n, i) => {
    T_(e, n, i)
  })
}
function T_(e, t, n) {
  const i = new xt('/.info/' + t),
    r = Nn(n)
  e.infoData_.updateSnapshot(i, r)
  const s = Jf(e.infoSyncTree_, i, r)
  oa(e.eventQueue_, i, s)
}
function sH(e) {
  return e.nextWriteId_++
}
function oH(e) {
  dR(e, 'onDisconnectEvents')
  const t = cR(e),
    n = Zh()
  Xv(e.onDisconnect_, yt(), (r, s) => {
    const o = Bz(r, s, e.serverSyncTree_, t)
    FP(n, r, o)
  })
  let i = []
  Xv(n, yt(), (r, s) => {
    i = i.concat(Jf(e.serverSyncTree_, r, s))
    const o = cH(e, r)
    A_(e, o)
  }),
    (e.onDisconnect_ = Zh()),
    oa(e.eventQueue_, yt(), i)
}
function aH(e) {
  e.persistentConnection_ && e.persistentConnection_.interrupt(Zz)
}
function dR(e, ...t) {
  let n = ''
  e.persistentConnection_ && (n = e.persistentConnection_.id + ':'), Dn(n, ...t)
}
function hR(e, t, n) {
  return ZP(e.serverSyncTree_, t, n) || ft.EMPTY_NODE
}
function C_(e, t = e.transactionQueueTree_) {
  if ((t || tm(e, t), $l(t))) {
    const n = mR(e, t)
    Pe(n.length > 0, 'Sending zero length transaction queue'), n.every((r) => r.status === 0) && lH(e, Xc(t), n)
  } else
    oR(t) &&
      em(t, (n) => {
        C_(e, n)
      })
}
function lH(e, t, n) {
  const i = n.map((u) => u.currentWriteId),
    r = hR(e, t, i)
  let s = r
  const o = r.hash()
  for (let u = 0; u < n.length; u++) {
    const c = n[u]
    Pe(c.status === 0, 'tryToSendTransactionQueue_: items in queue should all be run.'), (c.status = 1), c.retryCount++
    const d = Ti(t, c.path)
    s = s.updateChild(d, c.currentOutputSnapshotRaw)
  }
  const a = s.val(!0),
    l = t
  e.server_.put(
    l.toString(),
    a,
    (u) => {
      dR(e, 'transaction put response', { path: l.toString(), status: u })
      let c = []
      if (u === 'ok') {
        const d = []
        for (let f = 0; f < n.length; f++)
          (n[f].status = 2),
            (c = c.concat(qa(e.serverSyncTree_, n[f].currentWriteId))),
            n[f].onComplete && d.push(() => n[f].onComplete(null, !0, n[f].currentOutputSnapshotResolved)),
            n[f].unwatcher()
        tm(e, E_(e.transactionQueueTree_, t)), C_(e, e.transactionQueueTree_), oa(e.eventQueue_, t, c)
        for (let f = 0; f < d.length; f++) Yc(d[f])
      } else {
        if (u === 'datastale')
          for (let d = 0; d < n.length; d++) n[d].status === 3 ? (n[d].status = 4) : (n[d].status = 0)
        else {
          fi('transaction at ' + l.toString() + ' failed: ' + u)
          for (let d = 0; d < n.length; d++) (n[d].status = 4), (n[d].abortReason = u)
        }
        A_(e, t)
      }
    },
    o
  )
}
function A_(e, t) {
  const n = fR(e, t),
    i = Xc(n),
    r = mR(e, n)
  return uH(e, r, i), i
}
function uH(e, t, n) {
  if (t.length === 0) return
  const i = []
  let r = []
  const o = t.filter((a) => a.status === 0).map((a) => a.currentWriteId)
  for (let a = 0; a < t.length; a++) {
    const l = t[a],
      u = Ti(n, l.path)
    let c = !1,
      d
    if ((Pe(u !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.'), l.status === 4))
      (c = !0), (d = l.abortReason), (r = r.concat(qa(e.serverSyncTree_, l.currentWriteId, !0)))
    else if (l.status === 0)
      if (l.retryCount >= eH) (c = !0), (d = 'maxretry'), (r = r.concat(qa(e.serverSyncTree_, l.currentWriteId, !0)))
      else {
        const f = hR(e, l.path, o)
        l.currentInputSnapshot = f
        const m = t[a].update(f.val())
        if (m !== void 0) {
          uR('transaction failed: Data returned ', m, l.path)
          let p = Nn(m)
          ;(typeof m == 'object' && m != null && Hr(m, '.priority')) || (p = p.updatePriority(f.getPriority()))
          const y = l.currentWriteId,
            T = cR(e),
            A = $z(p, f, T)
          ;(l.currentOutputSnapshotRaw = p),
            (l.currentOutputSnapshotResolved = A),
            (l.currentWriteId = sH(e)),
            o.splice(o.indexOf(y), 1),
            (r = r.concat(Vz(e.serverSyncTree_, l.path, A, l.currentWriteId, l.applyLocally))),
            (r = r.concat(qa(e.serverSyncTree_, y, !0)))
        } else (c = !0), (d = 'nodata'), (r = r.concat(qa(e.serverSyncTree_, l.currentWriteId, !0)))
      }
    oa(e.eventQueue_, n, r),
      (r = []),
      c &&
        ((t[a].status = 2),
        (function (f) {
          setTimeout(f, Math.floor(0))
        })(t[a].unwatcher),
        t[a].onComplete &&
          (d === 'nodata'
            ? i.push(() => t[a].onComplete(null, !1, t[a].currentInputSnapshot))
            : i.push(() => t[a].onComplete(new Error(d), !1, null))))
  }
  tm(e, e.transactionQueueTree_)
  for (let a = 0; a < i.length; a++) Yc(i[a])
  C_(e, e.transactionQueueTree_)
}
function fR(e, t) {
  let n,
    i = e.transactionQueueTree_
  for (n = it(t); n !== null && $l(i) === void 0; ) (i = E_(i, n)), (t = kt(t)), (n = it(t))
  return i
}
function mR(e, t) {
  const n = []
  return gR(e, t, n), n.sort((i, r) => i.order - r.order), n
}
function gR(e, t, n) {
  const i = $l(t)
  if (i) for (let r = 0; r < i.length; r++) n.push(i[r])
  em(t, (r) => {
    gR(e, r, n)
  })
}
function tm(e, t) {
  const n = $l(t)
  if (n) {
    let i = 0
    for (let r = 0; r < n.length; r++) n[r].status !== 2 && ((n[i] = n[r]), i++)
    ;(n.length = i), sR(t, n.length > 0 ? n : void 0)
  }
  em(t, (i) => {
    tm(e, i)
  })
}
function cH(e, t) {
  const n = Xc(fR(e, t)),
    i = E_(e.transactionQueueTree_, t)
  return (
    jz(i, (r) => {
      jg(e, r)
    }),
    jg(e, i),
    aR(i, (r) => {
      jg(e, r)
    }),
    n
  )
}
function jg(e, t) {
  const n = $l(t)
  if (n) {
    const i = []
    let r = [],
      s = -1
    for (let o = 0; o < n.length; o++)
      n[o].status === 3 ||
        (n[o].status === 1
          ? (Pe(s === o - 1, 'All SENT items should be at beginning of queue.'),
            (s = o),
            (n[o].status = 3),
            (n[o].abortReason = 'set'))
          : (Pe(n[o].status === 0, 'Unexpected transaction status in abort'),
            n[o].unwatcher(),
            (r = r.concat(qa(e.serverSyncTree_, n[o].currentWriteId, !0))),
            n[o].onComplete && i.push(n[o].onComplete.bind(null, new Error('set'), !1, null))))
    s === -1 ? sR(t, void 0) : (n.length = s + 1), oa(e.eventQueue_, Xc(t), r)
    for (let o = 0; o < i.length; o++) Yc(i[o])
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function dH(e) {
  let t = ''
  const n = e.split('/')
  for (let i = 0; i < n.length; i++)
    if (n[i].length > 0) {
      let r = n[i]
      try {
        r = decodeURIComponent(r.replace(/\+/g, ' '))
      } catch {}
      t += '/' + r
    }
  return t
}
function hH(e) {
  const t = {}
  e.charAt(0) === '?' && (e = e.substring(1))
  for (const n of e.split('&')) {
    if (n.length === 0) continue
    const i = n.split('=')
    i.length === 2
      ? (t[decodeURIComponent(i[0])] = decodeURIComponent(i[1]))
      : fi(`Invalid query segment '${n}' in query '${e}'`)
  }
  return t
}
const SE = function (e, t) {
    const n = fH(e),
      i = n.namespace
    n.domain === 'firebase.com' &&
      Do(n.host + ' is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead'),
      (!i || i === 'undefined') &&
        n.domain !== 'localhost' &&
        Do('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'),
      n.secure || j4()
    const r = n.scheme === 'ws' || n.scheme === 'wss'
    return { repoInfo: new Z4(n.host, n.secure, i, r, t, '', i !== n.subdomain), path: new xt(n.pathString) }
  },
  fH = function (e) {
    let t = '',
      n = '',
      i = '',
      r = '',
      s = '',
      o = !0,
      a = 'https',
      l = 443
    if (typeof e == 'string') {
      let u = e.indexOf('//')
      u >= 0 && ((a = e.substring(0, u - 1)), (e = e.substring(u + 2)))
      let c = e.indexOf('/')
      c === -1 && (c = e.length)
      let d = e.indexOf('?')
      d === -1 && (d = e.length), (t = e.substring(0, Math.min(c, d))), c < d && (r = dH(e.substring(c, d)))
      const f = hH(e.substring(Math.min(e.length, d)))
      ;(u = t.indexOf(':')),
        u >= 0 ? ((o = a === 'https' || a === 'wss'), (l = parseInt(t.substring(u + 1), 10))) : (u = t.length)
      const m = t.slice(0, u)
      if (m.toLowerCase() === 'localhost') n = 'localhost'
      else if (m.split('.').length <= 2) n = m
      else {
        const p = t.indexOf('.')
        ;(i = t.substring(0, p).toLowerCase()), (n = t.substring(p + 1)), (s = i)
      }
      'ns' in f && (s = f.ns)
    }
    return { host: t, port: l, domain: n, subdomain: i, secure: o, scheme: a, pathString: r, namespace: s }
  }
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class k_ {
  constructor(t, n, i, r) {
    ;(this._repo = t), (this._path = n), (this._queryParams = i), (this._orderByCalled = r)
  }
  get key() {
    return et(this._path) ? null : kP(this._path)
  }
  get ref() {
    return new Ul(this._repo, this._path)
  }
  get _queryIdentifier() {
    const t = lE(this._queryParams),
      n = l_(t)
    return n === '{}' ? 'default' : n
  }
  get _queryObject() {
    return lE(this._queryParams)
  }
  isEqual(t) {
    if (((t = Et(t)), !(t instanceof k_))) return !1
    const n = this._repo === t._repo,
      i = xP(this._path, t._path),
      r = this._queryIdentifier === t._queryIdentifier
    return n && i && r
  }
  toJSON() {
    return this.toString()
  }
  toString() {
    return this._repo.toString() + Tj(this._path)
  }
}
class Ul extends k_ {
  constructor(t, n) {
    super(t, n, new m_(), !1)
  }
  get parent() {
    const t = RP(this._path)
    return t === null ? null : new Ul(this._repo, t)
  }
  get root() {
    let t = this
    for (; t.parent !== null; ) t = t.parent
    return t
  }
}
Rz(Ul)
xz(Ul)
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const mH = 'FIREBASE_DATABASE_EMULATOR_HOST',
  sp = {}
let gH = !1
function vH(e, t, n, i, r) {
  let s = i || e.options.databaseURL
  s === void 0 &&
    (e.options.projectId ||
      Do(
        "Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."
      ),
    Dn('Using default host for project ', e.options.projectId),
    (s = `${e.options.projectId}-default-rtdb.firebaseio.com`))
  let o = SE(s, r),
    a = o.repoInfo,
    l
  typeof process < 'u' && zS && (l = zS[mH]),
    l ? ((s = `http://${l}?ns=${a.namespace}`), (o = SE(s, r)), (a = o.repoInfo)) : o.repoInfo.secure
  const u = new J4(e.name, e.options, t)
  Kz('Invalid Firebase Database URL', o),
    et(o.path) || Do('Database URL must point to the root of a Firebase Database (not including a child path).')
  const c = yH(a, e, u, new X4(e.name, n))
  return new _H(c, e)
}
function pH(e, t) {
  const n = sp[t]
  ;(!n || n[e.key] !== e) && Do(`Database ${t}(${e.repoInfo_}) has already been deleted.`), aH(e), delete n[e.key]
}
function yH(e, t, n, i) {
  let r = sp[t.name]
  r || ((r = {}), (sp[t.name] = r))
  let s = r[e.toURLString()]
  return (
    s &&
      Do(
        'Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.'
      ),
    (s = new tH(e, gH, n, i)),
    (r[e.toURLString()] = s),
    s
  )
}
class _H {
  constructor(t, n) {
    ;(this._repoInternal = t), (this.app = n), (this.type = 'database'), (this._instanceStarted = !1)
  }
  get _repo() {
    return (
      this._instanceStarted ||
        (nH(this._repoInternal, this.app.options.appId, this.app.options.databaseAuthVariableOverride),
        (this._instanceStarted = !0)),
      this._repoInternal
    )
  }
  get _root() {
    return this._rootInternal || (this._rootInternal = new Ul(this._repo, yt())), this._rootInternal
  }
  _delete() {
    return (
      this._rootInternal !== null &&
        (pH(this._repo, this.app.name), (this._repoInternal = null), (this._rootInternal = null)),
      Promise.resolve()
    )
  }
  _checkNotDeleted(t) {
    this._rootInternal === null && Do('Cannot call ' + t + ' on a deleted database.')
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function bH(e) {
  M4(zs),
    Xn(
      new $n(
        'database',
        (t, { instanceIdentifier: n }) => {
          const i = t.getProvider('app').getImmediate(),
            r = t.getProvider('auth-internal'),
            s = t.getProvider('app-check-internal')
          return vH(i, r, s, n)
        },
        'PUBLIC'
      ).setMultipleInstances(!0)
    ),
    nn(HS, WS, e),
    nn(HS, WS, 'esm2017')
}
Dr.prototype.simpleListen = function (e, t) {
  this.sendRequest('q', { p: e }, t)
}
Dr.prototype.echo = function (e, t) {
  this.sendRequest('echo', { d: e }, t)
}
bH()
var EE =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/ var So, vR
;(function () {
  var e
  /** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/ function t(I, w) {
    function _() {}
    ;(_.prototype = w.prototype),
      (I.D = w.prototype),
      (I.prototype = new _()),
      (I.prototype.constructor = I),
      (I.C = function (S, E, C) {
        for (var R = Array(arguments.length - 2), B = 2; B < arguments.length; B++) R[B - 2] = arguments[B]
        return w.prototype[E].apply(S, R)
      })
  }
  function n() {
    this.blockSize = -1
  }
  function i() {
    ;(this.blockSize = -1),
      (this.blockSize = 64),
      (this.g = Array(4)),
      (this.B = Array(this.blockSize)),
      (this.o = this.h = 0),
      this.s()
  }
  t(i, n),
    (i.prototype.s = function () {
      ;(this.g[0] = 1732584193),
        (this.g[1] = 4023233417),
        (this.g[2] = 2562383102),
        (this.g[3] = 271733878),
        (this.o = this.h = 0)
    })
  function r(I, w, _) {
    _ || (_ = 0)
    var S = Array(16)
    if (typeof w == 'string')
      for (var E = 0; 16 > E; ++E)
        S[E] = w.charCodeAt(_++) | (w.charCodeAt(_++) << 8) | (w.charCodeAt(_++) << 16) | (w.charCodeAt(_++) << 24)
    else for (E = 0; 16 > E; ++E) S[E] = w[_++] | (w[_++] << 8) | (w[_++] << 16) | (w[_++] << 24)
    ;(w = I.g[0]), (_ = I.g[1]), (E = I.g[2])
    var C = I.g[3],
      R = (w + (C ^ (_ & (E ^ C))) + S[0] + 3614090360) & 4294967295
    ;(w = _ + (((R << 7) & 4294967295) | (R >>> 25))),
      (R = (C + (E ^ (w & (_ ^ E))) + S[1] + 3905402710) & 4294967295),
      (C = w + (((R << 12) & 4294967295) | (R >>> 20))),
      (R = (E + (_ ^ (C & (w ^ _))) + S[2] + 606105819) & 4294967295),
      (E = C + (((R << 17) & 4294967295) | (R >>> 15))),
      (R = (_ + (w ^ (E & (C ^ w))) + S[3] + 3250441966) & 4294967295),
      (_ = E + (((R << 22) & 4294967295) | (R >>> 10))),
      (R = (w + (C ^ (_ & (E ^ C))) + S[4] + 4118548399) & 4294967295),
      (w = _ + (((R << 7) & 4294967295) | (R >>> 25))),
      (R = (C + (E ^ (w & (_ ^ E))) + S[5] + 1200080426) & 4294967295),
      (C = w + (((R << 12) & 4294967295) | (R >>> 20))),
      (R = (E + (_ ^ (C & (w ^ _))) + S[6] + 2821735955) & 4294967295),
      (E = C + (((R << 17) & 4294967295) | (R >>> 15))),
      (R = (_ + (w ^ (E & (C ^ w))) + S[7] + 4249261313) & 4294967295),
      (_ = E + (((R << 22) & 4294967295) | (R >>> 10))),
      (R = (w + (C ^ (_ & (E ^ C))) + S[8] + 1770035416) & 4294967295),
      (w = _ + (((R << 7) & 4294967295) | (R >>> 25))),
      (R = (C + (E ^ (w & (_ ^ E))) + S[9] + 2336552879) & 4294967295),
      (C = w + (((R << 12) & 4294967295) | (R >>> 20))),
      (R = (E + (_ ^ (C & (w ^ _))) + S[10] + 4294925233) & 4294967295),
      (E = C + (((R << 17) & 4294967295) | (R >>> 15))),
      (R = (_ + (w ^ (E & (C ^ w))) + S[11] + 2304563134) & 4294967295),
      (_ = E + (((R << 22) & 4294967295) | (R >>> 10))),
      (R = (w + (C ^ (_ & (E ^ C))) + S[12] + 1804603682) & 4294967295),
      (w = _ + (((R << 7) & 4294967295) | (R >>> 25))),
      (R = (C + (E ^ (w & (_ ^ E))) + S[13] + 4254626195) & 4294967295),
      (C = w + (((R << 12) & 4294967295) | (R >>> 20))),
      (R = (E + (_ ^ (C & (w ^ _))) + S[14] + 2792965006) & 4294967295),
      (E = C + (((R << 17) & 4294967295) | (R >>> 15))),
      (R = (_ + (w ^ (E & (C ^ w))) + S[15] + 1236535329) & 4294967295),
      (_ = E + (((R << 22) & 4294967295) | (R >>> 10))),
      (R = (w + (E ^ (C & (_ ^ E))) + S[1] + 4129170786) & 4294967295),
      (w = _ + (((R << 5) & 4294967295) | (R >>> 27))),
      (R = (C + (_ ^ (E & (w ^ _))) + S[6] + 3225465664) & 4294967295),
      (C = w + (((R << 9) & 4294967295) | (R >>> 23))),
      (R = (E + (w ^ (_ & (C ^ w))) + S[11] + 643717713) & 4294967295),
      (E = C + (((R << 14) & 4294967295) | (R >>> 18))),
      (R = (_ + (C ^ (w & (E ^ C))) + S[0] + 3921069994) & 4294967295),
      (_ = E + (((R << 20) & 4294967295) | (R >>> 12))),
      (R = (w + (E ^ (C & (_ ^ E))) + S[5] + 3593408605) & 4294967295),
      (w = _ + (((R << 5) & 4294967295) | (R >>> 27))),
      (R = (C + (_ ^ (E & (w ^ _))) + S[10] + 38016083) & 4294967295),
      (C = w + (((R << 9) & 4294967295) | (R >>> 23))),
      (R = (E + (w ^ (_ & (C ^ w))) + S[15] + 3634488961) & 4294967295),
      (E = C + (((R << 14) & 4294967295) | (R >>> 18))),
      (R = (_ + (C ^ (w & (E ^ C))) + S[4] + 3889429448) & 4294967295),
      (_ = E + (((R << 20) & 4294967295) | (R >>> 12))),
      (R = (w + (E ^ (C & (_ ^ E))) + S[9] + 568446438) & 4294967295),
      (w = _ + (((R << 5) & 4294967295) | (R >>> 27))),
      (R = (C + (_ ^ (E & (w ^ _))) + S[14] + 3275163606) & 4294967295),
      (C = w + (((R << 9) & 4294967295) | (R >>> 23))),
      (R = (E + (w ^ (_ & (C ^ w))) + S[3] + 4107603335) & 4294967295),
      (E = C + (((R << 14) & 4294967295) | (R >>> 18))),
      (R = (_ + (C ^ (w & (E ^ C))) + S[8] + 1163531501) & 4294967295),
      (_ = E + (((R << 20) & 4294967295) | (R >>> 12))),
      (R = (w + (E ^ (C & (_ ^ E))) + S[13] + 2850285829) & 4294967295),
      (w = _ + (((R << 5) & 4294967295) | (R >>> 27))),
      (R = (C + (_ ^ (E & (w ^ _))) + S[2] + 4243563512) & 4294967295),
      (C = w + (((R << 9) & 4294967295) | (R >>> 23))),
      (R = (E + (w ^ (_ & (C ^ w))) + S[7] + 1735328473) & 4294967295),
      (E = C + (((R << 14) & 4294967295) | (R >>> 18))),
      (R = (_ + (C ^ (w & (E ^ C))) + S[12] + 2368359562) & 4294967295),
      (_ = E + (((R << 20) & 4294967295) | (R >>> 12))),
      (R = (w + (_ ^ E ^ C) + S[5] + 4294588738) & 4294967295),
      (w = _ + (((R << 4) & 4294967295) | (R >>> 28))),
      (R = (C + (w ^ _ ^ E) + S[8] + 2272392833) & 4294967295),
      (C = w + (((R << 11) & 4294967295) | (R >>> 21))),
      (R = (E + (C ^ w ^ _) + S[11] + 1839030562) & 4294967295),
      (E = C + (((R << 16) & 4294967295) | (R >>> 16))),
      (R = (_ + (E ^ C ^ w) + S[14] + 4259657740) & 4294967295),
      (_ = E + (((R << 23) & 4294967295) | (R >>> 9))),
      (R = (w + (_ ^ E ^ C) + S[1] + 2763975236) & 4294967295),
      (w = _ + (((R << 4) & 4294967295) | (R >>> 28))),
      (R = (C + (w ^ _ ^ E) + S[4] + 1272893353) & 4294967295),
      (C = w + (((R << 11) & 4294967295) | (R >>> 21))),
      (R = (E + (C ^ w ^ _) + S[7] + 4139469664) & 4294967295),
      (E = C + (((R << 16) & 4294967295) | (R >>> 16))),
      (R = (_ + (E ^ C ^ w) + S[10] + 3200236656) & 4294967295),
      (_ = E + (((R << 23) & 4294967295) | (R >>> 9))),
      (R = (w + (_ ^ E ^ C) + S[13] + 681279174) & 4294967295),
      (w = _ + (((R << 4) & 4294967295) | (R >>> 28))),
      (R = (C + (w ^ _ ^ E) + S[0] + 3936430074) & 4294967295),
      (C = w + (((R << 11) & 4294967295) | (R >>> 21))),
      (R = (E + (C ^ w ^ _) + S[3] + 3572445317) & 4294967295),
      (E = C + (((R << 16) & 4294967295) | (R >>> 16))),
      (R = (_ + (E ^ C ^ w) + S[6] + 76029189) & 4294967295),
      (_ = E + (((R << 23) & 4294967295) | (R >>> 9))),
      (R = (w + (_ ^ E ^ C) + S[9] + 3654602809) & 4294967295),
      (w = _ + (((R << 4) & 4294967295) | (R >>> 28))),
      (R = (C + (w ^ _ ^ E) + S[12] + 3873151461) & 4294967295),
      (C = w + (((R << 11) & 4294967295) | (R >>> 21))),
      (R = (E + (C ^ w ^ _) + S[15] + 530742520) & 4294967295),
      (E = C + (((R << 16) & 4294967295) | (R >>> 16))),
      (R = (_ + (E ^ C ^ w) + S[2] + 3299628645) & 4294967295),
      (_ = E + (((R << 23) & 4294967295) | (R >>> 9))),
      (R = (w + (E ^ (_ | ~C)) + S[0] + 4096336452) & 4294967295),
      (w = _ + (((R << 6) & 4294967295) | (R >>> 26))),
      (R = (C + (_ ^ (w | ~E)) + S[7] + 1126891415) & 4294967295),
      (C = w + (((R << 10) & 4294967295) | (R >>> 22))),
      (R = (E + (w ^ (C | ~_)) + S[14] + 2878612391) & 4294967295),
      (E = C + (((R << 15) & 4294967295) | (R >>> 17))),
      (R = (_ + (C ^ (E | ~w)) + S[5] + 4237533241) & 4294967295),
      (_ = E + (((R << 21) & 4294967295) | (R >>> 11))),
      (R = (w + (E ^ (_ | ~C)) + S[12] + 1700485571) & 4294967295),
      (w = _ + (((R << 6) & 4294967295) | (R >>> 26))),
      (R = (C + (_ ^ (w | ~E)) + S[3] + 2399980690) & 4294967295),
      (C = w + (((R << 10) & 4294967295) | (R >>> 22))),
      (R = (E + (w ^ (C | ~_)) + S[10] + 4293915773) & 4294967295),
      (E = C + (((R << 15) & 4294967295) | (R >>> 17))),
      (R = (_ + (C ^ (E | ~w)) + S[1] + 2240044497) & 4294967295),
      (_ = E + (((R << 21) & 4294967295) | (R >>> 11))),
      (R = (w + (E ^ (_ | ~C)) + S[8] + 1873313359) & 4294967295),
      (w = _ + (((R << 6) & 4294967295) | (R >>> 26))),
      (R = (C + (_ ^ (w | ~E)) + S[15] + 4264355552) & 4294967295),
      (C = w + (((R << 10) & 4294967295) | (R >>> 22))),
      (R = (E + (w ^ (C | ~_)) + S[6] + 2734768916) & 4294967295),
      (E = C + (((R << 15) & 4294967295) | (R >>> 17))),
      (R = (_ + (C ^ (E | ~w)) + S[13] + 1309151649) & 4294967295),
      (_ = E + (((R << 21) & 4294967295) | (R >>> 11))),
      (R = (w + (E ^ (_ | ~C)) + S[4] + 4149444226) & 4294967295),
      (w = _ + (((R << 6) & 4294967295) | (R >>> 26))),
      (R = (C + (_ ^ (w | ~E)) + S[11] + 3174756917) & 4294967295),
      (C = w + (((R << 10) & 4294967295) | (R >>> 22))),
      (R = (E + (w ^ (C | ~_)) + S[2] + 718787259) & 4294967295),
      (E = C + (((R << 15) & 4294967295) | (R >>> 17))),
      (R = (_ + (C ^ (E | ~w)) + S[9] + 3951481745) & 4294967295),
      (I.g[0] = (I.g[0] + w) & 4294967295),
      (I.g[1] = (I.g[1] + (E + (((R << 21) & 4294967295) | (R >>> 11)))) & 4294967295),
      (I.g[2] = (I.g[2] + E) & 4294967295),
      (I.g[3] = (I.g[3] + C) & 4294967295)
  }
  ;(i.prototype.u = function (I, w) {
    w === void 0 && (w = I.length)
    for (var _ = w - this.blockSize, S = this.B, E = this.h, C = 0; C < w; ) {
      if (E == 0) for (; C <= _; ) r(this, I, C), (C += this.blockSize)
      if (typeof I == 'string') {
        for (; C < w; )
          if (((S[E++] = I.charCodeAt(C++)), E == this.blockSize)) {
            r(this, S), (E = 0)
            break
          }
      } else
        for (; C < w; )
          if (((S[E++] = I[C++]), E == this.blockSize)) {
            r(this, S), (E = 0)
            break
          }
    }
    ;(this.h = E), (this.o += w)
  }),
    (i.prototype.v = function () {
      var I = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h)
      I[0] = 128
      for (var w = 1; w < I.length - 8; ++w) I[w] = 0
      var _ = 8 * this.o
      for (w = I.length - 8; w < I.length; ++w) (I[w] = _ & 255), (_ /= 256)
      for (this.u(I), I = Array(16), w = _ = 0; 4 > w; ++w)
        for (var S = 0; 32 > S; S += 8) I[_++] = (this.g[w] >>> S) & 255
      return I
    })
  function s(I, w) {
    var _ = a
    return Object.prototype.hasOwnProperty.call(_, I) ? _[I] : (_[I] = w(I))
  }
  function o(I, w) {
    this.h = w
    for (var _ = [], S = !0, E = I.length - 1; 0 <= E; E--) {
      var C = I[E] | 0
      ;(S && C == w) || ((_[E] = C), (S = !1))
    }
    this.g = _
  }
  var a = {}
  function l(I) {
    return -128 <= I && 128 > I
      ? s(I, function (w) {
          return new o([w | 0], 0 > w ? -1 : 0)
        })
      : new o([I | 0], 0 > I ? -1 : 0)
  }
  function u(I) {
    if (isNaN(I) || !isFinite(I)) return d
    if (0 > I) return y(u(-I))
    for (var w = [], _ = 1, S = 0; I >= _; S++) (w[S] = (I / _) | 0), (_ *= 4294967296)
    return new o(w, 0)
  }
  function c(I, w) {
    if (I.length == 0) throw Error('number format error: empty string')
    if (((w = w || 10), 2 > w || 36 < w)) throw Error('radix out of range: ' + w)
    if (I.charAt(0) == '-') return y(c(I.substring(1), w))
    if (0 <= I.indexOf('-')) throw Error('number format error: interior "-" character')
    for (var _ = u(Math.pow(w, 8)), S = d, E = 0; E < I.length; E += 8) {
      var C = Math.min(8, I.length - E),
        R = parseInt(I.substring(E, E + C), w)
      8 > C ? ((C = u(Math.pow(w, C))), (S = S.j(C).add(u(R)))) : ((S = S.j(_)), (S = S.add(u(R))))
    }
    return S
  }
  var d = l(0),
    f = l(1),
    m = l(16777216)
  ;(e = o.prototype),
    (e.m = function () {
      if (v(this)) return -y(this).m()
      for (var I = 0, w = 1, _ = 0; _ < this.g.length; _++) {
        var S = this.i(_)
        ;(I += (0 <= S ? S : 4294967296 + S) * w), (w *= 4294967296)
      }
      return I
    }),
    (e.toString = function (I) {
      if (((I = I || 10), 2 > I || 36 < I)) throw Error('radix out of range: ' + I)
      if (p(this)) return '0'
      if (v(this)) return '-' + y(this).toString(I)
      for (var w = u(Math.pow(I, 6)), _ = this, S = ''; ; ) {
        var E = N(_, w).g
        _ = T(_, E.j(w))
        var C = ((0 < _.g.length ? _.g[0] : _.h) >>> 0).toString(I)
        if (((_ = E), p(_))) return C + S
        for (; 6 > C.length; ) C = '0' + C
        S = C + S
      }
    }),
    (e.i = function (I) {
      return 0 > I ? 0 : I < this.g.length ? this.g[I] : this.h
    })
  function p(I) {
    if (I.h != 0) return !1
    for (var w = 0; w < I.g.length; w++) if (I.g[w] != 0) return !1
    return !0
  }
  function v(I) {
    return I.h == -1
  }
  e.l = function (I) {
    return (I = T(this, I)), v(I) ? -1 : p(I) ? 0 : 1
  }
  function y(I) {
    for (var w = I.g.length, _ = [], S = 0; S < w; S++) _[S] = ~I.g[S]
    return new o(_, ~I.h).add(f)
  }
  ;(e.abs = function () {
    return v(this) ? y(this) : this
  }),
    (e.add = function (I) {
      for (var w = Math.max(this.g.length, I.g.length), _ = [], S = 0, E = 0; E <= w; E++) {
        var C = S + (this.i(E) & 65535) + (I.i(E) & 65535),
          R = (C >>> 16) + (this.i(E) >>> 16) + (I.i(E) >>> 16)
        ;(S = R >>> 16), (C &= 65535), (R &= 65535), (_[E] = (R << 16) | C)
      }
      return new o(_, _[_.length - 1] & -2147483648 ? -1 : 0)
    })
  function T(I, w) {
    return I.add(y(w))
  }
  e.j = function (I) {
    if (p(this) || p(I)) return d
    if (v(this)) return v(I) ? y(this).j(y(I)) : y(y(this).j(I))
    if (v(I)) return y(this.j(y(I)))
    if (0 > this.l(m) && 0 > I.l(m)) return u(this.m() * I.m())
    for (var w = this.g.length + I.g.length, _ = [], S = 0; S < 2 * w; S++) _[S] = 0
    for (S = 0; S < this.g.length; S++)
      for (var E = 0; E < I.g.length; E++) {
        var C = this.i(S) >>> 16,
          R = this.i(S) & 65535,
          B = I.i(E) >>> 16,
          U = I.i(E) & 65535
        ;(_[2 * S + 2 * E] += R * U),
          A(_, 2 * S + 2 * E),
          (_[2 * S + 2 * E + 1] += C * U),
          A(_, 2 * S + 2 * E + 1),
          (_[2 * S + 2 * E + 1] += R * B),
          A(_, 2 * S + 2 * E + 1),
          (_[2 * S + 2 * E + 2] += C * B),
          A(_, 2 * S + 2 * E + 2)
      }
    for (S = 0; S < w; S++) _[S] = (_[2 * S + 1] << 16) | _[2 * S]
    for (S = w; S < 2 * w; S++) _[S] = 0
    return new o(_, 0)
  }
  function A(I, w) {
    for (; (I[w] & 65535) != I[w]; ) (I[w + 1] += I[w] >>> 16), (I[w] &= 65535), w++
  }
  function x(I, w) {
    ;(this.g = I), (this.h = w)
  }
  function N(I, w) {
    if (p(w)) throw Error('division by zero')
    if (p(I)) return new x(d, d)
    if (v(I)) return (w = N(y(I), w)), new x(y(w.g), y(w.h))
    if (v(w)) return (w = N(I, y(w))), new x(y(w.g), w.h)
    if (30 < I.g.length) {
      if (v(I) || v(w)) throw Error('slowDivide_ only works with positive integers.')
      for (var _ = f, S = w; 0 >= S.l(I); ) (_ = V(_)), (S = V(S))
      var E = D(_, 1),
        C = D(S, 1)
      for (S = D(S, 2), _ = D(_, 2); !p(S); ) {
        var R = C.add(S)
        0 >= R.l(I) && ((E = E.add(_)), (C = R)), (S = D(S, 1)), (_ = D(_, 1))
      }
      return (w = T(I, E.j(w))), new x(E, w)
    }
    for (E = d; 0 <= I.l(w); ) {
      for (
        _ = Math.max(1, Math.floor(I.m() / w.m())),
          S = Math.ceil(Math.log(_) / Math.LN2),
          S = 48 >= S ? 1 : Math.pow(2, S - 48),
          C = u(_),
          R = C.j(w);
        v(R) || 0 < R.l(I);

      )
        (_ -= S), (C = u(_)), (R = C.j(w))
      p(C) && (C = f), (E = E.add(C)), (I = T(I, R))
    }
    return new x(E, I)
  }
  ;(e.A = function (I) {
    return N(this, I).h
  }),
    (e.and = function (I) {
      for (var w = Math.max(this.g.length, I.g.length), _ = [], S = 0; S < w; S++) _[S] = this.i(S) & I.i(S)
      return new o(_, this.h & I.h)
    }),
    (e.or = function (I) {
      for (var w = Math.max(this.g.length, I.g.length), _ = [], S = 0; S < w; S++) _[S] = this.i(S) | I.i(S)
      return new o(_, this.h | I.h)
    }),
    (e.xor = function (I) {
      for (var w = Math.max(this.g.length, I.g.length), _ = [], S = 0; S < w; S++) _[S] = this.i(S) ^ I.i(S)
      return new o(_, this.h ^ I.h)
    })
  function V(I) {
    for (var w = I.g.length + 1, _ = [], S = 0; S < w; S++) _[S] = (I.i(S) << 1) | (I.i(S - 1) >>> 31)
    return new o(_, I.h)
  }
  function D(I, w) {
    var _ = w >> 5
    w %= 32
    for (var S = I.g.length - _, E = [], C = 0; C < S; C++)
      E[C] = 0 < w ? (I.i(C + _) >>> w) | (I.i(C + _ + 1) << (32 - w)) : I.i(C + _)
    return new o(E, I.h)
  }
  ;(i.prototype.digest = i.prototype.v),
    (i.prototype.reset = i.prototype.s),
    (i.prototype.update = i.prototype.u),
    (vR = i),
    (o.prototype.add = o.prototype.add),
    (o.prototype.multiply = o.prototype.j),
    (o.prototype.modulo = o.prototype.A),
    (o.prototype.compare = o.prototype.l),
    (o.prototype.toNumber = o.prototype.m),
    (o.prototype.toString = o.prototype.toString),
    (o.prototype.getBits = o.prototype.i),
    (o.fromNumber = u),
    (o.fromString = c),
    (So = o)
}).apply(typeof EE < 'u' ? EE : typeof self < 'u' ? self : typeof window < 'u' ? window : {})
var Xd =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/ var pR, yR, Ru, _R, wh, op, bR, wR, IR
;(function () {
  var e,
    t =
      typeof Object.defineProperties == 'function'
        ? Object.defineProperty
        : function (h, b, P) {
            return h == Array.prototype || h == Object.prototype || (h[b] = P.value), h
          }
  function n(h) {
    h = [
      typeof globalThis == 'object' && globalThis,
      h,
      typeof window == 'object' && window,
      typeof self == 'object' && self,
      typeof Xd == 'object' && Xd,
    ]
    for (var b = 0; b < h.length; ++b) {
      var P = h[b]
      if (P && P.Math == Math) return P
    }
    throw Error('Cannot find global object')
  }
  var i = n(this)
  function r(h, b) {
    if (b)
      e: {
        var P = i
        h = h.split('.')
        for (var M = 0; M < h.length - 1; M++) {
          var Y = h[M]
          if (!(Y in P)) break e
          P = P[Y]
        }
        ;(h = h[h.length - 1]),
          (M = P[h]),
          (b = b(M)),
          b != M && b != null && t(P, h, { configurable: !0, writable: !0, value: b })
      }
  }
  function s(h, b) {
    h instanceof String && (h += '')
    var P = 0,
      M = !1,
      Y = {
        next: function () {
          if (!M && P < h.length) {
            var ie = P++
            return { value: b(ie, h[ie]), done: !1 }
          }
          return (M = !0), { done: !0, value: void 0 }
        },
      }
    return (
      (Y[Symbol.iterator] = function () {
        return Y
      }),
      Y
    )
  }
  r('Array.prototype.values', function (h) {
    return (
      h ||
      function () {
        return s(this, function (b, P) {
          return P
        })
      }
    )
  })
  /** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/ var o = o || {},
    a = this || self
  function l(h) {
    var b = typeof h
    return (
      (b = b != 'object' ? b : h ? (Array.isArray(h) ? 'array' : b) : 'null'),
      b == 'array' || (b == 'object' && typeof h.length == 'number')
    )
  }
  function u(h) {
    var b = typeof h
    return (b == 'object' && h != null) || b == 'function'
  }
  function c(h, b, P) {
    return h.call.apply(h.bind, arguments)
  }
  function d(h, b, P) {
    if (!h) throw Error()
    if (2 < arguments.length) {
      var M = Array.prototype.slice.call(arguments, 2)
      return function () {
        var Y = Array.prototype.slice.call(arguments)
        return Array.prototype.unshift.apply(Y, M), h.apply(b, Y)
      }
    }
    return function () {
      return h.apply(b, arguments)
    }
  }
  function f(h, b, P) {
    return (
      (f = Function.prototype.bind && Function.prototype.bind.toString().indexOf('native code') != -1 ? c : d),
      f.apply(null, arguments)
    )
  }
  function m(h, b) {
    var P = Array.prototype.slice.call(arguments, 1)
    return function () {
      var M = P.slice()
      return M.push.apply(M, arguments), h.apply(this, M)
    }
  }
  function p(h, b) {
    function P() {}
    ;(P.prototype = b.prototype),
      (h.aa = b.prototype),
      (h.prototype = new P()),
      (h.prototype.constructor = h),
      (h.Qb = function (M, Y, ie) {
        for (var Ce = Array(arguments.length - 2), wt = 2; wt < arguments.length; wt++) Ce[wt - 2] = arguments[wt]
        return b.prototype[Y].apply(M, Ce)
      })
  }
  function v(h) {
    const b = h.length
    if (0 < b) {
      const P = Array(b)
      for (let M = 0; M < b; M++) P[M] = h[M]
      return P
    }
    return []
  }
  function y(h, b) {
    for (let P = 1; P < arguments.length; P++) {
      const M = arguments[P]
      if (l(M)) {
        const Y = h.length || 0,
          ie = M.length || 0
        h.length = Y + ie
        for (let Ce = 0; Ce < ie; Ce++) h[Y + Ce] = M[Ce]
      } else h.push(M)
    }
  }
  class T {
    constructor(b, P) {
      ;(this.i = b), (this.j = P), (this.h = 0), (this.g = null)
    }
    get() {
      let b
      return 0 < this.h ? (this.h--, (b = this.g), (this.g = b.next), (b.next = null)) : (b = this.i()), b
    }
  }
  function A(h) {
    return /^[\s\xa0]*$/.test(h)
  }
  function x() {
    var h = a.navigator
    return h && (h = h.userAgent) ? h : ''
  }
  function N(h) {
    return N[' '](h), h
  }
  N[' '] = function () {}
  var V =
    x().indexOf('Gecko') != -1 &&
    !(x().toLowerCase().indexOf('webkit') != -1 && x().indexOf('Edge') == -1) &&
    !(x().indexOf('Trident') != -1 || x().indexOf('MSIE') != -1) &&
    x().indexOf('Edge') == -1
  function D(h, b, P) {
    for (const M in h) b.call(P, h[M], M, h)
  }
  function I(h, b) {
    for (const P in h) b.call(void 0, h[P], P, h)
  }
  function w(h) {
    const b = {}
    for (const P in h) b[P] = h[P]
    return b
  }
  const _ = 'constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf'.split(' ')
  function S(h, b) {
    let P, M
    for (let Y = 1; Y < arguments.length; Y++) {
      M = arguments[Y]
      for (P in M) h[P] = M[P]
      for (let ie = 0; ie < _.length; ie++) (P = _[ie]), Object.prototype.hasOwnProperty.call(M, P) && (h[P] = M[P])
    }
  }
  function E(h) {
    var b = 1
    h = h.split(':')
    const P = []
    for (; 0 < b && h.length; ) P.push(h.shift()), b--
    return h.length && P.push(h.join(':')), P
  }
  function C(h) {
    a.setTimeout(() => {
      throw h
    }, 0)
  }
  function R() {
    var h = K
    let b = null
    return h.g && ((b = h.g), (h.g = h.g.next), h.g || (h.h = null), (b.next = null)), b
  }
  class B {
    constructor() {
      this.h = this.g = null
    }
    add(b, P) {
      const M = U.get()
      M.set(b, P), this.h ? (this.h.next = M) : (this.g = M), (this.h = M)
    }
  }
  var U = new T(
    () => new $(),
    (h) => h.reset()
  )
  class $ {
    constructor() {
      this.next = this.g = this.h = null
    }
    set(b, P) {
      ;(this.h = b), (this.g = P), (this.next = null)
    }
    reset() {
      this.next = this.g = this.h = null
    }
  }
  let G,
    F = !1,
    K = new B(),
    j = () => {
      const h = a.Promise.resolve(void 0)
      G = () => {
        h.then(q)
      }
    }
  var q = () => {
    for (var h; (h = R()); ) {
      try {
        h.h.call(h.g)
      } catch (P) {
        C(P)
      }
      var b = U
      b.j(h), 100 > b.h && (b.h++, (h.next = b.g), (b.g = h))
    }
    F = !1
  }
  function te() {
    ;(this.s = this.s), (this.C = this.C)
  }
  ;(te.prototype.s = !1),
    (te.prototype.ma = function () {
      this.s || ((this.s = !0), this.N())
    }),
    (te.prototype.N = function () {
      if (this.C) for (; this.C.length; ) this.C.shift()()
    })
  function ce(h, b) {
    ;(this.type = h), (this.g = this.target = b), (this.defaultPrevented = !1)
  }
  ce.prototype.h = function () {
    this.defaultPrevented = !0
  }
  var Ee = (function () {
    if (!a.addEventListener || !Object.defineProperty) return !1
    var h = !1,
      b = Object.defineProperty({}, 'passive', {
        get: function () {
          h = !0
        },
      })
    try {
      const P = () => {}
      a.addEventListener('test', P, b), a.removeEventListener('test', P, b)
    } catch {}
    return h
  })()
  function me(h, b) {
    if (
      (ce.call(this, h ? h.type : ''),
      (this.relatedTarget = this.g = this.target = null),
      (this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0),
      (this.key = ''),
      (this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1),
      (this.state = null),
      (this.pointerId = 0),
      (this.pointerType = ''),
      (this.i = null),
      h)
    ) {
      var P = (this.type = h.type),
        M = h.changedTouches && h.changedTouches.length ? h.changedTouches[0] : null
      if (((this.target = h.target || h.srcElement), (this.g = b), (b = h.relatedTarget))) {
        if (V) {
          e: {
            try {
              N(b.nodeName)
              var Y = !0
              break e
            } catch {}
            Y = !1
          }
          Y || (b = null)
        }
      } else P == 'mouseover' ? (b = h.fromElement) : P == 'mouseout' && (b = h.toElement)
      ;(this.relatedTarget = b),
        M
          ? ((this.clientX = M.clientX !== void 0 ? M.clientX : M.pageX),
            (this.clientY = M.clientY !== void 0 ? M.clientY : M.pageY),
            (this.screenX = M.screenX || 0),
            (this.screenY = M.screenY || 0))
          : ((this.clientX = h.clientX !== void 0 ? h.clientX : h.pageX),
            (this.clientY = h.clientY !== void 0 ? h.clientY : h.pageY),
            (this.screenX = h.screenX || 0),
            (this.screenY = h.screenY || 0)),
        (this.button = h.button),
        (this.key = h.key || ''),
        (this.ctrlKey = h.ctrlKey),
        (this.altKey = h.altKey),
        (this.shiftKey = h.shiftKey),
        (this.metaKey = h.metaKey),
        (this.pointerId = h.pointerId || 0),
        (this.pointerType = typeof h.pointerType == 'string' ? h.pointerType : oe[h.pointerType] || ''),
        (this.state = h.state),
        (this.i = h),
        h.defaultPrevented && me.aa.h.call(this)
    }
  }
  p(me, ce)
  var oe = { 2: 'touch', 3: 'pen', 4: 'mouse' }
  me.prototype.h = function () {
    me.aa.h.call(this)
    var h = this.i
    h.preventDefault ? h.preventDefault() : (h.returnValue = !1)
  }
  var z = 'closure_listenable_' + ((1e6 * Math.random()) | 0),
    ue = 0
  function de(h, b, P, M, Y) {
    ;(this.listener = h),
      (this.proxy = null),
      (this.src = b),
      (this.type = P),
      (this.capture = !!M),
      (this.ha = Y),
      (this.key = ++ue),
      (this.da = this.fa = !1)
  }
  function Z(h) {
    ;(h.da = !0), (h.listener = null), (h.proxy = null), (h.src = null), (h.ha = null)
  }
  function pe(h) {
    ;(this.src = h), (this.g = {}), (this.h = 0)
  }
  pe.prototype.add = function (h, b, P, M, Y) {
    var ie = h.toString()
    ;(h = this.g[ie]), h || ((h = this.g[ie] = []), this.h++)
    var Ce = O(h, b, M, Y)
    return -1 < Ce ? ((b = h[Ce]), P || (b.fa = !1)) : ((b = new de(b, this.src, ie, !!M, Y)), (b.fa = P), h.push(b)), b
  }
  function re(h, b) {
    var P = b.type
    if (P in h.g) {
      var M = h.g[P],
        Y = Array.prototype.indexOf.call(M, b, void 0),
        ie
      ;(ie = 0 <= Y) && Array.prototype.splice.call(M, Y, 1), ie && (Z(b), h.g[P].length == 0 && (delete h.g[P], h.h--))
    }
  }
  function O(h, b, P, M) {
    for (var Y = 0; Y < h.length; ++Y) {
      var ie = h[Y]
      if (!ie.da && ie.listener == b && ie.capture == !!P && ie.ha == M) return Y
    }
    return -1
  }
  var L = 'closure_lm_' + ((1e6 * Math.random()) | 0),
    H = {}
  function X(h, b, P, M, Y) {
    if (Array.isArray(b)) {
      for (var ie = 0; ie < b.length; ie++) X(h, b[ie], P, M, Y)
      return null
    }
    return (P = De(P)), h && h[z] ? h.K(b, P, u(M) ? !!M.capture : !!M, Y) : ee(h, b, P, !1, M, Y)
  }
  function ee(h, b, P, M, Y, ie) {
    if (!b) throw Error('Invalid event type')
    var Ce = u(Y) ? !!Y.capture : !!Y,
      wt = Ae(h)
    if ((wt || (h[L] = wt = new pe(h)), (P = wt.add(b, P, M, Ce, ie)), P.proxy)) return P
    if (((M = he()), (P.proxy = M), (M.src = h), (M.listener = P), h.addEventListener))
      Ee || (Y = Ce), Y === void 0 && (Y = !1), h.addEventListener(b.toString(), M, Y)
    else if (h.attachEvent) h.attachEvent(_e(b.toString()), M)
    else if (h.addListener && h.removeListener) h.addListener(M)
    else throw Error('addEventListener and attachEvent are unavailable.')
    return P
  }
  function he() {
    function h(P) {
      return b.call(h.src, h.listener, P)
    }
    const b = ve
    return h
  }
  function ge(h, b, P, M, Y) {
    if (Array.isArray(b)) for (var ie = 0; ie < b.length; ie++) ge(h, b[ie], P, M, Y)
    else
      (M = u(M) ? !!M.capture : !!M),
        (P = De(P)),
        h && h[z]
          ? ((h = h.i),
            (b = String(b).toString()),
            b in h.g &&
              ((ie = h.g[b]),
              (P = O(ie, P, M, Y)),
              -1 < P && (Z(ie[P]), Array.prototype.splice.call(ie, P, 1), ie.length == 0 && (delete h.g[b], h.h--))))
          : h &&
            (h = Ae(h)) &&
            ((b = h.g[b.toString()]), (h = -1), b && (h = O(b, P, M, Y)), (P = -1 < h ? b[h] : null) && Ie(P))
  }
  function Ie(h) {
    if (typeof h != 'number' && h && !h.da) {
      var b = h.src
      if (b && b[z]) re(b.i, h)
      else {
        var P = h.type,
          M = h.proxy
        b.removeEventListener
          ? b.removeEventListener(P, M, h.capture)
          : b.detachEvent
          ? b.detachEvent(_e(P), M)
          : b.addListener && b.removeListener && b.removeListener(M),
          (P = Ae(b)) ? (re(P, h), P.h == 0 && ((P.src = null), (b[L] = null))) : Z(h)
      }
    }
  }
  function _e(h) {
    return h in H ? H[h] : (H[h] = 'on' + h)
  }
  function ve(h, b) {
    if (h.da) h = !0
    else {
      b = new me(b, this)
      var P = h.listener,
        M = h.ha || h.src
      h.fa && Ie(h), (h = P.call(M, b))
    }
    return h
  }
  function Ae(h) {
    return (h = h[L]), h instanceof pe ? h : null
  }
  var Ne = '__closure_events_fn_' + ((1e9 * Math.random()) >>> 0)
  function De(h) {
    return typeof h == 'function'
      ? h
      : (h[Ne] ||
          (h[Ne] = function (b) {
            return h.handleEvent(b)
          }),
        h[Ne])
  }
  function Me() {
    te.call(this), (this.i = new pe(this)), (this.M = this), (this.F = null)
  }
  p(Me, te),
    (Me.prototype[z] = !0),
    (Me.prototype.removeEventListener = function (h, b, P, M) {
      ge(this, h, b, P, M)
    })
  function Be(h, b) {
    var P,
      M = h.F
    if (M) for (P = []; M; M = M.F) P.push(M)
    if (((h = h.M), (M = b.type || b), typeof b == 'string')) b = new ce(b, h)
    else if (b instanceof ce) b.target = b.target || h
    else {
      var Y = b
      ;(b = new ce(M, h)), S(b, Y)
    }
    if (((Y = !0), P))
      for (var ie = P.length - 1; 0 <= ie; ie--) {
        var Ce = (b.g = P[ie])
        Y = ht(Ce, M, !0, b) && Y
      }
    if (((Ce = b.g = h), (Y = ht(Ce, M, !0, b) && Y), (Y = ht(Ce, M, !1, b) && Y), P))
      for (ie = 0; ie < P.length; ie++) (Ce = b.g = P[ie]), (Y = ht(Ce, M, !1, b) && Y)
  }
  ;(Me.prototype.N = function () {
    if ((Me.aa.N.call(this), this.i)) {
      var h = this.i,
        b
      for (b in h.g) {
        for (var P = h.g[b], M = 0; M < P.length; M++) Z(P[M])
        delete h.g[b], h.h--
      }
    }
    this.F = null
  }),
    (Me.prototype.K = function (h, b, P, M) {
      return this.i.add(String(h), b, !1, P, M)
    }),
    (Me.prototype.L = function (h, b, P, M) {
      return this.i.add(String(h), b, !0, P, M)
    })
  function ht(h, b, P, M) {
    if (((b = h.i.g[String(b)]), !b)) return !0
    b = b.concat()
    for (var Y = !0, ie = 0; ie < b.length; ++ie) {
      var Ce = b[ie]
      if (Ce && !Ce.da && Ce.capture == P) {
        var wt = Ce.listener,
          _n = Ce.ha || Ce.src
        Ce.fa && re(h.i, Ce), (Y = wt.call(_n, M) !== !1 && Y)
      }
    }
    return Y && !M.defaultPrevented
  }
  function lt(h, b, P) {
    if (typeof h == 'function') P && (h = f(h, P))
    else if (h && typeof h.handleEvent == 'function') h = f(h.handleEvent, h)
    else throw Error('Invalid listener argument')
    return 2147483647 < Number(b) ? -1 : a.setTimeout(h, b || 0)
  }
  function Yt(h) {
    h.g = lt(() => {
      ;(h.g = null), h.i && ((h.i = !1), Yt(h))
    }, h.l)
    const b = h.h
    ;(h.h = null), h.m.apply(null, b)
  }
  class si extends te {
    constructor(b, P) {
      super(), (this.m = b), (this.l = P), (this.h = null), (this.i = !1), (this.g = null)
    }
    j(b) {
      ;(this.h = arguments), this.g ? (this.i = !0) : Yt(this)
    }
    N() {
      super.N(), this.g && (a.clearTimeout(this.g), (this.g = null), (this.i = !1), (this.h = null))
    }
  }
  function wi(h) {
    te.call(this), (this.h = h), (this.g = {})
  }
  p(wi, te)
  var Xl = []
  function Jr(h) {
    D(
      h.g,
      function (b, P) {
        this.g.hasOwnProperty(P) && Ie(b)
      },
      h
    ),
      (h.g = {})
  }
  ;(wi.prototype.N = function () {
    wi.aa.N.call(this), Jr(this)
  }),
    (wi.prototype.handleEvent = function () {
      throw Error('EventHandler.handleEvent not implemented')
    })
  var ba = a.JSON.stringify,
    jn = a.JSON.parse,
    Ii = class {
      stringify(h) {
        return a.JSON.stringify(h, void 0)
      }
      parse(h) {
        return a.JSON.parse(h, void 0)
      }
    }
  function wa() {}
  wa.prototype.h = null
  function Ew(h) {
    return h.h || (h.h = h.i())
  }
  function Tw() {}
  var Jl = { OPEN: 'a', kb: 'b', Ja: 'c', wb: 'd' }
  function rg() {
    ce.call(this, 'd')
  }
  p(rg, ce)
  function sg() {
    ce.call(this, 'c')
  }
  p(sg, ce)
  var Qs = {},
    Cw = null
  function bd() {
    return (Cw = Cw || new Me())
  }
  Qs.La = 'serverreachability'
  function Aw(h) {
    ce.call(this, Qs.La, h)
  }
  p(Aw, ce)
  function Zl(h) {
    const b = bd()
    Be(b, new Aw(b))
  }
  Qs.STAT_EVENT = 'statevent'
  function kw(h, b) {
    ce.call(this, Qs.STAT_EVENT, h), (this.stat = b)
  }
  p(kw, ce)
  function zn(h) {
    const b = bd()
    Be(b, new kw(b, h))
  }
  Qs.Ma = 'timingevent'
  function Pw(h, b) {
    ce.call(this, Qs.Ma, h), (this.size = b)
  }
  p(Pw, ce)
  function eu(h, b) {
    if (typeof h != 'function') throw Error('Fn must not be null and must be a function')
    return a.setTimeout(function () {
      h()
    }, b)
  }
  function tu() {
    this.g = !0
  }
  tu.prototype.xa = function () {
    this.g = !1
  }
  function YO(h, b, P, M, Y, ie) {
    h.info(function () {
      if (h.g)
        if (ie)
          for (var Ce = '', wt = ie.split('&'), _n = 0; _n < wt.length; _n++) {
            var dt = wt[_n].split('=')
            if (1 < dt.length) {
              var Pn = dt[0]
              dt = dt[1]
              var Rn = Pn.split('_')
              Ce = 2 <= Rn.length && Rn[1] == 'type' ? Ce + (Pn + '=' + dt + '&') : Ce + (Pn + '=redacted&')
            }
          }
        else Ce = null
      else Ce = ie
      return (
        'XMLHTTP REQ (' +
        M +
        ') [attempt ' +
        Y +
        ']: ' +
        b +
        `
` +
        P +
        `
` +
        Ce
      )
    })
  }
  function QO(h, b, P, M, Y, ie, Ce) {
    h.info(function () {
      return (
        'XMLHTTP RESP (' +
        M +
        ') [ attempt ' +
        Y +
        ']: ' +
        b +
        `
` +
        P +
        `
` +
        ie +
        ' ' +
        Ce
      )
    })
  }
  function Ia(h, b, P, M) {
    h.info(function () {
      return 'XMLHTTP TEXT (' + b + '): ' + JO(h, P) + (M ? ' ' + M : '')
    })
  }
  function XO(h, b) {
    h.info(function () {
      return 'TIMEOUT: ' + b
    })
  }
  tu.prototype.info = function () {}
  function JO(h, b) {
    if (!h.g) return b
    if (!b) return null
    try {
      var P = JSON.parse(b)
      if (P) {
        for (h = 0; h < P.length; h++)
          if (Array.isArray(P[h])) {
            var M = P[h]
            if (!(2 > M.length)) {
              var Y = M[1]
              if (Array.isArray(Y) && !(1 > Y.length)) {
                var ie = Y[0]
                if (ie != 'noop' && ie != 'stop' && ie != 'close') for (var Ce = 1; Ce < Y.length; Ce++) Y[Ce] = ''
              }
            }
          }
      }
      return ba(P)
    } catch {
      return b
    }
  }
  var wd = { NO_ERROR: 0, gb: 1, tb: 2, sb: 3, nb: 4, rb: 5, ub: 6, Ia: 7, TIMEOUT: 8, xb: 9 },
    Rw = {
      lb: 'complete',
      Hb: 'success',
      Ja: 'error',
      Ia: 'abort',
      zb: 'ready',
      Ab: 'readystatechange',
      TIMEOUT: 'timeout',
      vb: 'incrementaldata',
      yb: 'progress',
      ob: 'downloadprogress',
      Pb: 'uploadprogress',
    },
    og
  function Id() {}
  p(Id, wa),
    (Id.prototype.g = function () {
      return new XMLHttpRequest()
    }),
    (Id.prototype.i = function () {
      return {}
    }),
    (og = new Id())
  function Zr(h, b, P, M) {
    ;(this.j = h),
      (this.i = b),
      (this.l = P),
      (this.R = M || 1),
      (this.U = new wi(this)),
      (this.I = 45e3),
      (this.H = null),
      (this.o = !1),
      (this.m = this.A = this.v = this.L = this.F = this.S = this.B = null),
      (this.D = []),
      (this.g = null),
      (this.C = 0),
      (this.s = this.u = null),
      (this.X = -1),
      (this.J = !1),
      (this.O = 0),
      (this.M = null),
      (this.W = this.K = this.T = this.P = !1),
      (this.h = new xw())
  }
  function xw() {
    ;(this.i = null), (this.g = ''), (this.h = !1)
  }
  var Vw = {},
    ag = {}
  function lg(h, b, P) {
    ;(h.L = 1), (h.v = Cd(br(b))), (h.m = P), (h.P = !0), Dw(h, null)
  }
  function Dw(h, b) {
    ;(h.F = Date.now()), Sd(h), (h.A = br(h.v))
    var P = h.A,
      M = h.R
    Array.isArray(M) || (M = [String(M)]),
      Gw(P.i, 't', M),
      (h.C = 0),
      (P = h.j.J),
      (h.h = new xw()),
      (h.g = dI(h.j, P ? b : null, !h.m)),
      0 < h.O && (h.M = new si(f(h.Y, h, h.g), h.O)),
      (b = h.U),
      (P = h.g),
      (M = h.ca)
    var Y = 'readystatechange'
    Array.isArray(Y) || (Y && (Xl[0] = Y.toString()), (Y = Xl))
    for (var ie = 0; ie < Y.length; ie++) {
      var Ce = X(P, Y[ie], M || b.handleEvent, !1, b.h || b)
      if (!Ce) break
      b.g[Ce.key] = Ce
    }
    ;(b = h.H ? w(h.H) : {}),
      h.m
        ? (h.u || (h.u = 'POST'), (b['Content-Type'] = 'application/x-www-form-urlencoded'), h.g.ea(h.A, h.u, h.m, b))
        : ((h.u = 'GET'), h.g.ea(h.A, h.u, null, b)),
      Zl(),
      YO(h.i, h.u, h.A, h.l, h.R, h.m)
  }
  ;(Zr.prototype.ca = function (h) {
    h = h.target
    const b = this.M
    b && wr(h) == 3 ? b.j() : this.Y(h)
  }),
    (Zr.prototype.Y = function (h) {
      try {
        if (h == this.g)
          e: {
            const Rn = wr(this.g)
            var b = this.g.Ba()
            const Ta = this.g.Z()
            if (!(3 > Rn) && (Rn != 3 || (this.g && (this.h.h || this.g.oa() || eI(this.g))))) {
              this.J || Rn != 4 || b == 7 || (b == 8 || 0 >= Ta ? Zl(3) : Zl(2)), ug(this)
              var P = this.g.Z()
              this.X = P
              t: if (Nw(this)) {
                var M = eI(this.g)
                h = ''
                var Y = M.length,
                  ie = wr(this.g) == 4
                if (!this.h.i) {
                  if (typeof TextDecoder > 'u') {
                    Xs(this), nu(this)
                    var Ce = ''
                    break t
                  }
                  this.h.i = new a.TextDecoder()
                }
                for (b = 0; b < Y; b++) (this.h.h = !0), (h += this.h.i.decode(M[b], { stream: !(ie && b == Y - 1) }))
                ;(M.length = 0), (this.h.g += h), (this.C = 0), (Ce = this.h.g)
              } else Ce = this.g.oa()
              if (((this.o = P == 200), QO(this.i, this.u, this.A, this.l, this.R, Rn, P), this.o)) {
                if (this.T && !this.K) {
                  t: {
                    if (this.g) {
                      var wt,
                        _n = this.g
                      if ((wt = _n.g ? _n.g.getResponseHeader('X-HTTP-Initial-Response') : null) && !A(wt)) {
                        var dt = wt
                        break t
                      }
                    }
                    dt = null
                  }
                  if ((P = dt))
                    Ia(this.i, this.l, P, 'Initial handshake response via X-HTTP-Initial-Response'),
                      (this.K = !0),
                      cg(this, P)
                  else {
                    ;(this.o = !1), (this.s = 3), zn(12), Xs(this), nu(this)
                    break e
                  }
                }
                if (this.P) {
                  P = !0
                  let Fi
                  for (; !this.J && this.C < Ce.length; )
                    if (((Fi = ZO(this, Ce)), Fi == ag)) {
                      Rn == 4 && ((this.s = 4), zn(14), (P = !1)), Ia(this.i, this.l, null, '[Incomplete Response]')
                      break
                    } else if (Fi == Vw) {
                      ;(this.s = 4), zn(15), Ia(this.i, this.l, Ce, '[Invalid Chunk]'), (P = !1)
                      break
                    } else Ia(this.i, this.l, Fi, null), cg(this, Fi)
                  if (
                    (Nw(this) && this.C != 0 && ((this.h.g = this.h.g.slice(this.C)), (this.C = 0)),
                    Rn != 4 || Ce.length != 0 || this.h.h || ((this.s = 1), zn(16), (P = !1)),
                    (this.o = this.o && P),
                    !P)
                  )
                    Ia(this.i, this.l, Ce, '[Invalid Chunked Response]'), Xs(this), nu(this)
                  else if (0 < Ce.length && !this.W) {
                    this.W = !0
                    var Pn = this.j
                    Pn.g == this &&
                      Pn.ba &&
                      !Pn.M &&
                      (Pn.j.info('Great, no buffering proxy detected. Bytes received: ' + Ce.length),
                      vg(Pn),
                      (Pn.M = !0),
                      zn(11))
                  }
                } else Ia(this.i, this.l, Ce, null), cg(this, Ce)
                Rn == 4 && Xs(this), this.o && !this.J && (Rn == 4 ? aI(this.j, this) : ((this.o = !1), Sd(this)))
              } else
                vM(this.g),
                  P == 400 && 0 < Ce.indexOf('Unknown SID') ? ((this.s = 3), zn(12)) : ((this.s = 0), zn(13)),
                  Xs(this),
                  nu(this)
            }
          }
      } catch {
      } finally {
      }
    })
  function Nw(h) {
    return h.g ? h.u == 'GET' && h.L != 2 && h.j.Ca : !1
  }
  function ZO(h, b) {
    var P = h.C,
      M = b.indexOf(
        `
`,
        P
      )
    return M == -1
      ? ag
      : ((P = Number(b.substring(P, M))),
        isNaN(P) ? Vw : ((M += 1), M + P > b.length ? ag : ((b = b.slice(M, M + P)), (h.C = M + P), b)))
  }
  Zr.prototype.cancel = function () {
    ;(this.J = !0), Xs(this)
  }
  function Sd(h) {
    ;(h.S = Date.now() + h.I), Ow(h, h.I)
  }
  function Ow(h, b) {
    if (h.B != null) throw Error('WatchDog timer not null')
    h.B = eu(f(h.ba, h), b)
  }
  function ug(h) {
    h.B && (a.clearTimeout(h.B), (h.B = null))
  }
  Zr.prototype.ba = function () {
    this.B = null
    const h = Date.now()
    0 <= h - this.S
      ? (XO(this.i, this.A), this.L != 2 && (Zl(), zn(17)), Xs(this), (this.s = 2), nu(this))
      : Ow(this, this.S - h)
  }
  function nu(h) {
    h.j.G == 0 || h.J || aI(h.j, h)
  }
  function Xs(h) {
    ug(h)
    var b = h.M
    b && typeof b.ma == 'function' && b.ma(), (h.M = null), Jr(h.U), h.g && ((b = h.g), (h.g = null), b.abort(), b.ma())
  }
  function cg(h, b) {
    try {
      var P = h.j
      if (P.G != 0 && (P.g == h || dg(P.h, h))) {
        if (!h.K && dg(P.h, h) && P.G == 3) {
          try {
            var M = P.Da.g.parse(b)
          } catch {
            M = null
          }
          if (Array.isArray(M) && M.length == 3) {
            var Y = M
            if (Y[0] == 0) {
              e: if (!P.u) {
                if (P.g)
                  if (P.g.F + 3e3 < h.F) xd(P), Pd(P)
                  else break e
                gg(P), zn(18)
              }
            } else
              (P.za = Y[1]), 0 < P.za - P.T && 37500 > Y[2] && P.F && P.v == 0 && !P.C && (P.C = eu(f(P.Za, P), 6e3))
            if (1 >= Fw(P.h) && P.ca) {
              try {
                P.ca()
              } catch {}
              P.ca = void 0
            }
          } else Zs(P, 11)
        } else if (((h.K || P.g == h) && xd(P), !A(b)))
          for (Y = P.Da.g.parse(b), b = 0; b < Y.length; b++) {
            let dt = Y[b]
            if (((P.T = dt[0]), (dt = dt[1]), P.G == 2))
              if (dt[0] == 'c') {
                ;(P.K = dt[1]), (P.ia = dt[2])
                const Pn = dt[3]
                Pn != null && ((P.la = Pn), P.j.info('VER=' + P.la))
                const Rn = dt[4]
                Rn != null && ((P.Aa = Rn), P.j.info('SVER=' + P.Aa))
                const Ta = dt[5]
                Ta != null &&
                  typeof Ta == 'number' &&
                  0 < Ta &&
                  ((M = 1.5 * Ta), (P.L = M), P.j.info('backChannelRequestTimeoutMs_=' + M)),
                  (M = P)
                const Fi = h.g
                if (Fi) {
                  const Dd = Fi.g ? Fi.g.getResponseHeader('X-Client-Wire-Protocol') : null
                  if (Dd) {
                    var ie = M.h
                    ie.g ||
                      (Dd.indexOf('spdy') == -1 && Dd.indexOf('quic') == -1 && Dd.indexOf('h2') == -1) ||
                      ((ie.j = ie.l), (ie.g = new Set()), ie.h && (hg(ie, ie.h), (ie.h = null)))
                  }
                  if (M.D) {
                    const pg = Fi.g ? Fi.g.getResponseHeader('X-HTTP-Session-Id') : null
                    pg && ((M.ya = pg), Ct(M.I, M.D, pg))
                  }
                }
                ;(P.G = 3),
                  P.l && P.l.ua(),
                  P.ba && ((P.R = Date.now() - h.F), P.j.info('Handshake RTT: ' + P.R + 'ms')),
                  (M = P)
                var Ce = h
                if (((M.qa = cI(M, M.J ? M.ia : null, M.W)), Ce.K)) {
                  Bw(M.h, Ce)
                  var wt = Ce,
                    _n = M.L
                  _n && (wt.I = _n), wt.B && (ug(wt), Sd(wt)), (M.g = Ce)
                } else sI(M)
                0 < P.i.length && Rd(P)
              } else (dt[0] != 'stop' && dt[0] != 'close') || Zs(P, 7)
            else
              P.G == 3 &&
                (dt[0] == 'stop' || dt[0] == 'close'
                  ? dt[0] == 'stop'
                    ? Zs(P, 7)
                    : mg(P)
                  : dt[0] != 'noop' && P.l && P.l.ta(dt),
                (P.v = 0))
          }
      }
      Zl(4)
    } catch {}
  }
  var eM = class {
    constructor(h, b) {
      ;(this.g = h), (this.map = b)
    }
  }
  function Mw(h) {
    ;(this.l = h || 10),
      a.PerformanceNavigationTiming
        ? ((h = a.performance.getEntriesByType('navigation')),
          (h = 0 < h.length && (h[0].nextHopProtocol == 'hq' || h[0].nextHopProtocol == 'h2')))
        : (h = !!(a.chrome && a.chrome.loadTimes && a.chrome.loadTimes() && a.chrome.loadTimes().wasFetchedViaSpdy)),
      (this.j = h ? this.l : 1),
      (this.g = null),
      1 < this.j && (this.g = new Set()),
      (this.h = null),
      (this.i = [])
  }
  function Lw(h) {
    return h.h ? !0 : h.g ? h.g.size >= h.j : !1
  }
  function Fw(h) {
    return h.h ? 1 : h.g ? h.g.size : 0
  }
  function dg(h, b) {
    return h.h ? h.h == b : h.g ? h.g.has(b) : !1
  }
  function hg(h, b) {
    h.g ? h.g.add(b) : (h.h = b)
  }
  function Bw(h, b) {
    h.h && h.h == b ? (h.h = null) : h.g && h.g.has(b) && h.g.delete(b)
  }
  Mw.prototype.cancel = function () {
    if (((this.i = $w(this)), this.h)) this.h.cancel(), (this.h = null)
    else if (this.g && this.g.size !== 0) {
      for (const h of this.g.values()) h.cancel()
      this.g.clear()
    }
  }
  function $w(h) {
    if (h.h != null) return h.i.concat(h.h.D)
    if (h.g != null && h.g.size !== 0) {
      let b = h.i
      for (const P of h.g.values()) b = b.concat(P.D)
      return b
    }
    return v(h.i)
  }
  function tM(h) {
    if (h.V && typeof h.V == 'function') return h.V()
    if ((typeof Map < 'u' && h instanceof Map) || (typeof Set < 'u' && h instanceof Set)) return Array.from(h.values())
    if (typeof h == 'string') return h.split('')
    if (l(h)) {
      for (var b = [], P = h.length, M = 0; M < P; M++) b.push(h[M])
      return b
    }
    ;(b = []), (P = 0)
    for (M in h) b[P++] = h[M]
    return b
  }
  function nM(h) {
    if (h.na && typeof h.na == 'function') return h.na()
    if (!h.V || typeof h.V != 'function') {
      if (typeof Map < 'u' && h instanceof Map) return Array.from(h.keys())
      if (!(typeof Set < 'u' && h instanceof Set)) {
        if (l(h) || typeof h == 'string') {
          var b = []
          h = h.length
          for (var P = 0; P < h; P++) b.push(P)
          return b
        }
        ;(b = []), (P = 0)
        for (const M in h) b[P++] = M
        return b
      }
    }
  }
  function Uw(h, b) {
    if (h.forEach && typeof h.forEach == 'function') h.forEach(b, void 0)
    else if (l(h) || typeof h == 'string') Array.prototype.forEach.call(h, b, void 0)
    else for (var P = nM(h), M = tM(h), Y = M.length, ie = 0; ie < Y; ie++) b.call(void 0, M[ie], P && P[ie], h)
  }
  var jw = RegExp(
    '^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$'
  )
  function iM(h, b) {
    if (h) {
      h = h.split('&')
      for (var P = 0; P < h.length; P++) {
        var M = h[P].indexOf('='),
          Y = null
        if (0 <= M) {
          var ie = h[P].substring(0, M)
          Y = h[P].substring(M + 1)
        } else ie = h[P]
        b(ie, Y ? decodeURIComponent(Y.replace(/\+/g, ' ')) : '')
      }
    }
  }
  function Js(h) {
    if (((this.g = this.o = this.j = ''), (this.s = null), (this.m = this.l = ''), (this.h = !1), h instanceof Js)) {
      ;(this.h = h.h), Ed(this, h.j), (this.o = h.o), (this.g = h.g), Td(this, h.s), (this.l = h.l)
      var b = h.i,
        P = new su()
      ;(P.i = b.i), b.g && ((P.g = new Map(b.g)), (P.h = b.h)), zw(this, P), (this.m = h.m)
    } else
      h && (b = String(h).match(jw))
        ? ((this.h = !1),
          Ed(this, b[1] || '', !0),
          (this.o = iu(b[2] || '')),
          (this.g = iu(b[3] || '', !0)),
          Td(this, b[4]),
          (this.l = iu(b[5] || '', !0)),
          zw(this, b[6] || '', !0),
          (this.m = iu(b[7] || '')))
        : ((this.h = !1), (this.i = new su(null, this.h)))
  }
  Js.prototype.toString = function () {
    var h = [],
      b = this.j
    b && h.push(ru(b, Hw, !0), ':')
    var P = this.g
    return (
      (P || b == 'file') &&
        (h.push('//'),
        (b = this.o) && h.push(ru(b, Hw, !0), '@'),
        h.push(encodeURIComponent(String(P)).replace(/%25([0-9a-fA-F]{2})/g, '%$1')),
        (P = this.s),
        P != null && h.push(':', String(P))),
      (P = this.l) && (this.g && P.charAt(0) != '/' && h.push('/'), h.push(ru(P, P.charAt(0) == '/' ? oM : sM, !0))),
      (P = this.i.toString()) && h.push('?', P),
      (P = this.m) && h.push('#', ru(P, lM)),
      h.join('')
    )
  }
  function br(h) {
    return new Js(h)
  }
  function Ed(h, b, P) {
    ;(h.j = P ? iu(b, !0) : b), h.j && (h.j = h.j.replace(/:$/, ''))
  }
  function Td(h, b) {
    if (b) {
      if (((b = Number(b)), isNaN(b) || 0 > b)) throw Error('Bad port number ' + b)
      h.s = b
    } else h.s = null
  }
  function zw(h, b, P) {
    b instanceof su ? ((h.i = b), uM(h.i, h.h)) : (P || (b = ru(b, aM)), (h.i = new su(b, h.h)))
  }
  function Ct(h, b, P) {
    h.i.set(b, P)
  }
  function Cd(h) {
    return (
      Ct(
        h,
        'zx',
        Math.floor(2147483648 * Math.random()).toString(36) +
          Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)
      ),
      h
    )
  }
  function iu(h, b) {
    return h ? (b ? decodeURI(h.replace(/%25/g, '%2525')) : decodeURIComponent(h)) : ''
  }
  function ru(h, b, P) {
    return typeof h == 'string'
      ? ((h = encodeURI(h).replace(b, rM)), P && (h = h.replace(/%25([0-9a-fA-F]{2})/g, '%$1')), h)
      : null
  }
  function rM(h) {
    return (h = h.charCodeAt(0)), '%' + ((h >> 4) & 15).toString(16) + (h & 15).toString(16)
  }
  var Hw = /[#\/\?@]/g,
    sM = /[#\?:]/g,
    oM = /[#\?]/g,
    aM = /[#\?@]/g,
    lM = /#/g
  function su(h, b) {
    ;(this.h = this.g = null), (this.i = h || null), (this.j = !!b)
  }
  function es(h) {
    h.g ||
      ((h.g = new Map()),
      (h.h = 0),
      h.i &&
        iM(h.i, function (b, P) {
          h.add(decodeURIComponent(b.replace(/\+/g, ' ')), P)
        }))
  }
  ;(e = su.prototype),
    (e.add = function (h, b) {
      es(this), (this.i = null), (h = Sa(this, h))
      var P = this.g.get(h)
      return P || this.g.set(h, (P = [])), P.push(b), (this.h += 1), this
    })
  function Ww(h, b) {
    es(h), (b = Sa(h, b)), h.g.has(b) && ((h.i = null), (h.h -= h.g.get(b).length), h.g.delete(b))
  }
  function qw(h, b) {
    return es(h), (b = Sa(h, b)), h.g.has(b)
  }
  ;(e.forEach = function (h, b) {
    es(this),
      this.g.forEach(function (P, M) {
        P.forEach(function (Y) {
          h.call(b, Y, M, this)
        }, this)
      }, this)
  }),
    (e.na = function () {
      es(this)
      const h = Array.from(this.g.values()),
        b = Array.from(this.g.keys()),
        P = []
      for (let M = 0; M < b.length; M++) {
        const Y = h[M]
        for (let ie = 0; ie < Y.length; ie++) P.push(b[M])
      }
      return P
    }),
    (e.V = function (h) {
      es(this)
      let b = []
      if (typeof h == 'string') qw(this, h) && (b = b.concat(this.g.get(Sa(this, h))))
      else {
        h = Array.from(this.g.values())
        for (let P = 0; P < h.length; P++) b = b.concat(h[P])
      }
      return b
    }),
    (e.set = function (h, b) {
      return (
        es(this),
        (this.i = null),
        (h = Sa(this, h)),
        qw(this, h) && (this.h -= this.g.get(h).length),
        this.g.set(h, [b]),
        (this.h += 1),
        this
      )
    }),
    (e.get = function (h, b) {
      return h ? ((h = this.V(h)), 0 < h.length ? String(h[0]) : b) : b
    })
  function Gw(h, b, P) {
    Ww(h, b), 0 < P.length && ((h.i = null), h.g.set(Sa(h, b), v(P)), (h.h += P.length))
  }
  e.toString = function () {
    if (this.i) return this.i
    if (!this.g) return ''
    const h = [],
      b = Array.from(this.g.keys())
    for (var P = 0; P < b.length; P++) {
      var M = b[P]
      const ie = encodeURIComponent(String(M)),
        Ce = this.V(M)
      for (M = 0; M < Ce.length; M++) {
        var Y = ie
        Ce[M] !== '' && (Y += '=' + encodeURIComponent(String(Ce[M]))), h.push(Y)
      }
    }
    return (this.i = h.join('&'))
  }
  function Sa(h, b) {
    return (b = String(b)), h.j && (b = b.toLowerCase()), b
  }
  function uM(h, b) {
    b &&
      !h.j &&
      (es(h),
      (h.i = null),
      h.g.forEach(function (P, M) {
        var Y = M.toLowerCase()
        M != Y && (Ww(this, M), Gw(this, Y, P))
      }, h)),
      (h.j = b)
  }
  function cM(h, b) {
    const P = new tu()
    if (a.Image) {
      const M = new Image()
      ;(M.onload = m(ts, P, 'TestLoadImage: loaded', !0, b, M)),
        (M.onerror = m(ts, P, 'TestLoadImage: error', !1, b, M)),
        (M.onabort = m(ts, P, 'TestLoadImage: abort', !1, b, M)),
        (M.ontimeout = m(ts, P, 'TestLoadImage: timeout', !1, b, M)),
        a.setTimeout(function () {
          M.ontimeout && M.ontimeout()
        }, 1e4),
        (M.src = h)
    } else b(!1)
  }
  function dM(h, b) {
    const P = new tu(),
      M = new AbortController(),
      Y = setTimeout(() => {
        M.abort(), ts(P, 'TestPingServer: timeout', !1, b)
      }, 1e4)
    fetch(h, { signal: M.signal })
      .then((ie) => {
        clearTimeout(Y), ie.ok ? ts(P, 'TestPingServer: ok', !0, b) : ts(P, 'TestPingServer: server error', !1, b)
      })
      .catch(() => {
        clearTimeout(Y), ts(P, 'TestPingServer: error', !1, b)
      })
  }
  function ts(h, b, P, M, Y) {
    try {
      Y && ((Y.onload = null), (Y.onerror = null), (Y.onabort = null), (Y.ontimeout = null)), M(P)
    } catch {}
  }
  function hM() {
    this.g = new Ii()
  }
  function fM(h, b, P) {
    const M = P || ''
    try {
      Uw(h, function (Y, ie) {
        let Ce = Y
        u(Y) && (Ce = ba(Y)), b.push(M + ie + '=' + encodeURIComponent(Ce))
      })
    } catch (Y) {
      throw (b.push(M + 'type=' + encodeURIComponent('_badmap')), Y)
    }
  }
  function ou(h) {
    ;(this.l = h.Ub || null), (this.j = h.eb || !1)
  }
  p(ou, wa),
    (ou.prototype.g = function () {
      return new Ad(this.l, this.j)
    }),
    (ou.prototype.i = (function (h) {
      return function () {
        return h
      }
    })({}))
  function Ad(h, b) {
    Me.call(this),
      (this.D = h),
      (this.o = b),
      (this.m = void 0),
      (this.status = this.readyState = 0),
      (this.responseType = this.responseText = this.response = this.statusText = ''),
      (this.onreadystatechange = null),
      (this.u = new Headers()),
      (this.h = null),
      (this.B = 'GET'),
      (this.A = ''),
      (this.g = !1),
      (this.v = this.j = this.l = null)
  }
  p(Ad, Me),
    (e = Ad.prototype),
    (e.open = function (h, b) {
      if (this.readyState != 0) throw (this.abort(), Error('Error reopening a connection'))
      ;(this.B = h), (this.A = b), (this.readyState = 1), lu(this)
    }),
    (e.send = function (h) {
      if (this.readyState != 1) throw (this.abort(), Error('need to call open() first. '))
      this.g = !0
      const b = { headers: this.u, method: this.B, credentials: this.m, cache: void 0 }
      h && (b.body = h), (this.D || a).fetch(new Request(this.A, b)).then(this.Sa.bind(this), this.ga.bind(this))
    }),
    (e.abort = function () {
      ;(this.response = this.responseText = ''),
        (this.u = new Headers()),
        (this.status = 0),
        this.j && this.j.cancel('Request was aborted.').catch(() => {}),
        1 <= this.readyState && this.g && this.readyState != 4 && ((this.g = !1), au(this)),
        (this.readyState = 0)
    }),
    (e.Sa = function (h) {
      if (
        this.g &&
        ((this.l = h),
        this.h ||
          ((this.status = this.l.status),
          (this.statusText = this.l.statusText),
          (this.h = h.headers),
          (this.readyState = 2),
          lu(this)),
        this.g && ((this.readyState = 3), lu(this), this.g))
      )
        if (this.responseType === 'arraybuffer') h.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this))
        else if (typeof a.ReadableStream < 'u' && 'body' in h) {
          if (((this.j = h.body.getReader()), this.o)) {
            if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.')
            this.response = []
          } else (this.response = this.responseText = ''), (this.v = new TextDecoder())
          Kw(this)
        } else h.text().then(this.Ra.bind(this), this.ga.bind(this))
    })
  function Kw(h) {
    h.j.read().then(h.Pa.bind(h)).catch(h.ga.bind(h))
  }
  ;(e.Pa = function (h) {
    if (this.g) {
      if (this.o && h.value) this.response.push(h.value)
      else if (!this.o) {
        var b = h.value ? h.value : new Uint8Array(0)
        ;(b = this.v.decode(b, { stream: !h.done })) && (this.response = this.responseText += b)
      }
      h.done ? au(this) : lu(this), this.readyState == 3 && Kw(this)
    }
  }),
    (e.Ra = function (h) {
      this.g && ((this.response = this.responseText = h), au(this))
    }),
    (e.Qa = function (h) {
      this.g && ((this.response = h), au(this))
    }),
    (e.ga = function () {
      this.g && au(this)
    })
  function au(h) {
    ;(h.readyState = 4), (h.l = null), (h.j = null), (h.v = null), lu(h)
  }
  ;(e.setRequestHeader = function (h, b) {
    this.u.append(h, b)
  }),
    (e.getResponseHeader = function (h) {
      return (this.h && this.h.get(h.toLowerCase())) || ''
    }),
    (e.getAllResponseHeaders = function () {
      if (!this.h) return ''
      const h = [],
        b = this.h.entries()
      for (var P = b.next(); !P.done; ) (P = P.value), h.push(P[0] + ': ' + P[1]), (P = b.next())
      return h.join(`\r
`)
    })
  function lu(h) {
    h.onreadystatechange && h.onreadystatechange.call(h)
  }
  Object.defineProperty(Ad.prototype, 'withCredentials', {
    get: function () {
      return this.m === 'include'
    },
    set: function (h) {
      this.m = h ? 'include' : 'same-origin'
    },
  })
  function Yw(h) {
    let b = ''
    return (
      D(h, function (P, M) {
        ;(b += M),
          (b += ':'),
          (b += P),
          (b += `\r
`)
      }),
      b
    )
  }
  function fg(h, b, P) {
    e: {
      for (M in P) {
        var M = !1
        break e
      }
      M = !0
    }
    M || ((P = Yw(P)), typeof h == 'string' ? P != null && encodeURIComponent(String(P)) : Ct(h, b, P))
  }
  function zt(h) {
    Me.call(this),
      (this.headers = new Map()),
      (this.o = h || null),
      (this.h = !1),
      (this.v = this.g = null),
      (this.D = ''),
      (this.m = 0),
      (this.l = ''),
      (this.j = this.B = this.u = this.A = !1),
      (this.I = null),
      (this.H = ''),
      (this.J = !1)
  }
  p(zt, Me)
  var mM = /^https?$/i,
    gM = ['POST', 'PUT']
  ;(e = zt.prototype),
    (e.Ha = function (h) {
      this.J = h
    }),
    (e.ea = function (h, b, P, M) {
      if (this.g) throw Error('[goog.net.XhrIo] Object is active with another request=' + this.D + '; newUri=' + h)
      ;(b = b ? b.toUpperCase() : 'GET'),
        (this.D = h),
        (this.l = ''),
        (this.m = 0),
        (this.A = !1),
        (this.h = !0),
        (this.g = this.o ? this.o.g() : og.g()),
        (this.v = this.o ? Ew(this.o) : Ew(og)),
        (this.g.onreadystatechange = f(this.Ea, this))
      try {
        ;(this.B = !0), this.g.open(b, String(h), !0), (this.B = !1)
      } catch (ie) {
        Qw(this, ie)
        return
      }
      if (((h = P || ''), (P = new Map(this.headers)), M))
        if (Object.getPrototypeOf(M) === Object.prototype) for (var Y in M) P.set(Y, M[Y])
        else if (typeof M.keys == 'function' && typeof M.get == 'function')
          for (const ie of M.keys()) P.set(ie, M.get(ie))
        else throw Error('Unknown input type for opt_headers: ' + String(M))
      ;(M = Array.from(P.keys()).find((ie) => ie.toLowerCase() == 'content-type')),
        (Y = a.FormData && h instanceof a.FormData),
        !(0 <= Array.prototype.indexOf.call(gM, b, void 0)) ||
          M ||
          Y ||
          P.set('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8')
      for (const [ie, Ce] of P) this.g.setRequestHeader(ie, Ce)
      this.H && (this.g.responseType = this.H),
        'withCredentials' in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J)
      try {
        Zw(this), (this.u = !0), this.g.send(h), (this.u = !1)
      } catch (ie) {
        Qw(this, ie)
      }
    })
  function Qw(h, b) {
    ;(h.h = !1), h.g && ((h.j = !0), h.g.abort(), (h.j = !1)), (h.l = b), (h.m = 5), Xw(h), kd(h)
  }
  function Xw(h) {
    h.A || ((h.A = !0), Be(h, 'complete'), Be(h, 'error'))
  }
  ;(e.abort = function (h) {
    this.g &&
      this.h &&
      ((this.h = !1),
      (this.j = !0),
      this.g.abort(),
      (this.j = !1),
      (this.m = h || 7),
      Be(this, 'complete'),
      Be(this, 'abort'),
      kd(this))
  }),
    (e.N = function () {
      this.g && (this.h && ((this.h = !1), (this.j = !0), this.g.abort(), (this.j = !1)), kd(this, !0)),
        zt.aa.N.call(this)
    }),
    (e.Ea = function () {
      this.s || (this.B || this.u || this.j ? Jw(this) : this.bb())
    }),
    (e.bb = function () {
      Jw(this)
    })
  function Jw(h) {
    if (h.h && typeof o < 'u' && (!h.v[1] || wr(h) != 4 || h.Z() != 2)) {
      if (h.u && wr(h) == 4) lt(h.Ea, 0, h)
      else if ((Be(h, 'readystatechange'), wr(h) == 4)) {
        h.h = !1
        try {
          const Ce = h.Z()
          e: switch (Ce) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = !0
              break e
            default:
              b = !1
          }
          var P
          if (!(P = b)) {
            var M
            if ((M = Ce === 0)) {
              var Y = String(h.D).match(jw)[1] || null
              !Y && a.self && a.self.location && (Y = a.self.location.protocol.slice(0, -1)),
                (M = !mM.test(Y ? Y.toLowerCase() : ''))
            }
            P = M
          }
          if (P) Be(h, 'complete'), Be(h, 'success')
          else {
            h.m = 6
            try {
              var ie = 2 < wr(h) ? h.g.statusText : ''
            } catch {
              ie = ''
            }
            ;(h.l = ie + ' [' + h.Z() + ']'), Xw(h)
          }
        } finally {
          kd(h)
        }
      }
    }
  }
  function kd(h, b) {
    if (h.g) {
      Zw(h)
      const P = h.g,
        M = h.v[0] ? () => {} : null
      ;(h.g = null), (h.v = null), b || Be(h, 'ready')
      try {
        P.onreadystatechange = M
      } catch {}
    }
  }
  function Zw(h) {
    h.I && (a.clearTimeout(h.I), (h.I = null))
  }
  e.isActive = function () {
    return !!this.g
  }
  function wr(h) {
    return h.g ? h.g.readyState : 0
  }
  ;(e.Z = function () {
    try {
      return 2 < wr(this) ? this.g.status : -1
    } catch {
      return -1
    }
  }),
    (e.oa = function () {
      try {
        return this.g ? this.g.responseText : ''
      } catch {
        return ''
      }
    }),
    (e.Oa = function (h) {
      if (this.g) {
        var b = this.g.responseText
        return h && b.indexOf(h) == 0 && (b = b.substring(h.length)), jn(b)
      }
    })
  function eI(h) {
    try {
      if (!h.g) return null
      if ('response' in h.g) return h.g.response
      switch (h.H) {
        case '':
        case 'text':
          return h.g.responseText
        case 'arraybuffer':
          if ('mozResponseArrayBuffer' in h.g) return h.g.mozResponseArrayBuffer
      }
      return null
    } catch {
      return null
    }
  }
  function vM(h) {
    const b = {}
    h = ((h.g && 2 <= wr(h) && h.g.getAllResponseHeaders()) || '').split(`\r
`)
    for (let M = 0; M < h.length; M++) {
      if (A(h[M])) continue
      var P = E(h[M])
      const Y = P[0]
      if (((P = P[1]), typeof P != 'string')) continue
      P = P.trim()
      const ie = b[Y] || []
      ;(b[Y] = ie), ie.push(P)
    }
    I(b, function (M) {
      return M.join(', ')
    })
  }
  ;(e.Ba = function () {
    return this.m
  }),
    (e.Ka = function () {
      return typeof this.l == 'string' ? this.l : String(this.l)
    })
  function uu(h, b, P) {
    return (P && P.internalChannelParams && P.internalChannelParams[h]) || b
  }
  function tI(h) {
    ;(this.Aa = 0),
      (this.i = []),
      (this.j = new tu()),
      (this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null),
      (this.Ya = this.U = 0),
      (this.Va = uu('failFast', !1, h)),
      (this.F = this.C = this.u = this.s = this.l = null),
      (this.X = !0),
      (this.za = this.T = -1),
      (this.Y = this.v = this.B = 0),
      (this.Ta = uu('baseRetryDelayMs', 5e3, h)),
      (this.cb = uu('retryDelaySeedMs', 1e4, h)),
      (this.Wa = uu('forwardChannelMaxRetries', 2, h)),
      (this.wa = uu('forwardChannelRequestTimeoutMs', 2e4, h)),
      (this.pa = (h && h.xmlHttpFactory) || void 0),
      (this.Xa = (h && h.Tb) || void 0),
      (this.Ca = (h && h.useFetchStreams) || !1),
      (this.L = void 0),
      (this.J = (h && h.supportsCrossDomainXhr) || !1),
      (this.K = ''),
      (this.h = new Mw(h && h.concurrentRequestLimit)),
      (this.Da = new hM()),
      (this.P = (h && h.fastHandshake) || !1),
      (this.O = (h && h.encodeInitMessageHeaders) || !1),
      this.P && this.O && (this.O = !1),
      (this.Ua = (h && h.Rb) || !1),
      h && h.xa && this.j.xa(),
      h && h.forceLongPolling && (this.X = !1),
      (this.ba = (!this.P && this.X && h && h.detectBufferingProxy) || !1),
      (this.ja = void 0),
      h && h.longPollingTimeout && 0 < h.longPollingTimeout && (this.ja = h.longPollingTimeout),
      (this.ca = void 0),
      (this.R = 0),
      (this.M = !1),
      (this.ka = this.A = null)
  }
  ;(e = tI.prototype),
    (e.la = 8),
    (e.G = 1),
    (e.connect = function (h, b, P, M) {
      zn(0),
        (this.W = h),
        (this.H = b || {}),
        P && M !== void 0 && ((this.H.OSID = P), (this.H.OAID = M)),
        (this.F = this.X),
        (this.I = cI(this, null, this.W)),
        Rd(this)
    })
  function mg(h) {
    if ((nI(h), h.G == 3)) {
      var b = h.U++,
        P = br(h.I)
      if (
        (Ct(P, 'SID', h.K),
        Ct(P, 'RID', b),
        Ct(P, 'TYPE', 'terminate'),
        cu(h, P),
        (b = new Zr(h, h.j, b)),
        (b.L = 2),
        (b.v = Cd(br(P))),
        (P = !1),
        a.navigator && a.navigator.sendBeacon)
      )
        try {
          P = a.navigator.sendBeacon(b.v.toString(), '')
        } catch {}
      !P && a.Image && ((new Image().src = b.v), (P = !0)),
        P || ((b.g = dI(b.j, null)), b.g.ea(b.v)),
        (b.F = Date.now()),
        Sd(b)
    }
    uI(h)
  }
  function Pd(h) {
    h.g && (vg(h), h.g.cancel(), (h.g = null))
  }
  function nI(h) {
    Pd(h),
      h.u && (a.clearTimeout(h.u), (h.u = null)),
      xd(h),
      h.h.cancel(),
      h.s && (typeof h.s == 'number' && a.clearTimeout(h.s), (h.s = null))
  }
  function Rd(h) {
    if (!Lw(h.h) && !h.s) {
      h.s = !0
      var b = h.Ga
      G || j(), F || (G(), (F = !0)), K.add(b, h), (h.B = 0)
    }
  }
  function pM(h, b) {
    return Fw(h.h) >= h.h.j - (h.s ? 1 : 0)
      ? !1
      : h.s
      ? ((h.i = b.D.concat(h.i)), !0)
      : h.G == 1 || h.G == 2 || h.B >= (h.Va ? 0 : h.Wa)
      ? !1
      : ((h.s = eu(f(h.Ga, h, b), lI(h, h.B))), h.B++, !0)
  }
  e.Ga = function (h) {
    if (this.s)
      if (((this.s = null), this.G == 1)) {
        if (!h) {
          ;(this.U = Math.floor(1e5 * Math.random())), (h = this.U++)
          const Y = new Zr(this, this.j, h)
          let ie = this.o
          if (
            (this.S && (ie ? ((ie = w(ie)), S(ie, this.S)) : (ie = this.S)),
            this.m !== null || this.O || ((Y.H = ie), (ie = null)),
            this.P)
          )
            e: {
              for (var b = 0, P = 0; P < this.i.length; P++) {
                t: {
                  var M = this.i[P]
                  if ('__data__' in M.map && ((M = M.map.__data__), typeof M == 'string')) {
                    M = M.length
                    break t
                  }
                  M = void 0
                }
                if (M === void 0) break
                if (((b += M), 4096 < b)) {
                  b = P
                  break e
                }
                if (b === 4096 || P === this.i.length - 1) {
                  b = P + 1
                  break e
                }
              }
              b = 1e3
            }
          else b = 1e3
          ;(b = rI(this, Y, b)),
            (P = br(this.I)),
            Ct(P, 'RID', h),
            Ct(P, 'CVER', 22),
            this.D && Ct(P, 'X-HTTP-Session-Id', this.D),
            cu(this, P),
            ie &&
              (this.O ? (b = 'headers=' + encodeURIComponent(String(Yw(ie))) + '&' + b) : this.m && fg(P, this.m, ie)),
            hg(this.h, Y),
            this.Ua && Ct(P, 'TYPE', 'init'),
            this.P ? (Ct(P, '$req', b), Ct(P, 'SID', 'null'), (Y.T = !0), lg(Y, P, null)) : lg(Y, P, b),
            (this.G = 2)
        }
      } else this.G == 3 && (h ? iI(this, h) : this.i.length == 0 || Lw(this.h) || iI(this))
  }
  function iI(h, b) {
    var P
    b ? (P = b.l) : (P = h.U++)
    const M = br(h.I)
    Ct(M, 'SID', h.K),
      Ct(M, 'RID', P),
      Ct(M, 'AID', h.T),
      cu(h, M),
      h.m && h.o && fg(M, h.m, h.o),
      (P = new Zr(h, h.j, P, h.B + 1)),
      h.m === null && (P.H = h.o),
      b && (h.i = b.D.concat(h.i)),
      (b = rI(h, P, 1e3)),
      (P.I = Math.round(0.5 * h.wa) + Math.round(0.5 * h.wa * Math.random())),
      hg(h.h, P),
      lg(P, M, b)
  }
  function cu(h, b) {
    h.H &&
      D(h.H, function (P, M) {
        Ct(b, M, P)
      }),
      h.l &&
        Uw({}, function (P, M) {
          Ct(b, M, P)
        })
  }
  function rI(h, b, P) {
    P = Math.min(h.i.length, P)
    var M = h.l ? f(h.l.Na, h.l, h) : null
    e: {
      var Y = h.i
      let ie = -1
      for (;;) {
        const Ce = ['count=' + P]
        ie == -1 ? (0 < P ? ((ie = Y[0].g), Ce.push('ofs=' + ie)) : (ie = 0)) : Ce.push('ofs=' + ie)
        let wt = !0
        for (let _n = 0; _n < P; _n++) {
          let dt = Y[_n].g
          const Pn = Y[_n].map
          if (((dt -= ie), 0 > dt)) (ie = Math.max(0, Y[_n].g - 100)), (wt = !1)
          else
            try {
              fM(Pn, Ce, 'req' + dt + '_')
            } catch {
              M && M(Pn)
            }
        }
        if (wt) {
          M = Ce.join('&')
          break e
        }
      }
    }
    return (h = h.i.splice(0, P)), (b.D = h), M
  }
  function sI(h) {
    if (!h.g && !h.u) {
      h.Y = 1
      var b = h.Fa
      G || j(), F || (G(), (F = !0)), K.add(b, h), (h.v = 0)
    }
  }
  function gg(h) {
    return h.g || h.u || 3 <= h.v ? !1 : (h.Y++, (h.u = eu(f(h.Fa, h), lI(h, h.v))), h.v++, !0)
  }
  ;(e.Fa = function () {
    if (((this.u = null), oI(this), this.ba && !(this.M || this.g == null || 0 >= this.R))) {
      var h = 2 * this.R
      this.j.info('BP detection timer enabled: ' + h), (this.A = eu(f(this.ab, this), h))
    }
  }),
    (e.ab = function () {
      this.A &&
        ((this.A = null),
        this.j.info('BP detection timeout reached.'),
        this.j.info('Buffering proxy detected and switch to long-polling!'),
        (this.F = !1),
        (this.M = !0),
        zn(10),
        Pd(this),
        oI(this))
    })
  function vg(h) {
    h.A != null && (a.clearTimeout(h.A), (h.A = null))
  }
  function oI(h) {
    ;(h.g = new Zr(h, h.j, 'rpc', h.Y)), h.m === null && (h.g.H = h.o), (h.g.O = 0)
    var b = br(h.qa)
    Ct(b, 'RID', 'rpc'),
      Ct(b, 'SID', h.K),
      Ct(b, 'AID', h.T),
      Ct(b, 'CI', h.F ? '0' : '1'),
      !h.F && h.ja && Ct(b, 'TO', h.ja),
      Ct(b, 'TYPE', 'xmlhttp'),
      cu(h, b),
      h.m && h.o && fg(b, h.m, h.o),
      h.L && (h.g.I = h.L)
    var P = h.g
    ;(h = h.ia), (P.L = 1), (P.v = Cd(br(b))), (P.m = null), (P.P = !0), Dw(P, h)
  }
  e.Za = function () {
    this.C != null && ((this.C = null), Pd(this), gg(this), zn(19))
  }
  function xd(h) {
    h.C != null && (a.clearTimeout(h.C), (h.C = null))
  }
  function aI(h, b) {
    var P = null
    if (h.g == b) {
      xd(h), vg(h), (h.g = null)
      var M = 2
    } else if (dg(h.h, b)) (P = b.D), Bw(h.h, b), (M = 1)
    else return
    if (h.G != 0) {
      if (b.o)
        if (M == 1) {
          ;(P = b.m ? b.m.length : 0), (b = Date.now() - b.F)
          var Y = h.B
          ;(M = bd()), Be(M, new Pw(M, P)), Rd(h)
        } else sI(h)
      else if (((Y = b.s), Y == 3 || (Y == 0 && 0 < b.X) || !((M == 1 && pM(h, b)) || (M == 2 && gg(h)))))
        switch ((P && 0 < P.length && ((b = h.h), (b.i = b.i.concat(P))), Y)) {
          case 1:
            Zs(h, 5)
            break
          case 4:
            Zs(h, 10)
            break
          case 3:
            Zs(h, 6)
            break
          default:
            Zs(h, 2)
        }
    }
  }
  function lI(h, b) {
    let P = h.Ta + Math.floor(Math.random() * h.cb)
    return h.isActive() || (P *= 2), P * b
  }
  function Zs(h, b) {
    if ((h.j.info('Error code ' + b), b == 2)) {
      var P = f(h.fb, h),
        M = h.Xa
      const Y = !M
      ;(M = new Js(M || '//www.google.com/images/cleardot.gif')),
        (a.location && a.location.protocol == 'http') || Ed(M, 'https'),
        Cd(M),
        Y ? cM(M.toString(), P) : dM(M.toString(), P)
    } else zn(2)
    ;(h.G = 0), h.l && h.l.sa(b), uI(h), nI(h)
  }
  e.fb = function (h) {
    h ? (this.j.info('Successfully pinged google.com'), zn(2)) : (this.j.info('Failed to ping google.com'), zn(1))
  }
  function uI(h) {
    if (((h.G = 0), (h.ka = []), h.l)) {
      const b = $w(h.h)
      ;(b.length != 0 || h.i.length != 0) && (y(h.ka, b), y(h.ka, h.i), (h.h.i.length = 0), v(h.i), (h.i.length = 0)),
        h.l.ra()
    }
  }
  function cI(h, b, P) {
    var M = P instanceof Js ? br(P) : new Js(P)
    if (M.g != '') b && (M.g = b + '.' + M.g), Td(M, M.s)
    else {
      var Y = a.location
      ;(M = Y.protocol), (b = b ? b + '.' + Y.hostname : Y.hostname), (Y = +Y.port)
      var ie = new Js(null)
      M && Ed(ie, M), b && (ie.g = b), Y && Td(ie, Y), P && (ie.l = P), (M = ie)
    }
    return (P = h.D), (b = h.ya), P && b && Ct(M, P, b), Ct(M, 'VER', h.la), cu(h, M), M
  }
  function dI(h, b, P) {
    if (b && !h.J) throw Error("Can't create secondary domain capable XhrIo object.")
    return (b = h.Ca && !h.pa ? new zt(new ou({ eb: P })) : new zt(h.pa)), b.Ha(h.J), b
  }
  e.isActive = function () {
    return !!this.l && this.l.isActive(this)
  }
  function hI() {}
  ;(e = hI.prototype),
    (e.ua = function () {}),
    (e.ta = function () {}),
    (e.sa = function () {}),
    (e.ra = function () {}),
    (e.isActive = function () {
      return !0
    }),
    (e.Na = function () {})
  function Vd() {}
  Vd.prototype.g = function (h, b) {
    return new oi(h, b)
  }
  function oi(h, b) {
    Me.call(this),
      (this.g = new tI(b)),
      (this.l = h),
      (this.h = (b && b.messageUrlParams) || null),
      (h = (b && b.messageHeaders) || null),
      b &&
        b.clientProtocolHeaderRequired &&
        (h ? (h['X-Client-Protocol'] = 'webchannel') : (h = { 'X-Client-Protocol': 'webchannel' })),
      (this.g.o = h),
      (h = (b && b.initMessageHeaders) || null),
      b &&
        b.messageContentType &&
        (h
          ? (h['X-WebChannel-Content-Type'] = b.messageContentType)
          : (h = { 'X-WebChannel-Content-Type': b.messageContentType })),
      b && b.va && (h ? (h['X-WebChannel-Client-Profile'] = b.va) : (h = { 'X-WebChannel-Client-Profile': b.va })),
      (this.g.S = h),
      (h = b && b.Sb) && !A(h) && (this.g.m = h),
      (this.v = (b && b.supportsCrossDomainXhr) || !1),
      (this.u = (b && b.sendRawJson) || !1),
      (b = b && b.httpSessionIdParam) &&
        !A(b) &&
        ((this.g.D = b), (h = this.h), h !== null && b in h && ((h = this.h), b in h && delete h[b])),
      (this.j = new Ea(this))
  }
  p(oi, Me),
    (oi.prototype.m = function () {
      ;(this.g.l = this.j), this.v && (this.g.J = !0), this.g.connect(this.l, this.h || void 0)
    }),
    (oi.prototype.close = function () {
      mg(this.g)
    }),
    (oi.prototype.o = function (h) {
      var b = this.g
      if (typeof h == 'string') {
        var P = {}
        ;(P.__data__ = h), (h = P)
      } else this.u && ((P = {}), (P.__data__ = ba(h)), (h = P))
      b.i.push(new eM(b.Ya++, h)), b.G == 3 && Rd(b)
    }),
    (oi.prototype.N = function () {
      ;(this.g.l = null), delete this.j, mg(this.g), delete this.g, oi.aa.N.call(this)
    })
  function fI(h) {
    rg.call(this),
      h.__headers__ &&
        ((this.headers = h.__headers__), (this.statusCode = h.__status__), delete h.__headers__, delete h.__status__)
    var b = h.__sm__
    if (b) {
      e: {
        for (const P in b) {
          h = P
          break e
        }
        h = void 0
      }
      ;(this.i = h) && ((h = this.i), (b = b !== null && h in b ? b[h] : void 0)), (this.data = b)
    } else this.data = h
  }
  p(fI, rg)
  function mI() {
    sg.call(this), (this.status = 1)
  }
  p(mI, sg)
  function Ea(h) {
    this.g = h
  }
  p(Ea, hI),
    (Ea.prototype.ua = function () {
      Be(this.g, 'a')
    }),
    (Ea.prototype.ta = function (h) {
      Be(this.g, new fI(h))
    }),
    (Ea.prototype.sa = function (h) {
      Be(this.g, new mI())
    }),
    (Ea.prototype.ra = function () {
      Be(this.g, 'b')
    }),
    (Vd.prototype.createWebChannel = Vd.prototype.g),
    (oi.prototype.send = oi.prototype.o),
    (oi.prototype.open = oi.prototype.m),
    (oi.prototype.close = oi.prototype.close),
    (IR = function () {
      return new Vd()
    }),
    (wR = function () {
      return bd()
    }),
    (bR = Qs),
    (op = {
      mb: 0,
      pb: 1,
      qb: 2,
      Jb: 3,
      Ob: 4,
      Lb: 5,
      Mb: 6,
      Kb: 7,
      Ib: 8,
      Nb: 9,
      PROXY: 10,
      NOPROXY: 11,
      Gb: 12,
      Cb: 13,
      Db: 14,
      Bb: 15,
      Eb: 16,
      Fb: 17,
      ib: 18,
      hb: 19,
      jb: 20,
    }),
    (wd.NO_ERROR = 0),
    (wd.TIMEOUT = 8),
    (wd.HTTP_ERROR = 6),
    (wh = wd),
    (Rw.COMPLETE = 'complete'),
    (_R = Rw),
    (Tw.EventType = Jl),
    (Jl.OPEN = 'a'),
    (Jl.CLOSE = 'b'),
    (Jl.ERROR = 'c'),
    (Jl.MESSAGE = 'd'),
    (Me.prototype.listen = Me.prototype.K),
    (Ru = Tw),
    (yR = ou),
    (zt.prototype.listenOnce = zt.prototype.L),
    (zt.prototype.getLastError = zt.prototype.Ka),
    (zt.prototype.getLastErrorCode = zt.prototype.Ba),
    (zt.prototype.getStatus = zt.prototype.Z),
    (zt.prototype.getResponseJson = zt.prototype.Oa),
    (zt.prototype.getResponseText = zt.prototype.oa),
    (zt.prototype.send = zt.prototype.ea),
    (zt.prototype.setWithCredentials = zt.prototype.Ha),
    (pR = zt)
}).apply(typeof Xd < 'u' ? Xd : typeof self < 'u' ? self : typeof window < 'u' ? window : {})
const TE = '@firebase/firestore'
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class qn {
  constructor(t) {
    this.uid = t
  }
  isAuthenticated() {
    return this.uid != null
  }
  toKey() {
    return this.isAuthenticated() ? 'uid:' + this.uid : 'anonymous-user'
  }
  isEqual(t) {
    return t.uid === this.uid
  }
}
;(qn.UNAUTHENTICATED = new qn(null)),
  (qn.GOOGLE_CREDENTIALS = new qn('google-credentials-uid')),
  (qn.FIRST_PARTY = new qn('first-party-uid')),
  (qn.MOCK_USER = new qn('mock-user'))
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let jl = '10.12.3'
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Lo = new na('@firebase/firestore')
function Fa() {
  return Lo.logLevel
}
function we(e, ...t) {
  if (Lo.logLevel <= Je.DEBUG) {
    const n = t.map(P_)
    Lo.debug(`Firestore (${jl}): ${e}`, ...n)
  }
}
function Gn(e, ...t) {
  if (Lo.logLevel <= Je.ERROR) {
    const n = t.map(P_)
    Lo.error(`Firestore (${jl}): ${e}`, ...n)
  }
}
function mc(e, ...t) {
  if (Lo.logLevel <= Je.WARN) {
    const n = t.map(P_)
    Lo.warn(`Firestore (${jl}): ${e}`, ...n)
  }
}
function P_(e) {
  if (typeof e == 'string') return e
  try {
    /**
     * @license
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */ return (function (n) {
      return JSON.stringify(n)
    })(e)
  } catch {
    return e
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Oe(e = 'Unexpected state') {
  const t = `FIRESTORE (${jl}) INTERNAL ASSERTION FAILED: ` + e
  throw (Gn(t), new Error(t))
}
function Fe(e, t) {
  e || Oe()
}
function Ke(e, t) {
  return e
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const fe = {
  OK: 'ok',
  CANCELLED: 'cancelled',
  UNKNOWN: 'unknown',
  INVALID_ARGUMENT: 'invalid-argument',
  DEADLINE_EXCEEDED: 'deadline-exceeded',
  NOT_FOUND: 'not-found',
  ALREADY_EXISTS: 'already-exists',
  PERMISSION_DENIED: 'permission-denied',
  UNAUTHENTICATED: 'unauthenticated',
  RESOURCE_EXHAUSTED: 'resource-exhausted',
  FAILED_PRECONDITION: 'failed-precondition',
  ABORTED: 'aborted',
  OUT_OF_RANGE: 'out-of-range',
  UNIMPLEMENTED: 'unimplemented',
  INTERNAL: 'internal',
  UNAVAILABLE: 'unavailable',
  DATA_LOSS: 'data-loss',
}
class Ve extends Di {
  constructor(t, n) {
    super(t, n),
      (this.code = t),
      (this.message = n),
      (this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class cr {
  constructor() {
    this.promise = new Promise((t, n) => {
      ;(this.resolve = t), (this.reject = n)
    })
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class wH {
  constructor(t, n) {
    ;(this.user = n),
      (this.type = 'OAuth'),
      (this.headers = new Map()),
      this.headers.set('Authorization', `Bearer ${t}`)
  }
}
class IH {
  getToken() {
    return Promise.resolve(null)
  }
  invalidateToken() {}
  start(t, n) {
    t.enqueueRetryable(() => n(qn.UNAUTHENTICATED))
  }
  shutdown() {}
}
class SH {
  constructor(t) {
    ;(this.t = t), (this.currentUser = qn.UNAUTHENTICATED), (this.i = 0), (this.forceRefresh = !1), (this.auth = null)
  }
  start(t, n) {
    let i = this.i
    const r = (l) => (this.i !== i ? ((i = this.i), n(l)) : Promise.resolve())
    let s = new cr()
    this.o = () => {
      this.i++,
        (this.currentUser = this.u()),
        s.resolve(),
        (s = new cr()),
        t.enqueueRetryable(() => r(this.currentUser))
    }
    const o = () => {
        const l = s
        t.enqueueRetryable(async () => {
          await l.promise, await r(this.currentUser)
        })
      },
      a = (l) => {
        we('FirebaseAuthCredentialsProvider', 'Auth detected'),
          (this.auth = l),
          this.auth.addAuthTokenListener(this.o),
          o()
      }
    this.t.onInit((l) => a(l)),
      setTimeout(() => {
        if (!this.auth) {
          const l = this.t.getImmediate({ optional: !0 })
          l ? a(l) : (we('FirebaseAuthCredentialsProvider', 'Auth not yet detected'), s.resolve(), (s = new cr()))
        }
      }, 0),
      o()
  }
  getToken() {
    const t = this.i,
      n = this.forceRefresh
    return (
      (this.forceRefresh = !1),
      this.auth
        ? this.auth
            .getToken(n)
            .then((i) =>
              this.i !== t
                ? (we('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.'), this.getToken())
                : i
                ? (Fe(typeof i.accessToken == 'string'), new wH(i.accessToken, this.currentUser))
                : null
            )
        : Promise.resolve(null)
    )
  }
  invalidateToken() {
    this.forceRefresh = !0
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o)
  }
  u() {
    const t = this.auth && this.auth.getUid()
    return Fe(t === null || typeof t == 'string'), new qn(t)
  }
}
class EH {
  constructor(t, n, i) {
    ;(this.l = t),
      (this.h = n),
      (this.P = i),
      (this.type = 'FirstParty'),
      (this.user = qn.FIRST_PARTY),
      (this.I = new Map())
  }
  T() {
    return this.P ? this.P() : null
  }
  get headers() {
    this.I.set('X-Goog-AuthUser', this.l)
    const t = this.T()
    return t && this.I.set('Authorization', t), this.h && this.I.set('X-Goog-Iam-Authorization-Token', this.h), this.I
  }
}
class TH {
  constructor(t, n, i) {
    ;(this.l = t), (this.h = n), (this.P = i)
  }
  getToken() {
    return Promise.resolve(new EH(this.l, this.h, this.P))
  }
  start(t, n) {
    t.enqueueRetryable(() => n(qn.FIRST_PARTY))
  }
  shutdown() {}
  invalidateToken() {}
}
class CH {
  constructor(t) {
    ;(this.value = t),
      (this.type = 'AppCheck'),
      (this.headers = new Map()),
      t && t.length > 0 && this.headers.set('x-firebase-appcheck', this.value)
  }
}
class AH {
  constructor(t) {
    ;(this.A = t), (this.forceRefresh = !1), (this.appCheck = null), (this.R = null)
  }
  start(t, n) {
    const i = (s) => {
      s.error != null &&
        we(
          'FirebaseAppCheckTokenProvider',
          `Error getting App Check token; using placeholder token instead. Error: ${s.error.message}`
        )
      const o = s.token !== this.R
      return (
        (this.R = s.token),
        we('FirebaseAppCheckTokenProvider', `Received ${o ? 'new' : 'existing'} token.`),
        o ? n(s.token) : Promise.resolve()
      )
    }
    this.o = (s) => {
      t.enqueueRetryable(() => i(s))
    }
    const r = (s) => {
      we('FirebaseAppCheckTokenProvider', 'AppCheck detected'),
        (this.appCheck = s),
        this.appCheck.addTokenListener(this.o)
    }
    this.A.onInit((s) => r(s)),
      setTimeout(() => {
        if (!this.appCheck) {
          const s = this.A.getImmediate({ optional: !0 })
          s ? r(s) : we('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected')
        }
      }, 0)
  }
  getToken() {
    const t = this.forceRefresh
    return (
      (this.forceRefresh = !1),
      this.appCheck
        ? this.appCheck
            .getToken(t)
            .then((n) => (n ? (Fe(typeof n.token == 'string'), (this.R = n.token), new CH(n.token)) : null))
        : Promise.resolve(null)
    )
  }
  invalidateToken() {
    this.forceRefresh = !0
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function kH(e) {
  const t = typeof self < 'u' && (self.crypto || self.msCrypto),
    n = new Uint8Array(e)
  if (t && typeof t.getRandomValues == 'function') t.getRandomValues(n)
  else for (let i = 0; i < e; i++) n[i] = Math.floor(256 * Math.random())
  return n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class SR {
  static newId() {
    const t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
      n = Math.floor(256 / t.length) * t.length
    let i = ''
    for (; i.length < 20; ) {
      const r = kH(40)
      for (let s = 0; s < r.length; ++s) i.length < 20 && r[s] < n && (i += t.charAt(r[s] % t.length))
    }
    return i
  }
}
function Ye(e, t) {
  return e < t ? -1 : e > t ? 1 : 0
}
function pl(e, t, n) {
  return e.length === t.length && e.every((i, r) => n(i, t[r]))
}
function ER(e) {
  return e + '\0'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Dt {
  constructor(t, n) {
    if (((this.seconds = t), (this.nanoseconds = n), n < 0))
      throw new Ve(fe.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + n)
    if (n >= 1e9) throw new Ve(fe.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + n)
    if (t < -62135596800) throw new Ve(fe.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + t)
    if (t >= 253402300800) throw new Ve(fe.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + t)
  }
  static now() {
    return Dt.fromMillis(Date.now())
  }
  static fromDate(t) {
    return Dt.fromMillis(t.getTime())
  }
  static fromMillis(t) {
    const n = Math.floor(t / 1e3),
      i = Math.floor(1e6 * (t - 1e3 * n))
    return new Dt(n, i)
  }
  toDate() {
    return new Date(this.toMillis())
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6
  }
  _compareTo(t) {
    return this.seconds === t.seconds ? Ye(this.nanoseconds, t.nanoseconds) : Ye(this.seconds, t.seconds)
  }
  isEqual(t) {
    return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds
  }
  toString() {
    return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')'
  }
  toJSON() {
    return { seconds: this.seconds, nanoseconds: this.nanoseconds }
  }
  valueOf() {
    const t = this.seconds - -62135596800
    return String(t).padStart(12, '0') + '.' + String(this.nanoseconds).padStart(9, '0')
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class $e {
  constructor(t) {
    this.timestamp = t
  }
  static fromTimestamp(t) {
    return new $e(t)
  }
  static min() {
    return new $e(new Dt(0, 0))
  }
  static max() {
    return new $e(new Dt(253402300799, 999999999))
  }
  compareTo(t) {
    return this.timestamp._compareTo(t.timestamp)
  }
  isEqual(t) {
    return this.timestamp.isEqual(t.timestamp)
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
  }
  toString() {
    return 'SnapshotVersion(' + this.timestamp.toString() + ')'
  }
  toTimestamp() {
    return this.timestamp
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class gc {
  constructor(t, n, i) {
    n === void 0 ? (n = 0) : n > t.length && Oe(),
      i === void 0 ? (i = t.length - n) : i > t.length - n && Oe(),
      (this.segments = t),
      (this.offset = n),
      (this.len = i)
  }
  get length() {
    return this.len
  }
  isEqual(t) {
    return gc.comparator(this, t) === 0
  }
  child(t) {
    const n = this.segments.slice(this.offset, this.limit())
    return (
      t instanceof gc
        ? t.forEach((i) => {
            n.push(i)
          })
        : n.push(t),
      this.construct(n)
    )
  }
  limit() {
    return this.offset + this.length
  }
  popFirst(t) {
    return (t = t === void 0 ? 1 : t), this.construct(this.segments, this.offset + t, this.length - t)
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1)
  }
  firstSegment() {
    return this.segments[this.offset]
  }
  lastSegment() {
    return this.get(this.length - 1)
  }
  get(t) {
    return this.segments[this.offset + t]
  }
  isEmpty() {
    return this.length === 0
  }
  isPrefixOf(t) {
    if (t.length < this.length) return !1
    for (let n = 0; n < this.length; n++) if (this.get(n) !== t.get(n)) return !1
    return !0
  }
  isImmediateParentOf(t) {
    if (this.length + 1 !== t.length) return !1
    for (let n = 0; n < this.length; n++) if (this.get(n) !== t.get(n)) return !1
    return !0
  }
  forEach(t) {
    for (let n = this.offset, i = this.limit(); n < i; n++) t(this.segments[n])
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit())
  }
  static comparator(t, n) {
    const i = Math.min(t.length, n.length)
    for (let r = 0; r < i; r++) {
      const s = t.get(r),
        o = n.get(r)
      if (s < o) return -1
      if (s > o) return 1
    }
    return t.length < n.length ? -1 : t.length > n.length ? 1 : 0
  }
}
class pt extends gc {
  construct(t, n, i) {
    return new pt(t, n, i)
  }
  canonicalString() {
    return this.toArray().join('/')
  }
  toString() {
    return this.canonicalString()
  }
  toUriEncodedString() {
    return this.toArray().map(encodeURIComponent).join('/')
  }
  static fromString(...t) {
    const n = []
    for (const i of t) {
      if (i.indexOf('//') >= 0)
        throw new Ve(fe.INVALID_ARGUMENT, `Invalid segment (${i}). Paths must not contain // in them.`)
      n.push(...i.split('/').filter((r) => r.length > 0))
    }
    return new pt(n)
  }
  static emptyPath() {
    return new pt([])
  }
}
const PH = /^[_a-zA-Z][_a-zA-Z0-9]*$/
class Ft extends gc {
  construct(t, n, i) {
    return new Ft(t, n, i)
  }
  static isValidIdentifier(t) {
    return PH.test(t)
  }
  canonicalString() {
    return this.toArray()
      .map(
        (t) => ((t = t.replace(/\\/g, '\\\\').replace(/`/g, '\\`')), Ft.isValidIdentifier(t) || (t = '`' + t + '`'), t)
      )
      .join('.')
  }
  toString() {
    return this.canonicalString()
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === '__name__'
  }
  static keyField() {
    return new Ft(['__name__'])
  }
  static fromServerFormat(t) {
    const n = []
    let i = '',
      r = 0
    const s = () => {
      if (i.length === 0)
        throw new Ve(
          fe.INVALID_ARGUMENT,
          `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`
        )
      n.push(i), (i = '')
    }
    let o = !1
    for (; r < t.length; ) {
      const a = t[r]
      if (a === '\\') {
        if (r + 1 === t.length) throw new Ve(fe.INVALID_ARGUMENT, 'Path has trailing escape character: ' + t)
        const l = t[r + 1]
        if (l !== '\\' && l !== '.' && l !== '`')
          throw new Ve(fe.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + t)
        ;(i += l), (r += 2)
      } else a === '`' ? ((o = !o), r++) : a !== '.' || o ? ((i += a), r++) : (s(), r++)
    }
    if ((s(), o)) throw new Ve(fe.INVALID_ARGUMENT, 'Unterminated ` in path: ' + t)
    return new Ft(n)
  }
  static emptyPath() {
    return new Ft([])
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Re {
  constructor(t) {
    this.path = t
  }
  static fromPath(t) {
    return new Re(pt.fromString(t))
  }
  static fromName(t) {
    return new Re(pt.fromString(t).popFirst(5))
  }
  static empty() {
    return new Re(pt.emptyPath())
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment()
  }
  hasCollectionId(t) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2)
  }
  getCollectionPath() {
    return this.path.popLast()
  }
  isEqual(t) {
    return t !== null && pt.comparator(this.path, t.path) === 0
  }
  toString() {
    return this.path.toString()
  }
  static comparator(t, n) {
    return pt.comparator(t.path, n.path)
  }
  static isDocumentKey(t) {
    return t.length % 2 == 0
  }
  static fromSegments(t) {
    return new Re(new pt(t.slice()))
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class rf {
  constructor(t, n, i, r) {
    ;(this.indexId = t), (this.collectionGroup = n), (this.fields = i), (this.indexState = r)
  }
}
function ap(e) {
  return e.fields.find((t) => t.kind === 2)
}
function uo(e) {
  return e.fields.filter((t) => t.kind !== 2)
}
rf.UNKNOWN_ID = -1
class Ih {
  constructor(t, n) {
    ;(this.fieldPath = t), (this.kind = n)
  }
}
class vc {
  constructor(t, n) {
    ;(this.sequenceNumber = t), (this.offset = n)
  }
  static empty() {
    return new vc(0, vi.min())
  }
}
function RH(e, t) {
  const n = e.toTimestamp().seconds,
    i = e.toTimestamp().nanoseconds + 1,
    r = $e.fromTimestamp(i === 1e9 ? new Dt(n + 1, 0) : new Dt(n, i))
  return new vi(r, Re.empty(), t)
}
function TR(e) {
  return new vi(e.readTime, e.key, -1)
}
class vi {
  constructor(t, n, i) {
    ;(this.readTime = t), (this.documentKey = n), (this.largestBatchId = i)
  }
  static min() {
    return new vi($e.min(), Re.empty(), -1)
  }
  static max() {
    return new vi($e.max(), Re.empty(), -1)
  }
}
function R_(e, t) {
  let n = e.readTime.compareTo(t.readTime)
  return n !== 0
    ? n
    : ((n = Re.comparator(e.documentKey, t.documentKey)), n !== 0 ? n : Ye(e.largestBatchId, t.largestBatchId))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const CR =
  'The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.'
class AR {
  constructor() {
    this.onCommittedListeners = []
  }
  addOnCommittedListener(t) {
    this.onCommittedListeners.push(t)
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t) => t())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function aa(e) {
  if (e.code !== fe.FAILED_PRECONDITION || e.message !== CR) throw e
  we('LocalStore', 'Unexpectedly lost primary lease')
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class J {
  constructor(t) {
    ;(this.nextCallback = null),
      (this.catchCallback = null),
      (this.result = void 0),
      (this.error = void 0),
      (this.isDone = !1),
      (this.callbackAttached = !1),
      t(
        (n) => {
          ;(this.isDone = !0), (this.result = n), this.nextCallback && this.nextCallback(n)
        },
        (n) => {
          ;(this.isDone = !0), (this.error = n), this.catchCallback && this.catchCallback(n)
        }
      )
  }
  catch(t) {
    return this.next(void 0, t)
  }
  next(t, n) {
    return (
      this.callbackAttached && Oe(),
      (this.callbackAttached = !0),
      this.isDone
        ? this.error
          ? this.wrapFailure(n, this.error)
          : this.wrapSuccess(t, this.result)
        : new J((i, r) => {
            ;(this.nextCallback = (s) => {
              this.wrapSuccess(t, s).next(i, r)
            }),
              (this.catchCallback = (s) => {
                this.wrapFailure(n, s).next(i, r)
              })
          })
    )
  }
  toPromise() {
    return new Promise((t, n) => {
      this.next(t, n)
    })
  }
  wrapUserFunction(t) {
    try {
      const n = t()
      return n instanceof J ? n : J.resolve(n)
    } catch (n) {
      return J.reject(n)
    }
  }
  wrapSuccess(t, n) {
    return t ? this.wrapUserFunction(() => t(n)) : J.resolve(n)
  }
  wrapFailure(t, n) {
    return t ? this.wrapUserFunction(() => t(n)) : J.reject(n)
  }
  static resolve(t) {
    return new J((n, i) => {
      n(t)
    })
  }
  static reject(t) {
    return new J((n, i) => {
      i(t)
    })
  }
  static waitFor(t) {
    return new J((n, i) => {
      let r = 0,
        s = 0,
        o = !1
      t.forEach((a) => {
        ++r,
          a.next(
            () => {
              ++s, o && s === r && n()
            },
            (l) => i(l)
          )
      }),
        (o = !0),
        s === r && n()
    })
  }
  static or(t) {
    let n = J.resolve(!1)
    for (const i of t) n = n.next((r) => (r ? J.resolve(r) : i()))
    return n
  }
  static forEach(t, n) {
    const i = []
    return (
      t.forEach((r, s) => {
        i.push(n.call(this, r, s))
      }),
      this.waitFor(i)
    )
  }
  static mapArray(t, n) {
    return new J((i, r) => {
      const s = t.length,
        o = new Array(s)
      let a = 0
      for (let l = 0; l < s; l++) {
        const u = l
        n(t[u]).next(
          (c) => {
            ;(o[u] = c), ++a, a === s && i(o)
          },
          (c) => r(c)
        )
      }
    })
  }
  static doWhile(t, n) {
    return new J((i, r) => {
      const s = () => {
        t() === !0
          ? n().next(() => {
              s()
            }, r)
          : i()
      }
      s()
    })
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class nm {
  constructor(t, n) {
    ;(this.action = t),
      (this.transaction = n),
      (this.aborted = !1),
      (this.V = new cr()),
      (this.transaction.oncomplete = () => {
        this.V.resolve()
      }),
      (this.transaction.onabort = () => {
        n.error ? this.V.reject(new Gu(t, n.error)) : this.V.resolve()
      }),
      (this.transaction.onerror = (i) => {
        const r = x_(i.target.error)
        this.V.reject(new Gu(t, r))
      })
  }
  static open(t, n, i, r) {
    try {
      return new nm(n, t.transaction(r, i))
    } catch (s) {
      throw new Gu(n, s)
    }
  }
  get m() {
    return this.V.promise
  }
  abort(t) {
    t && this.V.reject(t),
      this.aborted ||
        (we('SimpleDb', 'Aborting transaction:', t ? t.message : 'Client-initiated abort'),
        (this.aborted = !0),
        this.transaction.abort())
  }
  g() {
    const t = this.transaction
    this.aborted || typeof t.commit != 'function' || t.commit()
  }
  store(t) {
    const n = this.transaction.objectStore(t)
    return new VH(n)
  }
}
class Ps {
  constructor(t, n, i) {
    ;(this.name = t),
      (this.version = n),
      (this.p = i),
      Ps.S(Zt()) === 12.2 &&
        Gn(
          'Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.'
        )
  }
  static delete(t) {
    return we('SimpleDb', 'Removing database:', t), ho(window.indexedDB.deleteDatabase(t)).toPromise()
  }
  static D() {
    if (!jc()) return !1
    if (Ps.C()) return !0
    const t = Zt(),
      n = Ps.S(t),
      i = 0 < n && n < 10,
      r = kR(t),
      s = 0 < r && r < 4.5
    return !(t.indexOf('MSIE ') > 0 || t.indexOf('Trident/') > 0 || t.indexOf('Edge/') > 0 || i || s)
  }
  static C() {
    var t
    return typeof process < 'u' && ((t = process.__PRIVATE_env) === null || t === void 0 ? void 0 : t.v) === 'YES'
  }
  static F(t, n) {
    return t.store(n)
  }
  static S(t) {
    const n = t.match(/i(?:phone|pad|pod) os ([\d_]+)/i),
      i = n ? n[1].split('_').slice(0, 2).join('.') : '-1'
    return Number(i)
  }
  async M(t) {
    return (
      this.db ||
        (we('SimpleDb', 'Opening database:', this.name),
        (this.db = await new Promise((n, i) => {
          const r = indexedDB.open(this.name, this.version)
          ;(r.onsuccess = (s) => {
            const o = s.target.result
            n(o)
          }),
            (r.onblocked = () => {
              i(
                new Gu(
                  t,
                  'Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.'
                )
              )
            }),
            (r.onerror = (s) => {
              const o = s.target.error
              o.name === 'VersionError'
                ? i(
                    new Ve(
                      fe.FAILED_PRECONDITION,
                      'A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.'
                    )
                  )
                : o.name === 'InvalidStateError'
                ? i(
                    new Ve(
                      fe.FAILED_PRECONDITION,
                      'Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: ' +
                        o
                    )
                  )
                : i(new Gu(t, o))
            }),
            (r.onupgradeneeded = (s) => {
              we('SimpleDb', 'Database "' + this.name + '" requires upgrade from version:', s.oldVersion)
              const o = s.target.result
              this.p.O(o, r.transaction, s.oldVersion, this.version).next(() => {
                we('SimpleDb', 'Database upgrade to version ' + this.version + ' complete')
              })
            })
        }))),
      this.N && (this.db.onversionchange = (n) => this.N(n)),
      this.db
    )
  }
  L(t) {
    ;(this.N = t), this.db && (this.db.onversionchange = (n) => t(n))
  }
  async runTransaction(t, n, i, r) {
    const s = n === 'readonly'
    let o = 0
    for (;;) {
      ++o
      try {
        this.db = await this.M(t)
        const a = nm.open(this.db, t, s ? 'readonly' : 'readwrite', i),
          l = r(a)
            .next((u) => (a.g(), u))
            .catch((u) => (a.abort(u), J.reject(u)))
            .toPromise()
        return l.catch(() => {}), await a.m, l
      } catch (a) {
        const l = a,
          u = l.name !== 'FirebaseError' && o < 3
        if ((we('SimpleDb', 'Transaction failed with error:', l.message, 'Retrying:', u), this.close(), !u))
          return Promise.reject(l)
      }
    }
  }
  close() {
    this.db && this.db.close(), (this.db = void 0)
  }
}
function kR(e) {
  const t = e.match(/Android ([\d.]+)/i),
    n = t ? t[1].split('.').slice(0, 2).join('.') : '-1'
  return Number(n)
}
class xH {
  constructor(t) {
    ;(this.B = t), (this.k = !1), (this.q = null)
  }
  get isDone() {
    return this.k
  }
  get K() {
    return this.q
  }
  set cursor(t) {
    this.B = t
  }
  done() {
    this.k = !0
  }
  $(t) {
    this.q = t
  }
  delete() {
    return ho(this.B.delete())
  }
}
class Gu extends Ve {
  constructor(t, n) {
    super(fe.UNAVAILABLE, `IndexedDB transaction '${t}' failed: ${n}`), (this.name = 'IndexedDbTransactionError')
  }
}
function Ws(e) {
  return e.name === 'IndexedDbTransactionError'
}
class VH {
  constructor(t) {
    this.store = t
  }
  put(t, n) {
    let i
    return (
      n !== void 0
        ? (we('SimpleDb', 'PUT', this.store.name, t, n), (i = this.store.put(n, t)))
        : (we('SimpleDb', 'PUT', this.store.name, '<auto-key>', t), (i = this.store.put(t))),
      ho(i)
    )
  }
  add(t) {
    return we('SimpleDb', 'ADD', this.store.name, t, t), ho(this.store.add(t))
  }
  get(t) {
    return ho(this.store.get(t)).next(
      (n) => (n === void 0 && (n = null), we('SimpleDb', 'GET', this.store.name, t, n), n)
    )
  }
  delete(t) {
    return we('SimpleDb', 'DELETE', this.store.name, t), ho(this.store.delete(t))
  }
  count() {
    return we('SimpleDb', 'COUNT', this.store.name), ho(this.store.count())
  }
  U(t, n) {
    const i = this.options(t, n),
      r = i.index ? this.store.index(i.index) : this.store
    if (typeof r.getAll == 'function') {
      const s = r.getAll(i.range)
      return new J((o, a) => {
        ;(s.onerror = (l) => {
          a(l.target.error)
        }),
          (s.onsuccess = (l) => {
            o(l.target.result)
          })
      })
    }
    {
      const s = this.cursor(i),
        o = []
      return this.W(s, (a, l) => {
        o.push(l)
      }).next(() => o)
    }
  }
  G(t, n) {
    const i = this.store.getAll(t, n === null ? void 0 : n)
    return new J((r, s) => {
      ;(i.onerror = (o) => {
        s(o.target.error)
      }),
        (i.onsuccess = (o) => {
          r(o.target.result)
        })
    })
  }
  j(t, n) {
    we('SimpleDb', 'DELETE ALL', this.store.name)
    const i = this.options(t, n)
    i.H = !1
    const r = this.cursor(i)
    return this.W(r, (s, o, a) => a.delete())
  }
  J(t, n) {
    let i
    n ? (i = t) : ((i = {}), (n = t))
    const r = this.cursor(i)
    return this.W(r, n)
  }
  Y(t) {
    const n = this.cursor({})
    return new J((i, r) => {
      ;(n.onerror = (s) => {
        const o = x_(s.target.error)
        r(o)
      }),
        (n.onsuccess = (s) => {
          const o = s.target.result
          o
            ? t(o.primaryKey, o.value).next((a) => {
                a ? o.continue() : i()
              })
            : i()
        })
    })
  }
  W(t, n) {
    const i = []
    return new J((r, s) => {
      ;(t.onerror = (o) => {
        s(o.target.error)
      }),
        (t.onsuccess = (o) => {
          const a = o.target.result
          if (!a) return void r()
          const l = new xH(a),
            u = n(a.primaryKey, a.value, l)
          if (u instanceof J) {
            const c = u.catch((d) => (l.done(), J.reject(d)))
            i.push(c)
          }
          l.isDone ? r() : l.K === null ? a.continue() : a.continue(l.K)
        })
    }).next(() => J.waitFor(i))
  }
  options(t, n) {
    let i
    return t !== void 0 && (typeof t == 'string' ? (i = t) : (n = t)), { index: i, range: n }
  }
  cursor(t) {
    let n = 'next'
    if ((t.reverse && (n = 'prev'), t.index)) {
      const i = this.store.index(t.index)
      return t.H ? i.openKeyCursor(t.range, n) : i.openCursor(t.range, n)
    }
    return this.store.openCursor(t.range, n)
  }
}
function ho(e) {
  return new J((t, n) => {
    ;(e.onsuccess = (i) => {
      const r = i.target.result
      t(r)
    }),
      (e.onerror = (i) => {
        const r = x_(i.target.error)
        n(r)
      })
  })
}
let CE = !1
function x_(e) {
  const t = Ps.S(Zt())
  if (t >= 12.2 && t < 13) {
    const n = 'An internal error was encountered in the Indexed Database server'
    if (e.message.indexOf(n) >= 0) {
      const i = new Ve(
        'internal',
        `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${n}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`
      )
      return (
        CE ||
          ((CE = !0),
          setTimeout(() => {
            throw i
          }, 0)),
        i
      )
    }
  }
  return e
}
class DH {
  constructor(t, n) {
    ;(this.asyncQueue = t), (this.Z = n), (this.task = null)
  }
  start() {
    this.X(15e3)
  }
  stop() {
    this.task && (this.task.cancel(), (this.task = null))
  }
  get started() {
    return this.task !== null
  }
  X(t) {
    we('IndexBackfiller', `Scheduled in ${t}ms`),
      (this.task = this.asyncQueue.enqueueAfterDelay('index_backfill', t, async () => {
        this.task = null
        try {
          we('IndexBackfiller', `Documents written: ${await this.Z.ee()}`)
        } catch (n) {
          Ws(n) ? we('IndexBackfiller', 'Ignoring IndexedDB error during index backfill: ', n) : await aa(n)
        }
        await this.X(6e4)
      }))
  }
}
class NH {
  constructor(t, n) {
    ;(this.localStore = t), (this.persistence = n)
  }
  async ee(t = 50) {
    return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', (n) => this.te(n, t))
  }
  te(t, n) {
    const i = new Set()
    let r = n,
      s = !0
    return J.doWhile(
      () => s === !0 && r > 0,
      () =>
        this.localStore.indexManager.getNextCollectionGroupToUpdate(t).next((o) => {
          if (o !== null && !i.has(o))
            return (
              we('IndexBackfiller', `Processing collection: ${o}`),
              this.ne(t, o, r).next((a) => {
                ;(r -= a), i.add(o)
              })
            )
          s = !1
        })
    ).next(() => n - r)
  }
  ne(t, n, i) {
    return this.localStore.indexManager.getMinOffsetFromCollectionGroup(t, n).next((r) =>
      this.localStore.localDocuments.getNextDocuments(t, n, r, i).next((s) => {
        const o = s.changes
        return this.localStore.indexManager
          .updateIndexEntries(t, o)
          .next(() => this.re(r, s))
          .next(
            (a) => (
              we('IndexBackfiller', `Updating offset: ${a}`),
              this.localStore.indexManager.updateCollectionGroup(t, n, a)
            )
          )
          .next(() => o.size)
      })
    )
  }
  re(t, n) {
    let i = t
    return (
      n.changes.forEach((r, s) => {
        const o = TR(s)
        R_(o, i) > 0 && (i = o)
      }),
      new vi(i.readTime, i.documentKey, Math.max(n.batchId, t.largestBatchId))
    )
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ci {
  constructor(t, n) {
    ;(this.previousValue = t),
      n && ((n.sequenceNumberHandler = (i) => this.ie(i)), (this.se = (i) => n.writeSequenceNumber(i)))
  }
  ie(t) {
    return (this.previousValue = Math.max(t, this.previousValue)), this.previousValue
  }
  next() {
    const t = ++this.previousValue
    return this.se && this.se(t), t
  }
}
Ci.oe = -1
function im(e) {
  return e == null
}
function pc(e) {
  return e === 0 && 1 / e == -1 / 0
}
function OH(e) {
  return (
    typeof e == 'number' &&
    Number.isInteger(e) &&
    !pc(e) &&
    e <= Number.MAX_SAFE_INTEGER &&
    e >= Number.MIN_SAFE_INTEGER
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Yn(e) {
  let t = ''
  for (let n = 0; n < e.length; n++) t.length > 0 && (t = AE(t)), (t = MH(e.get(n), t))
  return AE(t)
}
function MH(e, t) {
  let n = t
  const i = e.length
  for (let r = 0; r < i; r++) {
    const s = e.charAt(r)
    switch (s) {
      case '\0':
        n += ''
        break
      case '':
        n += ''
        break
      default:
        n += s
    }
  }
  return n
}
function AE(e) {
  return e + ''
}
function rr(e) {
  const t = e.length
  if ((Fe(t >= 2), t === 2)) return Fe(e.charAt(0) === '' && e.charAt(1) === ''), pt.emptyPath()
  const n = t - 2,
    i = []
  let r = ''
  for (let s = 0; s < t; ) {
    const o = e.indexOf('', s)
    switch (((o < 0 || o > n) && Oe(), e.charAt(o + 1))) {
      case '':
        const a = e.substring(s, o)
        let l
        r.length === 0 ? (l = a) : ((r += a), (l = r), (r = '')), i.push(l)
        break
      case '':
        ;(r += e.substring(s, o)), (r += '\0')
        break
      case '':
        r += e.substring(s, o + 1)
        break
      default:
        Oe()
    }
    s = o + 2
  }
  return new pt(i)
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const kE = ['userId', 'batchId']
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Sh(e, t) {
  return [e, Yn(t)]
}
function PR(e, t, n) {
  return [e, Yn(t), n]
}
const LH = {},
  FH = ['prefixPath', 'collectionGroup', 'readTime', 'documentId'],
  BH = ['prefixPath', 'collectionGroup', 'documentId'],
  $H = ['collectionGroup', 'readTime', 'prefixPath', 'documentId'],
  UH = ['canonicalId', 'targetId'],
  jH = ['targetId', 'path'],
  zH = ['path', 'targetId'],
  HH = ['collectionId', 'parent'],
  WH = ['indexId', 'uid'],
  qH = ['uid', 'sequenceNumber'],
  GH = ['indexId', 'uid', 'arrayValue', 'directionalValue', 'orderedDocumentKey', 'documentKey'],
  KH = ['indexId', 'uid', 'orderedDocumentKey'],
  YH = ['userId', 'collectionPath', 'documentId'],
  QH = ['userId', 'collectionPath', 'largestBatchId'],
  XH = ['userId', 'collectionGroup', 'largestBatchId'],
  RR = [
    'mutationQueues',
    'mutations',
    'documentMutations',
    'remoteDocuments',
    'targets',
    'owner',
    'targetGlobal',
    'targetDocuments',
    'clientMetadata',
    'remoteDocumentGlobal',
    'collectionParents',
    'bundles',
    'namedQueries',
  ],
  JH = [...RR, 'documentOverlays'],
  xR = [
    'mutationQueues',
    'mutations',
    'documentMutations',
    'remoteDocumentsV14',
    'targets',
    'owner',
    'targetGlobal',
    'targetDocuments',
    'clientMetadata',
    'remoteDocumentGlobal',
    'collectionParents',
    'bundles',
    'namedQueries',
    'documentOverlays',
  ],
  VR = xR,
  DR = [...VR, 'indexConfiguration', 'indexState', 'indexEntries'],
  ZH = DR
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class lp extends AR {
  constructor(t, n) {
    super(), (this._e = t), (this.currentSequenceNumber = n)
  }
}
function vn(e, t) {
  const n = Ke(e)
  return Ps.F(n._e, t)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function PE(e) {
  let t = 0
  for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++
  return t
}
function la(e, t) {
  for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n])
}
function NR(e) {
  for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1
  return !0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Nt {
  constructor(t, n) {
    ;(this.comparator = t), (this.root = n || bn.EMPTY)
  }
  insert(t, n) {
    return new Nt(this.comparator, this.root.insert(t, n, this.comparator).copy(null, null, bn.BLACK, null, null))
  }
  remove(t) {
    return new Nt(this.comparator, this.root.remove(t, this.comparator).copy(null, null, bn.BLACK, null, null))
  }
  get(t) {
    let n = this.root
    for (; !n.isEmpty(); ) {
      const i = this.comparator(t, n.key)
      if (i === 0) return n.value
      i < 0 ? (n = n.left) : i > 0 && (n = n.right)
    }
    return null
  }
  indexOf(t) {
    let n = 0,
      i = this.root
    for (; !i.isEmpty(); ) {
      const r = this.comparator(t, i.key)
      if (r === 0) return n + i.left.size
      r < 0 ? (i = i.left) : ((n += i.left.size + 1), (i = i.right))
    }
    return -1
  }
  isEmpty() {
    return this.root.isEmpty()
  }
  get size() {
    return this.root.size
  }
  minKey() {
    return this.root.minKey()
  }
  maxKey() {
    return this.root.maxKey()
  }
  inorderTraversal(t) {
    return this.root.inorderTraversal(t)
  }
  forEach(t) {
    this.inorderTraversal((n, i) => (t(n, i), !1))
  }
  toString() {
    const t = []
    return this.inorderTraversal((n, i) => (t.push(`${n}:${i}`), !1)), `{${t.join(', ')}}`
  }
  reverseTraversal(t) {
    return this.root.reverseTraversal(t)
  }
  getIterator() {
    return new Jd(this.root, null, this.comparator, !1)
  }
  getIteratorFrom(t) {
    return new Jd(this.root, t, this.comparator, !1)
  }
  getReverseIterator() {
    return new Jd(this.root, null, this.comparator, !0)
  }
  getReverseIteratorFrom(t) {
    return new Jd(this.root, t, this.comparator, !0)
  }
}
class Jd {
  constructor(t, n, i, r) {
    ;(this.isReverse = r), (this.nodeStack = [])
    let s = 1
    for (; !t.isEmpty(); )
      if (((s = n ? i(t.key, n) : 1), n && r && (s *= -1), s < 0)) t = this.isReverse ? t.left : t.right
      else {
        if (s === 0) {
          this.nodeStack.push(t)
          break
        }
        this.nodeStack.push(t), (t = this.isReverse ? t.right : t.left)
      }
  }
  getNext() {
    let t = this.nodeStack.pop()
    const n = { key: t.key, value: t.value }
    if (this.isReverse) for (t = t.left; !t.isEmpty(); ) this.nodeStack.push(t), (t = t.right)
    else for (t = t.right; !t.isEmpty(); ) this.nodeStack.push(t), (t = t.left)
    return n
  }
  hasNext() {
    return this.nodeStack.length > 0
  }
  peek() {
    if (this.nodeStack.length === 0) return null
    const t = this.nodeStack[this.nodeStack.length - 1]
    return { key: t.key, value: t.value }
  }
}
class bn {
  constructor(t, n, i, r, s) {
    ;(this.key = t),
      (this.value = n),
      (this.color = i ?? bn.RED),
      (this.left = r ?? bn.EMPTY),
      (this.right = s ?? bn.EMPTY),
      (this.size = this.left.size + 1 + this.right.size)
  }
  copy(t, n, i, r, s) {
    return new bn(t ?? this.key, n ?? this.value, i ?? this.color, r ?? this.left, s ?? this.right)
  }
  isEmpty() {
    return !1
  }
  inorderTraversal(t) {
    return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t)
  }
  reverseTraversal(t) {
    return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t)
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min()
  }
  minKey() {
    return this.min().key
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey()
  }
  insert(t, n, i) {
    let r = this
    const s = i(t, r.key)
    return (
      (r =
        s < 0
          ? r.copy(null, null, null, r.left.insert(t, n, i), null)
          : s === 0
          ? r.copy(null, n, null, null, null)
          : r.copy(null, null, null, null, r.right.insert(t, n, i))),
      r.fixUp()
    )
  }
  removeMin() {
    if (this.left.isEmpty()) return bn.EMPTY
    let t = this
    return (
      t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()),
      (t = t.copy(null, null, null, t.left.removeMin(), null)),
      t.fixUp()
    )
  }
  remove(t, n) {
    let i,
      r = this
    if (n(t, r.key) < 0)
      r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()),
        (r = r.copy(null, null, null, r.left.remove(t, n), null))
    else {
      if (
        (r.left.isRed() && (r = r.rotateRight()),
        r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()),
        n(t, r.key) === 0)
      ) {
        if (r.right.isEmpty()) return bn.EMPTY
        ;(i = r.right.min()), (r = r.copy(i.key, i.value, null, null, r.right.removeMin()))
      }
      r = r.copy(null, null, null, null, r.right.remove(t, n))
    }
    return r.fixUp()
  }
  isRed() {
    return this.color
  }
  fixUp() {
    let t = this
    return (
      t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()),
      t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()),
      t.left.isRed() && t.right.isRed() && (t = t.colorFlip()),
      t
    )
  }
  moveRedLeft() {
    let t = this.colorFlip()
    return (
      t.right.left.isRed() &&
        ((t = t.copy(null, null, null, null, t.right.rotateRight())), (t = t.rotateLeft()), (t = t.colorFlip())),
      t
    )
  }
  moveRedRight() {
    let t = this.colorFlip()
    return t.left.left.isRed() && ((t = t.rotateRight()), (t = t.colorFlip())), t
  }
  rotateLeft() {
    const t = this.copy(null, null, bn.RED, null, this.right.left)
    return this.right.copy(null, null, this.color, t, null)
  }
  rotateRight() {
    const t = this.copy(null, null, bn.RED, this.left.right, null)
    return this.left.copy(null, null, this.color, null, t)
  }
  colorFlip() {
    const t = this.left.copy(null, null, !this.left.color, null, null),
      n = this.right.copy(null, null, !this.right.color, null, null)
    return this.copy(null, null, !this.color, t, n)
  }
  checkMaxDepth() {
    const t = this.check()
    return Math.pow(2, t) <= this.size + 1
  }
  check() {
    if ((this.isRed() && this.left.isRed()) || this.right.isRed()) throw Oe()
    const t = this.left.check()
    if (t !== this.right.check()) throw Oe()
    return t + (this.isRed() ? 0 : 1)
  }
}
;(bn.EMPTY = null), (bn.RED = !0), (bn.BLACK = !1)
bn.EMPTY = new (class {
  constructor() {
    this.size = 0
  }
  get key() {
    throw Oe()
  }
  get value() {
    throw Oe()
  }
  get color() {
    throw Oe()
  }
  get left() {
    throw Oe()
  }
  get right() {
    throw Oe()
  }
  copy(t, n, i, r, s) {
    return this
  }
  insert(t, n, i) {
    return new bn(t, n)
  }
  remove(t, n) {
    return this
  }
  isEmpty() {
    return !0
  }
  inorderTraversal(t) {
    return !1
  }
  reverseTraversal(t) {
    return !1
  }
  minKey() {
    return null
  }
  maxKey() {
    return null
  }
  isRed() {
    return !1
  }
  checkMaxDepth() {
    return !0
  }
  check() {
    return 0
  }
})()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class bt {
  constructor(t) {
    ;(this.comparator = t), (this.data = new Nt(this.comparator))
  }
  has(t) {
    return this.data.get(t) !== null
  }
  first() {
    return this.data.minKey()
  }
  last() {
    return this.data.maxKey()
  }
  get size() {
    return this.data.size
  }
  indexOf(t) {
    return this.data.indexOf(t)
  }
  forEach(t) {
    this.data.inorderTraversal((n, i) => (t(n), !1))
  }
  forEachInRange(t, n) {
    const i = this.data.getIteratorFrom(t[0])
    for (; i.hasNext(); ) {
      const r = i.getNext()
      if (this.comparator(r.key, t[1]) >= 0) return
      n(r.key)
    }
  }
  forEachWhile(t, n) {
    let i
    for (i = n !== void 0 ? this.data.getIteratorFrom(n) : this.data.getIterator(); i.hasNext(); )
      if (!t(i.getNext().key)) return
  }
  firstAfterOrEqual(t) {
    const n = this.data.getIteratorFrom(t)
    return n.hasNext() ? n.getNext().key : null
  }
  getIterator() {
    return new RE(this.data.getIterator())
  }
  getIteratorFrom(t) {
    return new RE(this.data.getIteratorFrom(t))
  }
  add(t) {
    return this.copy(this.data.remove(t).insert(t, !0))
  }
  delete(t) {
    return this.has(t) ? this.copy(this.data.remove(t)) : this
  }
  isEmpty() {
    return this.data.isEmpty()
  }
  unionWith(t) {
    let n = this
    return (
      n.size < t.size && ((n = t), (t = this)),
      t.forEach((i) => {
        n = n.add(i)
      }),
      n
    )
  }
  isEqual(t) {
    if (!(t instanceof bt) || this.size !== t.size) return !1
    const n = this.data.getIterator(),
      i = t.data.getIterator()
    for (; n.hasNext(); ) {
      const r = n.getNext().key,
        s = i.getNext().key
      if (this.comparator(r, s) !== 0) return !1
    }
    return !0
  }
  toArray() {
    const t = []
    return (
      this.forEach((n) => {
        t.push(n)
      }),
      t
    )
  }
  toString() {
    const t = []
    return this.forEach((n) => t.push(n)), 'SortedSet(' + t.toString() + ')'
  }
  copy(t) {
    const n = new bt(this.comparator)
    return (n.data = t), n
  }
}
class RE {
  constructor(t) {
    this.iter = t
  }
  getNext() {
    return this.iter.getNext().key
  }
  hasNext() {
    return this.iter.hasNext()
  }
}
function ka(e) {
  return e.hasNext() ? e.getNext() : void 0
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ti {
  constructor(t) {
    ;(this.fields = t), t.sort(Ft.comparator)
  }
  static empty() {
    return new ti([])
  }
  unionWith(t) {
    let n = new bt(Ft.comparator)
    for (const i of this.fields) n = n.add(i)
    for (const i of t) n = n.add(i)
    return new ti(n.toArray())
  }
  covers(t) {
    for (const n of this.fields) if (n.isPrefixOf(t)) return !0
    return !1
  }
  isEqual(t) {
    return pl(this.fields, t.fields, (n, i) => n.isEqual(i))
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class OR extends Error {
  constructor() {
    super(...arguments), (this.name = 'Base64DecodeError')
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class En {
  constructor(t) {
    this.binaryString = t
  }
  static fromBase64String(t) {
    const n = (function (r) {
      try {
        return atob(r)
      } catch (s) {
        throw typeof DOMException < 'u' && s instanceof DOMException ? new OR('Invalid base64 string: ' + s) : s
      }
    })(t)
    return new En(n)
  }
  static fromUint8Array(t) {
    const n = (function (r) {
      let s = ''
      for (let o = 0; o < r.length; ++o) s += String.fromCharCode(r[o])
      return s
    })(t)
    return new En(n)
  }
  [Symbol.iterator]() {
    let t = 0
    return {
      next: () =>
        t < this.binaryString.length
          ? { value: this.binaryString.charCodeAt(t++), done: !1 }
          : { value: void 0, done: !0 },
    }
  }
  toBase64() {
    return (function (n) {
      return btoa(n)
    })(this.binaryString)
  }
  toUint8Array() {
    return (function (n) {
      const i = new Uint8Array(n.length)
      for (let r = 0; r < n.length; r++) i[r] = n.charCodeAt(r)
      return i
    })(this.binaryString)
  }
  approximateByteSize() {
    return 2 * this.binaryString.length
  }
  compareTo(t) {
    return Ye(this.binaryString, t.binaryString)
  }
  isEqual(t) {
    return this.binaryString === t.binaryString
  }
}
En.EMPTY_BYTE_STRING = new En('')
const e6 = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/)
function Lr(e) {
  if ((Fe(!!e), typeof e == 'string')) {
    let t = 0
    const n = e6.exec(e)
    if ((Fe(!!n), n[1])) {
      let r = n[1]
      ;(r = (r + '000000000').substr(0, 9)), (t = Number(r))
    }
    const i = new Date(e)
    return { seconds: Math.floor(i.getTime() / 1e3), nanos: t }
  }
  return { seconds: Ht(e.seconds), nanos: Ht(e.nanos) }
}
function Ht(e) {
  return typeof e == 'number' ? e : typeof e == 'string' ? Number(e) : 0
}
function Ns(e) {
  return typeof e == 'string' ? En.fromBase64String(e) : En.fromUint8Array(e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function V_(e) {
  var t, n
  return (
    ((n = (((t = e == null ? void 0 : e.mapValue) === null || t === void 0 ? void 0 : t.fields) || {}).__type__) ===
      null || n === void 0
      ? void 0
      : n.stringValue) === 'server_timestamp'
  )
}
function D_(e) {
  const t = e.mapValue.fields.__previous_value__
  return V_(t) ? D_(t) : t
}
function yc(e) {
  const t = Lr(e.mapValue.fields.__local_write_time__.timestampValue)
  return new Dt(t.seconds, t.nanos)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class t6 {
  constructor(t, n, i, r, s, o, a, l, u) {
    ;(this.databaseId = t),
      (this.appId = n),
      (this.persistenceKey = i),
      (this.host = r),
      (this.ssl = s),
      (this.forceLongPolling = o),
      (this.autoDetectLongPolling = a),
      (this.longPollingOptions = l),
      (this.useFetchStreams = u)
  }
}
class Fo {
  constructor(t, n) {
    ;(this.projectId = t), (this.database = n || '(default)')
  }
  static empty() {
    return new Fo('', '')
  }
  get isDefaultDatabase() {
    return this.database === '(default)'
  }
  isEqual(t) {
    return t instanceof Fo && t.projectId === this.projectId && t.database === this.database
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Is = { mapValue: { fields: { __type__: { stringValue: '__max__' } } } },
  Eh = { nullValue: 'NULL_VALUE' }
function Bo(e) {
  return 'nullValue' in e
    ? 0
    : 'booleanValue' in e
    ? 1
    : 'integerValue' in e || 'doubleValue' in e
    ? 2
    : 'timestampValue' in e
    ? 3
    : 'stringValue' in e
    ? 5
    : 'bytesValue' in e
    ? 6
    : 'referenceValue' in e
    ? 7
    : 'geoPointValue' in e
    ? 8
    : 'arrayValue' in e
    ? 9
    : 'mapValue' in e
    ? V_(e)
      ? 4
      : MR(e)
      ? 9007199254740991
      : 10
    : Oe()
}
function hr(e, t) {
  if (e === t) return !0
  const n = Bo(e)
  if (n !== Bo(t)) return !1
  switch (n) {
    case 0:
    case 9007199254740991:
      return !0
    case 1:
      return e.booleanValue === t.booleanValue
    case 4:
      return yc(e).isEqual(yc(t))
    case 3:
      return (function (r, s) {
        if (
          typeof r.timestampValue == 'string' &&
          typeof s.timestampValue == 'string' &&
          r.timestampValue.length === s.timestampValue.length
        )
          return r.timestampValue === s.timestampValue
        const o = Lr(r.timestampValue),
          a = Lr(s.timestampValue)
        return o.seconds === a.seconds && o.nanos === a.nanos
      })(e, t)
    case 5:
      return e.stringValue === t.stringValue
    case 6:
      return (function (r, s) {
        return Ns(r.bytesValue).isEqual(Ns(s.bytesValue))
      })(e, t)
    case 7:
      return e.referenceValue === t.referenceValue
    case 8:
      return (function (r, s) {
        return (
          Ht(r.geoPointValue.latitude) === Ht(s.geoPointValue.latitude) &&
          Ht(r.geoPointValue.longitude) === Ht(s.geoPointValue.longitude)
        )
      })(e, t)
    case 2:
      return (function (r, s) {
        if ('integerValue' in r && 'integerValue' in s) return Ht(r.integerValue) === Ht(s.integerValue)
        if ('doubleValue' in r && 'doubleValue' in s) {
          const o = Ht(r.doubleValue),
            a = Ht(s.doubleValue)
          return o === a ? pc(o) === pc(a) : isNaN(o) && isNaN(a)
        }
        return !1
      })(e, t)
    case 9:
      return pl(e.arrayValue.values || [], t.arrayValue.values || [], hr)
    case 10:
      return (function (r, s) {
        const o = r.mapValue.fields || {},
          a = s.mapValue.fields || {}
        if (PE(o) !== PE(a)) return !1
        for (const l in o) if (o.hasOwnProperty(l) && (a[l] === void 0 || !hr(o[l], a[l]))) return !1
        return !0
      })(e, t)
    default:
      return Oe()
  }
}
function _c(e, t) {
  return (e.values || []).find((n) => hr(n, t)) !== void 0
}
function Os(e, t) {
  if (e === t) return 0
  const n = Bo(e),
    i = Bo(t)
  if (n !== i) return Ye(n, i)
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0
    case 1:
      return Ye(e.booleanValue, t.booleanValue)
    case 2:
      return (function (s, o) {
        const a = Ht(s.integerValue || s.doubleValue),
          l = Ht(o.integerValue || o.doubleValue)
        return a < l ? -1 : a > l ? 1 : a === l ? 0 : isNaN(a) ? (isNaN(l) ? 0 : -1) : 1
      })(e, t)
    case 3:
      return xE(e.timestampValue, t.timestampValue)
    case 4:
      return xE(yc(e), yc(t))
    case 5:
      return Ye(e.stringValue, t.stringValue)
    case 6:
      return (function (s, o) {
        const a = Ns(s),
          l = Ns(o)
        return a.compareTo(l)
      })(e.bytesValue, t.bytesValue)
    case 7:
      return (function (s, o) {
        const a = s.split('/'),
          l = o.split('/')
        for (let u = 0; u < a.length && u < l.length; u++) {
          const c = Ye(a[u], l[u])
          if (c !== 0) return c
        }
        return Ye(a.length, l.length)
      })(e.referenceValue, t.referenceValue)
    case 8:
      return (function (s, o) {
        const a = Ye(Ht(s.latitude), Ht(o.latitude))
        return a !== 0 ? a : Ye(Ht(s.longitude), Ht(o.longitude))
      })(e.geoPointValue, t.geoPointValue)
    case 9:
      return (function (s, o) {
        const a = s.values || [],
          l = o.values || []
        for (let u = 0; u < a.length && u < l.length; ++u) {
          const c = Os(a[u], l[u])
          if (c) return c
        }
        return Ye(a.length, l.length)
      })(e.arrayValue, t.arrayValue)
    case 10:
      return (function (s, o) {
        if (s === Is.mapValue && o === Is.mapValue) return 0
        if (s === Is.mapValue) return 1
        if (o === Is.mapValue) return -1
        const a = s.fields || {},
          l = Object.keys(a),
          u = o.fields || {},
          c = Object.keys(u)
        l.sort(), c.sort()
        for (let d = 0; d < l.length && d < c.length; ++d) {
          const f = Ye(l[d], c[d])
          if (f !== 0) return f
          const m = Os(a[l[d]], u[c[d]])
          if (m !== 0) return m
        }
        return Ye(l.length, c.length)
      })(e.mapValue, t.mapValue)
    default:
      throw Oe()
  }
}
function xE(e, t) {
  if (typeof e == 'string' && typeof t == 'string' && e.length === t.length) return Ye(e, t)
  const n = Lr(e),
    i = Lr(t),
    r = Ye(n.seconds, i.seconds)
  return r !== 0 ? r : Ye(n.nanos, i.nanos)
}
function yl(e) {
  return up(e)
}
function up(e) {
  return 'nullValue' in e
    ? 'null'
    : 'booleanValue' in e
    ? '' + e.booleanValue
    : 'integerValue' in e
    ? '' + e.integerValue
    : 'doubleValue' in e
    ? '' + e.doubleValue
    : 'timestampValue' in e
    ? (function (n) {
        const i = Lr(n)
        return `time(${i.seconds},${i.nanos})`
      })(e.timestampValue)
    : 'stringValue' in e
    ? e.stringValue
    : 'bytesValue' in e
    ? (function (n) {
        return Ns(n).toBase64()
      })(e.bytesValue)
    : 'referenceValue' in e
    ? (function (n) {
        return Re.fromName(n).toString()
      })(e.referenceValue)
    : 'geoPointValue' in e
    ? (function (n) {
        return `geo(${n.latitude},${n.longitude})`
      })(e.geoPointValue)
    : 'arrayValue' in e
    ? (function (n) {
        let i = '[',
          r = !0
        for (const s of n.values || []) r ? (r = !1) : (i += ','), (i += up(s))
        return i + ']'
      })(e.arrayValue)
    : 'mapValue' in e
    ? (function (n) {
        const i = Object.keys(n.fields || {}).sort()
        let r = '{',
          s = !0
        for (const o of i) s ? (s = !1) : (r += ','), (r += `${o}:${up(n.fields[o])}`)
        return r + '}'
      })(e.mapValue)
    : Oe()
}
function N_(e, t) {
  return { referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}` }
}
function cp(e) {
  return !!e && 'integerValue' in e
}
function bc(e) {
  return !!e && 'arrayValue' in e
}
function VE(e) {
  return !!e && 'nullValue' in e
}
function DE(e) {
  return !!e && 'doubleValue' in e && isNaN(Number(e.doubleValue))
}
function Th(e) {
  return !!e && 'mapValue' in e
}
function Ku(e) {
  if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) }
  if (e.timestampValue && typeof e.timestampValue == 'object')
    return { timestampValue: Object.assign({}, e.timestampValue) }
  if (e.mapValue) {
    const t = { mapValue: { fields: {} } }
    return la(e.mapValue.fields, (n, i) => (t.mapValue.fields[n] = Ku(i))), t
  }
  if (e.arrayValue) {
    const t = { arrayValue: { values: [] } }
    for (let n = 0; n < (e.arrayValue.values || []).length; ++n) t.arrayValue.values[n] = Ku(e.arrayValue.values[n])
    return t
  }
  return Object.assign({}, e)
}
function MR(e) {
  return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === '__max__'
}
function n6(e) {
  return 'nullValue' in e
    ? Eh
    : 'booleanValue' in e
    ? { booleanValue: !1 }
    : 'integerValue' in e || 'doubleValue' in e
    ? { doubleValue: NaN }
    : 'timestampValue' in e
    ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
    : 'stringValue' in e
    ? { stringValue: '' }
    : 'bytesValue' in e
    ? { bytesValue: '' }
    : 'referenceValue' in e
    ? N_(Fo.empty(), Re.empty())
    : 'geoPointValue' in e
    ? { geoPointValue: { latitude: -90, longitude: -180 } }
    : 'arrayValue' in e
    ? { arrayValue: {} }
    : 'mapValue' in e
    ? { mapValue: {} }
    : Oe()
}
function i6(e) {
  return 'nullValue' in e
    ? { booleanValue: !1 }
    : 'booleanValue' in e
    ? { doubleValue: NaN }
    : 'integerValue' in e || 'doubleValue' in e
    ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
    : 'timestampValue' in e
    ? { stringValue: '' }
    : 'stringValue' in e
    ? { bytesValue: '' }
    : 'bytesValue' in e
    ? N_(Fo.empty(), Re.empty())
    : 'referenceValue' in e
    ? { geoPointValue: { latitude: -90, longitude: -180 } }
    : 'geoPointValue' in e
    ? { arrayValue: {} }
    : 'arrayValue' in e
    ? { mapValue: {} }
    : 'mapValue' in e
    ? Is
    : Oe()
}
function NE(e, t) {
  const n = Os(e.value, t.value)
  return n !== 0 ? n : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0
}
function OE(e, t) {
  const n = Os(e.value, t.value)
  return n !== 0 ? n : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Mn {
  constructor(t) {
    this.value = t
  }
  static empty() {
    return new Mn({ mapValue: {} })
  }
  field(t) {
    if (t.isEmpty()) return this.value
    {
      let n = this.value
      for (let i = 0; i < t.length - 1; ++i) if (((n = (n.mapValue.fields || {})[t.get(i)]), !Th(n))) return null
      return (n = (n.mapValue.fields || {})[t.lastSegment()]), n || null
    }
  }
  set(t, n) {
    this.getFieldsMap(t.popLast())[t.lastSegment()] = Ku(n)
  }
  setAll(t) {
    let n = Ft.emptyPath(),
      i = {},
      r = []
    t.forEach((o, a) => {
      if (!n.isImmediateParentOf(a)) {
        const l = this.getFieldsMap(n)
        this.applyChanges(l, i, r), (i = {}), (r = []), (n = a.popLast())
      }
      o ? (i[a.lastSegment()] = Ku(o)) : r.push(a.lastSegment())
    })
    const s = this.getFieldsMap(n)
    this.applyChanges(s, i, r)
  }
  delete(t) {
    const n = this.field(t.popLast())
    Th(n) && n.mapValue.fields && delete n.mapValue.fields[t.lastSegment()]
  }
  isEqual(t) {
    return hr(this.value, t.value)
  }
  getFieldsMap(t) {
    let n = this.value
    n.mapValue.fields || (n.mapValue = { fields: {} })
    for (let i = 0; i < t.length; ++i) {
      let r = n.mapValue.fields[t.get(i)]
      ;(Th(r) && r.mapValue.fields) || ((r = { mapValue: { fields: {} } }), (n.mapValue.fields[t.get(i)] = r)), (n = r)
    }
    return n.mapValue.fields
  }
  applyChanges(t, n, i) {
    la(n, (r, s) => (t[r] = s))
    for (const r of i) delete t[r]
  }
  clone() {
    return new Mn(Ku(this.value))
  }
}
function LR(e) {
  const t = []
  return (
    la(e.fields, (n, i) => {
      const r = new Ft([n])
      if (Th(i)) {
        const s = LR(i.mapValue).fields
        if (s.length === 0) t.push(r)
        else for (const o of s) t.push(r.child(o))
      } else t.push(r)
    }),
    new ti(t)
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Wt {
  constructor(t, n, i, r, s, o, a) {
    ;(this.key = t),
      (this.documentType = n),
      (this.version = i),
      (this.readTime = r),
      (this.createTime = s),
      (this.data = o),
      (this.documentState = a)
  }
  static newInvalidDocument(t) {
    return new Wt(t, 0, $e.min(), $e.min(), $e.min(), Mn.empty(), 0)
  }
  static newFoundDocument(t, n, i, r) {
    return new Wt(t, 1, n, $e.min(), i, r, 0)
  }
  static newNoDocument(t, n) {
    return new Wt(t, 2, n, $e.min(), $e.min(), Mn.empty(), 0)
  }
  static newUnknownDocument(t, n) {
    return new Wt(t, 3, n, $e.min(), $e.min(), Mn.empty(), 2)
  }
  convertToFoundDocument(t, n) {
    return (
      !this.createTime.isEqual($e.min()) ||
        (this.documentType !== 2 && this.documentType !== 0) ||
        (this.createTime = t),
      (this.version = t),
      (this.documentType = 1),
      (this.data = n),
      (this.documentState = 0),
      this
    )
  }
  convertToNoDocument(t) {
    return (this.version = t), (this.documentType = 2), (this.data = Mn.empty()), (this.documentState = 0), this
  }
  convertToUnknownDocument(t) {
    return (this.version = t), (this.documentType = 3), (this.data = Mn.empty()), (this.documentState = 2), this
  }
  setHasCommittedMutations() {
    return (this.documentState = 2), this
  }
  setHasLocalMutations() {
    return (this.documentState = 1), (this.version = $e.min()), this
  }
  setReadTime(t) {
    return (this.readTime = t), this
  }
  get hasLocalMutations() {
    return this.documentState === 1
  }
  get hasCommittedMutations() {
    return this.documentState === 2
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations
  }
  isValidDocument() {
    return this.documentType !== 0
  }
  isFoundDocument() {
    return this.documentType === 1
  }
  isNoDocument() {
    return this.documentType === 2
  }
  isUnknownDocument() {
    return this.documentType === 3
  }
  isEqual(t) {
    return (
      t instanceof Wt &&
      this.key.isEqual(t.key) &&
      this.version.isEqual(t.version) &&
      this.documentType === t.documentType &&
      this.documentState === t.documentState &&
      this.data.isEqual(t.data)
    )
  }
  mutableCopy() {
    return new Wt(
      this.key,
      this.documentType,
      this.version,
      this.readTime,
      this.createTime,
      this.data.clone(),
      this.documentState
    )
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${
      this.createTime
    }}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _l {
  constructor(t, n) {
    ;(this.position = t), (this.inclusive = n)
  }
}
function ME(e, t, n) {
  let i = 0
  for (let r = 0; r < e.position.length; r++) {
    const s = t[r],
      o = e.position[r]
    if (
      (s.field.isKeyField()
        ? (i = Re.comparator(Re.fromName(o.referenceValue), n.key))
        : (i = Os(o, n.data.field(s.field))),
      s.dir === 'desc' && (i *= -1),
      i !== 0)
    )
      break
  }
  return i
}
function LE(e, t) {
  if (e === null) return t === null
  if (t === null || e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1
  for (let n = 0; n < e.position.length; n++) if (!hr(e.position[n], t.position[n])) return !1
  return !0
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class sf {
  constructor(t, n = 'asc') {
    ;(this.field = t), (this.dir = n)
  }
}
function r6(e, t) {
  return e.dir === t.dir && e.field.isEqual(t.field)
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class FR {}
class tt extends FR {
  constructor(t, n, i) {
    super(), (this.field = t), (this.op = n), (this.value = i)
  }
  static create(t, n, i) {
    return t.isKeyField()
      ? n === 'in' || n === 'not-in'
        ? this.createKeyFieldInFilter(t, n, i)
        : new s6(t, n, i)
      : n === 'array-contains'
      ? new l6(t, i)
      : n === 'in'
      ? new HR(t, i)
      : n === 'not-in'
      ? new u6(t, i)
      : n === 'array-contains-any'
      ? new c6(t, i)
      : new tt(t, n, i)
  }
  static createKeyFieldInFilter(t, n, i) {
    return n === 'in' ? new o6(t, i) : new a6(t, i)
  }
  matches(t) {
    const n = t.data.field(this.field)
    return this.op === '!='
      ? n !== null && this.matchesComparison(Os(n, this.value))
      : n !== null && Bo(this.value) === Bo(n) && this.matchesComparison(Os(n, this.value))
  }
  matchesComparison(t) {
    switch (this.op) {
      case '<':
        return t < 0
      case '<=':
        return t <= 0
      case '==':
        return t === 0
      case '!=':
        return t !== 0
      case '>':
        return t > 0
      case '>=':
        return t >= 0
      default:
        return Oe()
    }
  }
  isInequality() {
    return ['<', '<=', '>', '>=', '!=', 'not-in'].indexOf(this.op) >= 0
  }
  getFlattenedFilters() {
    return [this]
  }
  getFilters() {
    return [this]
  }
}
class _t extends FR {
  constructor(t, n) {
    super(), (this.filters = t), (this.op = n), (this.ae = null)
  }
  static create(t, n) {
    return new _t(t, n)
  }
  matches(t) {
    return bl(this)
      ? this.filters.find((n) => !n.matches(t)) === void 0
      : this.filters.find((n) => n.matches(t)) !== void 0
  }
  getFlattenedFilters() {
    return this.ae !== null || (this.ae = this.filters.reduce((t, n) => t.concat(n.getFlattenedFilters()), [])), this.ae
  }
  getFilters() {
    return Object.assign([], this.filters)
  }
}
function bl(e) {
  return e.op === 'and'
}
function dp(e) {
  return e.op === 'or'
}
function O_(e) {
  return BR(e) && bl(e)
}
function BR(e) {
  for (const t of e.filters) if (t instanceof _t) return !1
  return !0
}
function hp(e) {
  if (e instanceof tt) return e.field.canonicalString() + e.op.toString() + yl(e.value)
  if (O_(e)) return e.filters.map((t) => hp(t)).join(',')
  {
    const t = e.filters.map((n) => hp(n)).join(',')
    return `${e.op}(${t})`
  }
}
function $R(e, t) {
  return e instanceof tt
    ? (function (i, r) {
        return r instanceof tt && i.op === r.op && i.field.isEqual(r.field) && hr(i.value, r.value)
      })(e, t)
    : e instanceof _t
    ? (function (i, r) {
        return r instanceof _t && i.op === r.op && i.filters.length === r.filters.length
          ? i.filters.reduce((s, o, a) => s && $R(o, r.filters[a]), !0)
          : !1
      })(e, t)
    : void Oe()
}
function UR(e, t) {
  const n = e.filters.concat(t)
  return _t.create(n, e.op)
}
function jR(e) {
  return e instanceof tt
    ? (function (n) {
        return `${n.field.canonicalString()} ${n.op} ${yl(n.value)}`
      })(e)
    : e instanceof _t
    ? (function (n) {
        return n.op.toString() + ' {' + n.getFilters().map(jR).join(' ,') + '}'
      })(e)
    : 'Filter'
}
class s6 extends tt {
  constructor(t, n, i) {
    super(t, n, i), (this.key = Re.fromName(i.referenceValue))
  }
  matches(t) {
    const n = Re.comparator(t.key, this.key)
    return this.matchesComparison(n)
  }
}
class o6 extends tt {
  constructor(t, n) {
    super(t, 'in', n), (this.keys = zR('in', n))
  }
  matches(t) {
    return this.keys.some((n) => n.isEqual(t.key))
  }
}
class a6 extends tt {
  constructor(t, n) {
    super(t, 'not-in', n), (this.keys = zR('not-in', n))
  }
  matches(t) {
    return !this.keys.some((n) => n.isEqual(t.key))
  }
}
function zR(e, t) {
  var n
  return (((n = t.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((i) =>
    Re.fromName(i.referenceValue)
  )
}
class l6 extends tt {
  constructor(t, n) {
    super(t, 'array-contains', n)
  }
  matches(t) {
    const n = t.data.field(this.field)
    return bc(n) && _c(n.arrayValue, this.value)
  }
}
class HR extends tt {
  constructor(t, n) {
    super(t, 'in', n)
  }
  matches(t) {
    const n = t.data.field(this.field)
    return n !== null && _c(this.value.arrayValue, n)
  }
}
class u6 extends tt {
  constructor(t, n) {
    super(t, 'not-in', n)
  }
  matches(t) {
    if (_c(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) return !1
    const n = t.data.field(this.field)
    return n !== null && !_c(this.value.arrayValue, n)
  }
}
class c6 extends tt {
  constructor(t, n) {
    super(t, 'array-contains-any', n)
  }
  matches(t) {
    const n = t.data.field(this.field)
    return !(!bc(n) || !n.arrayValue.values) && n.arrayValue.values.some((i) => _c(this.value.arrayValue, i))
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class d6 {
  constructor(t, n = null, i = [], r = [], s = null, o = null, a = null) {
    ;(this.path = t),
      (this.collectionGroup = n),
      (this.orderBy = i),
      (this.filters = r),
      (this.limit = s),
      (this.startAt = o),
      (this.endAt = a),
      (this.ue = null)
  }
}
function fp(e, t = null, n = [], i = [], r = null, s = null, o = null) {
  return new d6(e, t, n, i, r, s, o)
}
function $o(e) {
  const t = Ke(e)
  if (t.ue === null) {
    let n = t.path.canonicalString()
    t.collectionGroup !== null && (n += '|cg:' + t.collectionGroup),
      (n += '|f:'),
      (n += t.filters.map((i) => hp(i)).join(',')),
      (n += '|ob:'),
      (n += t.orderBy
        .map((i) =>
          (function (s) {
            return s.field.canonicalString() + s.dir
          })(i)
        )
        .join(',')),
      im(t.limit) || ((n += '|l:'), (n += t.limit)),
      t.startAt &&
        ((n += '|lb:'),
        (n += t.startAt.inclusive ? 'b:' : 'a:'),
        (n += t.startAt.position.map((i) => yl(i)).join(','))),
      t.endAt &&
        ((n += '|ub:'), (n += t.endAt.inclusive ? 'a:' : 'b:'), (n += t.endAt.position.map((i) => yl(i)).join(','))),
      (t.ue = n)
  }
  return t.ue
}
function Jc(e, t) {
  if (e.limit !== t.limit || e.orderBy.length !== t.orderBy.length) return !1
  for (let n = 0; n < e.orderBy.length; n++) if (!r6(e.orderBy[n], t.orderBy[n])) return !1
  if (e.filters.length !== t.filters.length) return !1
  for (let n = 0; n < e.filters.length; n++) if (!$R(e.filters[n], t.filters[n])) return !1
  return (
    e.collectionGroup === t.collectionGroup &&
    !!e.path.isEqual(t.path) &&
    !!LE(e.startAt, t.startAt) &&
    LE(e.endAt, t.endAt)
  )
}
function of(e) {
  return Re.isDocumentKey(e.path) && e.collectionGroup === null && e.filters.length === 0
}
function af(e, t) {
  return e.filters.filter((n) => n instanceof tt && n.field.isEqual(t))
}
function FE(e, t, n) {
  let i = Eh,
    r = !0
  for (const s of af(e, t)) {
    let o = Eh,
      a = !0
    switch (s.op) {
      case '<':
      case '<=':
        o = n6(s.value)
        break
      case '==':
      case 'in':
      case '>=':
        o = s.value
        break
      case '>':
        ;(o = s.value), (a = !1)
        break
      case '!=':
      case 'not-in':
        o = Eh
    }
    NE({ value: i, inclusive: r }, { value: o, inclusive: a }) < 0 && ((i = o), (r = a))
  }
  if (n !== null) {
    for (let s = 0; s < e.orderBy.length; ++s)
      if (e.orderBy[s].field.isEqual(t)) {
        const o = n.position[s]
        NE({ value: i, inclusive: r }, { value: o, inclusive: n.inclusive }) < 0 && ((i = o), (r = n.inclusive))
        break
      }
  }
  return { value: i, inclusive: r }
}
function BE(e, t, n) {
  let i = Is,
    r = !0
  for (const s of af(e, t)) {
    let o = Is,
      a = !0
    switch (s.op) {
      case '>=':
      case '>':
        ;(o = i6(s.value)), (a = !1)
        break
      case '==':
      case 'in':
      case '<=':
        o = s.value
        break
      case '<':
        ;(o = s.value), (a = !1)
        break
      case '!=':
      case 'not-in':
        o = Is
    }
    OE({ value: i, inclusive: r }, { value: o, inclusive: a }) > 0 && ((i = o), (r = a))
  }
  if (n !== null) {
    for (let s = 0; s < e.orderBy.length; ++s)
      if (e.orderBy[s].field.isEqual(t)) {
        const o = n.position[s]
        OE({ value: i, inclusive: r }, { value: o, inclusive: n.inclusive }) > 0 && ((i = o), (r = n.inclusive))
        break
      }
  }
  return { value: i, inclusive: r }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class rm {
  constructor(t, n = null, i = [], r = [], s = null, o = 'F', a = null, l = null) {
    ;(this.path = t),
      (this.collectionGroup = n),
      (this.explicitOrderBy = i),
      (this.filters = r),
      (this.limit = s),
      (this.limitType = o),
      (this.startAt = a),
      (this.endAt = l),
      (this.ce = null),
      (this.le = null),
      (this.he = null),
      this.startAt,
      this.endAt
  }
}
function h6(e, t, n, i, r, s, o, a) {
  return new rm(e, t, n, i, r, s, o, a)
}
function Zc(e) {
  return new rm(e)
}
function $E(e) {
  return (
    e.filters.length === 0 &&
    e.limit === null &&
    e.startAt == null &&
    e.endAt == null &&
    (e.explicitOrderBy.length === 0 || (e.explicitOrderBy.length === 1 && e.explicitOrderBy[0].field.isKeyField()))
  )
}
function f6(e) {
  return e.collectionGroup !== null
}
function Yu(e) {
  const t = Ke(e)
  if (t.ce === null) {
    t.ce = []
    const n = new Set()
    for (const s of t.explicitOrderBy) t.ce.push(s), n.add(s.field.canonicalString())
    const i = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : 'asc'
    ;(function (o) {
      let a = new bt(Ft.comparator)
      return (
        o.filters.forEach((l) => {
          l.getFlattenedFilters().forEach((u) => {
            u.isInequality() && (a = a.add(u.field))
          })
        }),
        a
      )
    })(t).forEach((s) => {
      n.has(s.canonicalString()) || s.isKeyField() || t.ce.push(new sf(s, i))
    }),
      n.has(Ft.keyField().canonicalString()) || t.ce.push(new sf(Ft.keyField(), i))
  }
  return t.ce
}
function Pi(e) {
  const t = Ke(e)
  return t.le || (t.le = m6(t, Yu(e))), t.le
}
function m6(e, t) {
  if (e.limitType === 'F') return fp(e.path, e.collectionGroup, t, e.filters, e.limit, e.startAt, e.endAt)
  {
    t = t.map((r) => {
      const s = r.dir === 'desc' ? 'asc' : 'desc'
      return new sf(r.field, s)
    })
    const n = e.endAt ? new _l(e.endAt.position, e.endAt.inclusive) : null,
      i = e.startAt ? new _l(e.startAt.position, e.startAt.inclusive) : null
    return fp(e.path, e.collectionGroup, t, e.filters, e.limit, n, i)
  }
}
function mp(e, t, n) {
  return new rm(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt)
}
function sm(e, t) {
  return Jc(Pi(e), Pi(t)) && e.limitType === t.limitType
}
function WR(e) {
  return `${$o(Pi(e))}|lt:${e.limitType}`
}
function Ba(e) {
  return `Query(target=${(function (n) {
    let i = n.path.canonicalString()
    return (
      n.collectionGroup !== null && (i += ' collectionGroup=' + n.collectionGroup),
      n.filters.length > 0 && (i += `, filters: [${n.filters.map((r) => jR(r)).join(', ')}]`),
      im(n.limit) || (i += ', limit: ' + n.limit),
      n.orderBy.length > 0 &&
        (i += `, orderBy: [${n.orderBy
          .map((r) =>
            (function (o) {
              return `${o.field.canonicalString()} (${o.dir})`
            })(r)
          )
          .join(', ')}]`),
      n.startAt &&
        ((i += ', startAt: '),
        (i += n.startAt.inclusive ? 'b:' : 'a:'),
        (i += n.startAt.position.map((r) => yl(r)).join(','))),
      n.endAt &&
        ((i += ', endAt: '),
        (i += n.endAt.inclusive ? 'a:' : 'b:'),
        (i += n.endAt.position.map((r) => yl(r)).join(','))),
      `Target(${i})`
    )
  })(Pi(e))}; limitType=${e.limitType})`
}
function ed(e, t) {
  return (
    t.isFoundDocument() &&
    (function (i, r) {
      const s = r.key.path
      return i.collectionGroup !== null
        ? r.key.hasCollectionId(i.collectionGroup) && i.path.isPrefixOf(s)
        : Re.isDocumentKey(i.path)
        ? i.path.isEqual(s)
        : i.path.isImmediateParentOf(s)
    })(e, t) &&
    (function (i, r) {
      for (const s of Yu(i)) if (!s.field.isKeyField() && r.data.field(s.field) === null) return !1
      return !0
    })(e, t) &&
    (function (i, r) {
      for (const s of i.filters) if (!s.matches(r)) return !1
      return !0
    })(e, t) &&
    (function (i, r) {
      return !(
        (i.startAt &&
          !(function (o, a, l) {
            const u = ME(o, a, l)
            return o.inclusive ? u <= 0 : u < 0
          })(i.startAt, Yu(i), r)) ||
        (i.endAt &&
          !(function (o, a, l) {
            const u = ME(o, a, l)
            return o.inclusive ? u >= 0 : u > 0
          })(i.endAt, Yu(i), r))
      )
    })(e, t)
  )
}
function g6(e) {
  return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2))
}
function qR(e) {
  return (t, n) => {
    let i = !1
    for (const r of Yu(e)) {
      const s = v6(r, t, n)
      if (s !== 0) return s
      i = i || r.field.isKeyField()
    }
    return 0
  }
}
function v6(e, t, n) {
  const i = e.field.isKeyField()
    ? Re.comparator(t.key, n.key)
    : (function (s, o, a) {
        const l = o.data.field(s),
          u = a.data.field(s)
        return l !== null && u !== null ? Os(l, u) : Oe()
      })(e.field, t, n)
  switch (e.dir) {
    case 'asc':
      return i
    case 'desc':
      return -1 * i
    default:
      return Oe()
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class qs {
  constructor(t, n) {
    ;(this.mapKeyFn = t), (this.equalsFn = n), (this.inner = {}), (this.innerSize = 0)
  }
  get(t) {
    const n = this.mapKeyFn(t),
      i = this.inner[n]
    if (i !== void 0) {
      for (const [r, s] of i) if (this.equalsFn(r, t)) return s
    }
  }
  has(t) {
    return this.get(t) !== void 0
  }
  set(t, n) {
    const i = this.mapKeyFn(t),
      r = this.inner[i]
    if (r === void 0) return (this.inner[i] = [[t, n]]), void this.innerSize++
    for (let s = 0; s < r.length; s++) if (this.equalsFn(r[s][0], t)) return void (r[s] = [t, n])
    r.push([t, n]), this.innerSize++
  }
  delete(t) {
    const n = this.mapKeyFn(t),
      i = this.inner[n]
    if (i === void 0) return !1
    for (let r = 0; r < i.length; r++)
      if (this.equalsFn(i[r][0], t)) return i.length === 1 ? delete this.inner[n] : i.splice(r, 1), this.innerSize--, !0
    return !1
  }
  forEach(t) {
    la(this.inner, (n, i) => {
      for (const [r, s] of i) t(r, s)
    })
  }
  isEmpty() {
    return NR(this.inner)
  }
  size() {
    return this.innerSize
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const p6 = new Nt(Re.comparator)
function ci() {
  return p6
}
const GR = new Nt(Re.comparator)
function xu(...e) {
  let t = GR
  for (const n of e) t = t.insert(n.key, n)
  return t
}
function KR(e) {
  let t = GR
  return e.forEach((n, i) => (t = t.insert(n, i.overlayedDocument))), t
}
function sr() {
  return Qu()
}
function YR() {
  return Qu()
}
function Qu() {
  return new qs(
    (e) => e.toString(),
    (e, t) => e.isEqual(t)
  )
}
const y6 = new Nt(Re.comparator),
  _6 = new bt(Re.comparator)
function Qe(...e) {
  let t = _6
  for (const n of e) t = t.add(n)
  return t
}
const b6 = new bt(Ye)
function w6() {
  return b6
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function QR(e, t) {
  if (e.useProto3Json) {
    if (isNaN(t)) return { doubleValue: 'NaN' }
    if (t === 1 / 0) return { doubleValue: 'Infinity' }
    if (t === -1 / 0) return { doubleValue: '-Infinity' }
  }
  return { doubleValue: pc(t) ? '-0' : t }
}
function XR(e) {
  return { integerValue: '' + e }
}
function I6(e, t) {
  return OH(t) ? XR(t) : QR(e, t)
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class om {
  constructor() {
    this._ = void 0
  }
}
function S6(e, t, n) {
  return e instanceof wc
    ? (function (r, s) {
        const o = {
          fields: {
            __type__: { stringValue: 'server_timestamp' },
            __local_write_time__: { timestampValue: { seconds: r.seconds, nanos: r.nanoseconds } },
          },
        }
        return s && V_(s) && (s = D_(s)), s && (o.fields.__previous_value__ = s), { mapValue: o }
      })(n, t)
    : e instanceof wl
    ? ZR(e, t)
    : e instanceof Il
    ? ex(e, t)
    : (function (r, s) {
        const o = JR(r, s),
          a = UE(o) + UE(r.Pe)
        return cp(o) && cp(r.Pe) ? XR(a) : QR(r.serializer, a)
      })(e, t)
}
function E6(e, t, n) {
  return e instanceof wl ? ZR(e, t) : e instanceof Il ? ex(e, t) : n
}
function JR(e, t) {
  return e instanceof Ic
    ? (function (i) {
        return (
          cp(i) ||
          (function (s) {
            return !!s && 'doubleValue' in s
          })(i)
        )
      })(t)
      ? t
      : { integerValue: 0 }
    : null
}
class wc extends om {}
class wl extends om {
  constructor(t) {
    super(), (this.elements = t)
  }
}
function ZR(e, t) {
  const n = tx(t)
  for (const i of e.elements) n.some((r) => hr(r, i)) || n.push(i)
  return { arrayValue: { values: n } }
}
class Il extends om {
  constructor(t) {
    super(), (this.elements = t)
  }
}
function ex(e, t) {
  let n = tx(t)
  for (const i of e.elements) n = n.filter((r) => !hr(r, i))
  return { arrayValue: { values: n } }
}
class Ic extends om {
  constructor(t, n) {
    super(), (this.serializer = t), (this.Pe = n)
  }
}
function UE(e) {
  return Ht(e.integerValue || e.doubleValue)
}
function tx(e) {
  return bc(e) && e.arrayValue.values ? e.arrayValue.values.slice() : []
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class T6 {
  constructor(t, n) {
    ;(this.field = t), (this.transform = n)
  }
}
function C6(e, t) {
  return (
    e.field.isEqual(t.field) &&
    (function (i, r) {
      return (i instanceof wl && r instanceof wl) || (i instanceof Il && r instanceof Il)
        ? pl(i.elements, r.elements, hr)
        : i instanceof Ic && r instanceof Ic
        ? hr(i.Pe, r.Pe)
        : i instanceof wc && r instanceof wc
    })(e.transform, t.transform)
  )
}
class A6 {
  constructor(t, n) {
    ;(this.version = t), (this.transformResults = n)
  }
}
class Kn {
  constructor(t, n) {
    ;(this.updateTime = t), (this.exists = n)
  }
  static none() {
    return new Kn()
  }
  static exists(t) {
    return new Kn(void 0, t)
  }
  static updateTime(t) {
    return new Kn(t)
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0
  }
  isEqual(t) {
    return (
      this.exists === t.exists &&
      (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime)
    )
  }
}
function Ch(e, t) {
  return e.updateTime !== void 0
    ? t.isFoundDocument() && t.version.isEqual(e.updateTime)
    : e.exists === void 0 || e.exists === t.isFoundDocument()
}
class am {}
function nx(e, t) {
  if (!e.hasLocalMutations || (t && t.fields.length === 0)) return null
  if (t === null) return e.isNoDocument() ? new lm(e.key, Kn.none()) : new zl(e.key, e.data, Kn.none())
  {
    const n = e.data,
      i = Mn.empty()
    let r = new bt(Ft.comparator)
    for (let s of t.fields)
      if (!r.has(s)) {
        let o = n.field(s)
        o === null && s.length > 1 && ((s = s.popLast()), (o = n.field(s))),
          o === null ? i.delete(s) : i.set(s, o),
          (r = r.add(s))
      }
    return new Gr(e.key, i, new ti(r.toArray()), Kn.none())
  }
}
function k6(e, t, n) {
  e instanceof zl
    ? (function (r, s, o) {
        const a = r.value.clone(),
          l = zE(r.fieldTransforms, s, o.transformResults)
        a.setAll(l), s.convertToFoundDocument(o.version, a).setHasCommittedMutations()
      })(e, t, n)
    : e instanceof Gr
    ? (function (r, s, o) {
        if (!Ch(r.precondition, s)) return void s.convertToUnknownDocument(o.version)
        const a = zE(r.fieldTransforms, s, o.transformResults),
          l = s.data
        l.setAll(ix(r)), l.setAll(a), s.convertToFoundDocument(o.version, l).setHasCommittedMutations()
      })(e, t, n)
    : (function (r, s, o) {
        s.convertToNoDocument(o.version).setHasCommittedMutations()
      })(0, t, n)
}
function Xu(e, t, n, i) {
  return e instanceof zl
    ? (function (s, o, a, l) {
        if (!Ch(s.precondition, o)) return a
        const u = s.value.clone(),
          c = HE(s.fieldTransforms, l, o)
        return u.setAll(c), o.convertToFoundDocument(o.version, u).setHasLocalMutations(), null
      })(e, t, n, i)
    : e instanceof Gr
    ? (function (s, o, a, l) {
        if (!Ch(s.precondition, o)) return a
        const u = HE(s.fieldTransforms, l, o),
          c = o.data
        return (
          c.setAll(ix(s)),
          c.setAll(u),
          o.convertToFoundDocument(o.version, c).setHasLocalMutations(),
          a === null ? null : a.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map((d) => d.field))
        )
      })(e, t, n, i)
    : (function (s, o, a) {
        return Ch(s.precondition, o) ? (o.convertToNoDocument(o.version).setHasLocalMutations(), null) : a
      })(e, t, n)
}
function P6(e, t) {
  let n = null
  for (const i of e.fieldTransforms) {
    const r = t.data.field(i.field),
      s = JR(i.transform, r || null)
    s != null && (n === null && (n = Mn.empty()), n.set(i.field, s))
  }
  return n || null
}
function jE(e, t) {
  return (
    e.type === t.type &&
    !!e.key.isEqual(t.key) &&
    !!e.precondition.isEqual(t.precondition) &&
    !!(function (i, r) {
      return (i === void 0 && r === void 0) || (!(!i || !r) && pl(i, r, (s, o) => C6(s, o)))
    })(e.fieldTransforms, t.fieldTransforms) &&
    (e.type === 0
      ? e.value.isEqual(t.value)
      : e.type !== 1 || (e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)))
  )
}
class zl extends am {
  constructor(t, n, i, r = []) {
    super(), (this.key = t), (this.value = n), (this.precondition = i), (this.fieldTransforms = r), (this.type = 0)
  }
  getFieldMask() {
    return null
  }
}
class Gr extends am {
  constructor(t, n, i, r, s = []) {
    super(),
      (this.key = t),
      (this.data = n),
      (this.fieldMask = i),
      (this.precondition = r),
      (this.fieldTransforms = s),
      (this.type = 1)
  }
  getFieldMask() {
    return this.fieldMask
  }
}
function ix(e) {
  const t = new Map()
  return (
    e.fieldMask.fields.forEach((n) => {
      if (!n.isEmpty()) {
        const i = e.data.field(n)
        t.set(n, i)
      }
    }),
    t
  )
}
function zE(e, t, n) {
  const i = new Map()
  Fe(e.length === n.length)
  for (let r = 0; r < n.length; r++) {
    const s = e[r],
      o = s.transform,
      a = t.data.field(s.field)
    i.set(s.field, E6(o, a, n[r]))
  }
  return i
}
function HE(e, t, n) {
  const i = new Map()
  for (const r of e) {
    const s = r.transform,
      o = n.data.field(r.field)
    i.set(r.field, S6(s, o, t))
  }
  return i
}
class lm extends am {
  constructor(t, n) {
    super(), (this.key = t), (this.precondition = n), (this.type = 2), (this.fieldTransforms = [])
  }
  getFieldMask() {
    return null
  }
}
class rx extends am {
  constructor(t, n) {
    super(), (this.key = t), (this.precondition = n), (this.type = 3), (this.fieldTransforms = [])
  }
  getFieldMask() {
    return null
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class M_ {
  constructor(t, n, i, r) {
    ;(this.batchId = t), (this.localWriteTime = n), (this.baseMutations = i), (this.mutations = r)
  }
  applyToRemoteDocument(t, n) {
    const i = n.mutationResults
    for (let r = 0; r < this.mutations.length; r++) {
      const s = this.mutations[r]
      s.key.isEqual(t.key) && k6(s, t, i[r])
    }
  }
  applyToLocalView(t, n) {
    for (const i of this.baseMutations) i.key.isEqual(t.key) && (n = Xu(i, t, n, this.localWriteTime))
    for (const i of this.mutations) i.key.isEqual(t.key) && (n = Xu(i, t, n, this.localWriteTime))
    return n
  }
  applyToLocalDocumentSet(t, n) {
    const i = YR()
    return (
      this.mutations.forEach((r) => {
        const s = t.get(r.key),
          o = s.overlayedDocument
        let a = this.applyToLocalView(o, s.mutatedFields)
        a = n.has(r.key) ? null : a
        const l = nx(o, a)
        l !== null && i.set(r.key, l), o.isValidDocument() || o.convertToNoDocument($e.min())
      }),
      i
    )
  }
  keys() {
    return this.mutations.reduce((t, n) => t.add(n.key), Qe())
  }
  isEqual(t) {
    return (
      this.batchId === t.batchId &&
      pl(this.mutations, t.mutations, (n, i) => jE(n, i)) &&
      pl(this.baseMutations, t.baseMutations, (n, i) => jE(n, i))
    )
  }
}
class L_ {
  constructor(t, n, i, r) {
    ;(this.batch = t), (this.commitVersion = n), (this.mutationResults = i), (this.docVersions = r)
  }
  static from(t, n, i) {
    Fe(t.mutations.length === i.length)
    let r = (function () {
      return y6
    })()
    const s = t.mutations
    for (let o = 0; o < s.length; o++) r = r.insert(s[o].key, i[o].version)
    return new L_(t, n, i, r)
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class F_ {
  constructor(t, n) {
    ;(this.largestBatchId = t), (this.mutation = n)
  }
  getKey() {
    return this.mutation.key
  }
  isEqual(t) {
    return t !== null && this.mutation === t.mutation
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class R6 {
  constructor(t, n) {
    ;(this.count = t), (this.unchangedNames = n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Xt, nt
function x6(e) {
  switch (e) {
    default:
      return Oe()
    case fe.CANCELLED:
    case fe.UNKNOWN:
    case fe.DEADLINE_EXCEEDED:
    case fe.RESOURCE_EXHAUSTED:
    case fe.INTERNAL:
    case fe.UNAVAILABLE:
    case fe.UNAUTHENTICATED:
      return !1
    case fe.INVALID_ARGUMENT:
    case fe.NOT_FOUND:
    case fe.ALREADY_EXISTS:
    case fe.PERMISSION_DENIED:
    case fe.FAILED_PRECONDITION:
    case fe.ABORTED:
    case fe.OUT_OF_RANGE:
    case fe.UNIMPLEMENTED:
    case fe.DATA_LOSS:
      return !0
  }
}
function sx(e) {
  if (e === void 0) return Gn('GRPC error has no .code'), fe.UNKNOWN
  switch (e) {
    case Xt.OK:
      return fe.OK
    case Xt.CANCELLED:
      return fe.CANCELLED
    case Xt.UNKNOWN:
      return fe.UNKNOWN
    case Xt.DEADLINE_EXCEEDED:
      return fe.DEADLINE_EXCEEDED
    case Xt.RESOURCE_EXHAUSTED:
      return fe.RESOURCE_EXHAUSTED
    case Xt.INTERNAL:
      return fe.INTERNAL
    case Xt.UNAVAILABLE:
      return fe.UNAVAILABLE
    case Xt.UNAUTHENTICATED:
      return fe.UNAUTHENTICATED
    case Xt.INVALID_ARGUMENT:
      return fe.INVALID_ARGUMENT
    case Xt.NOT_FOUND:
      return fe.NOT_FOUND
    case Xt.ALREADY_EXISTS:
      return fe.ALREADY_EXISTS
    case Xt.PERMISSION_DENIED:
      return fe.PERMISSION_DENIED
    case Xt.FAILED_PRECONDITION:
      return fe.FAILED_PRECONDITION
    case Xt.ABORTED:
      return fe.ABORTED
    case Xt.OUT_OF_RANGE:
      return fe.OUT_OF_RANGE
    case Xt.UNIMPLEMENTED:
      return fe.UNIMPLEMENTED
    case Xt.DATA_LOSS:
      return fe.DATA_LOSS
    default:
      return Oe()
  }
}
;((nt = Xt || (Xt = {}))[(nt.OK = 0)] = 'OK'),
  (nt[(nt.CANCELLED = 1)] = 'CANCELLED'),
  (nt[(nt.UNKNOWN = 2)] = 'UNKNOWN'),
  (nt[(nt.INVALID_ARGUMENT = 3)] = 'INVALID_ARGUMENT'),
  (nt[(nt.DEADLINE_EXCEEDED = 4)] = 'DEADLINE_EXCEEDED'),
  (nt[(nt.NOT_FOUND = 5)] = 'NOT_FOUND'),
  (nt[(nt.ALREADY_EXISTS = 6)] = 'ALREADY_EXISTS'),
  (nt[(nt.PERMISSION_DENIED = 7)] = 'PERMISSION_DENIED'),
  (nt[(nt.UNAUTHENTICATED = 16)] = 'UNAUTHENTICATED'),
  (nt[(nt.RESOURCE_EXHAUSTED = 8)] = 'RESOURCE_EXHAUSTED'),
  (nt[(nt.FAILED_PRECONDITION = 9)] = 'FAILED_PRECONDITION'),
  (nt[(nt.ABORTED = 10)] = 'ABORTED'),
  (nt[(nt.OUT_OF_RANGE = 11)] = 'OUT_OF_RANGE'),
  (nt[(nt.UNIMPLEMENTED = 12)] = 'UNIMPLEMENTED'),
  (nt[(nt.INTERNAL = 13)] = 'INTERNAL'),
  (nt[(nt.UNAVAILABLE = 14)] = 'UNAVAILABLE'),
  (nt[(nt.DATA_LOSS = 15)] = 'DATA_LOSS')
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function V6() {
  return new TextEncoder()
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const D6 = new So([4294967295, 4294967295], 0)
function WE(e) {
  const t = V6().encode(e),
    n = new vR()
  return n.update(t), new Uint8Array(n.digest())
}
function qE(e) {
  const t = new DataView(e.buffer),
    n = t.getUint32(0, !0),
    i = t.getUint32(4, !0),
    r = t.getUint32(8, !0),
    s = t.getUint32(12, !0)
  return [new So([n, i], 0), new So([r, s], 0)]
}
class B_ {
  constructor(t, n, i) {
    if (((this.bitmap = t), (this.padding = n), (this.hashCount = i), n < 0 || n >= 8))
      throw new Vu(`Invalid padding: ${n}`)
    if (i < 0) throw new Vu(`Invalid hash count: ${i}`)
    if (t.length > 0 && this.hashCount === 0) throw new Vu(`Invalid hash count: ${i}`)
    if (t.length === 0 && n !== 0) throw new Vu(`Invalid padding when bitmap length is 0: ${n}`)
    ;(this.Ie = 8 * t.length - n), (this.Te = So.fromNumber(this.Ie))
  }
  Ee(t, n, i) {
    let r = t.add(n.multiply(So.fromNumber(i)))
    return r.compare(D6) === 1 && (r = new So([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.Te).toNumber()
  }
  de(t) {
    return (this.bitmap[Math.floor(t / 8)] & (1 << t % 8)) != 0
  }
  mightContain(t) {
    if (this.Ie === 0) return !1
    const n = WE(t),
      [i, r] = qE(n)
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.Ee(i, r, s)
      if (!this.de(o)) return !1
    }
    return !0
  }
  static create(t, n, i) {
    const r = t % 8 == 0 ? 0 : 8 - (t % 8),
      s = new Uint8Array(Math.ceil(t / 8)),
      o = new B_(s, r, n)
    return i.forEach((a) => o.insert(a)), o
  }
  insert(t) {
    if (this.Ie === 0) return
    const n = WE(t),
      [i, r] = qE(n)
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.Ee(i, r, s)
      this.Ae(o)
    }
  }
  Ae(t) {
    const n = Math.floor(t / 8),
      i = t % 8
    this.bitmap[n] |= 1 << i
  }
}
class Vu extends Error {
  constructor() {
    super(...arguments), (this.name = 'BloomFilterError')
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class um {
  constructor(t, n, i, r, s) {
    ;(this.snapshotVersion = t),
      (this.targetChanges = n),
      (this.targetMismatches = i),
      (this.documentUpdates = r),
      (this.resolvedLimboDocuments = s)
  }
  static createSynthesizedRemoteEventForCurrentChange(t, n, i) {
    const r = new Map()
    return (
      r.set(t, td.createSynthesizedTargetChangeForCurrentChange(t, n, i)), new um($e.min(), r, new Nt(Ye), ci(), Qe())
    )
  }
}
class td {
  constructor(t, n, i, r, s) {
    ;(this.resumeToken = t),
      (this.current = n),
      (this.addedDocuments = i),
      (this.modifiedDocuments = r),
      (this.removedDocuments = s)
  }
  static createSynthesizedTargetChangeForCurrentChange(t, n, i) {
    return new td(i, n, Qe(), Qe(), Qe())
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ah {
  constructor(t, n, i, r) {
    ;(this.Re = t), (this.removedTargetIds = n), (this.key = i), (this.Ve = r)
  }
}
class ox {
  constructor(t, n) {
    ;(this.targetId = t), (this.me = n)
  }
}
class ax {
  constructor(t, n, i = En.EMPTY_BYTE_STRING, r = null) {
    ;(this.state = t), (this.targetIds = n), (this.resumeToken = i), (this.cause = r)
  }
}
class GE {
  constructor() {
    ;(this.fe = 0), (this.ge = YE()), (this.pe = En.EMPTY_BYTE_STRING), (this.ye = !1), (this.we = !0)
  }
  get current() {
    return this.ye
  }
  get resumeToken() {
    return this.pe
  }
  get Se() {
    return this.fe !== 0
  }
  get be() {
    return this.we
  }
  De(t) {
    t.approximateByteSize() > 0 && ((this.we = !0), (this.pe = t))
  }
  Ce() {
    let t = Qe(),
      n = Qe(),
      i = Qe()
    return (
      this.ge.forEach((r, s) => {
        switch (s) {
          case 0:
            t = t.add(r)
            break
          case 2:
            n = n.add(r)
            break
          case 1:
            i = i.add(r)
            break
          default:
            Oe()
        }
      }),
      new td(this.pe, this.ye, t, n, i)
    )
  }
  ve() {
    ;(this.we = !1), (this.ge = YE())
  }
  Fe(t, n) {
    ;(this.we = !0), (this.ge = this.ge.insert(t, n))
  }
  Me(t) {
    ;(this.we = !0), (this.ge = this.ge.remove(t))
  }
  xe() {
    this.fe += 1
  }
  Oe() {
    ;(this.fe -= 1), Fe(this.fe >= 0)
  }
  Ne() {
    ;(this.we = !0), (this.ye = !0)
  }
}
class N6 {
  constructor(t) {
    ;(this.Le = t), (this.Be = new Map()), (this.ke = ci()), (this.qe = KE()), (this.Qe = new Nt(Ye))
  }
  Ke(t) {
    for (const n of t.Re) t.Ve && t.Ve.isFoundDocument() ? this.$e(n, t.Ve) : this.Ue(n, t.key, t.Ve)
    for (const n of t.removedTargetIds) this.Ue(n, t.key, t.Ve)
  }
  We(t) {
    this.forEachTarget(t, (n) => {
      const i = this.Ge(n)
      switch (t.state) {
        case 0:
          this.ze(n) && i.De(t.resumeToken)
          break
        case 1:
          i.Oe(), i.Se || i.ve(), i.De(t.resumeToken)
          break
        case 2:
          i.Oe(), i.Se || this.removeTarget(n)
          break
        case 3:
          this.ze(n) && (i.Ne(), i.De(t.resumeToken))
          break
        case 4:
          this.ze(n) && (this.je(n), i.De(t.resumeToken))
          break
        default:
          Oe()
      }
    })
  }
  forEachTarget(t, n) {
    t.targetIds.length > 0
      ? t.targetIds.forEach(n)
      : this.Be.forEach((i, r) => {
          this.ze(r) && n(r)
        })
  }
  He(t) {
    const n = t.targetId,
      i = t.me.count,
      r = this.Je(n)
    if (r) {
      const s = r.target
      if (of(s))
        if (i === 0) {
          const o = new Re(s.path)
          this.Ue(n, o, Wt.newNoDocument(o, $e.min()))
        } else Fe(i === 1)
      else {
        const o = this.Ye(n)
        if (o !== i) {
          const a = this.Ze(t),
            l = a ? this.Xe(a, t, o) : 1
          if (l !== 0) {
            this.je(n)
            const u = l === 2 ? 'TargetPurposeExistenceFilterMismatchBloom' : 'TargetPurposeExistenceFilterMismatch'
            this.Qe = this.Qe.insert(n, u)
          }
        }
      }
    }
  }
  Ze(t) {
    const n = t.me.unchangedNames
    if (!n || !n.bits) return null
    const {
      bits: { bitmap: i = '', padding: r = 0 },
      hashCount: s = 0,
    } = n
    let o, a
    try {
      o = Ns(i).toUint8Array()
    } catch (l) {
      if (l instanceof OR)
        return (
          mc(
            'Decoding the base64 bloom filter in existence filter failed (' +
              l.message +
              '); ignoring the bloom filter and falling back to full re-query.'
          ),
          null
        )
      throw l
    }
    try {
      a = new B_(o, r, s)
    } catch (l) {
      return mc(l instanceof Vu ? 'BloomFilter error: ' : 'Applying bloom filter failed: ', l), null
    }
    return a.Ie === 0 ? null : a
  }
  Xe(t, n, i) {
    return n.me.count === i - this.nt(t, n.targetId) ? 0 : 2
  }
  nt(t, n) {
    const i = this.Le.getRemoteKeysForTarget(n)
    let r = 0
    return (
      i.forEach((s) => {
        const o = this.Le.tt(),
          a = `projects/${o.projectId}/databases/${o.database}/documents/${s.path.canonicalString()}`
        t.mightContain(a) || (this.Ue(n, s, null), r++)
      }),
      r
    )
  }
  rt(t) {
    const n = new Map()
    this.Be.forEach((s, o) => {
      const a = this.Je(o)
      if (a) {
        if (s.current && of(a.target)) {
          const l = new Re(a.target.path)
          this.ke.get(l) !== null || this.it(o, l) || this.Ue(o, l, Wt.newNoDocument(l, t))
        }
        s.be && (n.set(o, s.Ce()), s.ve())
      }
    })
    let i = Qe()
    this.qe.forEach((s, o) => {
      let a = !0
      o.forEachWhile((l) => {
        const u = this.Je(l)
        return !u || u.purpose === 'TargetPurposeLimboResolution' || ((a = !1), !1)
      }),
        a && (i = i.add(s))
    }),
      this.ke.forEach((s, o) => o.setReadTime(t))
    const r = new um(t, n, this.Qe, this.ke, i)
    return (this.ke = ci()), (this.qe = KE()), (this.Qe = new Nt(Ye)), r
  }
  $e(t, n) {
    if (!this.ze(t)) return
    const i = this.it(t, n.key) ? 2 : 0
    this.Ge(t).Fe(n.key, i),
      (this.ke = this.ke.insert(n.key, n)),
      (this.qe = this.qe.insert(n.key, this.st(n.key).add(t)))
  }
  Ue(t, n, i) {
    if (!this.ze(t)) return
    const r = this.Ge(t)
    this.it(t, n) ? r.Fe(n, 1) : r.Me(n),
      (this.qe = this.qe.insert(n, this.st(n).delete(t))),
      i && (this.ke = this.ke.insert(n, i))
  }
  removeTarget(t) {
    this.Be.delete(t)
  }
  Ye(t) {
    const n = this.Ge(t).Ce()
    return this.Le.getRemoteKeysForTarget(t).size + n.addedDocuments.size - n.removedDocuments.size
  }
  xe(t) {
    this.Ge(t).xe()
  }
  Ge(t) {
    let n = this.Be.get(t)
    return n || ((n = new GE()), this.Be.set(t, n)), n
  }
  st(t) {
    let n = this.qe.get(t)
    return n || ((n = new bt(Ye)), (this.qe = this.qe.insert(t, n))), n
  }
  ze(t) {
    const n = this.Je(t) !== null
    return n || we('WatchChangeAggregator', 'Detected inactive target', t), n
  }
  Je(t) {
    const n = this.Be.get(t)
    return n && n.Se ? null : this.Le.ot(t)
  }
  je(t) {
    this.Be.set(t, new GE()),
      this.Le.getRemoteKeysForTarget(t).forEach((n) => {
        this.Ue(t, n, null)
      })
  }
  it(t, n) {
    return this.Le.getRemoteKeysForTarget(t).has(n)
  }
}
function KE() {
  return new Nt(Re.comparator)
}
function YE() {
  return new Nt(Re.comparator)
}
const O6 = { asc: 'ASCENDING', desc: 'DESCENDING' },
  M6 = {
    '<': 'LESS_THAN',
    '<=': 'LESS_THAN_OR_EQUAL',
    '>': 'GREATER_THAN',
    '>=': 'GREATER_THAN_OR_EQUAL',
    '==': 'EQUAL',
    '!=': 'NOT_EQUAL',
    'array-contains': 'ARRAY_CONTAINS',
    in: 'IN',
    'not-in': 'NOT_IN',
    'array-contains-any': 'ARRAY_CONTAINS_ANY',
  },
  L6 = { and: 'AND', or: 'OR' }
class F6 {
  constructor(t, n) {
    ;(this.databaseId = t), (this.useProto3Json = n)
  }
}
function gp(e, t) {
  return e.useProto3Json || im(t) ? t : { value: t }
}
function Sl(e, t) {
  return e.useProto3Json
    ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, '').replace('Z', '')}.${(
        '000000000' + t.nanoseconds
      ).slice(-9)}Z`
    : { seconds: '' + t.seconds, nanos: t.nanoseconds }
}
function lx(e, t) {
  return e.useProto3Json ? t.toBase64() : t.toUint8Array()
}
function B6(e, t) {
  return Sl(e, t.toTimestamp())
}
function Qn(e) {
  return (
    Fe(!!e),
    $e.fromTimestamp(
      (function (n) {
        const i = Lr(n)
        return new Dt(i.seconds, i.nanos)
      })(e)
    )
  )
}
function $_(e, t) {
  return vp(e, t).canonicalString()
}
function vp(e, t) {
  const n = (function (r) {
    return new pt(['projects', r.projectId, 'databases', r.database])
  })(e).child('documents')
  return t === void 0 ? n : n.child(t)
}
function ux(e) {
  const t = pt.fromString(e)
  return Fe(yx(t)), t
}
function lf(e, t) {
  return $_(e.databaseId, t.path)
}
function Eo(e, t) {
  const n = ux(t)
  if (n.get(1) !== e.databaseId.projectId)
    throw new Ve(
      fe.INVALID_ARGUMENT,
      'Tried to deserialize key from different project: ' + n.get(1) + ' vs ' + e.databaseId.projectId
    )
  if (n.get(3) !== e.databaseId.database)
    throw new Ve(
      fe.INVALID_ARGUMENT,
      'Tried to deserialize key from different database: ' + n.get(3) + ' vs ' + e.databaseId.database
    )
  return new Re(hx(n))
}
function cx(e, t) {
  return $_(e.databaseId, t)
}
function dx(e) {
  const t = ux(e)
  return t.length === 4 ? pt.emptyPath() : hx(t)
}
function pp(e) {
  return new pt(['projects', e.databaseId.projectId, 'databases', e.databaseId.database]).canonicalString()
}
function hx(e) {
  return Fe(e.length > 4 && e.get(4) === 'documents'), e.popFirst(5)
}
function QE(e, t, n) {
  return { name: lf(e, t), fields: n.value.mapValue.fields }
}
function $6(e, t, n) {
  const i = Eo(e, t.name),
    r = Qn(t.updateTime),
    s = t.createTime ? Qn(t.createTime) : $e.min(),
    o = new Mn({ mapValue: { fields: t.fields } }),
    a = Wt.newFoundDocument(i, r, s, o)
  return n && a.setHasCommittedMutations(), n ? a.setHasCommittedMutations() : a
}
function U6(e, t) {
  let n
  if ('targetChange' in t) {
    t.targetChange
    const i = (function (u) {
        return u === 'NO_CHANGE'
          ? 0
          : u === 'ADD'
          ? 1
          : u === 'REMOVE'
          ? 2
          : u === 'CURRENT'
          ? 3
          : u === 'RESET'
          ? 4
          : Oe()
      })(t.targetChange.targetChangeType || 'NO_CHANGE'),
      r = t.targetChange.targetIds || [],
      s = (function (u, c) {
        return u.useProto3Json
          ? (Fe(c === void 0 || typeof c == 'string'), En.fromBase64String(c || ''))
          : (Fe(c === void 0 || c instanceof Buffer || c instanceof Uint8Array),
            En.fromUint8Array(c || new Uint8Array()))
      })(e, t.targetChange.resumeToken),
      o = t.targetChange.cause,
      a =
        o &&
        (function (u) {
          const c = u.code === void 0 ? fe.UNKNOWN : sx(u.code)
          return new Ve(c, u.message || '')
        })(o)
    n = new ax(i, r, s, a || null)
  } else if ('documentChange' in t) {
    t.documentChange
    const i = t.documentChange
    i.document, i.document.name, i.document.updateTime
    const r = Eo(e, i.document.name),
      s = Qn(i.document.updateTime),
      o = i.document.createTime ? Qn(i.document.createTime) : $e.min(),
      a = new Mn({ mapValue: { fields: i.document.fields } }),
      l = Wt.newFoundDocument(r, s, o, a),
      u = i.targetIds || [],
      c = i.removedTargetIds || []
    n = new Ah(u, c, l.key, l)
  } else if ('documentDelete' in t) {
    t.documentDelete
    const i = t.documentDelete
    i.document
    const r = Eo(e, i.document),
      s = i.readTime ? Qn(i.readTime) : $e.min(),
      o = Wt.newNoDocument(r, s),
      a = i.removedTargetIds || []
    n = new Ah([], a, o.key, o)
  } else if ('documentRemove' in t) {
    t.documentRemove
    const i = t.documentRemove
    i.document
    const r = Eo(e, i.document),
      s = i.removedTargetIds || []
    n = new Ah([], s, r, null)
  } else {
    if (!('filter' in t)) return Oe()
    {
      t.filter
      const i = t.filter
      i.targetId
      const { count: r = 0, unchangedNames: s } = i,
        o = new R6(r, s),
        a = i.targetId
      n = new ox(a, o)
    }
  }
  return n
}
function uf(e, t) {
  let n
  if (t instanceof zl) n = { update: QE(e, t.key, t.value) }
  else if (t instanceof lm) n = { delete: lf(e, t.key) }
  else if (t instanceof Gr) n = { update: QE(e, t.key, t.data), updateMask: G6(t.fieldMask) }
  else {
    if (!(t instanceof rx)) return Oe()
    n = { verify: lf(e, t.key) }
  }
  return (
    t.fieldTransforms.length > 0 &&
      (n.updateTransforms = t.fieldTransforms.map((i) =>
        (function (s, o) {
          const a = o.transform
          if (a instanceof wc) return { fieldPath: o.field.canonicalString(), setToServerValue: 'REQUEST_TIME' }
          if (a instanceof wl)
            return { fieldPath: o.field.canonicalString(), appendMissingElements: { values: a.elements } }
          if (a instanceof Il)
            return { fieldPath: o.field.canonicalString(), removeAllFromArray: { values: a.elements } }
          if (a instanceof Ic) return { fieldPath: o.field.canonicalString(), increment: a.Pe }
          throw Oe()
        })(0, i)
      )),
    t.precondition.isNone ||
      (n.currentDocument = (function (r, s) {
        return s.updateTime !== void 0
          ? { updateTime: B6(r, s.updateTime) }
          : s.exists !== void 0
          ? { exists: s.exists }
          : Oe()
      })(e, t.precondition)),
    n
  )
}
function yp(e, t) {
  const n = t.currentDocument
      ? (function (s) {
          return s.updateTime !== void 0
            ? Kn.updateTime(Qn(s.updateTime))
            : s.exists !== void 0
            ? Kn.exists(s.exists)
            : Kn.none()
        })(t.currentDocument)
      : Kn.none(),
    i = t.updateTransforms
      ? t.updateTransforms.map((r) =>
          (function (o, a) {
            let l = null
            if ('setToServerValue' in a) Fe(a.setToServerValue === 'REQUEST_TIME'), (l = new wc())
            else if ('appendMissingElements' in a) {
              const c = a.appendMissingElements.values || []
              l = new wl(c)
            } else if ('removeAllFromArray' in a) {
              const c = a.removeAllFromArray.values || []
              l = new Il(c)
            } else 'increment' in a ? (l = new Ic(o, a.increment)) : Oe()
            const u = Ft.fromServerFormat(a.fieldPath)
            return new T6(u, l)
          })(e, r)
        )
      : []
  if (t.update) {
    t.update.name
    const r = Eo(e, t.update.name),
      s = new Mn({ mapValue: { fields: t.update.fields } })
    if (t.updateMask) {
      const o = (function (l) {
        const u = l.fieldPaths || []
        return new ti(u.map((c) => Ft.fromServerFormat(c)))
      })(t.updateMask)
      return new Gr(r, s, o, n, i)
    }
    return new zl(r, s, n, i)
  }
  if (t.delete) {
    const r = Eo(e, t.delete)
    return new lm(r, n)
  }
  if (t.verify) {
    const r = Eo(e, t.verify)
    return new rx(r, n)
  }
  return Oe()
}
function j6(e, t) {
  return e && e.length > 0
    ? (Fe(t !== void 0),
      e.map((n) =>
        (function (r, s) {
          let o = r.updateTime ? Qn(r.updateTime) : Qn(s)
          return o.isEqual($e.min()) && (o = Qn(s)), new A6(o, r.transformResults || [])
        })(n, t)
      ))
    : []
}
function fx(e, t) {
  return { documents: [cx(e, t.path)] }
}
function mx(e, t) {
  const n = { structuredQuery: {} },
    i = t.path
  let r
  t.collectionGroup !== null
    ? ((r = i), (n.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]))
    : ((r = i.popLast()), (n.structuredQuery.from = [{ collectionId: i.lastSegment() }])),
    (n.parent = cx(e, r))
  const s = (function (u) {
    if (u.length !== 0) return px(_t.create(u, 'and'))
  })(t.filters)
  s && (n.structuredQuery.where = s)
  const o = (function (u) {
    if (u.length !== 0)
      return u.map((c) =>
        (function (f) {
          return { field: $a(f.field), direction: H6(f.dir) }
        })(c)
      )
  })(t.orderBy)
  o && (n.structuredQuery.orderBy = o)
  const a = gp(e, t.limit)
  return (
    a !== null && (n.structuredQuery.limit = a),
    t.startAt &&
      (n.structuredQuery.startAt = (function (u) {
        return { before: u.inclusive, values: u.position }
      })(t.startAt)),
    t.endAt &&
      (n.structuredQuery.endAt = (function (u) {
        return { before: !u.inclusive, values: u.position }
      })(t.endAt)),
    { _t: n, parent: r }
  )
}
function gx(e) {
  let t = dx(e.parent)
  const n = e.structuredQuery,
    i = n.from ? n.from.length : 0
  let r = null
  if (i > 0) {
    Fe(i === 1)
    const c = n.from[0]
    c.allDescendants ? (r = c.collectionId) : (t = t.child(c.collectionId))
  }
  let s = []
  n.where &&
    (s = (function (d) {
      const f = vx(d)
      return f instanceof _t && O_(f) ? f.getFilters() : [f]
    })(n.where))
  let o = []
  n.orderBy &&
    (o = (function (d) {
      return d.map((f) =>
        (function (p) {
          return new sf(
            Ua(p.field),
            (function (y) {
              switch (y) {
                case 'ASCENDING':
                  return 'asc'
                case 'DESCENDING':
                  return 'desc'
                default:
                  return
              }
            })(p.direction)
          )
        })(f)
      )
    })(n.orderBy))
  let a = null
  n.limit &&
    (a = (function (d) {
      let f
      return (f = typeof d == 'object' ? d.value : d), im(f) ? null : f
    })(n.limit))
  let l = null
  n.startAt &&
    (l = (function (d) {
      const f = !!d.before,
        m = d.values || []
      return new _l(m, f)
    })(n.startAt))
  let u = null
  return (
    n.endAt &&
      (u = (function (d) {
        const f = !d.before,
          m = d.values || []
        return new _l(m, f)
      })(n.endAt)),
    h6(t, r, o, s, a, 'F', l, u)
  )
}
function z6(e, t) {
  const n = (function (r) {
    switch (r) {
      case 'TargetPurposeListen':
        return null
      case 'TargetPurposeExistenceFilterMismatch':
        return 'existence-filter-mismatch'
      case 'TargetPurposeExistenceFilterMismatchBloom':
        return 'existence-filter-mismatch-bloom'
      case 'TargetPurposeLimboResolution':
        return 'limbo-document'
      default:
        return Oe()
    }
  })(t.purpose)
  return n == null ? null : { 'goog-listen-tags': n }
}
function vx(e) {
  return e.unaryFilter !== void 0
    ? (function (n) {
        switch (n.unaryFilter.op) {
          case 'IS_NAN':
            const i = Ua(n.unaryFilter.field)
            return tt.create(i, '==', { doubleValue: NaN })
          case 'IS_NULL':
            const r = Ua(n.unaryFilter.field)
            return tt.create(r, '==', { nullValue: 'NULL_VALUE' })
          case 'IS_NOT_NAN':
            const s = Ua(n.unaryFilter.field)
            return tt.create(s, '!=', { doubleValue: NaN })
          case 'IS_NOT_NULL':
            const o = Ua(n.unaryFilter.field)
            return tt.create(o, '!=', { nullValue: 'NULL_VALUE' })
          default:
            return Oe()
        }
      })(e)
    : e.fieldFilter !== void 0
    ? (function (n) {
        return tt.create(
          Ua(n.fieldFilter.field),
          (function (r) {
            switch (r) {
              case 'EQUAL':
                return '=='
              case 'NOT_EQUAL':
                return '!='
              case 'GREATER_THAN':
                return '>'
              case 'GREATER_THAN_OR_EQUAL':
                return '>='
              case 'LESS_THAN':
                return '<'
              case 'LESS_THAN_OR_EQUAL':
                return '<='
              case 'ARRAY_CONTAINS':
                return 'array-contains'
              case 'IN':
                return 'in'
              case 'NOT_IN':
                return 'not-in'
              case 'ARRAY_CONTAINS_ANY':
                return 'array-contains-any'
              default:
                return Oe()
            }
          })(n.fieldFilter.op),
          n.fieldFilter.value
        )
      })(e)
    : e.compositeFilter !== void 0
    ? (function (n) {
        return _t.create(
          n.compositeFilter.filters.map((i) => vx(i)),
          (function (r) {
            switch (r) {
              case 'AND':
                return 'and'
              case 'OR':
                return 'or'
              default:
                return Oe()
            }
          })(n.compositeFilter.op)
        )
      })(e)
    : Oe()
}
function H6(e) {
  return O6[e]
}
function W6(e) {
  return M6[e]
}
function q6(e) {
  return L6[e]
}
function $a(e) {
  return { fieldPath: e.canonicalString() }
}
function Ua(e) {
  return Ft.fromServerFormat(e.fieldPath)
}
function px(e) {
  return e instanceof tt
    ? (function (n) {
        if (n.op === '==') {
          if (DE(n.value)) return { unaryFilter: { field: $a(n.field), op: 'IS_NAN' } }
          if (VE(n.value)) return { unaryFilter: { field: $a(n.field), op: 'IS_NULL' } }
        } else if (n.op === '!=') {
          if (DE(n.value)) return { unaryFilter: { field: $a(n.field), op: 'IS_NOT_NAN' } }
          if (VE(n.value)) return { unaryFilter: { field: $a(n.field), op: 'IS_NOT_NULL' } }
        }
        return { fieldFilter: { field: $a(n.field), op: W6(n.op), value: n.value } }
      })(e)
    : e instanceof _t
    ? (function (n) {
        const i = n.getFilters().map((r) => px(r))
        return i.length === 1 ? i[0] : { compositeFilter: { op: q6(n.op), filters: i } }
      })(e)
    : Oe()
}
function G6(e) {
  const t = []
  return e.fields.forEach((n) => t.push(n.canonicalString())), { fieldPaths: t }
}
function yx(e) {
  return e.length >= 4 && e.get(0) === 'projects' && e.get(2) === 'databases'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xr {
  constructor(t, n, i, r, s = $e.min(), o = $e.min(), a = En.EMPTY_BYTE_STRING, l = null) {
    ;(this.target = t),
      (this.targetId = n),
      (this.purpose = i),
      (this.sequenceNumber = r),
      (this.snapshotVersion = s),
      (this.lastLimboFreeSnapshotVersion = o),
      (this.resumeToken = a),
      (this.expectedCount = l)
  }
  withSequenceNumber(t) {
    return new xr(
      this.target,
      this.targetId,
      this.purpose,
      t,
      this.snapshotVersion,
      this.lastLimboFreeSnapshotVersion,
      this.resumeToken,
      this.expectedCount
    )
  }
  withResumeToken(t, n) {
    return new xr(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      n,
      this.lastLimboFreeSnapshotVersion,
      t,
      null
    )
  }
  withExpectedCount(t) {
    return new xr(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      this.snapshotVersion,
      this.lastLimboFreeSnapshotVersion,
      this.resumeToken,
      t
    )
  }
  withLastLimboFreeSnapshotVersion(t) {
    return new xr(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      this.snapshotVersion,
      t,
      this.resumeToken,
      this.expectedCount
    )
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _x {
  constructor(t) {
    this.ct = t
  }
}
function K6(e, t) {
  let n
  if (t.document) n = $6(e.ct, t.document, !!t.hasCommittedMutations)
  else if (t.noDocument) {
    const i = Re.fromSegments(t.noDocument.path),
      r = jo(t.noDocument.readTime)
    ;(n = Wt.newNoDocument(i, r)), t.hasCommittedMutations && n.setHasCommittedMutations()
  } else {
    if (!t.unknownDocument) return Oe()
    {
      const i = Re.fromSegments(t.unknownDocument.path),
        r = jo(t.unknownDocument.version)
      n = Wt.newUnknownDocument(i, r)
    }
  }
  return (
    t.readTime &&
      n.setReadTime(
        (function (r) {
          const s = new Dt(r[0], r[1])
          return $e.fromTimestamp(s)
        })(t.readTime)
      ),
    n
  )
}
function XE(e, t) {
  const n = t.key,
    i = {
      prefixPath: n.getCollectionPath().popLast().toArray(),
      collectionGroup: n.collectionGroup,
      documentId: n.path.lastSegment(),
      readTime: cf(t.readTime),
      hasCommittedMutations: t.hasCommittedMutations,
    }
  if (t.isFoundDocument())
    i.document = (function (s, o) {
      return {
        name: lf(s, o.key),
        fields: o.data.value.mapValue.fields,
        updateTime: Sl(s, o.version.toTimestamp()),
        createTime: Sl(s, o.createTime.toTimestamp()),
      }
    })(e.ct, t)
  else if (t.isNoDocument()) i.noDocument = { path: n.path.toArray(), readTime: Uo(t.version) }
  else {
    if (!t.isUnknownDocument()) return Oe()
    i.unknownDocument = { path: n.path.toArray(), version: Uo(t.version) }
  }
  return i
}
function cf(e) {
  const t = e.toTimestamp()
  return [t.seconds, t.nanoseconds]
}
function Uo(e) {
  const t = e.toTimestamp()
  return { seconds: t.seconds, nanoseconds: t.nanoseconds }
}
function jo(e) {
  const t = new Dt(e.seconds, e.nanoseconds)
  return $e.fromTimestamp(t)
}
function fo(e, t) {
  const n = (t.baseMutations || []).map((s) => yp(e.ct, s))
  for (let s = 0; s < t.mutations.length - 1; ++s) {
    const o = t.mutations[s]
    if (s + 1 < t.mutations.length && t.mutations[s + 1].transform !== void 0) {
      const a = t.mutations[s + 1]
      ;(o.updateTransforms = a.transform.fieldTransforms), t.mutations.splice(s + 1, 1), ++s
    }
  }
  const i = t.mutations.map((s) => yp(e.ct, s)),
    r = Dt.fromMillis(t.localWriteTimeMs)
  return new M_(t.batchId, r, n, i)
}
function Du(e) {
  const t = jo(e.readTime),
    n = e.lastLimboFreeSnapshotVersion !== void 0 ? jo(e.lastLimboFreeSnapshotVersion) : $e.min()
  let i
  return (
    (i = (function (s) {
      return s.documents !== void 0
    })(e.query)
      ? (function (s) {
          return Fe(s.documents.length === 1), Pi(Zc(dx(s.documents[0])))
        })(e.query)
      : (function (s) {
          return Pi(gx(s))
        })(e.query)),
    new xr(i, e.targetId, 'TargetPurposeListen', e.lastListenSequenceNumber, t, n, En.fromBase64String(e.resumeToken))
  )
}
function bx(e, t) {
  const n = Uo(t.snapshotVersion),
    i = Uo(t.lastLimboFreeSnapshotVersion)
  let r
  r = of(t.target) ? fx(e.ct, t.target) : mx(e.ct, t.target)._t
  const s = t.resumeToken.toBase64()
  return {
    targetId: t.targetId,
    canonicalId: $o(t.target),
    readTime: n,
    resumeToken: s,
    lastListenSequenceNumber: t.sequenceNumber,
    lastLimboFreeSnapshotVersion: i,
    query: r,
  }
}
function wx(e) {
  const t = gx({ parent: e.parent, structuredQuery: e.structuredQuery })
  return e.limitType === 'LAST' ? mp(t, t.limit, 'L') : t
}
function zg(e, t) {
  return new F_(t.largestBatchId, yp(e.ct, t.overlayMutation))
}
function JE(e, t) {
  const n = t.path.lastSegment()
  return [e, Yn(t.path.popLast()), n]
}
function ZE(e, t, n, i) {
  return {
    indexId: e,
    uid: t,
    sequenceNumber: n,
    readTime: Uo(i.readTime),
    documentKey: Yn(i.documentKey.path),
    largestBatchId: i.largestBatchId,
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Y6 {
  getBundleMetadata(t, n) {
    return e0(t)
      .get(n)
      .next((i) => {
        if (i)
          return (function (s) {
            return { id: s.bundleId, createTime: jo(s.createTime), version: s.version }
          })(i)
      })
  }
  saveBundleMetadata(t, n) {
    return e0(t).put(
      (function (r) {
        return { bundleId: r.id, createTime: Uo(Qn(r.createTime)), version: r.version }
      })(n)
    )
  }
  getNamedQuery(t, n) {
    return t0(t)
      .get(n)
      .next((i) => {
        if (i)
          return (function (s) {
            return { name: s.name, query: wx(s.bundledQuery), readTime: jo(s.readTime) }
          })(i)
      })
  }
  saveNamedQuery(t, n) {
    return t0(t).put(
      (function (r) {
        return { name: r.name, readTime: Uo(Qn(r.readTime)), bundledQuery: r.bundledQuery }
      })(n)
    )
  }
}
function e0(e) {
  return vn(e, 'bundles')
}
function t0(e) {
  return vn(e, 'namedQueries')
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class cm {
  constructor(t, n) {
    ;(this.serializer = t), (this.userId = n)
  }
  static lt(t, n) {
    const i = n.uid || ''
    return new cm(t, i)
  }
  getOverlay(t, n) {
    return pu(t)
      .get(JE(this.userId, n))
      .next((i) => (i ? zg(this.serializer, i) : null))
  }
  getOverlays(t, n) {
    const i = sr()
    return J.forEach(n, (r) =>
      this.getOverlay(t, r).next((s) => {
        s !== null && i.set(r, s)
      })
    ).next(() => i)
  }
  saveOverlays(t, n, i) {
    const r = []
    return (
      i.forEach((s, o) => {
        const a = new F_(n, o)
        r.push(this.ht(t, a))
      }),
      J.waitFor(r)
    )
  }
  removeOverlaysForBatchId(t, n, i) {
    const r = new Set()
    n.forEach((o) => r.add(Yn(o.getCollectionPath())))
    const s = []
    return (
      r.forEach((o) => {
        const a = IDBKeyRange.bound([this.userId, o, i], [this.userId, o, i + 1], !1, !0)
        s.push(pu(t).j('collectionPathOverlayIndex', a))
      }),
      J.waitFor(s)
    )
  }
  getOverlaysForCollection(t, n, i) {
    const r = sr(),
      s = Yn(n),
      o = IDBKeyRange.bound([this.userId, s, i], [this.userId, s, Number.POSITIVE_INFINITY], !0)
    return pu(t)
      .U('collectionPathOverlayIndex', o)
      .next((a) => {
        for (const l of a) {
          const u = zg(this.serializer, l)
          r.set(u.getKey(), u)
        }
        return r
      })
  }
  getOverlaysForCollectionGroup(t, n, i, r) {
    const s = sr()
    let o
    const a = IDBKeyRange.bound([this.userId, n, i], [this.userId, n, Number.POSITIVE_INFINITY], !0)
    return pu(t)
      .J({ index: 'collectionGroupOverlayIndex', range: a }, (l, u, c) => {
        const d = zg(this.serializer, u)
        s.size() < r || d.largestBatchId === o ? (s.set(d.getKey(), d), (o = d.largestBatchId)) : c.done()
      })
      .next(() => s)
  }
  ht(t, n) {
    return pu(t).put(
      (function (r, s, o) {
        const [a, l, u] = JE(s, o.mutation.key)
        return {
          userId: s,
          collectionPath: l,
          documentId: u,
          collectionGroup: o.mutation.key.getCollectionGroup(),
          largestBatchId: o.largestBatchId,
          overlayMutation: uf(r.ct, o.mutation),
        }
      })(this.serializer, this.userId, n)
    )
  }
}
function pu(e) {
  return vn(e, 'documentOverlays')
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class mo {
  constructor() {}
  Pt(t, n) {
    this.It(t, n), n.Tt()
  }
  It(t, n) {
    if ('nullValue' in t) this.Et(n, 5)
    else if ('booleanValue' in t) this.Et(n, 10), n.dt(t.booleanValue ? 1 : 0)
    else if ('integerValue' in t) this.Et(n, 15), n.dt(Ht(t.integerValue))
    else if ('doubleValue' in t) {
      const i = Ht(t.doubleValue)
      isNaN(i) ? this.Et(n, 13) : (this.Et(n, 15), pc(i) ? n.dt(0) : n.dt(i))
    } else if ('timestampValue' in t) {
      let i = t.timestampValue
      this.Et(n, 20), typeof i == 'string' && (i = Lr(i)), n.At(`${i.seconds || ''}`), n.dt(i.nanos || 0)
    } else if ('stringValue' in t) this.Rt(t.stringValue, n), this.Vt(n)
    else if ('bytesValue' in t) this.Et(n, 30), n.ft(Ns(t.bytesValue)), this.Vt(n)
    else if ('referenceValue' in t) this.gt(t.referenceValue, n)
    else if ('geoPointValue' in t) {
      const i = t.geoPointValue
      this.Et(n, 45), n.dt(i.latitude || 0), n.dt(i.longitude || 0)
    } else
      'mapValue' in t
        ? MR(t)
          ? this.Et(n, Number.MAX_SAFE_INTEGER)
          : (this.yt(t.mapValue, n), this.Vt(n))
        : 'arrayValue' in t
        ? (this.wt(t.arrayValue, n), this.Vt(n))
        : Oe()
  }
  Rt(t, n) {
    this.Et(n, 25), this.St(t, n)
  }
  St(t, n) {
    n.At(t)
  }
  yt(t, n) {
    const i = t.fields || {}
    this.Et(n, 55)
    for (const r of Object.keys(i)) this.Rt(r, n), this.It(i[r], n)
  }
  wt(t, n) {
    const i = t.values || []
    this.Et(n, 50)
    for (const r of i) this.It(r, n)
  }
  gt(t, n) {
    this.Et(n, 37),
      Re.fromName(t).path.forEach((i) => {
        this.Et(n, 60), this.St(i, n)
      })
  }
  Et(t, n) {
    t.dt(n)
  }
  Vt(t) {
    t.dt(2)
  }
}
mo.bt = new mo()
function Q6(e) {
  if (e === 0) return 8
  let t = 0
  return !(e >> 4) && ((t += 4), (e <<= 4)), !(e >> 6) && ((t += 2), (e <<= 2)), !(e >> 7) && (t += 1), t
}
function n0(e) {
  const t =
    64 -
    (function (i) {
      let r = 0
      for (let s = 0; s < 8; ++s) {
        const o = Q6(255 & i[s])
        if (((r += o), o !== 8)) break
      }
      return r
    })(e)
  return Math.ceil(t / 8)
}
class X6 {
  constructor() {
    ;(this.buffer = new Uint8Array(1024)), (this.position = 0)
  }
  Dt(t) {
    const n = t[Symbol.iterator]()
    let i = n.next()
    for (; !i.done; ) this.Ct(i.value), (i = n.next())
    this.vt()
  }
  Ft(t) {
    const n = t[Symbol.iterator]()
    let i = n.next()
    for (; !i.done; ) this.Mt(i.value), (i = n.next())
    this.xt()
  }
  Ot(t) {
    for (const n of t) {
      const i = n.charCodeAt(0)
      if (i < 128) this.Ct(i)
      else if (i < 2048) this.Ct(960 | (i >>> 6)), this.Ct(128 | (63 & i))
      else if (n < '\uD800' || '\uDBFF' < n)
        this.Ct(480 | (i >>> 12)), this.Ct(128 | (63 & (i >>> 6))), this.Ct(128 | (63 & i))
      else {
        const r = n.codePointAt(0)
        this.Ct(240 | (r >>> 18)),
          this.Ct(128 | (63 & (r >>> 12))),
          this.Ct(128 | (63 & (r >>> 6))),
          this.Ct(128 | (63 & r))
      }
    }
    this.vt()
  }
  Nt(t) {
    for (const n of t) {
      const i = n.charCodeAt(0)
      if (i < 128) this.Mt(i)
      else if (i < 2048) this.Mt(960 | (i >>> 6)), this.Mt(128 | (63 & i))
      else if (n < '\uD800' || '\uDBFF' < n)
        this.Mt(480 | (i >>> 12)), this.Mt(128 | (63 & (i >>> 6))), this.Mt(128 | (63 & i))
      else {
        const r = n.codePointAt(0)
        this.Mt(240 | (r >>> 18)),
          this.Mt(128 | (63 & (r >>> 12))),
          this.Mt(128 | (63 & (r >>> 6))),
          this.Mt(128 | (63 & r))
      }
    }
    this.xt()
  }
  Lt(t) {
    const n = this.Bt(t),
      i = n0(n)
    this.kt(1 + i), (this.buffer[this.position++] = 255 & i)
    for (let r = n.length - i; r < n.length; ++r) this.buffer[this.position++] = 255 & n[r]
  }
  qt(t) {
    const n = this.Bt(t),
      i = n0(n)
    this.kt(1 + i), (this.buffer[this.position++] = ~(255 & i))
    for (let r = n.length - i; r < n.length; ++r) this.buffer[this.position++] = ~(255 & n[r])
  }
  Qt() {
    this.Kt(255), this.Kt(255)
  }
  $t() {
    this.Ut(255), this.Ut(255)
  }
  reset() {
    this.position = 0
  }
  seed(t) {
    this.kt(t.length), this.buffer.set(t, this.position), (this.position += t.length)
  }
  Wt() {
    return this.buffer.slice(0, this.position)
  }
  Bt(t) {
    const n = (function (s) {
        const o = new DataView(new ArrayBuffer(8))
        return o.setFloat64(0, s, !1), new Uint8Array(o.buffer)
      })(t),
      i = (128 & n[0]) != 0
    n[0] ^= i ? 255 : 128
    for (let r = 1; r < n.length; ++r) n[r] ^= i ? 255 : 0
    return n
  }
  Ct(t) {
    const n = 255 & t
    n === 0 ? (this.Kt(0), this.Kt(255)) : n === 255 ? (this.Kt(255), this.Kt(0)) : this.Kt(n)
  }
  Mt(t) {
    const n = 255 & t
    n === 0 ? (this.Ut(0), this.Ut(255)) : n === 255 ? (this.Ut(255), this.Ut(0)) : this.Ut(t)
  }
  vt() {
    this.Kt(0), this.Kt(1)
  }
  xt() {
    this.Ut(0), this.Ut(1)
  }
  Kt(t) {
    this.kt(1), (this.buffer[this.position++] = t)
  }
  Ut(t) {
    this.kt(1), (this.buffer[this.position++] = ~t)
  }
  kt(t) {
    const n = t + this.position
    if (n <= this.buffer.length) return
    let i = 2 * this.buffer.length
    i < n && (i = n)
    const r = new Uint8Array(i)
    r.set(this.buffer), (this.buffer = r)
  }
}
class J6 {
  constructor(t) {
    this.Gt = t
  }
  ft(t) {
    this.Gt.Dt(t)
  }
  At(t) {
    this.Gt.Ot(t)
  }
  dt(t) {
    this.Gt.Lt(t)
  }
  Tt() {
    this.Gt.Qt()
  }
}
class Z6 {
  constructor(t) {
    this.Gt = t
  }
  ft(t) {
    this.Gt.Ft(t)
  }
  At(t) {
    this.Gt.Nt(t)
  }
  dt(t) {
    this.Gt.qt(t)
  }
  Tt() {
    this.Gt.$t()
  }
}
class yu {
  constructor() {
    ;(this.Gt = new X6()), (this.zt = new J6(this.Gt)), (this.jt = new Z6(this.Gt))
  }
  seed(t) {
    this.Gt.seed(t)
  }
  Ht(t) {
    return t === 0 ? this.zt : this.jt
  }
  Wt() {
    return this.Gt.Wt()
  }
  reset() {
    this.Gt.reset()
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class go {
  constructor(t, n, i, r) {
    ;(this.indexId = t), (this.documentKey = n), (this.arrayValue = i), (this.directionalValue = r)
  }
  Jt() {
    const t = this.directionalValue.length,
      n = t === 0 || this.directionalValue[t - 1] === 255 ? t + 1 : t,
      i = new Uint8Array(n)
    return (
      i.set(this.directionalValue, 0),
      n !== t ? i.set([0], this.directionalValue.length) : ++i[i.length - 1],
      new go(this.indexId, this.documentKey, this.arrayValue, i)
    )
  }
}
function ss(e, t) {
  let n = e.indexId - t.indexId
  return n !== 0
    ? n
    : ((n = i0(e.arrayValue, t.arrayValue)),
      n !== 0
        ? n
        : ((n = i0(e.directionalValue, t.directionalValue)), n !== 0 ? n : Re.comparator(e.documentKey, t.documentKey)))
}
function i0(e, t) {
  for (let n = 0; n < e.length && n < t.length; ++n) {
    const i = e[n] - t[n]
    if (i !== 0) return i
  }
  return e.length - t.length
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class r0 {
  constructor(t) {
    ;(this.Yt = new bt((n, i) => Ft.comparator(n.field, i.field))),
      (this.collectionId = t.collectionGroup != null ? t.collectionGroup : t.path.lastSegment()),
      (this.Zt = t.orderBy),
      (this.Xt = [])
    for (const n of t.filters) {
      const i = n
      i.isInequality() ? (this.Yt = this.Yt.add(i)) : this.Xt.push(i)
    }
  }
  get en() {
    return this.Yt.size > 1
  }
  tn(t) {
    if ((Fe(t.collectionGroup === this.collectionId), this.en)) return !1
    const n = ap(t)
    if (n !== void 0 && !this.nn(n)) return !1
    const i = uo(t)
    let r = new Set(),
      s = 0,
      o = 0
    for (; s < i.length && this.nn(i[s]); ++s) r = r.add(i[s].fieldPath.canonicalString())
    if (s === i.length) return !0
    if (this.Yt.size > 0) {
      const a = this.Yt.getIterator().getNext()
      if (!r.has(a.field.canonicalString())) {
        const l = i[s]
        if (!this.rn(a, l) || !this.sn(this.Zt[o++], l)) return !1
      }
      ++s
    }
    for (; s < i.length; ++s) {
      const a = i[s]
      if (o >= this.Zt.length || !this.sn(this.Zt[o++], a)) return !1
    }
    return !0
  }
  on() {
    if (this.en) return null
    let t = new bt(Ft.comparator)
    const n = []
    for (const i of this.Xt)
      if (!i.field.isKeyField())
        if (i.op === 'array-contains' || i.op === 'array-contains-any') n.push(new Ih(i.field, 2))
        else {
          if (t.has(i.field)) continue
          ;(t = t.add(i.field)), n.push(new Ih(i.field, 0))
        }
    for (const i of this.Zt)
      i.field.isKeyField() || t.has(i.field) || ((t = t.add(i.field)), n.push(new Ih(i.field, i.dir === 'asc' ? 0 : 1)))
    return new rf(rf.UNKNOWN_ID, this.collectionId, n, vc.empty())
  }
  nn(t) {
    for (const n of this.Xt) if (this.rn(n, t)) return !0
    return !1
  }
  rn(t, n) {
    if (t === void 0 || !t.field.isEqual(n.fieldPath)) return !1
    const i = t.op === 'array-contains' || t.op === 'array-contains-any'
    return (n.kind === 2) === i
  }
  sn(t, n) {
    return !!t.field.isEqual(n.fieldPath) && ((n.kind === 0 && t.dir === 'asc') || (n.kind === 1 && t.dir === 'desc'))
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Ix(e) {
  var t, n
  if ((Fe(e instanceof tt || e instanceof _t), e instanceof tt)) {
    if (e instanceof HR) {
      const r =
        ((n = (t = e.value.arrayValue) === null || t === void 0 ? void 0 : t.values) === null || n === void 0
          ? void 0
          : n.map((s) => tt.create(e.field, '==', s))) || []
      return _t.create(r, 'or')
    }
    return e
  }
  const i = e.filters.map((r) => Ix(r))
  return _t.create(i, e.op)
}
function e5(e) {
  if (e.getFilters().length === 0) return []
  const t = wp(Ix(e))
  return Fe(Sx(t)), _p(t) || bp(t) ? [t] : t.getFilters()
}
function _p(e) {
  return e instanceof tt
}
function bp(e) {
  return e instanceof _t && O_(e)
}
function Sx(e) {
  return (
    _p(e) ||
    bp(e) ||
    (function (n) {
      if (n instanceof _t && dp(n)) {
        for (const i of n.getFilters()) if (!_p(i) && !bp(i)) return !1
        return !0
      }
      return !1
    })(e)
  )
}
function wp(e) {
  if ((Fe(e instanceof tt || e instanceof _t), e instanceof tt)) return e
  if (e.filters.length === 1) return wp(e.filters[0])
  const t = e.filters.map((i) => wp(i))
  let n = _t.create(t, e.op)
  return (
    (n = df(n)),
    Sx(n) ? n : (Fe(n instanceof _t), Fe(bl(n)), Fe(n.filters.length > 1), n.filters.reduce((i, r) => U_(i, r)))
  )
}
function U_(e, t) {
  let n
  return (
    Fe(e instanceof tt || e instanceof _t),
    Fe(t instanceof tt || t instanceof _t),
    (n =
      e instanceof tt
        ? t instanceof tt
          ? (function (r, s) {
              return _t.create([r, s], 'and')
            })(e, t)
          : s0(e, t)
        : t instanceof tt
        ? s0(t, e)
        : (function (r, s) {
            if ((Fe(r.filters.length > 0 && s.filters.length > 0), bl(r) && bl(s))) return UR(r, s.getFilters())
            const o = dp(r) ? r : s,
              a = dp(r) ? s : r,
              l = o.filters.map((u) => U_(u, a))
            return _t.create(l, 'or')
          })(e, t)),
    df(n)
  )
}
function s0(e, t) {
  if (bl(t)) return UR(t, e.getFilters())
  {
    const n = t.filters.map((i) => U_(e, i))
    return _t.create(n, 'or')
  }
}
function df(e) {
  if ((Fe(e instanceof tt || e instanceof _t), e instanceof tt)) return e
  const t = e.getFilters()
  if (t.length === 1) return df(t[0])
  if (BR(e)) return e
  const n = t.map((r) => df(r)),
    i = []
  return (
    n.forEach((r) => {
      r instanceof tt ? i.push(r) : r instanceof _t && (r.op === e.op ? i.push(...r.filters) : i.push(r))
    }),
    i.length === 1 ? i[0] : _t.create(i, e.op)
  )
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class t5 {
  constructor() {
    this._n = new j_()
  }
  addToCollectionParentIndex(t, n) {
    return this._n.add(n), J.resolve()
  }
  getCollectionParents(t, n) {
    return J.resolve(this._n.getEntries(n))
  }
  addFieldIndex(t, n) {
    return J.resolve()
  }
  deleteFieldIndex(t, n) {
    return J.resolve()
  }
  deleteAllFieldIndexes(t) {
    return J.resolve()
  }
  createTargetIndexes(t, n) {
    return J.resolve()
  }
  getDocumentsMatchingTarget(t, n) {
    return J.resolve(null)
  }
  getIndexType(t, n) {
    return J.resolve(0)
  }
  getFieldIndexes(t, n) {
    return J.resolve([])
  }
  getNextCollectionGroupToUpdate(t) {
    return J.resolve(null)
  }
  getMinOffset(t, n) {
    return J.resolve(vi.min())
  }
  getMinOffsetFromCollectionGroup(t, n) {
    return J.resolve(vi.min())
  }
  updateCollectionGroup(t, n, i) {
    return J.resolve()
  }
  updateIndexEntries(t, n) {
    return J.resolve()
  }
}
class j_ {
  constructor() {
    this.index = {}
  }
  add(t) {
    const n = t.lastSegment(),
      i = t.popLast(),
      r = this.index[n] || new bt(pt.comparator),
      s = !r.has(i)
    return (this.index[n] = r.add(i)), s
  }
  has(t) {
    const n = t.lastSegment(),
      i = t.popLast(),
      r = this.index[n]
    return r && r.has(i)
  }
  getEntries(t) {
    return (this.index[t] || new bt(pt.comparator)).toArray()
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Zd = new Uint8Array(0)
class n5 {
  constructor(t, n) {
    ;(this.databaseId = n),
      (this.an = new j_()),
      (this.un = new qs(
        (i) => $o(i),
        (i, r) => Jc(i, r)
      )),
      (this.uid = t.uid || '')
  }
  addToCollectionParentIndex(t, n) {
    if (!this.an.has(n)) {
      const i = n.lastSegment(),
        r = n.popLast()
      t.addOnCommittedListener(() => {
        this.an.add(n)
      })
      const s = { collectionId: i, parent: Yn(r) }
      return o0(t).put(s)
    }
    return J.resolve()
  }
  getCollectionParents(t, n) {
    const i = [],
      r = IDBKeyRange.bound([n, ''], [ER(n), ''], !1, !0)
    return o0(t)
      .U(r)
      .next((s) => {
        for (const o of s) {
          if (o.collectionId !== n) break
          i.push(rr(o.parent))
        }
        return i
      })
  }
  addFieldIndex(t, n) {
    const i = _u(t),
      r = (function (a) {
        return {
          indexId: a.indexId,
          collectionGroup: a.collectionGroup,
          fields: a.fields.map((l) => [l.fieldPath.canonicalString(), l.kind]),
        }
      })(n)
    delete r.indexId
    const s = i.add(r)
    if (n.indexState) {
      const o = Ra(t)
      return s.next((a) => {
        o.put(ZE(a, this.uid, n.indexState.sequenceNumber, n.indexState.offset))
      })
    }
    return s.next()
  }
  deleteFieldIndex(t, n) {
    const i = _u(t),
      r = Ra(t),
      s = Pa(t)
    return i
      .delete(n.indexId)
      .next(() => r.delete(IDBKeyRange.bound([n.indexId], [n.indexId + 1], !1, !0)))
      .next(() => s.delete(IDBKeyRange.bound([n.indexId], [n.indexId + 1], !1, !0)))
  }
  deleteAllFieldIndexes(t) {
    const n = _u(t),
      i = Pa(t),
      r = Ra(t)
    return n
      .j()
      .next(() => i.j())
      .next(() => r.j())
  }
  createTargetIndexes(t, n) {
    return J.forEach(this.cn(n), (i) =>
      this.getIndexType(t, i).next((r) => {
        if (r === 0 || r === 1) {
          const s = new r0(i).on()
          if (s != null) return this.addFieldIndex(t, s)
        }
      })
    )
  }
  getDocumentsMatchingTarget(t, n) {
    const i = Pa(t)
    let r = !0
    const s = new Map()
    return J.forEach(this.cn(n), (o) =>
      this.ln(t, o).next((a) => {
        r && (r = !!a), s.set(o, a)
      })
    ).next(() => {
      if (r) {
        let o = Qe()
        const a = []
        return J.forEach(s, (l, u) => {
          we(
            'IndexedDbIndexManager',
            `Using index ${(function (x) {
              return `id=${x.indexId}|cg=${x.collectionGroup}|f=${x.fields
                .map((N) => `${N.fieldPath}:${N.kind}`)
                .join(',')}`
            })(l)} to execute ${$o(n)}`
          )
          const c = (function (x, N) {
              const V = ap(N)
              if (V === void 0) return null
              for (const D of af(x, V.fieldPath))
                switch (D.op) {
                  case 'array-contains-any':
                    return D.value.arrayValue.values || []
                  case 'array-contains':
                    return [D.value]
                }
              return null
            })(u, l),
            d = (function (x, N) {
              const V = new Map()
              for (const D of uo(N))
                for (const I of af(x, D.fieldPath))
                  switch (I.op) {
                    case '==':
                    case 'in':
                      V.set(D.fieldPath.canonicalString(), I.value)
                      break
                    case 'not-in':
                    case '!=':
                      return V.set(D.fieldPath.canonicalString(), I.value), Array.from(V.values())
                  }
              return null
            })(u, l),
            f = (function (x, N) {
              const V = []
              let D = !0
              for (const I of uo(N)) {
                const w = I.kind === 0 ? FE(x, I.fieldPath, x.startAt) : BE(x, I.fieldPath, x.startAt)
                V.push(w.value), D && (D = w.inclusive)
              }
              return new _l(V, D)
            })(u, l),
            m = (function (x, N) {
              const V = []
              let D = !0
              for (const I of uo(N)) {
                const w = I.kind === 0 ? BE(x, I.fieldPath, x.endAt) : FE(x, I.fieldPath, x.endAt)
                V.push(w.value), D && (D = w.inclusive)
              }
              return new _l(V, D)
            })(u, l),
            p = this.hn(l, u, f),
            v = this.hn(l, u, m),
            y = this.Pn(l, u, d),
            T = this.In(l.indexId, c, p, f.inclusive, v, m.inclusive, y)
          return J.forEach(T, (A) =>
            i.G(A, n.limit).next((x) => {
              x.forEach((N) => {
                const V = Re.fromSegments(N.documentKey)
                o.has(V) || ((o = o.add(V)), a.push(V))
              })
            })
          )
        }).next(() => a)
      }
      return J.resolve(null)
    })
  }
  cn(t) {
    let n = this.un.get(t)
    return (
      n ||
      (t.filters.length === 0
        ? (n = [t])
        : (n = e5(_t.create(t.filters, 'and')).map((i) =>
            fp(t.path, t.collectionGroup, t.orderBy, i.getFilters(), t.limit, t.startAt, t.endAt)
          )),
      this.un.set(t, n),
      n)
    )
  }
  In(t, n, i, r, s, o, a) {
    const l = (n != null ? n.length : 1) * Math.max(i.length, s.length),
      u = l / (n != null ? n.length : 1),
      c = []
    for (let d = 0; d < l; ++d) {
      const f = n ? this.Tn(n[d / u]) : Zd,
        m = this.En(t, f, i[d % u], r),
        p = this.dn(t, f, s[d % u], o),
        v = a.map((y) => this.En(t, f, y, !0))
      c.push(...this.createRange(m, p, v))
    }
    return c
  }
  En(t, n, i, r) {
    const s = new go(t, Re.empty(), n, i)
    return r ? s : s.Jt()
  }
  dn(t, n, i, r) {
    const s = new go(t, Re.empty(), n, i)
    return r ? s.Jt() : s
  }
  ln(t, n) {
    const i = new r0(n),
      r = n.collectionGroup != null ? n.collectionGroup : n.path.lastSegment()
    return this.getFieldIndexes(t, r).next((s) => {
      let o = null
      for (const a of s) i.tn(a) && (!o || a.fields.length > o.fields.length) && (o = a)
      return o
    })
  }
  getIndexType(t, n) {
    let i = 2
    const r = this.cn(n)
    return J.forEach(r, (s) =>
      this.ln(t, s).next((o) => {
        o
          ? i !== 0 &&
            o.fields.length <
              (function (l) {
                let u = new bt(Ft.comparator),
                  c = !1
                for (const d of l.filters)
                  for (const f of d.getFlattenedFilters())
                    f.field.isKeyField() ||
                      (f.op === 'array-contains' || f.op === 'array-contains-any' ? (c = !0) : (u = u.add(f.field)))
                for (const d of l.orderBy) d.field.isKeyField() || (u = u.add(d.field))
                return u.size + (c ? 1 : 0)
              })(s) &&
            (i = 1)
          : (i = 0)
      })
    ).next(() =>
      (function (o) {
        return o.limit !== null
      })(n) &&
      r.length > 1 &&
      i === 2
        ? 1
        : i
    )
  }
  An(t, n) {
    const i = new yu()
    for (const r of uo(t)) {
      const s = n.data.field(r.fieldPath)
      if (s == null) return null
      const o = i.Ht(r.kind)
      mo.bt.Pt(s, o)
    }
    return i.Wt()
  }
  Tn(t) {
    const n = new yu()
    return mo.bt.Pt(t, n.Ht(0)), n.Wt()
  }
  Rn(t, n) {
    const i = new yu()
    return (
      mo.bt.Pt(
        N_(this.databaseId, n),
        i.Ht(
          (function (s) {
            const o = uo(s)
            return o.length === 0 ? 0 : o[o.length - 1].kind
          })(t)
        )
      ),
      i.Wt()
    )
  }
  Pn(t, n, i) {
    if (i === null) return []
    let r = []
    r.push(new yu())
    let s = 0
    for (const o of uo(t)) {
      const a = i[s++]
      for (const l of r)
        if (this.Vn(n, o.fieldPath) && bc(a)) r = this.mn(r, o, a)
        else {
          const u = l.Ht(o.kind)
          mo.bt.Pt(a, u)
        }
    }
    return this.fn(r)
  }
  hn(t, n, i) {
    return this.Pn(t, n, i.position)
  }
  fn(t) {
    const n = []
    for (let i = 0; i < t.length; ++i) n[i] = t[i].Wt()
    return n
  }
  mn(t, n, i) {
    const r = [...t],
      s = []
    for (const o of i.arrayValue.values || [])
      for (const a of r) {
        const l = new yu()
        l.seed(a.Wt()), mo.bt.Pt(o, l.Ht(n.kind)), s.push(l)
      }
    return s
  }
  Vn(t, n) {
    return !!t.filters.find((i) => i instanceof tt && i.field.isEqual(n) && (i.op === 'in' || i.op === 'not-in'))
  }
  getFieldIndexes(t, n) {
    const i = _u(t),
      r = Ra(t)
    return (n ? i.U('collectionGroupIndex', IDBKeyRange.bound(n, n)) : i.U()).next((s) => {
      const o = []
      return J.forEach(s, (a) =>
        r.get([a.indexId, this.uid]).next((l) => {
          o.push(
            (function (c, d) {
              const f = d
                  ? new vc(d.sequenceNumber, new vi(jo(d.readTime), new Re(rr(d.documentKey)), d.largestBatchId))
                  : vc.empty(),
                m = c.fields.map(([p, v]) => new Ih(Ft.fromServerFormat(p), v))
              return new rf(c.indexId, c.collectionGroup, m, f)
            })(a, l)
          )
        })
      ).next(() => o)
    })
  }
  getNextCollectionGroupToUpdate(t) {
    return this.getFieldIndexes(t).next((n) =>
      n.length === 0
        ? null
        : (n.sort((i, r) => {
            const s = i.indexState.sequenceNumber - r.indexState.sequenceNumber
            return s !== 0 ? s : Ye(i.collectionGroup, r.collectionGroup)
          }),
          n[0].collectionGroup)
    )
  }
  updateCollectionGroup(t, n, i) {
    const r = _u(t),
      s = Ra(t)
    return this.gn(t).next((o) =>
      r
        .U('collectionGroupIndex', IDBKeyRange.bound(n, n))
        .next((a) => J.forEach(a, (l) => s.put(ZE(l.indexId, this.uid, o, i))))
    )
  }
  updateIndexEntries(t, n) {
    const i = new Map()
    return J.forEach(n, (r, s) => {
      const o = i.get(r.collectionGroup)
      return (o ? J.resolve(o) : this.getFieldIndexes(t, r.collectionGroup)).next(
        (a) => (
          i.set(r.collectionGroup, a),
          J.forEach(a, (l) =>
            this.pn(t, r, l).next((u) => {
              const c = this.yn(s, l)
              return u.isEqual(c) ? J.resolve() : this.wn(t, s, l, u, c)
            })
          )
        )
      )
    })
  }
  Sn(t, n, i, r) {
    return Pa(t).put({
      indexId: r.indexId,
      uid: this.uid,
      arrayValue: r.arrayValue,
      directionalValue: r.directionalValue,
      orderedDocumentKey: this.Rn(i, n.key),
      documentKey: n.key.path.toArray(),
    })
  }
  bn(t, n, i, r) {
    return Pa(t).delete([
      r.indexId,
      this.uid,
      r.arrayValue,
      r.directionalValue,
      this.Rn(i, n.key),
      n.key.path.toArray(),
    ])
  }
  pn(t, n, i) {
    const r = Pa(t)
    let s = new bt(ss)
    return r
      .J({ index: 'documentKeyIndex', range: IDBKeyRange.only([i.indexId, this.uid, this.Rn(i, n)]) }, (o, a) => {
        s = s.add(new go(i.indexId, n, a.arrayValue, a.directionalValue))
      })
      .next(() => s)
  }
  yn(t, n) {
    let i = new bt(ss)
    const r = this.An(n, t)
    if (r == null) return i
    const s = ap(n)
    if (s != null) {
      const o = t.data.field(s.fieldPath)
      if (bc(o)) for (const a of o.arrayValue.values || []) i = i.add(new go(n.indexId, t.key, this.Tn(a), r))
    } else i = i.add(new go(n.indexId, t.key, Zd, r))
    return i
  }
  wn(t, n, i, r, s) {
    we('IndexedDbIndexManager', "Updating index entries for document '%s'", n.key)
    const o = []
    return (
      (function (l, u, c, d, f) {
        const m = l.getIterator(),
          p = u.getIterator()
        let v = ka(m),
          y = ka(p)
        for (; v || y; ) {
          let T = !1,
            A = !1
          if (v && y) {
            const x = c(v, y)
            x < 0 ? (A = !0) : x > 0 && (T = !0)
          } else v != null ? (A = !0) : (T = !0)
          T ? (d(y), (y = ka(p))) : A ? (f(v), (v = ka(m))) : ((v = ka(m)), (y = ka(p)))
        }
      })(
        r,
        s,
        ss,
        (a) => {
          o.push(this.Sn(t, n, i, a))
        },
        (a) => {
          o.push(this.bn(t, n, i, a))
        }
      ),
      J.waitFor(o)
    )
  }
  gn(t) {
    let n = 1
    return Ra(t)
      .J(
        {
          index: 'sequenceNumberIndex',
          reverse: !0,
          range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]),
        },
        (i, r, s) => {
          s.done(), (n = r.sequenceNumber + 1)
        }
      )
      .next(() => n)
  }
  createRange(t, n, i) {
    i = i.sort((o, a) => ss(o, a)).filter((o, a, l) => !a || ss(o, l[a - 1]) !== 0)
    const r = []
    r.push(t)
    for (const o of i) {
      const a = ss(o, t),
        l = ss(o, n)
      if (a === 0) r[0] = t.Jt()
      else if (a > 0 && l < 0) r.push(o), r.push(o.Jt())
      else if (l > 0) break
    }
    r.push(n)
    const s = []
    for (let o = 0; o < r.length; o += 2) {
      if (this.Dn(r[o], r[o + 1])) return []
      const a = [r[o].indexId, this.uid, r[o].arrayValue, r[o].directionalValue, Zd, []],
        l = [r[o + 1].indexId, this.uid, r[o + 1].arrayValue, r[o + 1].directionalValue, Zd, []]
      s.push(IDBKeyRange.bound(a, l))
    }
    return s
  }
  Dn(t, n) {
    return ss(t, n) > 0
  }
  getMinOffsetFromCollectionGroup(t, n) {
    return this.getFieldIndexes(t, n).next(a0)
  }
  getMinOffset(t, n) {
    return J.mapArray(this.cn(n), (i) => this.ln(t, i).next((r) => r || Oe())).next(a0)
  }
}
function o0(e) {
  return vn(e, 'collectionParents')
}
function Pa(e) {
  return vn(e, 'indexEntries')
}
function _u(e) {
  return vn(e, 'indexConfiguration')
}
function Ra(e) {
  return vn(e, 'indexState')
}
function a0(e) {
  Fe(e.length !== 0)
  let t = e[0].indexState.offset,
    n = t.largestBatchId
  for (let i = 1; i < e.length; i++) {
    const r = e[i].indexState.offset
    R_(r, t) < 0 && (t = r), n < r.largestBatchId && (n = r.largestBatchId)
  }
  return new vi(t.readTime, t.documentKey, n)
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const l0 = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 }
class Zn {
  constructor(t, n, i) {
    ;(this.cacheSizeCollectionThreshold = t), (this.percentileToCollect = n), (this.maximumSequenceNumbersToCollect = i)
  }
  static withCacheSize(t) {
    return new Zn(t, Zn.DEFAULT_COLLECTION_PERCENTILE, Zn.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function Ex(e, t, n) {
  const i = e.store('mutations'),
    r = e.store('documentMutations'),
    s = [],
    o = IDBKeyRange.only(n.batchId)
  let a = 0
  const l = i.J({ range: o }, (c, d, f) => (a++, f.delete()))
  s.push(
    l.next(() => {
      Fe(a === 1)
    })
  )
  const u = []
  for (const c of n.mutations) {
    const d = PR(t, c.key.path, n.batchId)
    s.push(r.delete(d)), u.push(c.key)
  }
  return J.waitFor(s).next(() => u)
}
function hf(e) {
  if (!e) return 0
  let t
  if (e.document) t = e.document
  else if (e.unknownDocument) t = e.unknownDocument
  else {
    if (!e.noDocument) throw Oe()
    t = e.noDocument
  }
  return JSON.stringify(t).length
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ ;(Zn.DEFAULT_COLLECTION_PERCENTILE = 10),
  (Zn.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3),
  (Zn.DEFAULT = new Zn(41943040, Zn.DEFAULT_COLLECTION_PERCENTILE, Zn.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)),
  (Zn.DISABLED = new Zn(-1, 0, 0))
class dm {
  constructor(t, n, i, r) {
    ;(this.userId = t), (this.serializer = n), (this.indexManager = i), (this.referenceDelegate = r), (this.Cn = {})
  }
  static lt(t, n, i, r) {
    Fe(t.uid !== '')
    const s = t.isAuthenticated() ? t.uid : ''
    return new dm(s, n, i, r)
  }
  checkEmpty(t) {
    let n = !0
    const i = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY])
    return os(t)
      .J({ index: 'userMutationsIndex', range: i }, (r, s, o) => {
        ;(n = !1), o.done()
      })
      .next(() => n)
  }
  addMutationBatch(t, n, i, r) {
    const s = ja(t),
      o = os(t)
    return o.add({}).next((a) => {
      Fe(typeof a == 'number')
      const l = new M_(a, n, i, r),
        u = (function (m, p, v) {
          const y = v.baseMutations.map((A) => uf(m.ct, A)),
            T = v.mutations.map((A) => uf(m.ct, A))
          return {
            userId: p,
            batchId: v.batchId,
            localWriteTimeMs: v.localWriteTime.toMillis(),
            baseMutations: y,
            mutations: T,
          }
        })(this.serializer, this.userId, l),
        c = []
      let d = new bt((f, m) => Ye(f.canonicalString(), m.canonicalString()))
      for (const f of r) {
        const m = PR(this.userId, f.key.path, a)
        ;(d = d.add(f.key.path.popLast())), c.push(o.put(u)), c.push(s.put(m, LH))
      }
      return (
        d.forEach((f) => {
          c.push(this.indexManager.addToCollectionParentIndex(t, f))
        }),
        t.addOnCommittedListener(() => {
          this.Cn[a] = l.keys()
        }),
        J.waitFor(c).next(() => l)
      )
    })
  }
  lookupMutationBatch(t, n) {
    return os(t)
      .get(n)
      .next((i) => (i ? (Fe(i.userId === this.userId), fo(this.serializer, i)) : null))
  }
  vn(t, n) {
    return this.Cn[n]
      ? J.resolve(this.Cn[n])
      : this.lookupMutationBatch(t, n).next((i) => {
          if (i) {
            const r = i.keys()
            return (this.Cn[n] = r), r
          }
          return null
        })
  }
  getNextMutationBatchAfterBatchId(t, n) {
    const i = n + 1,
      r = IDBKeyRange.lowerBound([this.userId, i])
    let s = null
    return os(t)
      .J({ index: 'userMutationsIndex', range: r }, (o, a, l) => {
        a.userId === this.userId && (Fe(a.batchId >= i), (s = fo(this.serializer, a))), l.done()
      })
      .next(() => s)
  }
  getHighestUnacknowledgedBatchId(t) {
    const n = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY])
    let i = -1
    return os(t)
      .J({ index: 'userMutationsIndex', range: n, reverse: !0 }, (r, s, o) => {
        ;(i = s.batchId), o.done()
      })
      .next(() => i)
  }
  getAllMutationBatches(t) {
    const n = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY])
    return os(t)
      .U('userMutationsIndex', n)
      .next((i) => i.map((r) => fo(this.serializer, r)))
  }
  getAllMutationBatchesAffectingDocumentKey(t, n) {
    const i = Sh(this.userId, n.path),
      r = IDBKeyRange.lowerBound(i),
      s = []
    return ja(t)
      .J({ range: r }, (o, a, l) => {
        const [u, c, d] = o,
          f = rr(c)
        if (u === this.userId && n.path.isEqual(f))
          return os(t)
            .get(d)
            .next((m) => {
              if (!m) throw Oe()
              Fe(m.userId === this.userId), s.push(fo(this.serializer, m))
            })
        l.done()
      })
      .next(() => s)
  }
  getAllMutationBatchesAffectingDocumentKeys(t, n) {
    let i = new bt(Ye)
    const r = []
    return (
      n.forEach((s) => {
        const o = Sh(this.userId, s.path),
          a = IDBKeyRange.lowerBound(o),
          l = ja(t).J({ range: a }, (u, c, d) => {
            const [f, m, p] = u,
              v = rr(m)
            f === this.userId && s.path.isEqual(v) ? (i = i.add(p)) : d.done()
          })
        r.push(l)
      }),
      J.waitFor(r).next(() => this.Fn(t, i))
    )
  }
  getAllMutationBatchesAffectingQuery(t, n) {
    const i = n.path,
      r = i.length + 1,
      s = Sh(this.userId, i),
      o = IDBKeyRange.lowerBound(s)
    let a = new bt(Ye)
    return ja(t)
      .J({ range: o }, (l, u, c) => {
        const [d, f, m] = l,
          p = rr(f)
        d === this.userId && i.isPrefixOf(p) ? p.length === r && (a = a.add(m)) : c.done()
      })
      .next(() => this.Fn(t, a))
  }
  Fn(t, n) {
    const i = [],
      r = []
    return (
      n.forEach((s) => {
        r.push(
          os(t)
            .get(s)
            .next((o) => {
              if (o === null) throw Oe()
              Fe(o.userId === this.userId), i.push(fo(this.serializer, o))
            })
        )
      }),
      J.waitFor(r).next(() => i)
    )
  }
  removeMutationBatch(t, n) {
    return Ex(t._e, this.userId, n).next(
      (i) => (
        t.addOnCommittedListener(() => {
          this.Mn(n.batchId)
        }),
        J.forEach(i, (r) => this.referenceDelegate.markPotentiallyOrphaned(t, r))
      )
    )
  }
  Mn(t) {
    delete this.Cn[t]
  }
  performConsistencyCheck(t) {
    return this.checkEmpty(t).next((n) => {
      if (!n) return J.resolve()
      const i = IDBKeyRange.lowerBound(
          (function (o) {
            return [o]
          })(this.userId)
        ),
        r = []
      return ja(t)
        .J({ range: i }, (s, o, a) => {
          if (s[0] === this.userId) {
            const l = rr(s[1])
            r.push(l)
          } else a.done()
        })
        .next(() => {
          Fe(r.length === 0)
        })
    })
  }
  containsKey(t, n) {
    return Tx(t, this.userId, n)
  }
  xn(t) {
    return Cx(t)
      .get(this.userId)
      .next((n) => n || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: '' })
  }
}
function Tx(e, t, n) {
  const i = Sh(t, n.path),
    r = i[1],
    s = IDBKeyRange.lowerBound(i)
  let o = !1
  return ja(e)
    .J({ range: s, H: !0 }, (a, l, u) => {
      const [c, d, f] = a
      c === t && d === r && (o = !0), u.done()
    })
    .next(() => o)
}
function os(e) {
  return vn(e, 'mutations')
}
function ja(e) {
  return vn(e, 'documentMutations')
}
function Cx(e) {
  return vn(e, 'mutationQueues')
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class zo {
  constructor(t) {
    this.On = t
  }
  next() {
    return (this.On += 2), this.On
  }
  static Nn() {
    return new zo(0)
  }
  static Ln() {
    return new zo(-1)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class i5 {
  constructor(t, n) {
    ;(this.referenceDelegate = t), (this.serializer = n)
  }
  allocateTargetId(t) {
    return this.Bn(t).next((n) => {
      const i = new zo(n.highestTargetId)
      return (n.highestTargetId = i.next()), this.kn(t, n).next(() => n.highestTargetId)
    })
  }
  getLastRemoteSnapshotVersion(t) {
    return this.Bn(t).next((n) =>
      $e.fromTimestamp(new Dt(n.lastRemoteSnapshotVersion.seconds, n.lastRemoteSnapshotVersion.nanoseconds))
    )
  }
  getHighestSequenceNumber(t) {
    return this.Bn(t).next((n) => n.highestListenSequenceNumber)
  }
  setTargetsMetadata(t, n, i) {
    return this.Bn(t).next(
      (r) => (
        (r.highestListenSequenceNumber = n),
        i && (r.lastRemoteSnapshotVersion = i.toTimestamp()),
        n > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = n),
        this.kn(t, r)
      )
    )
  }
  addTargetData(t, n) {
    return this.qn(t, n).next(() => this.Bn(t).next((i) => ((i.targetCount += 1), this.Qn(n, i), this.kn(t, i))))
  }
  updateTargetData(t, n) {
    return this.qn(t, n)
  }
  removeTargetData(t, n) {
    return this.removeMatchingKeysForTargetId(t, n.targetId)
      .next(() => xa(t).delete(n.targetId))
      .next(() => this.Bn(t))
      .next((i) => (Fe(i.targetCount > 0), (i.targetCount -= 1), this.kn(t, i)))
  }
  removeTargets(t, n, i) {
    let r = 0
    const s = []
    return xa(t)
      .J((o, a) => {
        const l = Du(a)
        l.sequenceNumber <= n && i.get(l.targetId) === null && (r++, s.push(this.removeTargetData(t, l)))
      })
      .next(() => J.waitFor(s))
      .next(() => r)
  }
  forEachTarget(t, n) {
    return xa(t).J((i, r) => {
      const s = Du(r)
      n(s)
    })
  }
  Bn(t) {
    return u0(t)
      .get('targetGlobalKey')
      .next((n) => (Fe(n !== null), n))
  }
  kn(t, n) {
    return u0(t).put('targetGlobalKey', n)
  }
  qn(t, n) {
    return xa(t).put(bx(this.serializer, n))
  }
  Qn(t, n) {
    let i = !1
    return (
      t.targetId > n.highestTargetId && ((n.highestTargetId = t.targetId), (i = !0)),
      t.sequenceNumber > n.highestListenSequenceNumber &&
        ((n.highestListenSequenceNumber = t.sequenceNumber), (i = !0)),
      i
    )
  }
  getTargetCount(t) {
    return this.Bn(t).next((n) => n.targetCount)
  }
  getTargetData(t, n) {
    const i = $o(n),
      r = IDBKeyRange.bound([i, Number.NEGATIVE_INFINITY], [i, Number.POSITIVE_INFINITY])
    let s = null
    return xa(t)
      .J({ range: r, index: 'queryTargetsIndex' }, (o, a, l) => {
        const u = Du(a)
        Jc(n, u.target) && ((s = u), l.done())
      })
      .next(() => s)
  }
  addMatchingKeys(t, n, i) {
    const r = [],
      s = _s(t)
    return (
      n.forEach((o) => {
        const a = Yn(o.path)
        r.push(s.put({ targetId: i, path: a })), r.push(this.referenceDelegate.addReference(t, i, o))
      }),
      J.waitFor(r)
    )
  }
  removeMatchingKeys(t, n, i) {
    const r = _s(t)
    return J.forEach(n, (s) => {
      const o = Yn(s.path)
      return J.waitFor([r.delete([i, o]), this.referenceDelegate.removeReference(t, i, s)])
    })
  }
  removeMatchingKeysForTargetId(t, n) {
    const i = _s(t),
      r = IDBKeyRange.bound([n], [n + 1], !1, !0)
    return i.delete(r)
  }
  getMatchingKeysForTargetId(t, n) {
    const i = IDBKeyRange.bound([n], [n + 1], !1, !0),
      r = _s(t)
    let s = Qe()
    return r
      .J({ range: i, H: !0 }, (o, a, l) => {
        const u = rr(o[1]),
          c = new Re(u)
        s = s.add(c)
      })
      .next(() => s)
  }
  containsKey(t, n) {
    const i = Yn(n.path),
      r = IDBKeyRange.bound([i], [ER(i)], !1, !0)
    let s = 0
    return _s(t)
      .J({ index: 'documentTargetsIndex', H: !0, range: r }, ([o, a], l, u) => {
        o !== 0 && (s++, u.done())
      })
      .next(() => s > 0)
  }
  ot(t, n) {
    return xa(t)
      .get(n)
      .next((i) => (i ? Du(i) : null))
  }
}
function xa(e) {
  return vn(e, 'targets')
}
function u0(e) {
  return vn(e, 'targetGlobal')
}
function _s(e) {
  return vn(e, 'targetDocuments')
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function c0([e, t], [n, i]) {
  const r = Ye(e, n)
  return r === 0 ? Ye(t, i) : r
}
class r5 {
  constructor(t) {
    ;(this.Kn = t), (this.buffer = new bt(c0)), (this.$n = 0)
  }
  Un() {
    return ++this.$n
  }
  Wn(t) {
    const n = [t, this.Un()]
    if (this.buffer.size < this.Kn) this.buffer = this.buffer.add(n)
    else {
      const i = this.buffer.last()
      c0(n, i) < 0 && (this.buffer = this.buffer.delete(i).add(n))
    }
  }
  get maxValue() {
    return this.buffer.last()[0]
  }
}
class s5 {
  constructor(t, n, i) {
    ;(this.garbageCollector = t), (this.asyncQueue = n), (this.localStore = i), (this.Gn = null)
  }
  start() {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.zn(6e4)
  }
  stop() {
    this.Gn && (this.Gn.cancel(), (this.Gn = null))
  }
  get started() {
    return this.Gn !== null
  }
  zn(t) {
    we('LruGarbageCollector', `Garbage collection scheduled in ${t}ms`),
      (this.Gn = this.asyncQueue.enqueueAfterDelay('lru_garbage_collection', t, async () => {
        this.Gn = null
        try {
          await this.localStore.collectGarbage(this.garbageCollector)
        } catch (n) {
          Ws(n) ? we('LruGarbageCollector', 'Ignoring IndexedDB error during garbage collection: ', n) : await aa(n)
        }
        await this.zn(3e5)
      }))
  }
}
class o5 {
  constructor(t, n) {
    ;(this.jn = t), (this.params = n)
  }
  calculateTargetCount(t, n) {
    return this.jn.Hn(t).next((i) => Math.floor((n / 100) * i))
  }
  nthSequenceNumber(t, n) {
    if (n === 0) return J.resolve(Ci.oe)
    const i = new r5(n)
    return this.jn
      .forEachTarget(t, (r) => i.Wn(r.sequenceNumber))
      .next(() => this.jn.Jn(t, (r) => i.Wn(r)))
      .next(() => i.maxValue)
  }
  removeTargets(t, n, i) {
    return this.jn.removeTargets(t, n, i)
  }
  removeOrphanedDocuments(t, n) {
    return this.jn.removeOrphanedDocuments(t, n)
  }
  collect(t, n) {
    return this.params.cacheSizeCollectionThreshold === -1
      ? (we('LruGarbageCollector', 'Garbage collection skipped; disabled'), J.resolve(l0))
      : this.getCacheSize(t).next((i) =>
          i < this.params.cacheSizeCollectionThreshold
            ? (we(
                'LruGarbageCollector',
                `Garbage collection skipped; Cache size ${i} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`
              ),
              l0)
            : this.Yn(t, n)
        )
  }
  getCacheSize(t) {
    return this.jn.getCacheSize(t)
  }
  Yn(t, n) {
    let i, r, s, o, a, l, u
    const c = Date.now()
    return this.calculateTargetCount(t, this.params.percentileToCollect)
      .next(
        (d) => (
          d > this.params.maximumSequenceNumbersToCollect
            ? (we(
                'LruGarbageCollector',
                `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${d}`
              ),
              (r = this.params.maximumSequenceNumbersToCollect))
            : (r = d),
          (o = Date.now()),
          this.nthSequenceNumber(t, r)
        )
      )
      .next((d) => ((i = d), (a = Date.now()), this.removeTargets(t, i, n)))
      .next((d) => ((s = d), (l = Date.now()), this.removeOrphanedDocuments(t, i)))
      .next(
        (d) => (
          (u = Date.now()),
          Fa() <= Je.DEBUG &&
            we(
              'LruGarbageCollector',
              `LRU Garbage Collection
	Counted targets in ${o - c}ms
	Determined least recently used ${r} in ` +
                (a - o) +
                `ms
	Removed ${s} targets in ` +
                (l - a) +
                `ms
	Removed ${d} documents in ` +
                (u - l) +
                `ms
Total Duration: ${u - c}ms`
            ),
          J.resolve({ didRun: !0, sequenceNumbersCollected: r, targetsRemoved: s, documentsRemoved: d })
        )
      )
  }
}
function a5(e, t) {
  return new o5(e, t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class l5 {
  constructor(t, n) {
    ;(this.db = t), (this.garbageCollector = a5(this, n))
  }
  Hn(t) {
    const n = this.Zn(t)
    return this.db
      .getTargetCache()
      .getTargetCount(t)
      .next((i) => n.next((r) => i + r))
  }
  Zn(t) {
    let n = 0
    return this.Jn(t, (i) => {
      n++
    }).next(() => n)
  }
  forEachTarget(t, n) {
    return this.db.getTargetCache().forEachTarget(t, n)
  }
  Jn(t, n) {
    return this.Xn(t, (i, r) => n(r))
  }
  addReference(t, n, i) {
    return eh(t, i)
  }
  removeReference(t, n, i) {
    return eh(t, i)
  }
  removeTargets(t, n, i) {
    return this.db.getTargetCache().removeTargets(t, n, i)
  }
  markPotentiallyOrphaned(t, n) {
    return eh(t, n)
  }
  er(t, n) {
    return (function (r, s) {
      let o = !1
      return Cx(r)
        .Y((a) => Tx(r, a, s).next((l) => (l && (o = !0), J.resolve(!l))))
        .next(() => o)
    })(t, n)
  }
  removeOrphanedDocuments(t, n) {
    const i = this.db.getRemoteDocumentCache().newChangeBuffer(),
      r = []
    let s = 0
    return this.Xn(t, (o, a) => {
      if (a <= n) {
        const l = this.er(t, o).next((u) => {
          if (!u)
            return (
              s++,
              i.getEntry(t, o).next(
                () => (
                  i.removeEntry(o, $e.min()),
                  _s(t).delete(
                    (function (d) {
                      return [0, Yn(d.path)]
                    })(o)
                  )
                )
              )
            )
        })
        r.push(l)
      }
    })
      .next(() => J.waitFor(r))
      .next(() => i.apply(t))
      .next(() => s)
  }
  removeTarget(t, n) {
    const i = n.withSequenceNumber(t.currentSequenceNumber)
    return this.db.getTargetCache().updateTargetData(t, i)
  }
  updateLimboDocument(t, n) {
    return eh(t, n)
  }
  Xn(t, n) {
    const i = _s(t)
    let r,
      s = Ci.oe
    return i
      .J({ index: 'documentTargetsIndex' }, ([o, a], { path: l, sequenceNumber: u }) => {
        o === 0 ? (s !== Ci.oe && n(new Re(rr(r)), s), (s = u), (r = l)) : (s = Ci.oe)
      })
      .next(() => {
        s !== Ci.oe && n(new Re(rr(r)), s)
      })
  }
  getCacheSize(t) {
    return this.db.getRemoteDocumentCache().getSize(t)
  }
}
function eh(e, t) {
  return _s(e).put(
    (function (i, r) {
      return { targetId: 0, path: Yn(i.path), sequenceNumber: r }
    })(t, e.currentSequenceNumber)
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ax {
  constructor() {
    ;(this.changes = new qs(
      (t) => t.toString(),
      (t, n) => t.isEqual(n)
    )),
      (this.changesApplied = !1)
  }
  addEntry(t) {
    this.assertNotApplied(), this.changes.set(t.key, t)
  }
  removeEntry(t, n) {
    this.assertNotApplied(), this.changes.set(t, Wt.newInvalidDocument(t).setReadTime(n))
  }
  getEntry(t, n) {
    this.assertNotApplied()
    const i = this.changes.get(n)
    return i !== void 0 ? J.resolve(i) : this.getFromCache(t, n)
  }
  getEntries(t, n) {
    return this.getAllFromCache(t, n)
  }
  apply(t) {
    return this.assertNotApplied(), (this.changesApplied = !0), this.applyChanges(t)
  }
  assertNotApplied() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class u5 {
  constructor(t) {
    this.serializer = t
  }
  setIndexManager(t) {
    this.indexManager = t
  }
  addEntry(t, n, i) {
    return io(t).put(i)
  }
  removeEntry(t, n, i) {
    return io(t).delete(
      (function (s, o) {
        const a = s.path.toArray()
        return [a.slice(0, a.length - 2), a[a.length - 2], cf(o), a[a.length - 1]]
      })(n, i)
    )
  }
  updateMetadata(t, n) {
    return this.getMetadata(t).next((i) => ((i.byteSize += n), this.tr(t, i)))
  }
  getEntry(t, n) {
    let i = Wt.newInvalidDocument(n)
    return io(t)
      .J({ index: 'documentKeyIndex', range: IDBKeyRange.only(bu(n)) }, (r, s) => {
        i = this.nr(n, s)
      })
      .next(() => i)
  }
  rr(t, n) {
    let i = { size: 0, document: Wt.newInvalidDocument(n) }
    return io(t)
      .J({ index: 'documentKeyIndex', range: IDBKeyRange.only(bu(n)) }, (r, s) => {
        i = { document: this.nr(n, s), size: hf(s) }
      })
      .next(() => i)
  }
  getEntries(t, n) {
    let i = ci()
    return this.ir(t, n, (r, s) => {
      const o = this.nr(r, s)
      i = i.insert(r, o)
    }).next(() => i)
  }
  sr(t, n) {
    let i = ci(),
      r = new Nt(Re.comparator)
    return this.ir(t, n, (s, o) => {
      const a = this.nr(s, o)
      ;(i = i.insert(s, a)), (r = r.insert(s, hf(o)))
    }).next(() => ({ documents: i, _r: r }))
  }
  ir(t, n, i) {
    if (n.isEmpty()) return J.resolve()
    let r = new bt(f0)
    n.forEach((l) => (r = r.add(l)))
    const s = IDBKeyRange.bound(bu(r.first()), bu(r.last())),
      o = r.getIterator()
    let a = o.getNext()
    return io(t)
      .J({ index: 'documentKeyIndex', range: s }, (l, u, c) => {
        const d = Re.fromSegments([...u.prefixPath, u.collectionGroup, u.documentId])
        for (; a && f0(a, d) < 0; ) i(a, null), (a = o.getNext())
        a && a.isEqual(d) && (i(a, u), (a = o.hasNext() ? o.getNext() : null)), a ? c.$(bu(a)) : c.done()
      })
      .next(() => {
        for (; a; ) i(a, null), (a = o.hasNext() ? o.getNext() : null)
      })
  }
  getDocumentsMatchingQuery(t, n, i, r, s) {
    const o = n.path,
      a = [
        o.popLast().toArray(),
        o.lastSegment(),
        cf(i.readTime),
        i.documentKey.path.isEmpty() ? '' : i.documentKey.path.lastSegment(),
      ],
      l = [o.popLast().toArray(), o.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], '']
    return io(t)
      .U(IDBKeyRange.bound(a, l, !0))
      .next((u) => {
        s == null || s.incrementDocumentReadCount(u.length)
        let c = ci()
        for (const d of u) {
          const f = this.nr(Re.fromSegments(d.prefixPath.concat(d.collectionGroup, d.documentId)), d)
          f.isFoundDocument() && (ed(n, f) || r.has(f.key)) && (c = c.insert(f.key, f))
        }
        return c
      })
  }
  getAllFromCollectionGroup(t, n, i, r) {
    let s = ci()
    const o = h0(n, i),
      a = h0(n, vi.max())
    return io(t)
      .J({ index: 'collectionGroupIndex', range: IDBKeyRange.bound(o, a, !0) }, (l, u, c) => {
        const d = this.nr(Re.fromSegments(u.prefixPath.concat(u.collectionGroup, u.documentId)), u)
        ;(s = s.insert(d.key, d)), s.size === r && c.done()
      })
      .next(() => s)
  }
  newChangeBuffer(t) {
    return new c5(this, !!t && t.trackRemovals)
  }
  getSize(t) {
    return this.getMetadata(t).next((n) => n.byteSize)
  }
  getMetadata(t) {
    return d0(t)
      .get('remoteDocumentGlobalKey')
      .next((n) => (Fe(!!n), n))
  }
  tr(t, n) {
    return d0(t).put('remoteDocumentGlobalKey', n)
  }
  nr(t, n) {
    if (n) {
      const i = K6(this.serializer, n)
      if (!(i.isNoDocument() && i.version.isEqual($e.min()))) return i
    }
    return Wt.newInvalidDocument(t)
  }
}
function kx(e) {
  return new u5(e)
}
class c5 extends Ax {
  constructor(t, n) {
    super(),
      (this.ar = t),
      (this.trackRemovals = n),
      (this.ur = new qs(
        (i) => i.toString(),
        (i, r) => i.isEqual(r)
      ))
  }
  applyChanges(t) {
    const n = []
    let i = 0,
      r = new bt((s, o) => Ye(s.canonicalString(), o.canonicalString()))
    return (
      this.changes.forEach((s, o) => {
        const a = this.ur.get(s)
        if ((n.push(this.ar.removeEntry(t, s, a.readTime)), o.isValidDocument())) {
          const l = XE(this.ar.serializer, o)
          r = r.add(s.path.popLast())
          const u = hf(l)
          ;(i += u - a.size), n.push(this.ar.addEntry(t, s, l))
        } else if (((i -= a.size), this.trackRemovals)) {
          const l = XE(this.ar.serializer, o.convertToNoDocument($e.min()))
          n.push(this.ar.addEntry(t, s, l))
        }
      }),
      r.forEach((s) => {
        n.push(this.ar.indexManager.addToCollectionParentIndex(t, s))
      }),
      n.push(this.ar.updateMetadata(t, i)),
      J.waitFor(n)
    )
  }
  getFromCache(t, n) {
    return this.ar.rr(t, n).next((i) => (this.ur.set(n, { size: i.size, readTime: i.document.readTime }), i.document))
  }
  getAllFromCache(t, n) {
    return this.ar.sr(t, n).next(
      ({ documents: i, _r: r }) => (
        r.forEach((s, o) => {
          this.ur.set(s, { size: o, readTime: i.get(s).readTime })
        }),
        i
      )
    )
  }
}
function d0(e) {
  return vn(e, 'remoteDocumentGlobal')
}
function io(e) {
  return vn(e, 'remoteDocumentsV14')
}
function bu(e) {
  const t = e.path.toArray()
  return [t.slice(0, t.length - 2), t[t.length - 2], t[t.length - 1]]
}
function h0(e, t) {
  const n = t.documentKey.path.toArray()
  return [e, cf(t.readTime), n.slice(0, n.length - 2), n.length > 0 ? n[n.length - 1] : '']
}
function f0(e, t) {
  const n = e.path.toArray(),
    i = t.path.toArray()
  let r = 0
  for (let s = 0; s < n.length - 2 && s < i.length - 2; ++s) if (((r = Ye(n[s], i[s])), r)) return r
  return (
    (r = Ye(n.length, i.length)),
    r || ((r = Ye(n[n.length - 2], i[i.length - 2])), r || Ye(n[n.length - 1], i[i.length - 1]))
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class d5 {
  constructor(t, n) {
    ;(this.overlayedDocument = t), (this.mutatedFields = n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Px {
  constructor(t, n, i, r) {
    ;(this.remoteDocumentCache = t), (this.mutationQueue = n), (this.documentOverlayCache = i), (this.indexManager = r)
  }
  getDocument(t, n) {
    let i = null
    return this.documentOverlayCache
      .getOverlay(t, n)
      .next((r) => ((i = r), this.remoteDocumentCache.getEntry(t, n)))
      .next((r) => (i !== null && Xu(i.mutation, r, ti.empty(), Dt.now()), r))
  }
  getDocuments(t, n) {
    return this.remoteDocumentCache.getEntries(t, n).next((i) => this.getLocalViewOfDocuments(t, i, Qe()).next(() => i))
  }
  getLocalViewOfDocuments(t, n, i = Qe()) {
    const r = sr()
    return this.populateOverlays(t, r, n).next(() =>
      this.computeViews(t, n, r, i).next((s) => {
        let o = xu()
        return (
          s.forEach((a, l) => {
            o = o.insert(a, l.overlayedDocument)
          }),
          o
        )
      })
    )
  }
  getOverlayedDocuments(t, n) {
    const i = sr()
    return this.populateOverlays(t, i, n).next(() => this.computeViews(t, n, i, Qe()))
  }
  populateOverlays(t, n, i) {
    const r = []
    return (
      i.forEach((s) => {
        n.has(s) || r.push(s)
      }),
      this.documentOverlayCache.getOverlays(t, r).next((s) => {
        s.forEach((o, a) => {
          n.set(o, a)
        })
      })
    )
  }
  computeViews(t, n, i, r) {
    let s = ci()
    const o = Qu(),
      a = (function () {
        return Qu()
      })()
    return (
      n.forEach((l, u) => {
        const c = i.get(u.key)
        r.has(u.key) && (c === void 0 || c.mutation instanceof Gr)
          ? (s = s.insert(u.key, u))
          : c !== void 0
          ? (o.set(u.key, c.mutation.getFieldMask()), Xu(c.mutation, u, c.mutation.getFieldMask(), Dt.now()))
          : o.set(u.key, ti.empty())
      }),
      this.recalculateAndSaveOverlays(t, s).next(
        (l) => (
          l.forEach((u, c) => o.set(u, c)),
          n.forEach((u, c) => {
            var d
            return a.set(u, new d5(c, (d = o.get(u)) !== null && d !== void 0 ? d : null))
          }),
          a
        )
      )
    )
  }
  recalculateAndSaveOverlays(t, n) {
    const i = Qu()
    let r = new Nt((o, a) => o - a),
      s = Qe()
    return this.mutationQueue
      .getAllMutationBatchesAffectingDocumentKeys(t, n)
      .next((o) => {
        for (const a of o)
          a.keys().forEach((l) => {
            const u = n.get(l)
            if (u === null) return
            let c = i.get(l) || ti.empty()
            ;(c = a.applyToLocalView(u, c)), i.set(l, c)
            const d = (r.get(a.batchId) || Qe()).add(l)
            r = r.insert(a.batchId, d)
          })
      })
      .next(() => {
        const o = [],
          a = r.getReverseIterator()
        for (; a.hasNext(); ) {
          const l = a.getNext(),
            u = l.key,
            c = l.value,
            d = YR()
          c.forEach((f) => {
            if (!s.has(f)) {
              const m = nx(n.get(f), i.get(f))
              m !== null && d.set(f, m), (s = s.add(f))
            }
          }),
            o.push(this.documentOverlayCache.saveOverlays(t, u, d))
        }
        return J.waitFor(o)
      })
      .next(() => i)
  }
  recalculateAndSaveOverlaysForDocumentKeys(t, n) {
    return this.remoteDocumentCache.getEntries(t, n).next((i) => this.recalculateAndSaveOverlays(t, i))
  }
  getDocumentsMatchingQuery(t, n, i, r) {
    return (function (o) {
      return Re.isDocumentKey(o.path) && o.collectionGroup === null && o.filters.length === 0
    })(n)
      ? this.getDocumentsMatchingDocumentQuery(t, n.path)
      : f6(n)
      ? this.getDocumentsMatchingCollectionGroupQuery(t, n, i, r)
      : this.getDocumentsMatchingCollectionQuery(t, n, i, r)
  }
  getNextDocuments(t, n, i, r) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t, n, i, r).next((s) => {
      const o =
        r - s.size > 0
          ? this.documentOverlayCache.getOverlaysForCollectionGroup(t, n, i.largestBatchId, r - s.size)
          : J.resolve(sr())
      let a = -1,
        l = s
      return o.next((u) =>
        J.forEach(
          u,
          (c, d) => (
            a < d.largestBatchId && (a = d.largestBatchId),
            s.get(c)
              ? J.resolve()
              : this.remoteDocumentCache.getEntry(t, c).next((f) => {
                  l = l.insert(c, f)
                })
          )
        )
          .next(() => this.populateOverlays(t, u, s))
          .next(() => this.computeViews(t, l, u, Qe()))
          .next((c) => ({ batchId: a, changes: KR(c) }))
      )
    })
  }
  getDocumentsMatchingDocumentQuery(t, n) {
    return this.getDocument(t, new Re(n)).next((i) => {
      let r = xu()
      return i.isFoundDocument() && (r = r.insert(i.key, i)), r
    })
  }
  getDocumentsMatchingCollectionGroupQuery(t, n, i, r) {
    const s = n.collectionGroup
    let o = xu()
    return this.indexManager.getCollectionParents(t, s).next((a) =>
      J.forEach(a, (l) => {
        const u = (function (d, f) {
          return new rm(f, null, d.explicitOrderBy.slice(), d.filters.slice(), d.limit, d.limitType, d.startAt, d.endAt)
        })(n, l.child(s))
        return this.getDocumentsMatchingCollectionQuery(t, u, i, r).next((c) => {
          c.forEach((d, f) => {
            o = o.insert(d, f)
          })
        })
      }).next(() => o)
    )
  }
  getDocumentsMatchingCollectionQuery(t, n, i, r) {
    let s
    return this.documentOverlayCache
      .getOverlaysForCollection(t, n.path, i.largestBatchId)
      .next((o) => ((s = o), this.remoteDocumentCache.getDocumentsMatchingQuery(t, n, i, s, r)))
      .next((o) => {
        s.forEach((l, u) => {
          const c = u.getKey()
          o.get(c) === null && (o = o.insert(c, Wt.newInvalidDocument(c)))
        })
        let a = xu()
        return (
          o.forEach((l, u) => {
            const c = s.get(l)
            c !== void 0 && Xu(c.mutation, u, ti.empty(), Dt.now()), ed(n, u) && (a = a.insert(l, u))
          }),
          a
        )
      })
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class h5 {
  constructor(t) {
    ;(this.serializer = t), (this.cr = new Map()), (this.lr = new Map())
  }
  getBundleMetadata(t, n) {
    return J.resolve(this.cr.get(n))
  }
  saveBundleMetadata(t, n) {
    return (
      this.cr.set(
        n.id,
        (function (r) {
          return { id: r.id, version: r.version, createTime: Qn(r.createTime) }
        })(n)
      ),
      J.resolve()
    )
  }
  getNamedQuery(t, n) {
    return J.resolve(this.lr.get(n))
  }
  saveNamedQuery(t, n) {
    return (
      this.lr.set(
        n.name,
        (function (r) {
          return { name: r.name, query: wx(r.bundledQuery), readTime: Qn(r.readTime) }
        })(n)
      ),
      J.resolve()
    )
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class f5 {
  constructor() {
    ;(this.overlays = new Nt(Re.comparator)), (this.hr = new Map())
  }
  getOverlay(t, n) {
    return J.resolve(this.overlays.get(n))
  }
  getOverlays(t, n) {
    const i = sr()
    return J.forEach(n, (r) =>
      this.getOverlay(t, r).next((s) => {
        s !== null && i.set(r, s)
      })
    ).next(() => i)
  }
  saveOverlays(t, n, i) {
    return (
      i.forEach((r, s) => {
        this.ht(t, n, s)
      }),
      J.resolve()
    )
  }
  removeOverlaysForBatchId(t, n, i) {
    const r = this.hr.get(i)
    return r !== void 0 && (r.forEach((s) => (this.overlays = this.overlays.remove(s))), this.hr.delete(i)), J.resolve()
  }
  getOverlaysForCollection(t, n, i) {
    const r = sr(),
      s = n.length + 1,
      o = new Re(n.child('')),
      a = this.overlays.getIteratorFrom(o)
    for (; a.hasNext(); ) {
      const l = a.getNext().value,
        u = l.getKey()
      if (!n.isPrefixOf(u.path)) break
      u.path.length === s && l.largestBatchId > i && r.set(l.getKey(), l)
    }
    return J.resolve(r)
  }
  getOverlaysForCollectionGroup(t, n, i, r) {
    let s = new Nt((u, c) => u - c)
    const o = this.overlays.getIterator()
    for (; o.hasNext(); ) {
      const u = o.getNext().value
      if (u.getKey().getCollectionGroup() === n && u.largestBatchId > i) {
        let c = s.get(u.largestBatchId)
        c === null && ((c = sr()), (s = s.insert(u.largestBatchId, c))), c.set(u.getKey(), u)
      }
    }
    const a = sr(),
      l = s.getIterator()
    for (; l.hasNext() && (l.getNext().value.forEach((u, c) => a.set(u, c)), !(a.size() >= r)); );
    return J.resolve(a)
  }
  ht(t, n, i) {
    const r = this.overlays.get(i.key)
    if (r !== null) {
      const o = this.hr.get(r.largestBatchId).delete(i.key)
      this.hr.set(r.largestBatchId, o)
    }
    this.overlays = this.overlays.insert(i.key, new F_(n, i))
    let s = this.hr.get(n)
    s === void 0 && ((s = Qe()), this.hr.set(n, s)), this.hr.set(n, s.add(i.key))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class z_ {
  constructor() {
    ;(this.Pr = new bt(cn.Ir)), (this.Tr = new bt(cn.Er))
  }
  isEmpty() {
    return this.Pr.isEmpty()
  }
  addReference(t, n) {
    const i = new cn(t, n)
    ;(this.Pr = this.Pr.add(i)), (this.Tr = this.Tr.add(i))
  }
  dr(t, n) {
    t.forEach((i) => this.addReference(i, n))
  }
  removeReference(t, n) {
    this.Ar(new cn(t, n))
  }
  Rr(t, n) {
    t.forEach((i) => this.removeReference(i, n))
  }
  Vr(t) {
    const n = new Re(new pt([])),
      i = new cn(n, t),
      r = new cn(n, t + 1),
      s = []
    return (
      this.Tr.forEachInRange([i, r], (o) => {
        this.Ar(o), s.push(o.key)
      }),
      s
    )
  }
  mr() {
    this.Pr.forEach((t) => this.Ar(t))
  }
  Ar(t) {
    ;(this.Pr = this.Pr.delete(t)), (this.Tr = this.Tr.delete(t))
  }
  gr(t) {
    const n = new Re(new pt([])),
      i = new cn(n, t),
      r = new cn(n, t + 1)
    let s = Qe()
    return (
      this.Tr.forEachInRange([i, r], (o) => {
        s = s.add(o.key)
      }),
      s
    )
  }
  containsKey(t) {
    const n = new cn(t, 0),
      i = this.Pr.firstAfterOrEqual(n)
    return i !== null && t.isEqual(i.key)
  }
}
class cn {
  constructor(t, n) {
    ;(this.key = t), (this.pr = n)
  }
  static Ir(t, n) {
    return Re.comparator(t.key, n.key) || Ye(t.pr, n.pr)
  }
  static Er(t, n) {
    return Ye(t.pr, n.pr) || Re.comparator(t.key, n.key)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class m5 {
  constructor(t, n) {
    ;(this.indexManager = t),
      (this.referenceDelegate = n),
      (this.mutationQueue = []),
      (this.yr = 1),
      (this.wr = new bt(cn.Ir))
  }
  checkEmpty(t) {
    return J.resolve(this.mutationQueue.length === 0)
  }
  addMutationBatch(t, n, i, r) {
    const s = this.yr
    this.yr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1]
    const o = new M_(s, n, i, r)
    this.mutationQueue.push(o)
    for (const a of r)
      (this.wr = this.wr.add(new cn(a.key, s))), this.indexManager.addToCollectionParentIndex(t, a.key.path.popLast())
    return J.resolve(o)
  }
  lookupMutationBatch(t, n) {
    return J.resolve(this.Sr(n))
  }
  getNextMutationBatchAfterBatchId(t, n) {
    const i = n + 1,
      r = this.br(i),
      s = r < 0 ? 0 : r
    return J.resolve(this.mutationQueue.length > s ? this.mutationQueue[s] : null)
  }
  getHighestUnacknowledgedBatchId() {
    return J.resolve(this.mutationQueue.length === 0 ? -1 : this.yr - 1)
  }
  getAllMutationBatches(t) {
    return J.resolve(this.mutationQueue.slice())
  }
  getAllMutationBatchesAffectingDocumentKey(t, n) {
    const i = new cn(n, 0),
      r = new cn(n, Number.POSITIVE_INFINITY),
      s = []
    return (
      this.wr.forEachInRange([i, r], (o) => {
        const a = this.Sr(o.pr)
        s.push(a)
      }),
      J.resolve(s)
    )
  }
  getAllMutationBatchesAffectingDocumentKeys(t, n) {
    let i = new bt(Ye)
    return (
      n.forEach((r) => {
        const s = new cn(r, 0),
          o = new cn(r, Number.POSITIVE_INFINITY)
        this.wr.forEachInRange([s, o], (a) => {
          i = i.add(a.pr)
        })
      }),
      J.resolve(this.Dr(i))
    )
  }
  getAllMutationBatchesAffectingQuery(t, n) {
    const i = n.path,
      r = i.length + 1
    let s = i
    Re.isDocumentKey(s) || (s = s.child(''))
    const o = new cn(new Re(s), 0)
    let a = new bt(Ye)
    return (
      this.wr.forEachWhile((l) => {
        const u = l.key.path
        return !!i.isPrefixOf(u) && (u.length === r && (a = a.add(l.pr)), !0)
      }, o),
      J.resolve(this.Dr(a))
    )
  }
  Dr(t) {
    const n = []
    return (
      t.forEach((i) => {
        const r = this.Sr(i)
        r !== null && n.push(r)
      }),
      n
    )
  }
  removeMutationBatch(t, n) {
    Fe(this.Cr(n.batchId, 'removed') === 0), this.mutationQueue.shift()
    let i = this.wr
    return J.forEach(n.mutations, (r) => {
      const s = new cn(r.key, n.batchId)
      return (i = i.delete(s)), this.referenceDelegate.markPotentiallyOrphaned(t, r.key)
    }).next(() => {
      this.wr = i
    })
  }
  Mn(t) {}
  containsKey(t, n) {
    const i = new cn(n, 0),
      r = this.wr.firstAfterOrEqual(i)
    return J.resolve(n.isEqual(r && r.key))
  }
  performConsistencyCheck(t) {
    return this.mutationQueue.length, J.resolve()
  }
  Cr(t, n) {
    return this.br(t)
  }
  br(t) {
    return this.mutationQueue.length === 0 ? 0 : t - this.mutationQueue[0].batchId
  }
  Sr(t) {
    const n = this.br(t)
    return n < 0 || n >= this.mutationQueue.length ? null : this.mutationQueue[n]
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class g5 {
  constructor(t) {
    ;(this.vr = t),
      (this.docs = (function () {
        return new Nt(Re.comparator)
      })()),
      (this.size = 0)
  }
  setIndexManager(t) {
    this.indexManager = t
  }
  addEntry(t, n) {
    const i = n.key,
      r = this.docs.get(i),
      s = r ? r.size : 0,
      o = this.vr(n)
    return (
      (this.docs = this.docs.insert(i, { document: n.mutableCopy(), size: o })),
      (this.size += o - s),
      this.indexManager.addToCollectionParentIndex(t, i.path.popLast())
    )
  }
  removeEntry(t) {
    const n = this.docs.get(t)
    n && ((this.docs = this.docs.remove(t)), (this.size -= n.size))
  }
  getEntry(t, n) {
    const i = this.docs.get(n)
    return J.resolve(i ? i.document.mutableCopy() : Wt.newInvalidDocument(n))
  }
  getEntries(t, n) {
    let i = ci()
    return (
      n.forEach((r) => {
        const s = this.docs.get(r)
        i = i.insert(r, s ? s.document.mutableCopy() : Wt.newInvalidDocument(r))
      }),
      J.resolve(i)
    )
  }
  getDocumentsMatchingQuery(t, n, i, r) {
    let s = ci()
    const o = n.path,
      a = new Re(o.child('')),
      l = this.docs.getIteratorFrom(a)
    for (; l.hasNext(); ) {
      const {
        key: u,
        value: { document: c },
      } = l.getNext()
      if (!o.isPrefixOf(u.path)) break
      u.path.length > o.length + 1 ||
        R_(TR(c), i) <= 0 ||
        ((r.has(c.key) || ed(n, c)) && (s = s.insert(c.key, c.mutableCopy())))
    }
    return J.resolve(s)
  }
  getAllFromCollectionGroup(t, n, i, r) {
    Oe()
  }
  Fr(t, n) {
    return J.forEach(this.docs, (i) => n(i))
  }
  newChangeBuffer(t) {
    return new v5(this)
  }
  getSize(t) {
    return J.resolve(this.size)
  }
}
class v5 extends Ax {
  constructor(t) {
    super(), (this.ar = t)
  }
  applyChanges(t) {
    const n = []
    return (
      this.changes.forEach((i, r) => {
        r.isValidDocument() ? n.push(this.ar.addEntry(t, r)) : this.ar.removeEntry(i)
      }),
      J.waitFor(n)
    )
  }
  getFromCache(t, n) {
    return this.ar.getEntry(t, n)
  }
  getAllFromCache(t, n) {
    return this.ar.getEntries(t, n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class p5 {
  constructor(t) {
    ;(this.persistence = t),
      (this.Mr = new qs((n) => $o(n), Jc)),
      (this.lastRemoteSnapshotVersion = $e.min()),
      (this.highestTargetId = 0),
      (this.Or = 0),
      (this.Nr = new z_()),
      (this.targetCount = 0),
      (this.Lr = zo.Nn())
  }
  forEachTarget(t, n) {
    return this.Mr.forEach((i, r) => n(r)), J.resolve()
  }
  getLastRemoteSnapshotVersion(t) {
    return J.resolve(this.lastRemoteSnapshotVersion)
  }
  getHighestSequenceNumber(t) {
    return J.resolve(this.Or)
  }
  allocateTargetId(t) {
    return (this.highestTargetId = this.Lr.next()), J.resolve(this.highestTargetId)
  }
  setTargetsMetadata(t, n, i) {
    return i && (this.lastRemoteSnapshotVersion = i), n > this.Or && (this.Or = n), J.resolve()
  }
  qn(t) {
    this.Mr.set(t.target, t)
    const n = t.targetId
    n > this.highestTargetId && ((this.Lr = new zo(n)), (this.highestTargetId = n)),
      t.sequenceNumber > this.Or && (this.Or = t.sequenceNumber)
  }
  addTargetData(t, n) {
    return this.qn(n), (this.targetCount += 1), J.resolve()
  }
  updateTargetData(t, n) {
    return this.qn(n), J.resolve()
  }
  removeTargetData(t, n) {
    return this.Mr.delete(n.target), this.Nr.Vr(n.targetId), (this.targetCount -= 1), J.resolve()
  }
  removeTargets(t, n, i) {
    let r = 0
    const s = []
    return (
      this.Mr.forEach((o, a) => {
        a.sequenceNumber <= n &&
          i.get(a.targetId) === null &&
          (this.Mr.delete(o), s.push(this.removeMatchingKeysForTargetId(t, a.targetId)), r++)
      }),
      J.waitFor(s).next(() => r)
    )
  }
  getTargetCount(t) {
    return J.resolve(this.targetCount)
  }
  getTargetData(t, n) {
    const i = this.Mr.get(n) || null
    return J.resolve(i)
  }
  addMatchingKeys(t, n, i) {
    return this.Nr.dr(n, i), J.resolve()
  }
  removeMatchingKeys(t, n, i) {
    this.Nr.Rr(n, i)
    const r = this.persistence.referenceDelegate,
      s = []
    return (
      r &&
        n.forEach((o) => {
          s.push(r.markPotentiallyOrphaned(t, o))
        }),
      J.waitFor(s)
    )
  }
  removeMatchingKeysForTargetId(t, n) {
    return this.Nr.Vr(n), J.resolve()
  }
  getMatchingKeysForTargetId(t, n) {
    const i = this.Nr.gr(n)
    return J.resolve(i)
  }
  containsKey(t, n) {
    return J.resolve(this.Nr.containsKey(n))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Rx {
  constructor(t, n) {
    ;(this.Br = {}),
      (this.overlays = {}),
      (this.kr = new Ci(0)),
      (this.qr = !1),
      (this.qr = !0),
      (this.referenceDelegate = t(this)),
      (this.Qr = new p5(this)),
      (this.indexManager = new t5()),
      (this.remoteDocumentCache = (function (r) {
        return new g5(r)
      })((i) => this.referenceDelegate.Kr(i))),
      (this.serializer = new _x(n)),
      (this.$r = new h5(this.serializer))
  }
  start() {
    return Promise.resolve()
  }
  shutdown() {
    return (this.qr = !1), Promise.resolve()
  }
  get started() {
    return this.qr
  }
  setDatabaseDeletedListener() {}
  setNetworkEnabled() {}
  getIndexManager(t) {
    return this.indexManager
  }
  getDocumentOverlayCache(t) {
    let n = this.overlays[t.toKey()]
    return n || ((n = new f5()), (this.overlays[t.toKey()] = n)), n
  }
  getMutationQueue(t, n) {
    let i = this.Br[t.toKey()]
    return i || ((i = new m5(n, this.referenceDelegate)), (this.Br[t.toKey()] = i)), i
  }
  getTargetCache() {
    return this.Qr
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache
  }
  getBundleCache() {
    return this.$r
  }
  runTransaction(t, n, i) {
    we('MemoryPersistence', 'Starting transaction:', t)
    const r = new y5(this.kr.next())
    return (
      this.referenceDelegate.Ur(),
      i(r)
        .next((s) => this.referenceDelegate.Wr(r).next(() => s))
        .toPromise()
        .then((s) => (r.raiseOnCommittedEvent(), s))
    )
  }
  Gr(t, n) {
    return J.or(Object.values(this.Br).map((i) => () => i.containsKey(t, n)))
  }
}
class y5 extends AR {
  constructor(t) {
    super(), (this.currentSequenceNumber = t)
  }
}
class hm {
  constructor(t) {
    ;(this.persistence = t), (this.zr = new z_()), (this.jr = null)
  }
  static Hr(t) {
    return new hm(t)
  }
  get Jr() {
    if (this.jr) return this.jr
    throw Oe()
  }
  addReference(t, n, i) {
    return this.zr.addReference(i, n), this.Jr.delete(i.toString()), J.resolve()
  }
  removeReference(t, n, i) {
    return this.zr.removeReference(i, n), this.Jr.add(i.toString()), J.resolve()
  }
  markPotentiallyOrphaned(t, n) {
    return this.Jr.add(n.toString()), J.resolve()
  }
  removeTarget(t, n) {
    this.zr.Vr(n.targetId).forEach((r) => this.Jr.add(r.toString()))
    const i = this.persistence.getTargetCache()
    return i
      .getMatchingKeysForTargetId(t, n.targetId)
      .next((r) => {
        r.forEach((s) => this.Jr.add(s.toString()))
      })
      .next(() => i.removeTargetData(t, n))
  }
  Ur() {
    this.jr = new Set()
  }
  Wr(t) {
    const n = this.persistence.getRemoteDocumentCache().newChangeBuffer()
    return J.forEach(this.Jr, (i) => {
      const r = Re.fromPath(i)
      return this.Yr(t, r).next((s) => {
        s || n.removeEntry(r, $e.min())
      })
    }).next(() => ((this.jr = null), n.apply(t)))
  }
  updateLimboDocument(t, n) {
    return this.Yr(t, n).next((i) => {
      i ? this.Jr.delete(n.toString()) : this.Jr.add(n.toString())
    })
  }
  Kr(t) {
    return 0
  }
  Yr(t, n) {
    return J.or([
      () => J.resolve(this.zr.containsKey(n)),
      () => this.persistence.getTargetCache().containsKey(t, n),
      () => this.persistence.Gr(t, n),
    ])
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _5 {
  constructor(t) {
    this.serializer = t
  }
  O(t, n, i, r) {
    const s = new nm('createOrUpgrade', n)
    i < 1 &&
      r >= 1 &&
      ((function (l) {
        l.createObjectStore('owner')
      })(t),
      (function (l) {
        l.createObjectStore('mutationQueues', { keyPath: 'userId' }),
          l
            .createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 })
            .createIndex('userMutationsIndex', kE, { unique: !0 }),
          l.createObjectStore('documentMutations')
      })(t),
      m0(t),
      (function (l) {
        l.createObjectStore('remoteDocuments')
      })(t))
    let o = J.resolve()
    return (
      i < 3 &&
        r >= 3 &&
        (i !== 0 &&
          ((function (l) {
            l.deleteObjectStore('targetDocuments'), l.deleteObjectStore('targets'), l.deleteObjectStore('targetGlobal')
          })(t),
          m0(t)),
        (o = o.next(() =>
          (function (l) {
            const u = l.store('targetGlobal'),
              c = {
                highestTargetId: 0,
                highestListenSequenceNumber: 0,
                lastRemoteSnapshotVersion: $e.min().toTimestamp(),
                targetCount: 0,
              }
            return u.put('targetGlobalKey', c)
          })(s)
        ))),
      i < 4 &&
        r >= 4 &&
        (i !== 0 &&
          (o = o.next(() =>
            (function (l, u) {
              return u
                .store('mutations')
                .U()
                .next((c) => {
                  l.deleteObjectStore('mutations'),
                    l
                      .createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 })
                      .createIndex('userMutationsIndex', kE, { unique: !0 })
                  const d = u.store('mutations'),
                    f = c.map((m) => d.put(m))
                  return J.waitFor(f)
                })
            })(t, s)
          )),
        (o = o.next(() => {
          ;(function (l) {
            l.createObjectStore('clientMetadata', { keyPath: 'clientId' })
          })(t)
        }))),
      i < 5 && r >= 5 && (o = o.next(() => this.Xr(s))),
      i < 6 &&
        r >= 6 &&
        (o = o.next(
          () => (
            (function (l) {
              l.createObjectStore('remoteDocumentGlobal')
            })(t),
            this.ei(s)
          )
        )),
      i < 7 && r >= 7 && (o = o.next(() => this.ti(s))),
      i < 8 && r >= 8 && (o = o.next(() => this.ni(t, s))),
      i < 9 &&
        r >= 9 &&
        (o = o.next(() => {
          ;(function (l) {
            l.objectStoreNames.contains('remoteDocumentChanges') && l.deleteObjectStore('remoteDocumentChanges')
          })(t)
        })),
      i < 10 && r >= 10 && (o = o.next(() => this.ri(s))),
      i < 11 &&
        r >= 11 &&
        (o = o.next(() => {
          ;(function (l) {
            l.createObjectStore('bundles', { keyPath: 'bundleId' })
          })(t),
            (function (l) {
              l.createObjectStore('namedQueries', { keyPath: 'name' })
            })(t)
        })),
      i < 12 &&
        r >= 12 &&
        (o = o.next(() => {
          ;(function (l) {
            const u = l.createObjectStore('documentOverlays', { keyPath: YH })
            u.createIndex('collectionPathOverlayIndex', QH, { unique: !1 }),
              u.createIndex('collectionGroupOverlayIndex', XH, { unique: !1 })
          })(t)
        })),
      i < 13 &&
        r >= 13 &&
        (o = o
          .next(() =>
            (function (l) {
              const u = l.createObjectStore('remoteDocumentsV14', { keyPath: FH })
              u.createIndex('documentKeyIndex', BH), u.createIndex('collectionGroupIndex', $H)
            })(t)
          )
          .next(() => this.ii(t, s))
          .next(() => t.deleteObjectStore('remoteDocuments'))),
      i < 14 && r >= 14 && (o = o.next(() => this.si(t, s))),
      i < 15 &&
        r >= 15 &&
        (o = o.next(() =>
          (function (l) {
            l
              .createObjectStore('indexConfiguration', { keyPath: 'indexId', autoIncrement: !0 })
              .createIndex('collectionGroupIndex', 'collectionGroup', { unique: !1 }),
              l.createObjectStore('indexState', { keyPath: WH }).createIndex('sequenceNumberIndex', qH, { unique: !1 }),
              l.createObjectStore('indexEntries', { keyPath: GH }).createIndex('documentKeyIndex', KH, { unique: !1 })
          })(t)
        )),
      i < 16 &&
        r >= 16 &&
        (o = o
          .next(() => {
            n.objectStore('indexState').clear()
          })
          .next(() => {
            n.objectStore('indexEntries').clear()
          })),
      o
    )
  }
  ei(t) {
    let n = 0
    return t
      .store('remoteDocuments')
      .J((i, r) => {
        n += hf(r)
      })
      .next(() => {
        const i = { byteSize: n }
        return t.store('remoteDocumentGlobal').put('remoteDocumentGlobalKey', i)
      })
  }
  Xr(t) {
    const n = t.store('mutationQueues'),
      i = t.store('mutations')
    return n.U().next((r) =>
      J.forEach(r, (s) => {
        const o = IDBKeyRange.bound([s.userId, -1], [s.userId, s.lastAcknowledgedBatchId])
        return i.U('userMutationsIndex', o).next((a) =>
          J.forEach(a, (l) => {
            Fe(l.userId === s.userId)
            const u = fo(this.serializer, l)
            return Ex(t, s.userId, u).next(() => {})
          })
        )
      })
    )
  }
  ti(t) {
    const n = t.store('targetDocuments'),
      i = t.store('remoteDocuments')
    return t
      .store('targetGlobal')
      .get('targetGlobalKey')
      .next((r) => {
        const s = []
        return i
          .J((o, a) => {
            const l = new pt(o),
              u = (function (d) {
                return [0, Yn(d)]
              })(l)
            s.push(
              n
                .get(u)
                .next((c) =>
                  c
                    ? J.resolve()
                    : ((d) => n.put({ targetId: 0, path: Yn(d), sequenceNumber: r.highestListenSequenceNumber }))(l)
                )
            )
          })
          .next(() => J.waitFor(s))
      })
  }
  ni(t, n) {
    t.createObjectStore('collectionParents', { keyPath: HH })
    const i = n.store('collectionParents'),
      r = new j_(),
      s = (o) => {
        if (r.add(o)) {
          const a = o.lastSegment(),
            l = o.popLast()
          return i.put({ collectionId: a, parent: Yn(l) })
        }
      }
    return n
      .store('remoteDocuments')
      .J({ H: !0 }, (o, a) => {
        const l = new pt(o)
        return s(l.popLast())
      })
      .next(() =>
        n.store('documentMutations').J({ H: !0 }, ([o, a, l], u) => {
          const c = rr(a)
          return s(c.popLast())
        })
      )
  }
  ri(t) {
    const n = t.store('targets')
    return n.J((i, r) => {
      const s = Du(r),
        o = bx(this.serializer, s)
      return n.put(o)
    })
  }
  ii(t, n) {
    const i = n.store('remoteDocuments'),
      r = []
    return i
      .J((s, o) => {
        const a = n.store('remoteDocumentsV14'),
          l = (function (d) {
            return d.document
              ? new Re(pt.fromString(d.document.name).popFirst(5))
              : d.noDocument
              ? Re.fromSegments(d.noDocument.path)
              : d.unknownDocument
              ? Re.fromSegments(d.unknownDocument.path)
              : Oe()
          })(o).path.toArray(),
          u = {
            prefixPath: l.slice(0, l.length - 2),
            collectionGroup: l[l.length - 2],
            documentId: l[l.length - 1],
            readTime: o.readTime || [0, 0],
            unknownDocument: o.unknownDocument,
            noDocument: o.noDocument,
            document: o.document,
            hasCommittedMutations: !!o.hasCommittedMutations,
          }
        r.push(a.put(u))
      })
      .next(() => J.waitFor(r))
  }
  si(t, n) {
    const i = n.store('mutations'),
      r = kx(this.serializer),
      s = new Rx(hm.Hr, this.serializer.ct)
    return i.U().next((o) => {
      const a = new Map()
      return (
        o.forEach((l) => {
          var u
          let c = (u = a.get(l.userId)) !== null && u !== void 0 ? u : Qe()
          fo(this.serializer, l)
            .keys()
            .forEach((d) => (c = c.add(d))),
            a.set(l.userId, c)
        }),
        J.forEach(a, (l, u) => {
          const c = new qn(u),
            d = cm.lt(this.serializer, c),
            f = s.getIndexManager(c),
            m = dm.lt(c, this.serializer, f, s.referenceDelegate)
          return new Px(r, m, d, f).recalculateAndSaveOverlaysForDocumentKeys(new lp(n, Ci.oe), l).next()
        })
      )
    })
  }
}
function m0(e) {
  e.createObjectStore('targetDocuments', { keyPath: jH }).createIndex('documentTargetsIndex', zH, { unique: !0 }),
    e.createObjectStore('targets', { keyPath: 'targetId' }).createIndex('queryTargetsIndex', UH, { unique: !0 }),
    e.createObjectStore('targetGlobal')
}
const Hg =
  'Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.'
class H_ {
  constructor(t, n, i, r, s, o, a, l, u, c, d = 16) {
    if (
      ((this.allowTabSynchronization = t),
      (this.persistenceKey = n),
      (this.clientId = i),
      (this.oi = s),
      (this.window = o),
      (this.document = a),
      (this._i = u),
      (this.ai = c),
      (this.ui = d),
      (this.kr = null),
      (this.qr = !1),
      (this.isPrimary = !1),
      (this.networkEnabled = !0),
      (this.ci = null),
      (this.inForeground = !1),
      (this.li = null),
      (this.hi = null),
      (this.Pi = Number.NEGATIVE_INFINITY),
      (this.Ii = (f) => Promise.resolve()),
      !H_.D())
    )
      throw new Ve(
        fe.UNIMPLEMENTED,
        'This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.'
      )
    ;(this.referenceDelegate = new l5(this, r)),
      (this.Ti = n + 'main'),
      (this.serializer = new _x(l)),
      (this.Ei = new Ps(this.Ti, this.ui, new _5(this.serializer))),
      (this.Qr = new i5(this.referenceDelegate, this.serializer)),
      (this.remoteDocumentCache = kx(this.serializer)),
      (this.$r = new Y6()),
      this.window && this.window.localStorage
        ? (this.di = this.window.localStorage)
        : ((this.di = null),
          c === !1 &&
            Gn(
              'IndexedDbPersistence',
              'LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.'
            ))
  }
  start() {
    return this.Ai()
      .then(() => {
        if (!this.isPrimary && !this.allowTabSynchronization) throw new Ve(fe.FAILED_PRECONDITION, Hg)
        return (
          this.Ri(),
          this.Vi(),
          this.mi(),
          this.runTransaction('getHighestListenSequenceNumber', 'readonly', (t) => this.Qr.getHighestSequenceNumber(t))
        )
      })
      .then((t) => {
        this.kr = new Ci(t, this._i)
      })
      .then(() => {
        this.qr = !0
      })
      .catch((t) => (this.Ei && this.Ei.close(), Promise.reject(t)))
  }
  fi(t) {
    return (
      (this.Ii = async (n) => {
        if (this.started) return t(n)
      }),
      t(this.isPrimary)
    )
  }
  setDatabaseDeletedListener(t) {
    this.Ei.L(async (n) => {
      n.newVersion === null && (await t())
    })
  }
  setNetworkEnabled(t) {
    this.networkEnabled !== t &&
      ((this.networkEnabled = t),
      this.oi.enqueueAndForget(async () => {
        this.started && (await this.Ai())
      }))
  }
  Ai() {
    return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', (t) =>
      th(t)
        .put({
          clientId: this.clientId,
          updateTimeMs: Date.now(),
          networkEnabled: this.networkEnabled,
          inForeground: this.inForeground,
        })
        .next(() => {
          if (this.isPrimary)
            return this.gi(t).next((n) => {
              n || ((this.isPrimary = !1), this.oi.enqueueRetryable(() => this.Ii(!1)))
            })
        })
        .next(() => this.pi(t))
        .next((n) => (this.isPrimary && !n ? this.yi(t).next(() => !1) : !!n && this.wi(t).next(() => !0)))
    )
      .catch((t) => {
        if (Ws(t)) return we('IndexedDbPersistence', 'Failed to extend owner lease: ', t), this.isPrimary
        if (!this.allowTabSynchronization) throw t
        return we('IndexedDbPersistence', 'Releasing owner lease after error during lease refresh', t), !1
      })
      .then((t) => {
        this.isPrimary !== t && this.oi.enqueueRetryable(() => this.Ii(t)), (this.isPrimary = t)
      })
  }
  gi(t) {
    return wu(t)
      .get('owner')
      .next((n) => J.resolve(this.Si(n)))
  }
  bi(t) {
    return th(t).delete(this.clientId)
  }
  async Di() {
    if (this.isPrimary && !this.Ci(this.Pi, 18e5)) {
      this.Pi = Date.now()
      const t = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', (n) => {
        const i = vn(n, 'clientMetadata')
        return i.U().next((r) => {
          const s = this.vi(r, 18e5),
            o = r.filter((a) => s.indexOf(a) === -1)
          return J.forEach(o, (a) => i.delete(a.clientId)).next(() => o)
        })
      }).catch(() => [])
      if (this.di) for (const n of t) this.di.removeItem(this.Fi(n.clientId))
    }
  }
  mi() {
    this.hi = this.oi.enqueueAfterDelay('client_metadata_refresh', 4e3, () =>
      this.Ai()
        .then(() => this.Di())
        .then(() => this.mi())
    )
  }
  Si(t) {
    return !!t && t.ownerId === this.clientId
  }
  pi(t) {
    return this.ai
      ? J.resolve(!0)
      : wu(t)
          .get('owner')
          .next((n) => {
            if (n !== null && this.Ci(n.leaseTimestampMs, 5e3) && !this.Mi(n.ownerId)) {
              if (this.Si(n) && this.networkEnabled) return !0
              if (!this.Si(n)) {
                if (!n.allowTabSynchronization) throw new Ve(fe.FAILED_PRECONDITION, Hg)
                return !1
              }
            }
            return (
              !(!this.networkEnabled || !this.inForeground) ||
              th(t)
                .U()
                .next(
                  (i) =>
                    this.vi(i, 5e3).find((r) => {
                      if (this.clientId !== r.clientId) {
                        const s = !this.networkEnabled && r.networkEnabled,
                          o = !this.inForeground && r.inForeground,
                          a = this.networkEnabled === r.networkEnabled
                        if (s || (o && a)) return !0
                      }
                      return !1
                    }) === void 0
                )
            )
          })
          .next(
            (n) => (
              this.isPrimary !== n &&
                we('IndexedDbPersistence', `Client ${n ? 'is' : 'is not'} eligible for a primary lease.`),
              n
            )
          )
  }
  async shutdown() {
    ;(this.qr = !1),
      this.xi(),
      this.hi && (this.hi.cancel(), (this.hi = null)),
      this.Oi(),
      this.Ni(),
      await this.Ei.runTransaction('shutdown', 'readwrite', ['owner', 'clientMetadata'], (t) => {
        const n = new lp(t, Ci.oe)
        return this.yi(n).next(() => this.bi(n))
      }),
      this.Ei.close(),
      this.Li()
  }
  vi(t, n) {
    return t.filter((i) => this.Ci(i.updateTimeMs, n) && !this.Mi(i.clientId))
  }
  Bi() {
    return this.runTransaction('getActiveClients', 'readonly', (t) =>
      th(t)
        .U()
        .next((n) => this.vi(n, 18e5).map((i) => i.clientId))
    )
  }
  get started() {
    return this.qr
  }
  getMutationQueue(t, n) {
    return dm.lt(t, this.serializer, n, this.referenceDelegate)
  }
  getTargetCache() {
    return this.Qr
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache
  }
  getIndexManager(t) {
    return new n5(t, this.serializer.ct.databaseId)
  }
  getDocumentOverlayCache(t) {
    return cm.lt(this.serializer, t)
  }
  getBundleCache() {
    return this.$r
  }
  runTransaction(t, n, i) {
    we('IndexedDbPersistence', 'Starting transaction:', t)
    const r = n === 'readonly' ? 'readonly' : 'readwrite',
      s = (function (l) {
        return l === 16 ? ZH : l === 15 ? DR : l === 14 ? VR : l === 13 ? xR : l === 12 ? JH : l === 11 ? RR : void Oe()
      })(this.ui)
    let o
    return this.Ei.runTransaction(
      t,
      r,
      s,
      (a) => (
        (o = new lp(a, this.kr ? this.kr.next() : Ci.oe)),
        n === 'readwrite-primary'
          ? this.gi(o)
              .next((l) => !!l || this.pi(o))
              .next((l) => {
                if (!l)
                  throw (
                    (Gn(`Failed to obtain primary lease for action '${t}'.`),
                    (this.isPrimary = !1),
                    this.oi.enqueueRetryable(() => this.Ii(!1)),
                    new Ve(fe.FAILED_PRECONDITION, CR))
                  )
                return i(o)
              })
              .next((l) => this.wi(o).next(() => l))
          : this.ki(o).next(() => i(o))
      )
    ).then((a) => (o.raiseOnCommittedEvent(), a))
  }
  ki(t) {
    return wu(t)
      .get('owner')
      .next((n) => {
        if (
          n !== null &&
          this.Ci(n.leaseTimestampMs, 5e3) &&
          !this.Mi(n.ownerId) &&
          !this.Si(n) &&
          !(this.ai || (this.allowTabSynchronization && n.allowTabSynchronization))
        )
          throw new Ve(fe.FAILED_PRECONDITION, Hg)
      })
  }
  wi(t) {
    const n = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now(),
    }
    return wu(t).put('owner', n)
  }
  static D() {
    return Ps.D()
  }
  yi(t) {
    const n = wu(t)
    return n
      .get('owner')
      .next((i) =>
        this.Si(i) ? (we('IndexedDbPersistence', 'Releasing primary lease.'), n.delete('owner')) : J.resolve()
      )
  }
  Ci(t, n) {
    const i = Date.now()
    return !(t < i - n) && (!(t > i) || (Gn(`Detected an update time that is in the future: ${t} > ${i}`), !1))
  }
  Ri() {
    this.document !== null &&
      typeof this.document.addEventListener == 'function' &&
      ((this.li = () => {
        this.oi.enqueueAndForget(() => ((this.inForeground = this.document.visibilityState === 'visible'), this.Ai()))
      }),
      this.document.addEventListener('visibilitychange', this.li),
      (this.inForeground = this.document.visibilityState === 'visible'))
  }
  Oi() {
    this.li && (this.document.removeEventListener('visibilitychange', this.li), (this.li = null))
  }
  Vi() {
    var t
    typeof ((t = this.window) === null || t === void 0 ? void 0 : t.addEventListener) == 'function' &&
      ((this.ci = () => {
        this.xi()
        const n = /(?:Version|Mobile)\/1[456]/
        lk() && (navigator.appVersion.match(n) || navigator.userAgent.match(n)) && this.oi.enterRestrictedMode(!0),
          this.oi.enqueueAndForget(() => this.shutdown())
      }),
      this.window.addEventListener('pagehide', this.ci))
  }
  Ni() {
    this.ci && (this.window.removeEventListener('pagehide', this.ci), (this.ci = null))
  }
  Mi(t) {
    var n
    try {
      const i = ((n = this.di) === null || n === void 0 ? void 0 : n.getItem(this.Fi(t))) !== null
      return we('IndexedDbPersistence', `Client '${t}' ${i ? 'is' : 'is not'} zombied in LocalStorage`), i
    } catch (i) {
      return Gn('IndexedDbPersistence', 'Failed to get zombied client id.', i), !1
    }
  }
  xi() {
    if (this.di)
      try {
        this.di.setItem(this.Fi(this.clientId), String(Date.now()))
      } catch (t) {
        Gn('Failed to set zombie client id.', t)
      }
  }
  Li() {
    if (this.di)
      try {
        this.di.removeItem(this.Fi(this.clientId))
      } catch {}
  }
  Fi(t) {
    return `firestore_zombie_${this.persistenceKey}_${t}`
  }
}
function wu(e) {
  return vn(e, 'owner')
}
function th(e) {
  return vn(e, 'clientMetadata')
}
function b5(e, t) {
  let n = e.projectId
  return e.isDefaultDatabase || (n += '.' + e.database), 'firestore/' + t + '/' + n + '/'
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class W_ {
  constructor(t, n, i, r) {
    ;(this.targetId = t), (this.fromCache = n), (this.qi = i), (this.Qi = r)
  }
  static Ki(t, n) {
    let i = Qe(),
      r = Qe()
    for (const s of n.docChanges)
      switch (s.type) {
        case 0:
          i = i.add(s.doc.key)
          break
        case 1:
          r = r.add(s.doc.key)
      }
    return new W_(t, n.fromCache, i, r)
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class w5 {
  constructor() {
    this._documentReadCount = 0
  }
  get documentReadCount() {
    return this._documentReadCount
  }
  incrementDocumentReadCount(t) {
    this._documentReadCount += t
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class xx {
  constructor() {
    ;(this.$i = !1),
      (this.Ui = !1),
      (this.Wi = 100),
      (this.Gi = (function () {
        return lk() ? 8 : kR(Zt()) > 0 ? 6 : 4
      })())
  }
  initialize(t, n) {
    ;(this.zi = t), (this.indexManager = n), (this.$i = !0)
  }
  getDocumentsMatchingQuery(t, n, i, r) {
    const s = { result: null }
    return this.ji(t, n)
      .next((o) => {
        s.result = o
      })
      .next(() => {
        if (!s.result)
          return this.Hi(t, n, r, i).next((o) => {
            s.result = o
          })
      })
      .next(() => {
        if (s.result) return
        const o = new w5()
        return this.Ji(t, n, o).next((a) => {
          if (((s.result = a), this.Ui)) return this.Yi(t, n, o, a.size)
        })
      })
      .next(() => s.result)
  }
  Yi(t, n, i, r) {
    return i.documentReadCount < this.Wi
      ? (Fa() <= Je.DEBUG &&
          we(
            'QueryEngine',
            'SDK will not create cache indexes for query:',
            Ba(n),
            'since it only creates cache indexes for collection contains',
            'more than or equal to',
            this.Wi,
            'documents'
          ),
        J.resolve())
      : (Fa() <= Je.DEBUG &&
          we(
            'QueryEngine',
            'Query:',
            Ba(n),
            'scans',
            i.documentReadCount,
            'local documents and returns',
            r,
            'documents as results.'
          ),
        i.documentReadCount > this.Gi * r
          ? (Fa() <= Je.DEBUG &&
              we(
                'QueryEngine',
                'The SDK decides to create cache indexes for query:',
                Ba(n),
                'as using cache indexes may help improve performance.'
              ),
            this.indexManager.createTargetIndexes(t, Pi(n)))
          : J.resolve())
  }
  ji(t, n) {
    if ($E(n)) return J.resolve(null)
    let i = Pi(n)
    return this.indexManager.getIndexType(t, i).next((r) =>
      r === 0
        ? null
        : (n.limit !== null && r === 1 && ((n = mp(n, null, 'F')), (i = Pi(n))),
          this.indexManager.getDocumentsMatchingTarget(t, i).next((s) => {
            const o = Qe(...s)
            return this.zi.getDocuments(t, o).next((a) =>
              this.indexManager.getMinOffset(t, i).next((l) => {
                const u = this.Zi(n, a)
                return this.Xi(n, u, o, l.readTime) ? this.ji(t, mp(n, null, 'F')) : this.es(t, u, n, l)
              })
            )
          }))
    )
  }
  Hi(t, n, i, r) {
    return $E(n) || r.isEqual($e.min())
      ? J.resolve(null)
      : this.zi.getDocuments(t, i).next((s) => {
          const o = this.Zi(n, s)
          return this.Xi(n, o, i, r)
            ? J.resolve(null)
            : (Fa() <= Je.DEBUG &&
                we('QueryEngine', 'Re-using previous result from %s to execute query: %s', r.toString(), Ba(n)),
              this.es(t, o, n, RH(r, -1)).next((a) => a))
        })
  }
  Zi(t, n) {
    let i = new bt(qR(t))
    return (
      n.forEach((r, s) => {
        ed(t, s) && (i = i.add(s))
      }),
      i
    )
  }
  Xi(t, n, i, r) {
    if (t.limit === null) return !1
    if (i.size !== n.size) return !0
    const s = t.limitType === 'F' ? n.last() : n.first()
    return !!s && (s.hasPendingWrites || s.version.compareTo(r) > 0)
  }
  Ji(t, n, i) {
    return (
      Fa() <= Je.DEBUG && we('QueryEngine', 'Using full collection scan to execute query:', Ba(n)),
      this.zi.getDocumentsMatchingQuery(t, n, vi.min(), i)
    )
  }
  es(t, n, i, r) {
    return this.zi.getDocumentsMatchingQuery(t, i, r).next(
      (s) => (
        n.forEach((o) => {
          s = s.insert(o.key, o)
        }),
        s
      )
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class I5 {
  constructor(t, n, i, r) {
    ;(this.persistence = t),
      (this.ts = n),
      (this.serializer = r),
      (this.ns = new Nt(Ye)),
      (this.rs = new qs((s) => $o(s), Jc)),
      (this.ss = new Map()),
      (this.os = t.getRemoteDocumentCache()),
      (this.Qr = t.getTargetCache()),
      (this.$r = t.getBundleCache()),
      this._s(i)
  }
  _s(t) {
    ;(this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t)),
      (this.indexManager = this.persistence.getIndexManager(t)),
      (this.mutationQueue = this.persistence.getMutationQueue(t, this.indexManager)),
      (this.localDocuments = new Px(this.os, this.mutationQueue, this.documentOverlayCache, this.indexManager)),
      this.os.setIndexManager(this.indexManager),
      this.ts.initialize(this.localDocuments, this.indexManager)
  }
  collectGarbage(t) {
    return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', (n) => t.collect(n, this.ns))
  }
}
function Vx(e, t, n, i) {
  return new I5(e, t, n, i)
}
async function Dx(e, t) {
  const n = Ke(e)
  return await n.persistence.runTransaction('Handle user change', 'readonly', (i) => {
    let r
    return n.mutationQueue
      .getAllMutationBatches(i)
      .next((s) => ((r = s), n._s(t), n.mutationQueue.getAllMutationBatches(i)))
      .next((s) => {
        const o = [],
          a = []
        let l = Qe()
        for (const u of r) {
          o.push(u.batchId)
          for (const c of u.mutations) l = l.add(c.key)
        }
        for (const u of s) {
          a.push(u.batchId)
          for (const c of u.mutations) l = l.add(c.key)
        }
        return n.localDocuments.getDocuments(i, l).next((u) => ({ us: u, removedBatchIds: o, addedBatchIds: a }))
      })
  })
}
function S5(e, t) {
  const n = Ke(e)
  return n.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', (i) => {
    const r = t.batch.keys(),
      s = n.os.newChangeBuffer({ trackRemovals: !0 })
    return (function (a, l, u, c) {
      const d = u.batch,
        f = d.keys()
      let m = J.resolve()
      return (
        f.forEach((p) => {
          m = m
            .next(() => c.getEntry(l, p))
            .next((v) => {
              const y = u.docVersions.get(p)
              Fe(y !== null),
                v.version.compareTo(y) < 0 &&
                  (d.applyToRemoteDocument(v, u),
                  v.isValidDocument() && (v.setReadTime(u.commitVersion), c.addEntry(v)))
            })
        }),
        m.next(() => a.mutationQueue.removeMutationBatch(l, d))
      )
    })(n, i, t, s)
      .next(() => s.apply(i))
      .next(() => n.mutationQueue.performConsistencyCheck(i))
      .next(() => n.documentOverlayCache.removeOverlaysForBatchId(i, r, t.batch.batchId))
      .next(() =>
        n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(
          i,
          (function (a) {
            let l = Qe()
            for (let u = 0; u < a.mutationResults.length; ++u)
              a.mutationResults[u].transformResults.length > 0 && (l = l.add(a.batch.mutations[u].key))
            return l
          })(t)
        )
      )
      .next(() => n.localDocuments.getDocuments(i, r))
  })
}
function Nx(e) {
  const t = Ke(e)
  return t.persistence.runTransaction('Get last remote snapshot version', 'readonly', (n) =>
    t.Qr.getLastRemoteSnapshotVersion(n)
  )
}
function E5(e, t) {
  const n = Ke(e),
    i = t.snapshotVersion
  let r = n.ns
  return n.persistence
    .runTransaction('Apply remote event', 'readwrite-primary', (s) => {
      const o = n.os.newChangeBuffer({ trackRemovals: !0 })
      r = n.ns
      const a = []
      t.targetChanges.forEach((c, d) => {
        const f = r.get(d)
        if (!f) return
        a.push(
          n.Qr.removeMatchingKeys(s, c.removedDocuments, d).next(() => n.Qr.addMatchingKeys(s, c.addedDocuments, d))
        )
        let m = f.withSequenceNumber(s.currentSequenceNumber)
        t.targetMismatches.get(d) !== null
          ? (m = m.withResumeToken(En.EMPTY_BYTE_STRING, $e.min()).withLastLimboFreeSnapshotVersion($e.min()))
          : c.resumeToken.approximateByteSize() > 0 && (m = m.withResumeToken(c.resumeToken, i)),
          (r = r.insert(d, m)),
          (function (v, y, T) {
            return v.resumeToken.approximateByteSize() === 0 ||
              y.snapshotVersion.toMicroseconds() - v.snapshotVersion.toMicroseconds() >= 3e8
              ? !0
              : T.addedDocuments.size + T.modifiedDocuments.size + T.removedDocuments.size > 0
          })(f, m, c) && a.push(n.Qr.updateTargetData(s, m))
      })
      let l = ci(),
        u = Qe()
      if (
        (t.documentUpdates.forEach((c) => {
          t.resolvedLimboDocuments.has(c) && a.push(n.persistence.referenceDelegate.updateLimboDocument(s, c))
        }),
        a.push(
          T5(s, o, t.documentUpdates).next((c) => {
            ;(l = c.cs), (u = c.ls)
          })
        ),
        !i.isEqual($e.min()))
      ) {
        const c = n.Qr.getLastRemoteSnapshotVersion(s).next((d) =>
          n.Qr.setTargetsMetadata(s, s.currentSequenceNumber, i)
        )
        a.push(c)
      }
      return J.waitFor(a)
        .next(() => o.apply(s))
        .next(() => n.localDocuments.getLocalViewOfDocuments(s, l, u))
        .next(() => l)
    })
    .then((s) => ((n.ns = r), s))
}
function T5(e, t, n) {
  let i = Qe(),
    r = Qe()
  return (
    n.forEach((s) => (i = i.add(s))),
    t.getEntries(e, i).next((s) => {
      let o = ci()
      return (
        n.forEach((a, l) => {
          const u = s.get(a)
          l.isFoundDocument() !== u.isFoundDocument() && (r = r.add(a)),
            l.isNoDocument() && l.version.isEqual($e.min())
              ? (t.removeEntry(a, l.readTime), (o = o.insert(a, l)))
              : !u.isValidDocument() ||
                l.version.compareTo(u.version) > 0 ||
                (l.version.compareTo(u.version) === 0 && u.hasPendingWrites)
              ? (t.addEntry(l), (o = o.insert(a, l)))
              : we(
                  'LocalStore',
                  'Ignoring outdated watch update for ',
                  a,
                  '. Current version:',
                  u.version,
                  ' Watch version:',
                  l.version
                )
        }),
        { cs: o, ls: r }
      )
    })
  )
}
function C5(e, t) {
  const n = Ke(e)
  return n.persistence.runTransaction(
    'Get next mutation batch',
    'readonly',
    (i) => (t === void 0 && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(i, t))
  )
}
function A5(e, t) {
  const n = Ke(e)
  return n.persistence
    .runTransaction('Allocate target', 'readwrite', (i) => {
      let r
      return n.Qr.getTargetData(i, t).next((s) =>
        s
          ? ((r = s), J.resolve(r))
          : n.Qr.allocateTargetId(i).next(
              (o) => (
                (r = new xr(t, o, 'TargetPurposeListen', i.currentSequenceNumber)),
                n.Qr.addTargetData(i, r).next(() => r)
              )
            )
      )
    })
    .then((i) => {
      const r = n.ns.get(i.targetId)
      return (
        (r === null || i.snapshotVersion.compareTo(r.snapshotVersion) > 0) &&
          ((n.ns = n.ns.insert(i.targetId, i)), n.rs.set(t, i.targetId)),
        i
      )
    })
}
async function Ip(e, t, n) {
  const i = Ke(e),
    r = i.ns.get(t),
    s = n ? 'readwrite' : 'readwrite-primary'
  try {
    n ||
      (await i.persistence.runTransaction('Release target', s, (o) =>
        i.persistence.referenceDelegate.removeTarget(o, r)
      ))
  } catch (o) {
    if (!Ws(o)) throw o
    we('LocalStore', `Failed to update sequence numbers for target ${t}: ${o}`)
  }
  ;(i.ns = i.ns.remove(t)), i.rs.delete(r.target)
}
function g0(e, t, n) {
  const i = Ke(e)
  let r = $e.min(),
    s = Qe()
  return i.persistence.runTransaction('Execute query', 'readwrite', (o) =>
    (function (l, u, c) {
      const d = Ke(l),
        f = d.rs.get(c)
      return f !== void 0 ? J.resolve(d.ns.get(f)) : d.Qr.getTargetData(u, c)
    })(i, o, Pi(t))
      .next((a) => {
        if (a)
          return (
            (r = a.lastLimboFreeSnapshotVersion),
            i.Qr.getMatchingKeysForTargetId(o, a.targetId).next((l) => {
              s = l
            })
          )
      })
      .next(() => i.ts.getDocumentsMatchingQuery(o, t, n ? r : $e.min(), n ? s : Qe()))
      .next((a) => (k5(i, g6(t), a), { documents: a, hs: s }))
  )
}
function k5(e, t, n) {
  let i = e.ss.get(t) || $e.min()
  n.forEach((r, s) => {
    s.readTime.compareTo(i) > 0 && (i = s.readTime)
  }),
    e.ss.set(t, i)
}
class v0 {
  constructor() {
    this.activeTargetIds = w6()
  }
  As(t) {
    this.activeTargetIds = this.activeTargetIds.add(t)
  }
  Rs(t) {
    this.activeTargetIds = this.activeTargetIds.delete(t)
  }
  ds() {
    const t = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }
    return JSON.stringify(t)
  }
}
class Ox {
  constructor() {
    ;(this.no = new v0()), (this.ro = {}), (this.onlineStateHandler = null), (this.sequenceNumberHandler = null)
  }
  addPendingMutation(t) {}
  updateMutationState(t, n, i) {}
  addLocalQueryTarget(t) {
    return this.no.As(t), this.ro[t] || 'not-current'
  }
  updateQueryState(t, n, i) {
    this.ro[t] = n
  }
  removeLocalQueryTarget(t) {
    this.no.Rs(t)
  }
  isLocalQueryTarget(t) {
    return this.no.activeTargetIds.has(t)
  }
  clearQueryState(t) {
    delete this.ro[t]
  }
  getAllActiveQueryTargets() {
    return this.no.activeTargetIds
  }
  isActiveQueryTarget(t) {
    return this.no.activeTargetIds.has(t)
  }
  start() {
    return (this.no = new v0()), Promise.resolve()
  }
  handleUserChange(t, n, i) {}
  setOnlineState(t) {}
  shutdown() {}
  writeSequenceNumber(t) {}
  notifyBundleLoaded(t) {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class P5 {
  io(t) {}
  shutdown() {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class p0 {
  constructor() {
    ;(this.so = () => this.oo()), (this._o = () => this.ao()), (this.uo = []), this.co()
  }
  io(t) {
    this.uo.push(t)
  }
  shutdown() {
    window.removeEventListener('online', this.so), window.removeEventListener('offline', this._o)
  }
  co() {
    window.addEventListener('online', this.so), window.addEventListener('offline', this._o)
  }
  oo() {
    we('ConnectivityMonitor', 'Network connectivity changed: AVAILABLE')
    for (const t of this.uo) t(0)
  }
  ao() {
    we('ConnectivityMonitor', 'Network connectivity changed: UNAVAILABLE')
    for (const t of this.uo) t(1)
  }
  static D() {
    return typeof window < 'u' && window.addEventListener !== void 0 && window.removeEventListener !== void 0
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let nh = null
function Wg() {
  return (
    nh === null
      ? (nh = (function () {
          return 268435456 + Math.round(2147483648 * Math.random())
        })())
      : nh++,
    '0x' + nh.toString(16)
  )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const R5 = {
  BatchGetDocuments: 'batchGet',
  Commit: 'commit',
  RunQuery: 'runQuery',
  RunAggregationQuery: 'runAggregationQuery',
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class x5 {
  constructor(t) {
    ;(this.lo = t.lo), (this.ho = t.ho)
  }
  Po(t) {
    this.Io = t
  }
  To(t) {
    this.Eo = t
  }
  Ao(t) {
    this.Ro = t
  }
  onMessage(t) {
    this.Vo = t
  }
  close() {
    this.ho()
  }
  send(t) {
    this.lo(t)
  }
  mo() {
    this.Io()
  }
  fo() {
    this.Eo()
  }
  po(t) {
    this.Ro(t)
  }
  yo(t) {
    this.Vo(t)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const xn = 'WebChannelConnection'
class V5 extends class {
  constructor(n) {
    ;(this.databaseInfo = n), (this.databaseId = n.databaseId)
    const i = n.ssl ? 'https' : 'http',
      r = encodeURIComponent(this.databaseId.projectId),
      s = encodeURIComponent(this.databaseId.database)
    ;(this.wo = i + '://' + n.host),
      (this.So = `projects/${r}/databases/${s}`),
      (this.bo = this.databaseId.database === '(default)' ? `project_id=${r}` : `project_id=${r}&database_id=${s}`)
  }
  get Do() {
    return !1
  }
  Co(n, i, r, s, o) {
    const a = Wg(),
      l = this.vo(n, i.toUriEncodedString())
    we('RestConnection', `Sending RPC '${n}' ${a}:`, l, r)
    const u = { 'google-cloud-resource-prefix': this.So, 'x-goog-request-params': this.bo }
    return (
      this.Fo(u, s, o),
      this.Mo(n, l, u, r).then(
        (c) => (we('RestConnection', `Received RPC '${n}' ${a}: `, c), c),
        (c) => {
          throw (mc('RestConnection', `RPC '${n}' ${a} failed with error: `, c, 'url: ', l, 'request:', r), c)
        }
      )
    )
  }
  xo(n, i, r, s, o, a) {
    return this.Co(n, i, r, s, o)
  }
  Fo(n, i, r) {
    ;(n['X-Goog-Api-Client'] = (function () {
      return 'gl-js/ fire/' + jl
    })()),
      (n['Content-Type'] = 'text/plain'),
      this.databaseInfo.appId && (n['X-Firebase-GMPID'] = this.databaseInfo.appId),
      i && i.headers.forEach((s, o) => (n[o] = s)),
      r && r.headers.forEach((s, o) => (n[o] = s))
  }
  vo(n, i) {
    const r = R5[n]
    return `${this.wo}/v1/${i}:${r}`
  }
  terminate() {}
} {
  constructor(t) {
    super(t),
      (this.forceLongPolling = t.forceLongPolling),
      (this.autoDetectLongPolling = t.autoDetectLongPolling),
      (this.useFetchStreams = t.useFetchStreams),
      (this.longPollingOptions = t.longPollingOptions)
  }
  Mo(t, n, i, r) {
    const s = Wg()
    return new Promise((o, a) => {
      const l = new pR()
      l.setWithCredentials(!0),
        l.listenOnce(_R.COMPLETE, () => {
          try {
            switch (l.getLastErrorCode()) {
              case wh.NO_ERROR:
                const c = l.getResponseJson()
                we(xn, `XHR for RPC '${t}' ${s} received:`, JSON.stringify(c)), o(c)
                break
              case wh.TIMEOUT:
                we(xn, `RPC '${t}' ${s} timed out`), a(new Ve(fe.DEADLINE_EXCEEDED, 'Request time out'))
                break
              case wh.HTTP_ERROR:
                const d = l.getStatus()
                if ((we(xn, `RPC '${t}' ${s} failed with status:`, d, 'response text:', l.getResponseText()), d > 0)) {
                  let f = l.getResponseJson()
                  Array.isArray(f) && (f = f[0])
                  const m = f == null ? void 0 : f.error
                  if (m && m.status && m.message) {
                    const p = (function (y) {
                      const T = y.toLowerCase().replace(/_/g, '-')
                      return Object.values(fe).indexOf(T) >= 0 ? T : fe.UNKNOWN
                    })(m.status)
                    a(new Ve(p, m.message))
                  } else a(new Ve(fe.UNKNOWN, 'Server responded with status ' + l.getStatus()))
                } else a(new Ve(fe.UNAVAILABLE, 'Connection failed.'))
                break
              default:
                Oe()
            }
          } finally {
            we(xn, `RPC '${t}' ${s} completed.`)
          }
        })
      const u = JSON.stringify(r)
      we(xn, `RPC '${t}' ${s} sending request:`, r), l.send(n, 'POST', u, i, 15)
    })
  }
  Oo(t, n, i) {
    const r = Wg(),
      s = [this.wo, '/', 'google.firestore.v1.Firestore', '/', t, '/channel'],
      o = IR(),
      a = wR(),
      l = {
        httpSessionIdParam: 'gsessionid',
        initMessageHeaders: {},
        messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` },
        sendRawJson: !0,
        supportsCrossDomainXhr: !0,
        internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 },
        forceLongPolling: this.forceLongPolling,
        detectBufferingProxy: this.autoDetectLongPolling,
      },
      u = this.longPollingOptions.timeoutSeconds
    u !== void 0 && (l.longPollingTimeout = Math.round(1e3 * u)),
      this.useFetchStreams && (l.xmlHttpFactory = new yR({})),
      this.Fo(l.initMessageHeaders, n, i),
      (l.encodeInitMessageHeaders = !0)
    const c = s.join('')
    we(xn, `Creating RPC '${t}' stream ${r}: ${c}`, l)
    const d = o.createWebChannel(c, l)
    let f = !1,
      m = !1
    const p = new x5({
        lo: (y) => {
          m
            ? we(xn, `Not sending because RPC '${t}' stream ${r} is closed:`, y)
            : (f || (we(xn, `Opening RPC '${t}' stream ${r} transport.`), d.open(), (f = !0)),
              we(xn, `RPC '${t}' stream ${r} sending:`, y),
              d.send(y))
        },
        ho: () => d.close(),
      }),
      v = (y, T, A) => {
        y.listen(T, (x) => {
          try {
            A(x)
          } catch (N) {
            setTimeout(() => {
              throw N
            }, 0)
          }
        })
      }
    return (
      v(d, Ru.EventType.OPEN, () => {
        m || (we(xn, `RPC '${t}' stream ${r} transport opened.`), p.mo())
      }),
      v(d, Ru.EventType.CLOSE, () => {
        m || ((m = !0), we(xn, `RPC '${t}' stream ${r} transport closed`), p.po())
      }),
      v(d, Ru.EventType.ERROR, (y) => {
        m ||
          ((m = !0),
          mc(xn, `RPC '${t}' stream ${r} transport errored:`, y),
          p.po(new Ve(fe.UNAVAILABLE, 'The operation could not be completed')))
      }),
      v(d, Ru.EventType.MESSAGE, (y) => {
        var T
        if (!m) {
          const A = y.data[0]
          Fe(!!A)
          const x = A,
            N = x.error || ((T = x[0]) === null || T === void 0 ? void 0 : T.error)
          if (N) {
            we(xn, `RPC '${t}' stream ${r} received error:`, N)
            const V = N.status
            let D = (function (_) {
                const S = Xt[_]
                if (S !== void 0) return sx(S)
              })(V),
              I = N.message
            D === void 0 && ((D = fe.INTERNAL), (I = 'Unknown error status: ' + V + ' with message ' + N.message)),
              (m = !0),
              p.po(new Ve(D, I)),
              d.close()
          } else we(xn, `RPC '${t}' stream ${r} received:`, A), p.yo(A)
        }
      }),
      v(a, bR.STAT_EVENT, (y) => {
        y.stat === op.PROXY
          ? we(xn, `RPC '${t}' stream ${r} detected buffering proxy`)
          : y.stat === op.NOPROXY && we(xn, `RPC '${t}' stream ${r} detected no buffering proxy`)
      }),
      setTimeout(() => {
        p.fo()
      }, 0),
      p
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function D5() {
  return typeof window < 'u' ? window : null
}
function kh() {
  return typeof document < 'u' ? document : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function fm(e) {
  return new F6(e, !0)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Mx {
  constructor(t, n, i = 1e3, r = 1.5, s = 6e4) {
    ;(this.oi = t),
      (this.timerId = n),
      (this.No = i),
      (this.Lo = r),
      (this.Bo = s),
      (this.ko = 0),
      (this.qo = null),
      (this.Qo = Date.now()),
      this.reset()
  }
  reset() {
    this.ko = 0
  }
  Ko() {
    this.ko = this.Bo
  }
  $o(t) {
    this.cancel()
    const n = Math.floor(this.ko + this.Uo()),
      i = Math.max(0, Date.now() - this.Qo),
      r = Math.max(0, n - i)
    r > 0 &&
      we(
        'ExponentialBackoff',
        `Backing off for ${r} ms (base delay: ${this.ko} ms, delay with jitter: ${n} ms, last attempt: ${i} ms ago)`
      ),
      (this.qo = this.oi.enqueueAfterDelay(this.timerId, r, () => ((this.Qo = Date.now()), t()))),
      (this.ko *= this.Lo),
      this.ko < this.No && (this.ko = this.No),
      this.ko > this.Bo && (this.ko = this.Bo)
  }
  Wo() {
    this.qo !== null && (this.qo.skipDelay(), (this.qo = null))
  }
  cancel() {
    this.qo !== null && (this.qo.cancel(), (this.qo = null))
  }
  Uo() {
    return (Math.random() - 0.5) * this.ko
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Lx {
  constructor(t, n, i, r, s, o, a, l) {
    ;(this.oi = t),
      (this.Go = i),
      (this.zo = r),
      (this.connection = s),
      (this.authCredentialsProvider = o),
      (this.appCheckCredentialsProvider = a),
      (this.listener = l),
      (this.state = 0),
      (this.jo = 0),
      (this.Ho = null),
      (this.Jo = null),
      (this.stream = null),
      (this.Yo = new Mx(t, n))
  }
  Zo() {
    return this.state === 1 || this.state === 5 || this.Xo()
  }
  Xo() {
    return this.state === 2 || this.state === 3
  }
  start() {
    this.state !== 4 ? this.auth() : this.e_()
  }
  async stop() {
    this.Zo() && (await this.close(0))
  }
  t_() {
    ;(this.state = 0), this.Yo.reset()
  }
  n_() {
    this.Xo() && this.Ho === null && (this.Ho = this.oi.enqueueAfterDelay(this.Go, 6e4, () => this.r_()))
  }
  i_(t) {
    this.s_(), this.stream.send(t)
  }
  async r_() {
    if (this.Xo()) return this.close(0)
  }
  s_() {
    this.Ho && (this.Ho.cancel(), (this.Ho = null))
  }
  o_() {
    this.Jo && (this.Jo.cancel(), (this.Jo = null))
  }
  async close(t, n) {
    this.s_(),
      this.o_(),
      this.Yo.cancel(),
      this.jo++,
      t !== 4
        ? this.Yo.reset()
        : n && n.code === fe.RESOURCE_EXHAUSTED
        ? (Gn(n.toString()), Gn('Using maximum backoff delay to prevent overloading the backend.'), this.Yo.Ko())
        : n &&
          n.code === fe.UNAUTHENTICATED &&
          this.state !== 3 &&
          (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()),
      this.stream !== null && (this.__(), this.stream.close(), (this.stream = null)),
      (this.state = t),
      await this.listener.Ao(n)
  }
  __() {}
  auth() {
    this.state = 1
    const t = this.a_(this.jo),
      n = this.jo
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(
      ([i, r]) => {
        this.jo === n && this.u_(i, r)
      },
      (i) => {
        t(() => {
          const r = new Ve(fe.UNKNOWN, 'Fetching auth token failed: ' + i.message)
          return this.c_(r)
        })
      }
    )
  }
  u_(t, n) {
    const i = this.a_(this.jo)
    ;(this.stream = this.l_(t, n)),
      this.stream.Po(() => {
        i(() => this.listener.Po())
      }),
      this.stream.To(() => {
        i(
          () => (
            (this.state = 2),
            (this.Jo = this.oi.enqueueAfterDelay(
              this.zo,
              1e4,
              () => (this.Xo() && (this.state = 3), Promise.resolve())
            )),
            this.listener.To()
          )
        )
      }),
      this.stream.Ao((r) => {
        i(() => this.c_(r))
      }),
      this.stream.onMessage((r) => {
        i(() => this.onMessage(r))
      })
  }
  e_() {
    ;(this.state = 5),
      this.Yo.$o(async () => {
        ;(this.state = 0), this.start()
      })
  }
  c_(t) {
    return we('PersistentStream', `close with error: ${t}`), (this.stream = null), this.close(4, t)
  }
  a_(t) {
    return (n) => {
      this.oi.enqueueAndForget(() =>
        this.jo === t
          ? n()
          : (we('PersistentStream', 'stream callback skipped by getCloseGuardedDispatcher.'), Promise.resolve())
      )
    }
  }
}
class N5 extends Lx {
  constructor(t, n, i, r, s, o) {
    super(t, 'listen_stream_connection_backoff', 'listen_stream_idle', 'health_check_timeout', n, i, r, o),
      (this.serializer = s)
  }
  l_(t, n) {
    return this.connection.Oo('Listen', t, n)
  }
  onMessage(t) {
    this.Yo.reset()
    const n = U6(this.serializer, t),
      i = (function (s) {
        if (!('targetChange' in s)) return $e.min()
        const o = s.targetChange
        return o.targetIds && o.targetIds.length ? $e.min() : o.readTime ? Qn(o.readTime) : $e.min()
      })(t)
    return this.listener.h_(n, i)
  }
  P_(t) {
    const n = {}
    ;(n.database = pp(this.serializer)),
      (n.addTarget = (function (s, o) {
        let a
        const l = o.target
        if (
          ((a = of(l) ? { documents: fx(s, l) } : { query: mx(s, l)._t }),
          (a.targetId = o.targetId),
          o.resumeToken.approximateByteSize() > 0)
        ) {
          a.resumeToken = lx(s, o.resumeToken)
          const u = gp(s, o.expectedCount)
          u !== null && (a.expectedCount = u)
        } else if (o.snapshotVersion.compareTo($e.min()) > 0) {
          a.readTime = Sl(s, o.snapshotVersion.toTimestamp())
          const u = gp(s, o.expectedCount)
          u !== null && (a.expectedCount = u)
        }
        return a
      })(this.serializer, t))
    const i = z6(this.serializer, t)
    i && (n.labels = i), this.i_(n)
  }
  I_(t) {
    const n = {}
    ;(n.database = pp(this.serializer)), (n.removeTarget = t), this.i_(n)
  }
}
class O5 extends Lx {
  constructor(t, n, i, r, s, o) {
    super(t, 'write_stream_connection_backoff', 'write_stream_idle', 'health_check_timeout', n, i, r, o),
      (this.serializer = s),
      (this.T_ = !1)
  }
  get E_() {
    return this.T_
  }
  start() {
    ;(this.T_ = !1), (this.lastStreamToken = void 0), super.start()
  }
  __() {
    this.T_ && this.d_([])
  }
  l_(t, n) {
    return this.connection.Oo('Write', t, n)
  }
  onMessage(t) {
    if ((Fe(!!t.streamToken), (this.lastStreamToken = t.streamToken), this.T_)) {
      this.Yo.reset()
      const n = j6(t.writeResults, t.commitTime),
        i = Qn(t.commitTime)
      return this.listener.A_(i, n)
    }
    return Fe(!t.writeResults || t.writeResults.length === 0), (this.T_ = !0), this.listener.R_()
  }
  V_() {
    const t = {}
    ;(t.database = pp(this.serializer)), this.i_(t)
  }
  d_(t) {
    const n = { streamToken: this.lastStreamToken, writes: t.map((i) => uf(this.serializer, i)) }
    this.i_(n)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class M5 extends class {} {
  constructor(t, n, i, r) {
    super(),
      (this.authCredentials = t),
      (this.appCheckCredentials = n),
      (this.connection = i),
      (this.serializer = r),
      (this.m_ = !1)
  }
  f_() {
    if (this.m_) throw new Ve(fe.FAILED_PRECONDITION, 'The client has already been terminated.')
  }
  Co(t, n, i, r) {
    return (
      this.f_(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([s, o]) => this.connection.Co(t, vp(n, i), r, s, o))
        .catch((s) => {
          throw s.name === 'FirebaseError'
            ? (s.code === fe.UNAUTHENTICATED &&
                (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()),
              s)
            : new Ve(fe.UNKNOWN, s.toString())
        })
    )
  }
  xo(t, n, i, r, s) {
    return (
      this.f_(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([o, a]) => this.connection.xo(t, vp(n, i), r, o, a, s))
        .catch((o) => {
          throw o.name === 'FirebaseError'
            ? (o.code === fe.UNAUTHENTICATED &&
                (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()),
              o)
            : new Ve(fe.UNKNOWN, o.toString())
        })
    )
  }
  terminate() {
    ;(this.m_ = !0), this.connection.terminate()
  }
}
class L5 {
  constructor(t, n) {
    ;(this.asyncQueue = t),
      (this.onlineStateHandler = n),
      (this.state = 'Unknown'),
      (this.g_ = 0),
      (this.p_ = null),
      (this.y_ = !0)
  }
  w_() {
    this.g_ === 0 &&
      (this.S_('Unknown'),
      (this.p_ = this.asyncQueue.enqueueAfterDelay(
        'online_state_timeout',
        1e4,
        () => (
          (this.p_ = null), this.b_("Backend didn't respond within 10 seconds."), this.S_('Offline'), Promise.resolve()
        )
      )))
  }
  D_(t) {
    this.state === 'Online'
      ? this.S_('Unknown')
      : (this.g_++,
        this.g_ >= 1 &&
          (this.C_(), this.b_(`Connection failed 1 times. Most recent error: ${t.toString()}`), this.S_('Offline')))
  }
  set(t) {
    this.C_(), (this.g_ = 0), t === 'Online' && (this.y_ = !1), this.S_(t)
  }
  S_(t) {
    t !== this.state && ((this.state = t), this.onlineStateHandler(t))
  }
  b_(t) {
    const n = `Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`
    this.y_ ? (Gn(n), (this.y_ = !1)) : we('OnlineStateTracker', n)
  }
  C_() {
    this.p_ !== null && (this.p_.cancel(), (this.p_ = null))
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class F5 {
  constructor(t, n, i, r, s) {
    ;(this.localStore = t),
      (this.datastore = n),
      (this.asyncQueue = i),
      (this.remoteSyncer = {}),
      (this.v_ = []),
      (this.F_ = new Map()),
      (this.M_ = new Set()),
      (this.x_ = []),
      (this.O_ = s),
      this.O_.io((o) => {
        i.enqueueAndForget(async () => {
          ua(this) &&
            (we('RemoteStore', 'Restarting streams for network reachability change.'),
            await (async function (l) {
              const u = Ke(l)
              u.M_.add(4), await nd(u), u.N_.set('Unknown'), u.M_.delete(4), await mm(u)
            })(this))
        })
      }),
      (this.N_ = new L5(i, r))
  }
}
async function mm(e) {
  if (ua(e)) for (const t of e.x_) await t(!0)
}
async function nd(e) {
  for (const t of e.x_) await t(!1)
}
function Fx(e, t) {
  const n = Ke(e)
  n.F_.has(t.targetId) || (n.F_.set(t.targetId, t), Y_(n) ? K_(n) : Hl(n).Xo() && G_(n, t))
}
function q_(e, t) {
  const n = Ke(e),
    i = Hl(n)
  n.F_.delete(t), i.Xo() && Bx(n, t), n.F_.size === 0 && (i.Xo() ? i.n_() : ua(n) && n.N_.set('Unknown'))
}
function G_(e, t) {
  if ((e.L_.xe(t.targetId), t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo($e.min()) > 0)) {
    const n = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size
    t = t.withExpectedCount(n)
  }
  Hl(e).P_(t)
}
function Bx(e, t) {
  e.L_.xe(t), Hl(e).I_(t)
}
function K_(e) {
  ;(e.L_ = new N6({
    getRemoteKeysForTarget: (t) => e.remoteSyncer.getRemoteKeysForTarget(t),
    ot: (t) => e.F_.get(t) || null,
    tt: () => e.datastore.serializer.databaseId,
  })),
    Hl(e).start(),
    e.N_.w_()
}
function Y_(e) {
  return ua(e) && !Hl(e).Zo() && e.F_.size > 0
}
function ua(e) {
  return Ke(e).M_.size === 0
}
function $x(e) {
  e.L_ = void 0
}
async function B5(e) {
  e.N_.set('Online')
}
async function $5(e) {
  e.F_.forEach((t, n) => {
    G_(e, t)
  })
}
async function U5(e, t) {
  $x(e), Y_(e) ? (e.N_.D_(t), K_(e)) : e.N_.set('Unknown')
}
async function j5(e, t, n) {
  if ((e.N_.set('Online'), t instanceof ax && t.state === 2 && t.cause))
    try {
      await (async function (r, s) {
        const o = s.cause
        for (const a of s.targetIds)
          r.F_.has(a) && (await r.remoteSyncer.rejectListen(a, o), r.F_.delete(a), r.L_.removeTarget(a))
      })(e, t)
    } catch (i) {
      we('RemoteStore', 'Failed to remove targets %s: %s ', t.targetIds.join(','), i), await ff(e, i)
    }
  else if ((t instanceof Ah ? e.L_.Ke(t) : t instanceof ox ? e.L_.He(t) : e.L_.We(t), !n.isEqual($e.min())))
    try {
      const i = await Nx(e.localStore)
      n.compareTo(i) >= 0 &&
        (await (function (s, o) {
          const a = s.L_.rt(o)
          return (
            a.targetChanges.forEach((l, u) => {
              if (l.resumeToken.approximateByteSize() > 0) {
                const c = s.F_.get(u)
                c && s.F_.set(u, c.withResumeToken(l.resumeToken, o))
              }
            }),
            a.targetMismatches.forEach((l, u) => {
              const c = s.F_.get(l)
              if (!c) return
              s.F_.set(l, c.withResumeToken(En.EMPTY_BYTE_STRING, c.snapshotVersion)), Bx(s, l)
              const d = new xr(c.target, l, u, c.sequenceNumber)
              G_(s, d)
            }),
            s.remoteSyncer.applyRemoteEvent(a)
          )
        })(e, n))
    } catch (i) {
      we('RemoteStore', 'Failed to raise snapshot:', i), await ff(e, i)
    }
}
async function ff(e, t, n) {
  if (!Ws(t)) throw t
  e.M_.add(1),
    await nd(e),
    e.N_.set('Offline'),
    n || (n = () => Nx(e.localStore)),
    e.asyncQueue.enqueueRetryable(async () => {
      we('RemoteStore', 'Retrying IndexedDB access'), await n(), e.M_.delete(1), await mm(e)
    })
}
function Ux(e, t) {
  return t().catch((n) => ff(e, n, t))
}
async function id(e) {
  const t = Ke(e),
    n = Ms(t)
  let i = t.v_.length > 0 ? t.v_[t.v_.length - 1].batchId : -1
  for (; z5(t); )
    try {
      const r = await C5(t.localStore, i)
      if (r === null) {
        t.v_.length === 0 && n.n_()
        break
      }
      ;(i = r.batchId), H5(t, r)
    } catch (r) {
      await ff(t, r)
    }
  jx(t) && zx(t)
}
function z5(e) {
  return ua(e) && e.v_.length < 10
}
function H5(e, t) {
  e.v_.push(t)
  const n = Ms(e)
  n.Xo() && n.E_ && n.d_(t.mutations)
}
function jx(e) {
  return ua(e) && !Ms(e).Zo() && e.v_.length > 0
}
function zx(e) {
  Ms(e).start()
}
async function W5(e) {
  Ms(e).V_()
}
async function q5(e) {
  const t = Ms(e)
  for (const n of e.v_) t.d_(n.mutations)
}
async function G5(e, t, n) {
  const i = e.v_.shift(),
    r = L_.from(i, t, n)
  await Ux(e, () => e.remoteSyncer.applySuccessfulWrite(r)), await id(e)
}
async function K5(e, t) {
  t &&
    Ms(e).E_ &&
    (await (async function (i, r) {
      if (
        (function (o) {
          return x6(o) && o !== fe.ABORTED
        })(r.code)
      ) {
        const s = i.v_.shift()
        Ms(i).t_(), await Ux(i, () => i.remoteSyncer.rejectFailedWrite(s.batchId, r)), await id(i)
      }
    })(e, t)),
    jx(e) && zx(e)
}
async function y0(e, t) {
  const n = Ke(e)
  n.asyncQueue.verifyOperationInProgress(), we('RemoteStore', 'RemoteStore received new credentials')
  const i = ua(n)
  n.M_.add(3),
    await nd(n),
    i && n.N_.set('Unknown'),
    await n.remoteSyncer.handleCredentialChange(t),
    n.M_.delete(3),
    await mm(n)
}
async function Y5(e, t) {
  const n = Ke(e)
  t ? (n.M_.delete(2), await mm(n)) : t || (n.M_.add(2), await nd(n), n.N_.set('Unknown'))
}
function Hl(e) {
  return (
    e.B_ ||
      ((e.B_ = (function (n, i, r) {
        const s = Ke(n)
        return s.f_(), new N5(i, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, r)
      })(e.datastore, e.asyncQueue, {
        Po: B5.bind(null, e),
        To: $5.bind(null, e),
        Ao: U5.bind(null, e),
        h_: j5.bind(null, e),
      })),
      e.x_.push(async (t) => {
        t ? (e.B_.t_(), Y_(e) ? K_(e) : e.N_.set('Unknown')) : (await e.B_.stop(), $x(e))
      })),
    e.B_
  )
}
function Ms(e) {
  return (
    e.k_ ||
      ((e.k_ = (function (n, i, r) {
        const s = Ke(n)
        return s.f_(), new O5(i, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, r)
      })(e.datastore, e.asyncQueue, {
        Po: () => Promise.resolve(),
        To: W5.bind(null, e),
        Ao: K5.bind(null, e),
        R_: q5.bind(null, e),
        A_: G5.bind(null, e),
      })),
      e.x_.push(async (t) => {
        t
          ? (e.k_.t_(), await id(e))
          : (await e.k_.stop(),
            e.v_.length > 0 &&
              (we('RemoteStore', `Stopping write stream with ${e.v_.length} pending writes`), (e.v_ = [])))
      })),
    e.k_
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Q_ {
  constructor(t, n, i, r, s) {
    ;(this.asyncQueue = t),
      (this.timerId = n),
      (this.targetTimeMs = i),
      (this.op = r),
      (this.removalCallback = s),
      (this.deferred = new cr()),
      (this.then = this.deferred.promise.then.bind(this.deferred.promise)),
      this.deferred.promise.catch((o) => {})
  }
  get promise() {
    return this.deferred.promise
  }
  static createAndSchedule(t, n, i, r, s) {
    const o = Date.now() + i,
      a = new Q_(t, n, o, r, s)
    return a.start(i), a
  }
  start(t) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t)
  }
  skipDelay() {
    return this.handleDelayElapsed()
  }
  cancel(t) {
    this.timerHandle !== null &&
      (this.clearTimeout(), this.deferred.reject(new Ve(fe.CANCELLED, 'Operation cancelled' + (t ? ': ' + t : ''))))
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() =>
      this.timerHandle !== null
        ? (this.clearTimeout(), this.op().then((t) => this.deferred.resolve(t)))
        : Promise.resolve()
    )
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), (this.timerHandle = null))
  }
}
function X_(e, t) {
  if ((Gn('AsyncQueue', `${t}: ${e}`), Ws(e))) return new Ve(fe.UNAVAILABLE, `${t}: ${e}`)
  throw e
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class sl {
  constructor(t) {
    ;(this.comparator = t ? (n, i) => t(n, i) || Re.comparator(n.key, i.key) : (n, i) => Re.comparator(n.key, i.key)),
      (this.keyedMap = xu()),
      (this.sortedSet = new Nt(this.comparator))
  }
  static emptySet(t) {
    return new sl(t.comparator)
  }
  has(t) {
    return this.keyedMap.get(t) != null
  }
  get(t) {
    return this.keyedMap.get(t)
  }
  first() {
    return this.sortedSet.minKey()
  }
  last() {
    return this.sortedSet.maxKey()
  }
  isEmpty() {
    return this.sortedSet.isEmpty()
  }
  indexOf(t) {
    const n = this.keyedMap.get(t)
    return n ? this.sortedSet.indexOf(n) : -1
  }
  get size() {
    return this.sortedSet.size
  }
  forEach(t) {
    this.sortedSet.inorderTraversal((n, i) => (t(n), !1))
  }
  add(t) {
    const n = this.delete(t.key)
    return n.copy(n.keyedMap.insert(t.key, t), n.sortedSet.insert(t, null))
  }
  delete(t) {
    const n = this.get(t)
    return n ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(n)) : this
  }
  isEqual(t) {
    if (!(t instanceof sl) || this.size !== t.size) return !1
    const n = this.sortedSet.getIterator(),
      i = t.sortedSet.getIterator()
    for (; n.hasNext(); ) {
      const r = n.getNext().key,
        s = i.getNext().key
      if (!r.isEqual(s)) return !1
    }
    return !0
  }
  toString() {
    const t = []
    return (
      this.forEach((n) => {
        t.push(n.toString())
      }),
      t.length === 0
        ? 'DocumentSet ()'
        : `DocumentSet (
  ` +
          t.join(`  
`) +
          `
)`
    )
  }
  copy(t, n) {
    const i = new sl()
    return (i.comparator = this.comparator), (i.keyedMap = t), (i.sortedSet = n), i
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class _0 {
  constructor() {
    this.q_ = new Nt(Re.comparator)
  }
  track(t) {
    const n = t.doc.key,
      i = this.q_.get(n)
    i
      ? t.type !== 0 && i.type === 3
        ? (this.q_ = this.q_.insert(n, t))
        : t.type === 3 && i.type !== 1
        ? (this.q_ = this.q_.insert(n, { type: i.type, doc: t.doc }))
        : t.type === 2 && i.type === 2
        ? (this.q_ = this.q_.insert(n, { type: 2, doc: t.doc }))
        : t.type === 2 && i.type === 0
        ? (this.q_ = this.q_.insert(n, { type: 0, doc: t.doc }))
        : t.type === 1 && i.type === 0
        ? (this.q_ = this.q_.remove(n))
        : t.type === 1 && i.type === 2
        ? (this.q_ = this.q_.insert(n, { type: 1, doc: i.doc }))
        : t.type === 0 && i.type === 1
        ? (this.q_ = this.q_.insert(n, { type: 2, doc: t.doc }))
        : Oe()
      : (this.q_ = this.q_.insert(n, t))
  }
  Q_() {
    const t = []
    return (
      this.q_.inorderTraversal((n, i) => {
        t.push(i)
      }),
      t
    )
  }
}
class El {
  constructor(t, n, i, r, s, o, a, l, u) {
    ;(this.query = t),
      (this.docs = n),
      (this.oldDocs = i),
      (this.docChanges = r),
      (this.mutatedKeys = s),
      (this.fromCache = o),
      (this.syncStateChanged = a),
      (this.excludesMetadataChanges = l),
      (this.hasCachedResults = u)
  }
  static fromInitialDocuments(t, n, i, r, s) {
    const o = []
    return (
      n.forEach((a) => {
        o.push({ type: 0, doc: a })
      }),
      new El(t, n, sl.emptySet(n), o, i, r, !0, !1, s)
    )
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty()
  }
  isEqual(t) {
    if (
      !(
        this.fromCache === t.fromCache &&
        this.hasCachedResults === t.hasCachedResults &&
        this.syncStateChanged === t.syncStateChanged &&
        this.mutatedKeys.isEqual(t.mutatedKeys) &&
        sm(this.query, t.query) &&
        this.docs.isEqual(t.docs) &&
        this.oldDocs.isEqual(t.oldDocs)
      )
    )
      return !1
    const n = this.docChanges,
      i = t.docChanges
    if (n.length !== i.length) return !1
    for (let r = 0; r < n.length; r++) if (n[r].type !== i[r].type || !n[r].doc.isEqual(i[r].doc)) return !1
    return !0
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Q5 {
  constructor() {
    ;(this.K_ = void 0), (this.U_ = [])
  }
  W_() {
    return this.U_.some((t) => t.G_())
  }
}
class X5 {
  constructor() {
    ;(this.queries = new qs((t) => WR(t), sm)), (this.onlineState = 'Unknown'), (this.z_ = new Set())
  }
}
async function J_(e, t) {
  const n = Ke(e)
  let i = 3
  const r = t.query
  let s = n.queries.get(r)
  s ? !s.W_() && t.G_() && (i = 2) : ((s = new Q5()), (i = t.G_() ? 0 : 1))
  try {
    switch (i) {
      case 0:
        s.K_ = await n.onListen(r, !0)
        break
      case 1:
        s.K_ = await n.onListen(r, !1)
        break
      case 2:
        await n.onFirstRemoteStoreListen(r)
    }
  } catch (o) {
    const a = X_(o, `Initialization of query '${Ba(t.query)}' failed`)
    return void t.onError(a)
  }
  n.queries.set(r, s), s.U_.push(t), t.j_(n.onlineState), s.K_ && t.H_(s.K_) && eb(n)
}
async function Z_(e, t) {
  const n = Ke(e),
    i = t.query
  let r = 3
  const s = n.queries.get(i)
  if (s) {
    const o = s.U_.indexOf(t)
    o >= 0 && (s.U_.splice(o, 1), s.U_.length === 0 ? (r = t.G_() ? 0 : 1) : !s.W_() && t.G_() && (r = 2))
  }
  switch (r) {
    case 0:
      return n.queries.delete(i), n.onUnlisten(i, !0)
    case 1:
      return n.queries.delete(i), n.onUnlisten(i, !1)
    case 2:
      return n.onLastRemoteStoreUnlisten(i)
    default:
      return
  }
}
function J5(e, t) {
  const n = Ke(e)
  let i = !1
  for (const r of t) {
    const s = r.query,
      o = n.queries.get(s)
    if (o) {
      for (const a of o.U_) a.H_(r) && (i = !0)
      o.K_ = r
    }
  }
  i && eb(n)
}
function Z5(e, t, n) {
  const i = Ke(e),
    r = i.queries.get(t)
  if (r) for (const s of r.U_) s.onError(n)
  i.queries.delete(t)
}
function eb(e) {
  e.z_.forEach((t) => {
    t.next()
  })
}
var Sp, b0
;((b0 = Sp || (Sp = {})).J_ = 'default'), (b0.Cache = 'cache')
class tb {
  constructor(t, n, i) {
    ;(this.query = t),
      (this.Y_ = n),
      (this.Z_ = !1),
      (this.X_ = null),
      (this.onlineState = 'Unknown'),
      (this.options = i || {})
  }
  H_(t) {
    if (!this.options.includeMetadataChanges) {
      const i = []
      for (const r of t.docChanges) r.type !== 3 && i.push(r)
      t = new El(t.query, t.docs, t.oldDocs, i, t.mutatedKeys, t.fromCache, t.syncStateChanged, !0, t.hasCachedResults)
    }
    let n = !1
    return (
      this.Z_ ? this.ea(t) && (this.Y_.next(t), (n = !0)) : this.ta(t, this.onlineState) && (this.na(t), (n = !0)),
      (this.X_ = t),
      n
    )
  }
  onError(t) {
    this.Y_.error(t)
  }
  j_(t) {
    this.onlineState = t
    let n = !1
    return this.X_ && !this.Z_ && this.ta(this.X_, t) && (this.na(this.X_), (n = !0)), n
  }
  ta(t, n) {
    if (!t.fromCache || !this.G_()) return !0
    const i = n !== 'Offline'
    return (!this.options.ra || !i) && (!t.docs.isEmpty() || t.hasCachedResults || n === 'Offline')
  }
  ea(t) {
    if (t.docChanges.length > 0) return !0
    const n = this.X_ && this.X_.hasPendingWrites !== t.hasPendingWrites
    return !(!t.syncStateChanged && !n) && this.options.includeMetadataChanges === !0
  }
  na(t) {
    ;(t = El.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache, t.hasCachedResults)),
      (this.Z_ = !0),
      this.Y_.next(t)
  }
  G_() {
    return this.options.source !== Sp.Cache
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Hx {
  constructor(t) {
    this.key = t
  }
}
class Wx {
  constructor(t) {
    this.key = t
  }
}
class eW {
  constructor(t, n) {
    ;(this.query = t),
      (this.la = n),
      (this.ha = null),
      (this.hasCachedResults = !1),
      (this.current = !1),
      (this.Pa = Qe()),
      (this.mutatedKeys = Qe()),
      (this.Ia = qR(t)),
      (this.Ta = new sl(this.Ia))
  }
  get Ea() {
    return this.la
  }
  da(t, n) {
    const i = n ? n.Aa : new _0(),
      r = n ? n.Ta : this.Ta
    let s = n ? n.mutatedKeys : this.mutatedKeys,
      o = r,
      a = !1
    const l = this.query.limitType === 'F' && r.size === this.query.limit ? r.last() : null,
      u = this.query.limitType === 'L' && r.size === this.query.limit ? r.first() : null
    if (
      (t.inorderTraversal((c, d) => {
        const f = r.get(c),
          m = ed(this.query, d) ? d : null,
          p = !!f && this.mutatedKeys.has(f.key),
          v = !!m && (m.hasLocalMutations || (this.mutatedKeys.has(m.key) && m.hasCommittedMutations))
        let y = !1
        f && m
          ? f.data.isEqual(m.data)
            ? p !== v && (i.track({ type: 3, doc: m }), (y = !0))
            : this.Ra(f, m) ||
              (i.track({ type: 2, doc: m }),
              (y = !0),
              ((l && this.Ia(m, l) > 0) || (u && this.Ia(m, u) < 0)) && (a = !0))
          : !f && m
          ? (i.track({ type: 0, doc: m }), (y = !0))
          : f && !m && (i.track({ type: 1, doc: f }), (y = !0), (l || u) && (a = !0)),
          y && (m ? ((o = o.add(m)), (s = v ? s.add(c) : s.delete(c))) : ((o = o.delete(c)), (s = s.delete(c))))
      }),
      this.query.limit !== null)
    )
      for (; o.size > this.query.limit; ) {
        const c = this.query.limitType === 'F' ? o.last() : o.first()
        ;(o = o.delete(c.key)), (s = s.delete(c.key)), i.track({ type: 1, doc: c })
      }
    return { Ta: o, Aa: i, Xi: a, mutatedKeys: s }
  }
  Ra(t, n) {
    return t.hasLocalMutations && n.hasCommittedMutations && !n.hasLocalMutations
  }
  applyChanges(t, n, i, r) {
    const s = this.Ta
    ;(this.Ta = t.Ta), (this.mutatedKeys = t.mutatedKeys)
    const o = t.Aa.Q_()
    o.sort(
      (c, d) =>
        (function (m, p) {
          const v = (y) => {
            switch (y) {
              case 0:
                return 1
              case 2:
              case 3:
                return 2
              case 1:
                return 0
              default:
                return Oe()
            }
          }
          return v(m) - v(p)
        })(c.type, d.type) || this.Ia(c.doc, d.doc)
    ),
      this.Va(i),
      (r = r != null && r)
    const a = n && !r ? this.ma() : [],
      l = this.Pa.size === 0 && this.current && !r ? 1 : 0,
      u = l !== this.ha
    return (
      (this.ha = l),
      o.length !== 0 || u
        ? {
            snapshot: new El(
              this.query,
              t.Ta,
              s,
              o,
              t.mutatedKeys,
              l === 0,
              u,
              !1,
              !!i && i.resumeToken.approximateByteSize() > 0
            ),
            fa: a,
          }
        : { fa: a }
    )
  }
  j_(t) {
    return this.current && t === 'Offline'
      ? ((this.current = !1),
        this.applyChanges({ Ta: this.Ta, Aa: new _0(), mutatedKeys: this.mutatedKeys, Xi: !1 }, !1))
      : { fa: [] }
  }
  ga(t) {
    return !this.la.has(t) && !!this.Ta.has(t) && !this.Ta.get(t).hasLocalMutations
  }
  Va(t) {
    t &&
      (t.addedDocuments.forEach((n) => (this.la = this.la.add(n))),
      t.modifiedDocuments.forEach((n) => {}),
      t.removedDocuments.forEach((n) => (this.la = this.la.delete(n))),
      (this.current = t.current))
  }
  ma() {
    if (!this.current) return []
    const t = this.Pa
    ;(this.Pa = Qe()),
      this.Ta.forEach((i) => {
        this.ga(i.key) && (this.Pa = this.Pa.add(i.key))
      })
    const n = []
    return (
      t.forEach((i) => {
        this.Pa.has(i) || n.push(new Wx(i))
      }),
      this.Pa.forEach((i) => {
        t.has(i) || n.push(new Hx(i))
      }),
      n
    )
  }
  pa(t) {
    ;(this.la = t.hs), (this.Pa = Qe())
    const n = this.da(t.documents)
    return this.applyChanges(n, !0)
  }
  ya() {
    return El.fromInitialDocuments(this.query, this.Ta, this.mutatedKeys, this.ha === 0, this.hasCachedResults)
  }
}
class tW {
  constructor(t, n, i) {
    ;(this.query = t), (this.targetId = n), (this.view = i)
  }
}
class nW {
  constructor(t) {
    ;(this.key = t), (this.wa = !1)
  }
}
class iW {
  constructor(t, n, i, r, s, o) {
    ;(this.localStore = t),
      (this.remoteStore = n),
      (this.eventManager = i),
      (this.sharedClientState = r),
      (this.currentUser = s),
      (this.maxConcurrentLimboResolutions = o),
      (this.Sa = {}),
      (this.ba = new qs((a) => WR(a), sm)),
      (this.Da = new Map()),
      (this.Ca = new Set()),
      (this.va = new Nt(Re.comparator)),
      (this.Fa = new Map()),
      (this.Ma = new z_()),
      (this.xa = {}),
      (this.Oa = new Map()),
      (this.Na = zo.Ln()),
      (this.onlineState = 'Unknown'),
      (this.La = void 0)
  }
  get isPrimaryClient() {
    return this.La === !0
  }
}
async function rW(e, t, n = !0) {
  const i = Xx(e)
  let r
  const s = i.ba.get(t)
  return s ? (i.sharedClientState.addLocalQueryTarget(s.targetId), (r = s.view.ya())) : (r = await qx(i, t, n, !0)), r
}
async function sW(e, t) {
  const n = Xx(e)
  await qx(n, t, !0, !1)
}
async function qx(e, t, n, i) {
  const r = await A5(e.localStore, Pi(t)),
    s = r.targetId,
    o = n ? e.sharedClientState.addLocalQueryTarget(s) : 'not-current'
  let a
  return i && (a = await oW(e, t, s, o === 'current', r.resumeToken)), e.isPrimaryClient && n && Fx(e.remoteStore, r), a
}
async function oW(e, t, n, i, r) {
  e.Ba = (d, f, m) =>
    (async function (v, y, T, A) {
      let x = y.view.da(T)
      x.Xi && (x = await g0(v.localStore, y.query, !1).then(({ documents: I }) => y.view.da(I, x)))
      const N = A && A.targetChanges.get(y.targetId),
        V = A && A.targetMismatches.get(y.targetId) != null,
        D = y.view.applyChanges(x, v.isPrimaryClient, N, V)
      return I0(v, y.targetId, D.fa), D.snapshot
    })(e, d, f, m)
  const s = await g0(e.localStore, t, !0),
    o = new eW(t, s.hs),
    a = o.da(s.documents),
    l = td.createSynthesizedTargetChangeForCurrentChange(n, i && e.onlineState !== 'Offline', r),
    u = o.applyChanges(a, e.isPrimaryClient, l)
  I0(e, n, u.fa)
  const c = new tW(t, n, o)
  return e.ba.set(t, c), e.Da.has(n) ? e.Da.get(n).push(t) : e.Da.set(n, [t]), u.snapshot
}
async function aW(e, t, n) {
  const i = Ke(e),
    r = i.ba.get(t),
    s = i.Da.get(r.targetId)
  if (s.length > 1)
    return (
      i.Da.set(
        r.targetId,
        s.filter((o) => !sm(o, t))
      ),
      void i.ba.delete(t)
    )
  i.isPrimaryClient
    ? (i.sharedClientState.removeLocalQueryTarget(r.targetId),
      i.sharedClientState.isActiveQueryTarget(r.targetId) ||
        (await Ip(i.localStore, r.targetId, !1)
          .then(() => {
            i.sharedClientState.clearQueryState(r.targetId), n && q_(i.remoteStore, r.targetId), Ep(i, r.targetId)
          })
          .catch(aa)))
    : (Ep(i, r.targetId), await Ip(i.localStore, r.targetId, !0))
}
async function lW(e, t) {
  const n = Ke(e),
    i = n.ba.get(t),
    r = n.Da.get(i.targetId)
  n.isPrimaryClient &&
    r.length === 1 &&
    (n.sharedClientState.removeLocalQueryTarget(i.targetId), q_(n.remoteStore, i.targetId))
}
async function uW(e, t, n) {
  const i = Jx(e)
  try {
    const r = await (function (o, a) {
      const l = Ke(o),
        u = Dt.now(),
        c = a.reduce((m, p) => m.add(p.key), Qe())
      let d, f
      return l.persistence
        .runTransaction('Locally write mutations', 'readwrite', (m) => {
          let p = ci(),
            v = Qe()
          return l.os
            .getEntries(m, c)
            .next((y) => {
              ;(p = y),
                p.forEach((T, A) => {
                  A.isValidDocument() || (v = v.add(T))
                })
            })
            .next(() => l.localDocuments.getOverlayedDocuments(m, p))
            .next((y) => {
              d = y
              const T = []
              for (const A of a) {
                const x = P6(A, d.get(A.key).overlayedDocument)
                x != null && T.push(new Gr(A.key, x, LR(x.value.mapValue), Kn.exists(!0)))
              }
              return l.mutationQueue.addMutationBatch(m, u, T, a)
            })
            .next((y) => {
              f = y
              const T = y.applyToLocalDocumentSet(d, v)
              return l.documentOverlayCache.saveOverlays(m, y.batchId, T)
            })
        })
        .then(() => ({ batchId: f.batchId, changes: KR(d) }))
    })(i.localStore, t)
    i.sharedClientState.addPendingMutation(r.batchId),
      (function (o, a, l) {
        let u = o.xa[o.currentUser.toKey()]
        u || (u = new Nt(Ye)), (u = u.insert(a, l)), (o.xa[o.currentUser.toKey()] = u)
      })(i, r.batchId, n),
      await rd(i, r.changes),
      await id(i.remoteStore)
  } catch (r) {
    const s = X_(r, 'Failed to persist write')
    n.reject(s)
  }
}
async function Gx(e, t) {
  const n = Ke(e)
  try {
    const i = await E5(n.localStore, t)
    t.targetChanges.forEach((r, s) => {
      const o = n.Fa.get(s)
      o &&
        (Fe(r.addedDocuments.size + r.modifiedDocuments.size + r.removedDocuments.size <= 1),
        r.addedDocuments.size > 0
          ? (o.wa = !0)
          : r.modifiedDocuments.size > 0
          ? Fe(o.wa)
          : r.removedDocuments.size > 0 && (Fe(o.wa), (o.wa = !1)))
    }),
      await rd(n, i, t)
  } catch (i) {
    await aa(i)
  }
}
function w0(e, t, n) {
  const i = Ke(e)
  if ((i.isPrimaryClient && n === 0) || (!i.isPrimaryClient && n === 1)) {
    const r = []
    i.ba.forEach((s, o) => {
      const a = o.view.j_(t)
      a.snapshot && r.push(a.snapshot)
    }),
      (function (o, a) {
        const l = Ke(o)
        l.onlineState = a
        let u = !1
        l.queries.forEach((c, d) => {
          for (const f of d.U_) f.j_(a) && (u = !0)
        }),
          u && eb(l)
      })(i.eventManager, t),
      r.length && i.Sa.h_(r),
      (i.onlineState = t),
      i.isPrimaryClient && i.sharedClientState.setOnlineState(t)
  }
}
async function cW(e, t, n) {
  const i = Ke(e)
  i.sharedClientState.updateQueryState(t, 'rejected', n)
  const r = i.Fa.get(t),
    s = r && r.key
  if (s) {
    let o = new Nt(Re.comparator)
    o = o.insert(s, Wt.newNoDocument(s, $e.min()))
    const a = Qe().add(s),
      l = new um($e.min(), new Map(), new Nt(Ye), o, a)
    await Gx(i, l), (i.va = i.va.remove(s)), i.Fa.delete(t), nb(i)
  } else
    await Ip(i.localStore, t, !1)
      .then(() => Ep(i, t, n))
      .catch(aa)
}
async function dW(e, t) {
  const n = Ke(e),
    i = t.batch.batchId
  try {
    const r = await S5(n.localStore, t)
    Yx(n, i, null), Kx(n, i), n.sharedClientState.updateMutationState(i, 'acknowledged'), await rd(n, r)
  } catch (r) {
    await aa(r)
  }
}
async function hW(e, t, n) {
  const i = Ke(e)
  try {
    const r = await (function (o, a) {
      const l = Ke(o)
      return l.persistence.runTransaction('Reject batch', 'readwrite-primary', (u) => {
        let c
        return l.mutationQueue
          .lookupMutationBatch(u, a)
          .next((d) => (Fe(d !== null), (c = d.keys()), l.mutationQueue.removeMutationBatch(u, d)))
          .next(() => l.mutationQueue.performConsistencyCheck(u))
          .next(() => l.documentOverlayCache.removeOverlaysForBatchId(u, c, a))
          .next(() => l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(u, c))
          .next(() => l.localDocuments.getDocuments(u, c))
      })
    })(i.localStore, t)
    Yx(i, t, n), Kx(i, t), i.sharedClientState.updateMutationState(t, 'rejected', n), await rd(i, r)
  } catch (r) {
    await aa(r)
  }
}
function Kx(e, t) {
  ;(e.Oa.get(t) || []).forEach((n) => {
    n.resolve()
  }),
    e.Oa.delete(t)
}
function Yx(e, t, n) {
  const i = Ke(e)
  let r = i.xa[i.currentUser.toKey()]
  if (r) {
    const s = r.get(t)
    s && (n ? s.reject(n) : s.resolve(), (r = r.remove(t))), (i.xa[i.currentUser.toKey()] = r)
  }
}
function Ep(e, t, n = null) {
  e.sharedClientState.removeLocalQueryTarget(t)
  for (const i of e.Da.get(t)) e.ba.delete(i), n && e.Sa.ka(i, n)
  e.Da.delete(t),
    e.isPrimaryClient &&
      e.Ma.Vr(t).forEach((i) => {
        e.Ma.containsKey(i) || Qx(e, i)
      })
}
function Qx(e, t) {
  e.Ca.delete(t.path.canonicalString())
  const n = e.va.get(t)
  n !== null && (q_(e.remoteStore, n), (e.va = e.va.remove(t)), e.Fa.delete(n), nb(e))
}
function I0(e, t, n) {
  for (const i of n)
    i instanceof Hx
      ? (e.Ma.addReference(i.key, t), fW(e, i))
      : i instanceof Wx
      ? (we('SyncEngine', 'Document no longer in limbo: ' + i.key),
        e.Ma.removeReference(i.key, t),
        e.Ma.containsKey(i.key) || Qx(e, i.key))
      : Oe()
}
function fW(e, t) {
  const n = t.key,
    i = n.path.canonicalString()
  e.va.get(n) || e.Ca.has(i) || (we('SyncEngine', 'New document in limbo: ' + n), e.Ca.add(i), nb(e))
}
function nb(e) {
  for (; e.Ca.size > 0 && e.va.size < e.maxConcurrentLimboResolutions; ) {
    const t = e.Ca.values().next().value
    e.Ca.delete(t)
    const n = new Re(pt.fromString(t)),
      i = e.Na.next()
    e.Fa.set(i, new nW(n)),
      (e.va = e.va.insert(n, i)),
      Fx(e.remoteStore, new xr(Pi(Zc(n.path)), i, 'TargetPurposeLimboResolution', Ci.oe))
  }
}
async function rd(e, t, n) {
  const i = Ke(e),
    r = [],
    s = [],
    o = []
  i.ba.isEmpty() ||
    (i.ba.forEach((a, l) => {
      o.push(
        i.Ba(l, t, n).then((u) => {
          var c
          if ((u || n) && i.isPrimaryClient) {
            const d = u
              ? !u.fromCache
              : (c = n == null ? void 0 : n.targetChanges.get(l.targetId)) === null || c === void 0
              ? void 0
              : c.current
            i.sharedClientState.updateQueryState(l.targetId, d ? 'current' : 'not-current')
          }
          if (u) {
            r.push(u)
            const d = W_.Ki(l.targetId, u)
            s.push(d)
          }
        })
      )
    }),
    await Promise.all(o),
    i.Sa.h_(r),
    await (async function (l, u) {
      const c = Ke(l)
      try {
        await c.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', (d) =>
          J.forEach(u, (f) =>
            J.forEach(f.qi, (m) => c.persistence.referenceDelegate.addReference(d, f.targetId, m)).next(() =>
              J.forEach(f.Qi, (m) => c.persistence.referenceDelegate.removeReference(d, f.targetId, m))
            )
          )
        )
      } catch (d) {
        if (!Ws(d)) throw d
        we('LocalStore', 'Failed to update sequence numbers: ' + d)
      }
      for (const d of u) {
        const f = d.targetId
        if (!d.fromCache) {
          const m = c.ns.get(f),
            p = m.snapshotVersion,
            v = m.withLastLimboFreeSnapshotVersion(p)
          c.ns = c.ns.insert(f, v)
        }
      }
    })(i.localStore, s))
}
async function mW(e, t) {
  const n = Ke(e)
  if (!n.currentUser.isEqual(t)) {
    we('SyncEngine', 'User change. New user:', t.toKey())
    const i = await Dx(n.localStore, t)
    ;(n.currentUser = t),
      (function (s, o) {
        s.Oa.forEach((a) => {
          a.forEach((l) => {
            l.reject(new Ve(fe.CANCELLED, o))
          })
        }),
          s.Oa.clear()
      })(n, "'waitForPendingWrites' promise is rejected due to a user change."),
      n.sharedClientState.handleUserChange(t, i.removedBatchIds, i.addedBatchIds),
      await rd(n, i.us)
  }
}
function gW(e, t) {
  const n = Ke(e),
    i = n.Fa.get(t)
  if (i && i.wa) return Qe().add(i.key)
  {
    let r = Qe()
    const s = n.Da.get(t)
    if (!s) return r
    for (const o of s) {
      const a = n.ba.get(o)
      r = r.unionWith(a.view.Ea)
    }
    return r
  }
}
function Xx(e) {
  const t = Ke(e)
  return (
    (t.remoteStore.remoteSyncer.applyRemoteEvent = Gx.bind(null, t)),
    (t.remoteStore.remoteSyncer.getRemoteKeysForTarget = gW.bind(null, t)),
    (t.remoteStore.remoteSyncer.rejectListen = cW.bind(null, t)),
    (t.Sa.h_ = J5.bind(null, t.eventManager)),
    (t.Sa.ka = Z5.bind(null, t.eventManager)),
    t
  )
}
function Jx(e) {
  const t = Ke(e)
  return (
    (t.remoteStore.remoteSyncer.applySuccessfulWrite = dW.bind(null, t)),
    (t.remoteStore.remoteSyncer.rejectFailedWrite = hW.bind(null, t)),
    t
  )
}
class Tp {
  constructor() {
    this.synchronizeTabs = !1
  }
  async initialize(t) {
    ;(this.serializer = fm(t.databaseInfo.databaseId)),
      (this.sharedClientState = this.createSharedClientState(t)),
      (this.persistence = this.createPersistence(t)),
      await this.persistence.start(),
      (this.localStore = this.createLocalStore(t)),
      (this.gcScheduler = this.createGarbageCollectionScheduler(t, this.localStore)),
      (this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(t, this.localStore))
  }
  createGarbageCollectionScheduler(t, n) {
    return null
  }
  createIndexBackfillerScheduler(t, n) {
    return null
  }
  createLocalStore(t) {
    return Vx(this.persistence, new xx(), t.initialUser, this.serializer)
  }
  createPersistence(t) {
    return new Rx(hm.Hr, this.serializer)
  }
  createSharedClientState(t) {
    return new Ox()
  }
  async terminate() {
    var t, n
    ;(t = this.gcScheduler) === null || t === void 0 || t.stop(),
      (n = this.indexBackfillerScheduler) === null || n === void 0 || n.stop(),
      this.sharedClientState.shutdown(),
      await this.persistence.shutdown()
  }
}
class vW extends Tp {
  constructor(t, n, i) {
    super(), (this.Qa = t), (this.cacheSizeBytes = n), (this.forceOwnership = i), (this.synchronizeTabs = !1)
  }
  async initialize(t) {
    await super.initialize(t),
      await this.Qa.initialize(this, t),
      await Jx(this.Qa.syncEngine),
      await id(this.Qa.remoteStore),
      await this.persistence.fi(
        () => (
          this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(),
          this.indexBackfillerScheduler &&
            !this.indexBackfillerScheduler.started &&
            this.indexBackfillerScheduler.start(),
          Promise.resolve()
        )
      )
  }
  createLocalStore(t) {
    return Vx(this.persistence, new xx(), t.initialUser, this.serializer)
  }
  createGarbageCollectionScheduler(t, n) {
    const i = this.persistence.referenceDelegate.garbageCollector
    return new s5(i, t.asyncQueue, n)
  }
  createIndexBackfillerScheduler(t, n) {
    const i = new NH(n, this.persistence)
    return new DH(t.asyncQueue, i)
  }
  createPersistence(t) {
    const n = b5(t.databaseInfo.databaseId, t.databaseInfo.persistenceKey),
      i = this.cacheSizeBytes !== void 0 ? Zn.withCacheSize(this.cacheSizeBytes) : Zn.DEFAULT
    return new H_(
      this.synchronizeTabs,
      n,
      t.clientId,
      i,
      t.asyncQueue,
      D5(),
      kh(),
      this.serializer,
      this.sharedClientState,
      !!this.forceOwnership
    )
  }
  createSharedClientState(t) {
    return new Ox()
  }
}
class Zx {
  async initialize(t, n) {
    this.localStore ||
      ((this.localStore = t.localStore),
      (this.sharedClientState = t.sharedClientState),
      (this.datastore = this.createDatastore(n)),
      (this.remoteStore = this.createRemoteStore(n)),
      (this.eventManager = this.createEventManager(n)),
      (this.syncEngine = this.createSyncEngine(n, !t.synchronizeTabs)),
      (this.sharedClientState.onlineStateHandler = (i) => w0(this.syncEngine, i, 1)),
      (this.remoteStore.remoteSyncer.handleCredentialChange = mW.bind(null, this.syncEngine)),
      await Y5(this.remoteStore, this.syncEngine.isPrimaryClient))
  }
  createEventManager(t) {
    return (function () {
      return new X5()
    })()
  }
  createDatastore(t) {
    const n = fm(t.databaseInfo.databaseId),
      i = (function (s) {
        return new V5(s)
      })(t.databaseInfo)
    return (function (s, o, a, l) {
      return new M5(s, o, a, l)
    })(t.authCredentials, t.appCheckCredentials, i, n)
  }
  createRemoteStore(t) {
    return (function (i, r, s, o, a) {
      return new F5(i, r, s, o, a)
    })(
      this.localStore,
      this.datastore,
      t.asyncQueue,
      (n) => w0(this.syncEngine, n, 0),
      (function () {
        return p0.D() ? new p0() : new P5()
      })()
    )
  }
  createSyncEngine(t, n) {
    return (function (r, s, o, a, l, u, c) {
      const d = new iW(r, s, o, a, l, u)
      return c && (d.La = !0), d
    })(
      this.localStore,
      this.remoteStore,
      this.eventManager,
      this.sharedClientState,
      t.initialUser,
      t.maxConcurrentLimboResolutions,
      n
    )
  }
  async terminate() {
    var t
    await (async function (i) {
      const r = Ke(i)
      we('RemoteStore', 'RemoteStore shutting down.'), r.M_.add(5), await nd(r), r.O_.shutdown(), r.N_.set('Unknown')
    })(this.remoteStore),
      (t = this.datastore) === null || t === void 0 || t.terminate()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ib {
  constructor(t) {
    ;(this.observer = t), (this.muted = !1)
  }
  next(t) {
    this.observer.next && this.Ka(this.observer.next, t)
  }
  error(t) {
    this.observer.error ? this.Ka(this.observer.error, t) : Gn('Uncaught Error in snapshot listener:', t.toString())
  }
  $a() {
    this.muted = !0
  }
  Ka(t, n) {
    this.muted ||
      setTimeout(() => {
        this.muted || t(n)
      }, 0)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class pW {
  constructor(t, n, i, r) {
    ;(this.authCredentials = t),
      (this.appCheckCredentials = n),
      (this.asyncQueue = i),
      (this.databaseInfo = r),
      (this.user = qn.UNAUTHENTICATED),
      (this.clientId = SR.newId()),
      (this.authCredentialListener = () => Promise.resolve()),
      (this.appCheckCredentialListener = () => Promise.resolve()),
      this.authCredentials.start(i, async (s) => {
        we('FirestoreClient', 'Received user=', s.uid), await this.authCredentialListener(s), (this.user = s)
      }),
      this.appCheckCredentials.start(
        i,
        (s) => (
          we('FirestoreClient', 'Received new app check token=', s), this.appCheckCredentialListener(s, this.user)
        )
      )
  }
  get configuration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100,
    }
  }
  setCredentialChangeListener(t) {
    this.authCredentialListener = t
  }
  setAppCheckTokenChangeListener(t) {
    this.appCheckCredentialListener = t
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown) throw new Ve(fe.FAILED_PRECONDITION, 'The client has already been terminated.')
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode()
    const t = new cr()
    return (
      this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
        try {
          this._onlineComponents && (await this._onlineComponents.terminate()),
            this._offlineComponents && (await this._offlineComponents.terminate()),
            this.authCredentials.shutdown(),
            this.appCheckCredentials.shutdown(),
            t.resolve()
        } catch (n) {
          const i = X_(n, 'Failed to shutdown persistence')
          t.reject(i)
        }
      }),
      t.promise
    )
  }
}
async function qg(e, t) {
  e.asyncQueue.verifyOperationInProgress(), we('FirestoreClient', 'Initializing OfflineComponentProvider')
  const n = e.configuration
  await t.initialize(n)
  let i = n.initialUser
  e.setCredentialChangeListener(async (r) => {
    i.isEqual(r) || (await Dx(t.localStore, r), (i = r))
  }),
    t.persistence.setDatabaseDeletedListener(() => e.terminate()),
    (e._offlineComponents = t)
}
async function S0(e, t) {
  e.asyncQueue.verifyOperationInProgress()
  const n = await _W(e)
  we('FirestoreClient', 'Initializing OnlineComponentProvider'),
    await t.initialize(n, e.configuration),
    e.setCredentialChangeListener((i) => y0(t.remoteStore, i)),
    e.setAppCheckTokenChangeListener((i, r) => y0(t.remoteStore, r)),
    (e._onlineComponents = t)
}
function yW(e) {
  return e.name === 'FirebaseError'
    ? e.code === fe.FAILED_PRECONDITION || e.code === fe.UNIMPLEMENTED
    : !(typeof DOMException < 'u' && e instanceof DOMException) || e.code === 22 || e.code === 20 || e.code === 11
}
async function _W(e) {
  if (!e._offlineComponents)
    if (e._uninitializedComponentsProvider) {
      we('FirestoreClient', 'Using user provided OfflineComponentProvider')
      try {
        await qg(e, e._uninitializedComponentsProvider._offline)
      } catch (t) {
        const n = t
        if (!yW(n)) throw n
        mc('Error using user provided cache. Falling back to memory cache: ' + n), await qg(e, new Tp())
      }
    } else we('FirestoreClient', 'Using default OfflineComponentProvider'), await qg(e, new Tp())
  return e._offlineComponents
}
async function e1(e) {
  return (
    e._onlineComponents ||
      (e._uninitializedComponentsProvider
        ? (we('FirestoreClient', 'Using user provided OnlineComponentProvider'),
          await S0(e, e._uninitializedComponentsProvider._online))
        : (we('FirestoreClient', 'Using default OnlineComponentProvider'), await S0(e, new Zx()))),
    e._onlineComponents
  )
}
function bW(e) {
  return e1(e).then((t) => t.syncEngine)
}
async function mf(e) {
  const t = await e1(e),
    n = t.eventManager
  return (
    (n.onListen = rW.bind(null, t.syncEngine)),
    (n.onUnlisten = aW.bind(null, t.syncEngine)),
    (n.onFirstRemoteStoreListen = sW.bind(null, t.syncEngine)),
    (n.onLastRemoteStoreUnlisten = lW.bind(null, t.syncEngine)),
    n
  )
}
function wW(e, t, n = {}) {
  const i = new cr()
  return (
    e.asyncQueue.enqueueAndForget(async () =>
      (function (s, o, a, l, u) {
        const c = new ib({
            next: (f) => {
              o.enqueueAndForget(() => Z_(s, d))
              const m = f.docs.has(a)
              !m && f.fromCache
                ? u.reject(new Ve(fe.UNAVAILABLE, 'Failed to get document because the client is offline.'))
                : m && f.fromCache && l && l.source === 'server'
                ? u.reject(
                    new Ve(
                      fe.UNAVAILABLE,
                      'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)'
                    )
                  )
                : u.resolve(f)
            },
            error: (f) => u.reject(f),
          }),
          d = new tb(Zc(a.path), c, { includeMetadataChanges: !0, ra: !0 })
        return J_(s, d)
      })(await mf(e), e.asyncQueue, t, n, i)
    ),
    i.promise
  )
}
function IW(e, t, n = {}) {
  const i = new cr()
  return (
    e.asyncQueue.enqueueAndForget(async () =>
      (function (s, o, a, l, u) {
        const c = new ib({
            next: (f) => {
              o.enqueueAndForget(() => Z_(s, d)),
                f.fromCache && l.source === 'server'
                  ? u.reject(
                      new Ve(
                        fe.UNAVAILABLE,
                        'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)'
                      )
                    )
                  : u.resolve(f)
            },
            error: (f) => u.reject(f),
          }),
          d = new tb(a, c, { includeMetadataChanges: !0, ra: !0 })
        return J_(s, d)
      })(await mf(e), e.asyncQueue, t, n, i)
    ),
    i.promise
  )
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function t1(e) {
  const t = {}
  return e.timeoutSeconds !== void 0 && (t.timeoutSeconds = e.timeoutSeconds), t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const E0 = new Map()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function n1(e, t, n) {
  if (!n) throw new Ve(fe.INVALID_ARGUMENT, `Function ${e}() cannot be called with an empty ${t}.`)
}
function SW(e, t, n, i) {
  if (t === !0 && i === !0) throw new Ve(fe.INVALID_ARGUMENT, `${e} and ${n} cannot be used together.`)
}
function T0(e) {
  if (!Re.isDocumentKey(e))
    throw new Ve(
      fe.INVALID_ARGUMENT,
      `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`
    )
}
function C0(e) {
  if (Re.isDocumentKey(e))
    throw new Ve(
      fe.INVALID_ARGUMENT,
      `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`
    )
}
function rb(e) {
  if (e === void 0) return 'undefined'
  if (e === null) return 'null'
  if (typeof e == 'string') return e.length > 20 && (e = `${e.substring(0, 20)}...`), JSON.stringify(e)
  if (typeof e == 'number' || typeof e == 'boolean') return '' + e
  if (typeof e == 'object') {
    if (e instanceof Array) return 'an array'
    {
      const t = (function (i) {
        return i.constructor ? i.constructor.name : null
      })(e)
      return t ? `a custom ${t} object` : 'an object'
    }
  }
  return typeof e == 'function' ? 'a function' : Oe()
}
function Hi(e, t) {
  if (('_delegate' in e && (e = e._delegate), !(e instanceof t))) {
    if (t.name === e.constructor.name)
      throw new Ve(
        fe.INVALID_ARGUMENT,
        'Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?'
      )
    {
      const n = rb(e)
      throw new Ve(fe.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${n}`)
    }
  }
  return e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class A0 {
  constructor(t) {
    var n, i
    if (t.host === void 0) {
      if (t.ssl !== void 0) throw new Ve(fe.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set")
      ;(this.host = 'firestore.googleapis.com'), (this.ssl = !0)
    } else (this.host = t.host), (this.ssl = (n = t.ssl) === null || n === void 0 || n)
    if (
      ((this.credentials = t.credentials),
      (this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties),
      (this.localCache = t.localCache),
      t.cacheSizeBytes === void 0)
    )
      this.cacheSizeBytes = 41943040
    else {
      if (t.cacheSizeBytes !== -1 && t.cacheSizeBytes < 1048576)
        throw new Ve(fe.INVALID_ARGUMENT, 'cacheSizeBytes must be at least 1048576')
      this.cacheSizeBytes = t.cacheSizeBytes
    }
    SW(
      'experimentalForceLongPolling',
      t.experimentalForceLongPolling,
      'experimentalAutoDetectLongPolling',
      t.experimentalAutoDetectLongPolling
    ),
      (this.experimentalForceLongPolling = !!t.experimentalForceLongPolling),
      this.experimentalForceLongPolling
        ? (this.experimentalAutoDetectLongPolling = !1)
        : t.experimentalAutoDetectLongPolling === void 0
        ? (this.experimentalAutoDetectLongPolling = !0)
        : (this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling),
      (this.experimentalLongPollingOptions = t1(
        (i = t.experimentalLongPollingOptions) !== null && i !== void 0 ? i : {}
      )),
      (function (s) {
        if (s.timeoutSeconds !== void 0) {
          if (isNaN(s.timeoutSeconds))
            throw new Ve(fe.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (must not be NaN)`)
          if (s.timeoutSeconds < 5)
            throw new Ve(
              fe.INVALID_ARGUMENT,
              `invalid long polling timeout: ${s.timeoutSeconds} (minimum allowed value is 5)`
            )
          if (s.timeoutSeconds > 30)
            throw new Ve(
              fe.INVALID_ARGUMENT,
              `invalid long polling timeout: ${s.timeoutSeconds} (maximum allowed value is 30)`
            )
        }
      })(this.experimentalLongPollingOptions),
      (this.useFetchStreams = !!t.useFetchStreams)
  }
  isEqual(t) {
    return (
      this.host === t.host &&
      this.ssl === t.ssl &&
      this.credentials === t.credentials &&
      this.cacheSizeBytes === t.cacheSizeBytes &&
      this.experimentalForceLongPolling === t.experimentalForceLongPolling &&
      this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling &&
      (function (i, r) {
        return i.timeoutSeconds === r.timeoutSeconds
      })(this.experimentalLongPollingOptions, t.experimentalLongPollingOptions) &&
      this.ignoreUndefinedProperties === t.ignoreUndefinedProperties &&
      this.useFetchStreams === t.useFetchStreams
    )
  }
}
class sb {
  constructor(t, n, i, r) {
    ;(this._authCredentials = t),
      (this._appCheckCredentials = n),
      (this._databaseId = i),
      (this._app = r),
      (this.type = 'firestore-lite'),
      (this._persistenceKey = '(lite)'),
      (this._settings = new A0({})),
      (this._settingsFrozen = !1)
  }
  get app() {
    if (!this._app)
      throw new Ve(
        fe.FAILED_PRECONDITION,
        "Firestore was not initialized using the Firebase SDK. 'app' is not available"
      )
    return this._app
  }
  get _initialized() {
    return this._settingsFrozen
  }
  get _terminated() {
    return this._terminateTask !== void 0
  }
  _setSettings(t) {
    if (this._settingsFrozen)
      throw new Ve(
        fe.FAILED_PRECONDITION,
        'Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.'
      )
    ;(this._settings = new A0(t)),
      t.credentials !== void 0 &&
        (this._authCredentials = (function (i) {
          if (!i) return new IH()
          switch (i.type) {
            case 'firstParty':
              return new TH(i.sessionIndex || '0', i.iamToken || null, i.authTokenFactory || null)
            case 'provider':
              return i.client
            default:
              throw new Ve(fe.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type')
          }
        })(t.credentials))
  }
  _getSettings() {
    return this._settings
  }
  _freezeSettings() {
    return (this._settingsFrozen = !0), this._settings
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask
  }
  toJSON() {
    return { app: this._app, databaseId: this._databaseId, settings: this._settings }
  }
  _terminate() {
    return (
      (function (n) {
        const i = E0.get(n)
        i && (we('ComponentProvider', 'Removing Datastore'), E0.delete(n), i.terminate())
      })(this),
      Promise.resolve()
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class sd {
  constructor(t, n, i) {
    ;(this.converter = n), (this._query = i), (this.type = 'query'), (this.firestore = t)
  }
  withConverter(t) {
    return new sd(this.firestore, t, this._query)
  }
}
class ni {
  constructor(t, n, i) {
    ;(this.converter = n), (this._key = i), (this.type = 'document'), (this.firestore = t)
  }
  get _path() {
    return this._key.path
  }
  get id() {
    return this._key.path.lastSegment()
  }
  get path() {
    return this._key.path.canonicalString()
  }
  get parent() {
    return new Rs(this.firestore, this.converter, this._key.path.popLast())
  }
  withConverter(t) {
    return new ni(this.firestore, t, this._key)
  }
}
class Rs extends sd {
  constructor(t, n, i) {
    super(t, n, Zc(i)), (this._path = i), (this.type = 'collection')
  }
  get id() {
    return this._query.path.lastSegment()
  }
  get path() {
    return this._query.path.canonicalString()
  }
  get parent() {
    const t = this._path.popLast()
    return t.isEmpty() ? null : new ni(this.firestore, null, new Re(t))
  }
  withConverter(t) {
    return new Rs(this.firestore, t, this._path)
  }
}
function EW(e, t, ...n) {
  if (((e = Et(e)), n1('collection', 'path', t), e instanceof sb)) {
    const i = pt.fromString(t, ...n)
    return C0(i), new Rs(e, null, i)
  }
  {
    if (!(e instanceof ni || e instanceof Rs))
      throw new Ve(
        fe.INVALID_ARGUMENT,
        'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore'
      )
    const i = e._path.child(pt.fromString(t, ...n))
    return C0(i), new Rs(e.firestore, null, i)
  }
}
function TW(e, t, ...n) {
  if (((e = Et(e)), arguments.length === 1 && (t = SR.newId()), n1('doc', 'path', t), e instanceof sb)) {
    const i = pt.fromString(t, ...n)
    return T0(i), new ni(e, null, new Re(i))
  }
  {
    if (!(e instanceof ni || e instanceof Rs))
      throw new Ve(
        fe.INVALID_ARGUMENT,
        'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore'
      )
    const i = e._path.child(pt.fromString(t, ...n))
    return T0(i), new ni(e.firestore, e instanceof Rs ? e.converter : null, new Re(i))
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class CW {
  constructor() {
    ;(this.iu = Promise.resolve()),
      (this.su = []),
      (this.ou = !1),
      (this._u = []),
      (this.au = null),
      (this.uu = !1),
      (this.cu = !1),
      (this.lu = []),
      (this.Yo = new Mx(this, 'async_queue_retry')),
      (this.hu = () => {
        const n = kh()
        n && we('AsyncQueue', 'Visibility state changed to ' + n.visibilityState), this.Yo.Wo()
      })
    const t = kh()
    t && typeof t.addEventListener == 'function' && t.addEventListener('visibilitychange', this.hu)
  }
  get isShuttingDown() {
    return this.ou
  }
  enqueueAndForget(t) {
    this.enqueue(t)
  }
  enqueueAndForgetEvenWhileRestricted(t) {
    this.Pu(), this.Iu(t)
  }
  enterRestrictedMode(t) {
    if (!this.ou) {
      ;(this.ou = !0), (this.cu = t || !1)
      const n = kh()
      n && typeof n.removeEventListener == 'function' && n.removeEventListener('visibilitychange', this.hu)
    }
  }
  enqueue(t) {
    if ((this.Pu(), this.ou)) return new Promise(() => {})
    const n = new cr()
    return this.Iu(() => (this.ou && this.cu ? Promise.resolve() : (t().then(n.resolve, n.reject), n.promise))).then(
      () => n.promise
    )
  }
  enqueueRetryable(t) {
    this.enqueueAndForget(() => (this.su.push(t), this.Tu()))
  }
  async Tu() {
    if (this.su.length !== 0) {
      try {
        await this.su[0](), this.su.shift(), this.Yo.reset()
      } catch (t) {
        if (!Ws(t)) throw t
        we('AsyncQueue', 'Operation failed with retryable error: ' + t)
      }
      this.su.length > 0 && this.Yo.$o(() => this.Tu())
    }
  }
  Iu(t) {
    const n = this.iu.then(
      () => (
        (this.uu = !0),
        t()
          .catch((i) => {
            ;(this.au = i), (this.uu = !1)
            const r = (function (o) {
              let a = o.message || ''
              return (
                o.stack &&
                  (a = o.stack.includes(o.message)
                    ? o.stack
                    : o.message +
                      `
` +
                      o.stack),
                a
              )
            })(i)
            throw (Gn('INTERNAL UNHANDLED ERROR: ', r), i)
          })
          .then((i) => ((this.uu = !1), i))
      )
    )
    return (this.iu = n), n
  }
  enqueueAfterDelay(t, n, i) {
    this.Pu(), this.lu.indexOf(t) > -1 && (n = 0)
    const r = Q_.createAndSchedule(this, t, n, i, (s) => this.Eu(s))
    return this._u.push(r), r
  }
  Pu() {
    this.au && Oe()
  }
  verifyOperationInProgress() {}
  async du() {
    let t
    do (t = this.iu), await t
    while (t !== this.iu)
  }
  Au(t) {
    for (const n of this._u) if (n.timerId === t) return !0
    return !1
  }
  Ru(t) {
    return this.du().then(() => {
      this._u.sort((n, i) => n.targetTimeMs - i.targetTimeMs)
      for (const n of this._u) if ((n.skipDelay(), t !== 'all' && n.timerId === t)) break
      return this.du()
    })
  }
  Vu(t) {
    this.lu.push(t)
  }
  Eu(t) {
    const n = this._u.indexOf(t)
    this._u.splice(n, 1)
  }
}
function k0(e) {
  return (function (n, i) {
    if (typeof n != 'object' || n === null) return !1
    const r = n
    for (const s of i) if (s in r && typeof r[s] == 'function') return !0
    return !1
  })(e, ['next', 'error', 'complete'])
}
class Ls extends sb {
  constructor(t, n, i, r) {
    super(t, n, i, r),
      (this.type = 'firestore'),
      (this._queue = (function () {
        return new CW()
      })()),
      (this._persistenceKey = (r == null ? void 0 : r.name) || '[DEFAULT]')
  }
  _terminate() {
    return this._firestoreClient || i1(this), this._firestoreClient.terminate()
  }
}
function AW(e, t, n) {
  n || (n = '(default)')
  const i = Wr(e, 'firestore')
  if (i.isInitialized(n)) {
    const r = i.getImmediate({ identifier: n }),
      s = i.getOptions(n)
    if (fl(s, t)) return r
    throw new Ve(
      fe.FAILED_PRECONDITION,
      'initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.'
    )
  }
  if (t.cacheSizeBytes !== void 0 && t.localCache !== void 0)
    throw new Ve(
      fe.INVALID_ARGUMENT,
      'cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes willbe deprecated. Instead, specify the cache size in the cache object'
    )
  if (t.cacheSizeBytes !== void 0 && t.cacheSizeBytes !== -1 && t.cacheSizeBytes < 1048576)
    throw new Ve(fe.INVALID_ARGUMENT, 'cacheSizeBytes must be at least 1048576')
  return i.initialize({ options: t, instanceIdentifier: n })
}
function gm(e) {
  return e._firestoreClient || i1(e), e._firestoreClient.verifyNotTerminated(), e._firestoreClient
}
function i1(e) {
  var t, n, i
  const r = e._freezeSettings(),
    s = (function (a, l, u, c) {
      return new t6(
        a,
        l,
        u,
        c.host,
        c.ssl,
        c.experimentalForceLongPolling,
        c.experimentalAutoDetectLongPolling,
        t1(c.experimentalLongPollingOptions),
        c.useFetchStreams
      )
    })(e._databaseId, ((t = e._app) === null || t === void 0 ? void 0 : t.options.appId) || '', e._persistenceKey, r)
  ;(e._firestoreClient = new pW(e._authCredentials, e._appCheckCredentials, e._queue, s)),
    !((n = r.localCache) === null || n === void 0) &&
      n._offlineComponentProvider &&
      !((i = r.localCache) === null || i === void 0) &&
      i._onlineComponentProvider &&
      (e._firestoreClient._uninitializedComponentsProvider = {
        _offlineKind: r.localCache.kind,
        _offline: r.localCache._offlineComponentProvider,
        _online: r.localCache._onlineComponentProvider,
      })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Tl {
  constructor(t) {
    this._byteString = t
  }
  static fromBase64String(t) {
    try {
      return new Tl(En.fromBase64String(t))
    } catch (n) {
      throw new Ve(fe.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + n)
    }
  }
  static fromUint8Array(t) {
    return new Tl(En.fromUint8Array(t))
  }
  toBase64() {
    return this._byteString.toBase64()
  }
  toUint8Array() {
    return this._byteString.toUint8Array()
  }
  toString() {
    return 'Bytes(base64: ' + this.toBase64() + ')'
  }
  isEqual(t) {
    return this._byteString.isEqual(t._byteString)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class vm {
  constructor(...t) {
    for (let n = 0; n < t.length; ++n)
      if (t[n].length === 0)
        throw new Ve(fe.INVALID_ARGUMENT, 'Invalid field name at argument $(i + 1). Field names must not be empty.')
    this._internalPath = new Ft(t)
  }
  isEqual(t) {
    return this._internalPath.isEqual(t._internalPath)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class ob {
  constructor(t) {
    this._methodName = t
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class pm {
  constructor(t, n) {
    if (!isFinite(t) || t < -90 || t > 90)
      throw new Ve(fe.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + t)
    if (!isFinite(n) || n < -180 || n > 180)
      throw new Ve(fe.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + n)
    ;(this._lat = t), (this._long = n)
  }
  get latitude() {
    return this._lat
  }
  get longitude() {
    return this._long
  }
  isEqual(t) {
    return this._lat === t._lat && this._long === t._long
  }
  toJSON() {
    return { latitude: this._lat, longitude: this._long }
  }
  _compareTo(t) {
    return Ye(this._lat, t._lat) || Ye(this._long, t._long)
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const kW = /^__.*__$/
class PW {
  constructor(t, n, i) {
    ;(this.data = t), (this.fieldMask = n), (this.fieldTransforms = i)
  }
  toMutation(t, n) {
    return this.fieldMask !== null
      ? new Gr(t, this.data, this.fieldMask, n, this.fieldTransforms)
      : new zl(t, this.data, n, this.fieldTransforms)
  }
}
class r1 {
  constructor(t, n, i) {
    ;(this.data = t), (this.fieldMask = n), (this.fieldTransforms = i)
  }
  toMutation(t, n) {
    return new Gr(t, this.data, this.fieldMask, n, this.fieldTransforms)
  }
}
function s1(e) {
  switch (e) {
    case 0:
    case 2:
    case 1:
      return !0
    case 3:
    case 4:
      return !1
    default:
      throw Oe()
  }
}
class ab {
  constructor(t, n, i, r, s, o) {
    ;(this.settings = t),
      (this.databaseId = n),
      (this.serializer = i),
      (this.ignoreUndefinedProperties = r),
      s === void 0 && this.mu(),
      (this.fieldTransforms = s || []),
      (this.fieldMask = o || [])
  }
  get path() {
    return this.settings.path
  }
  get fu() {
    return this.settings.fu
  }
  gu(t) {
    return new ab(
      Object.assign(Object.assign({}, this.settings), t),
      this.databaseId,
      this.serializer,
      this.ignoreUndefinedProperties,
      this.fieldTransforms,
      this.fieldMask
    )
  }
  pu(t) {
    var n
    const i = (n = this.path) === null || n === void 0 ? void 0 : n.child(t),
      r = this.gu({ path: i, yu: !1 })
    return r.wu(t), r
  }
  Su(t) {
    var n
    const i = (n = this.path) === null || n === void 0 ? void 0 : n.child(t),
      r = this.gu({ path: i, yu: !1 })
    return r.mu(), r
  }
  bu(t) {
    return this.gu({ path: void 0, yu: !0 })
  }
  Du(t) {
    return gf(t, this.settings.methodName, this.settings.Cu || !1, this.path, this.settings.vu)
  }
  contains(t) {
    return (
      this.fieldMask.find((n) => t.isPrefixOf(n)) !== void 0 ||
      this.fieldTransforms.find((n) => t.isPrefixOf(n.field)) !== void 0
    )
  }
  mu() {
    if (this.path) for (let t = 0; t < this.path.length; t++) this.wu(this.path.get(t))
  }
  wu(t) {
    if (t.length === 0) throw this.Du('Document fields must not be empty')
    if (s1(this.fu) && kW.test(t)) throw this.Du('Document fields cannot begin and end with "__"')
  }
}
class RW {
  constructor(t, n, i) {
    ;(this.databaseId = t), (this.ignoreUndefinedProperties = n), (this.serializer = i || fm(t))
  }
  Fu(t, n, i, r = !1) {
    return new ab(
      { fu: t, methodName: n, vu: i, path: Ft.emptyPath(), yu: !1, Cu: r },
      this.databaseId,
      this.serializer,
      this.ignoreUndefinedProperties
    )
  }
}
function o1(e) {
  const t = e._freezeSettings(),
    n = fm(e._databaseId)
  return new RW(e._databaseId, !!t.ignoreUndefinedProperties, n)
}
function xW(e, t, n, i, r, s = {}) {
  const o = e.Fu(s.merge || s.mergeFields ? 2 : 0, t, n, r)
  lb('Data must be an object, but it was:', o, i)
  const a = a1(i, o)
  let l, u
  if (s.merge) (l = new ti(o.fieldMask)), (u = o.fieldTransforms)
  else if (s.mergeFields) {
    const c = []
    for (const d of s.mergeFields) {
      const f = Cp(t, d, n)
      if (!o.contains(f))
        throw new Ve(
          fe.INVALID_ARGUMENT,
          `Field '${f}' is specified in your field mask but missing from your input data.`
        )
      u1(c, f) || c.push(f)
    }
    ;(l = new ti(c)), (u = o.fieldTransforms.filter((d) => l.covers(d.field)))
  } else (l = null), (u = o.fieldTransforms)
  return new PW(new Mn(a), l, u)
}
class ym extends ob {
  _toFieldTransform(t) {
    if (t.fu !== 2)
      throw t.fu === 1
        ? t.Du(`${this._methodName}() can only appear at the top level of your update data`)
        : t.Du(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`)
    return t.fieldMask.push(t.path), null
  }
  isEqual(t) {
    return t instanceof ym
  }
}
function VW(e, t, n, i) {
  const r = e.Fu(1, t, n)
  lb('Data must be an object, but it was:', r, i)
  const s = [],
    o = Mn.empty()
  la(i, (l, u) => {
    const c = ub(t, l, n)
    u = Et(u)
    const d = r.Su(c)
    if (u instanceof ym) s.push(c)
    else {
      const f = _m(u, d)
      f != null && (s.push(c), o.set(c, f))
    }
  })
  const a = new ti(s)
  return new r1(o, a, r.fieldTransforms)
}
function DW(e, t, n, i, r, s) {
  const o = e.Fu(1, t, n),
    a = [Cp(t, i, n)],
    l = [r]
  if (s.length % 2 != 0)
    throw new Ve(
      fe.INVALID_ARGUMENT,
      `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`
    )
  for (let f = 0; f < s.length; f += 2) a.push(Cp(t, s[f])), l.push(s[f + 1])
  const u = [],
    c = Mn.empty()
  for (let f = a.length - 1; f >= 0; --f)
    if (!u1(u, a[f])) {
      const m = a[f]
      let p = l[f]
      p = Et(p)
      const v = o.Su(m)
      if (p instanceof ym) u.push(m)
      else {
        const y = _m(p, v)
        y != null && (u.push(m), c.set(m, y))
      }
    }
  const d = new ti(u)
  return new r1(c, d, o.fieldTransforms)
}
function _m(e, t) {
  if (l1((e = Et(e)))) return lb('Unsupported field value:', t, e), a1(e, t)
  if (e instanceof ob)
    return (
      (function (i, r) {
        if (!s1(r.fu)) throw r.Du(`${i._methodName}() can only be used with update() and set()`)
        if (!r.path) throw r.Du(`${i._methodName}() is not currently supported inside arrays`)
        const s = i._toFieldTransform(r)
        s && r.fieldTransforms.push(s)
      })(e, t),
      null
    )
  if (e === void 0 && t.ignoreUndefinedProperties) return null
  if ((t.path && t.fieldMask.push(t.path), e instanceof Array)) {
    if (t.settings.yu && t.fu !== 4) throw t.Du('Nested arrays are not supported')
    return (function (i, r) {
      const s = []
      let o = 0
      for (const a of i) {
        let l = _m(a, r.bu(o))
        l == null && (l = { nullValue: 'NULL_VALUE' }), s.push(l), o++
      }
      return { arrayValue: { values: s } }
    })(e, t)
  }
  return (function (i, r) {
    if ((i = Et(i)) === null) return { nullValue: 'NULL_VALUE' }
    if (typeof i == 'number') return I6(r.serializer, i)
    if (typeof i == 'boolean') return { booleanValue: i }
    if (typeof i == 'string') return { stringValue: i }
    if (i instanceof Date) {
      const s = Dt.fromDate(i)
      return { timestampValue: Sl(r.serializer, s) }
    }
    if (i instanceof Dt) {
      const s = new Dt(i.seconds, 1e3 * Math.floor(i.nanoseconds / 1e3))
      return { timestampValue: Sl(r.serializer, s) }
    }
    if (i instanceof pm) return { geoPointValue: { latitude: i.latitude, longitude: i.longitude } }
    if (i instanceof Tl) return { bytesValue: lx(r.serializer, i._byteString) }
    if (i instanceof ni) {
      const s = r.databaseId,
        o = i.firestore._databaseId
      if (!o.isEqual(s))
        throw r.Du(
          `Document reference is for database ${o.projectId}/${o.database} but should be for database ${s.projectId}/${s.database}`
        )
      return { referenceValue: $_(i.firestore._databaseId || r.databaseId, i._key.path) }
    }
    throw r.Du(`Unsupported field value: ${rb(i)}`)
  })(e, t)
}
function a1(e, t) {
  const n = {}
  return (
    NR(e)
      ? t.path && t.path.length > 0 && t.fieldMask.push(t.path)
      : la(e, (i, r) => {
          const s = _m(r, t.pu(i))
          s != null && (n[i] = s)
        }),
    { mapValue: { fields: n } }
  )
}
function l1(e) {
  return !(
    typeof e != 'object' ||
    e === null ||
    e instanceof Array ||
    e instanceof Date ||
    e instanceof Dt ||
    e instanceof pm ||
    e instanceof Tl ||
    e instanceof ni ||
    e instanceof ob
  )
}
function lb(e, t, n) {
  if (
    !l1(n) ||
    !(function (r) {
      return (
        typeof r == 'object' &&
        r !== null &&
        (Object.getPrototypeOf(r) === Object.prototype || Object.getPrototypeOf(r) === null)
      )
    })(n)
  ) {
    const i = rb(n)
    throw i === 'an object' ? t.Du(e + ' a custom object') : t.Du(e + ' ' + i)
  }
}
function Cp(e, t, n) {
  if ((t = Et(t)) instanceof vm) return t._internalPath
  if (typeof t == 'string') return ub(e, t)
  throw gf('Field path arguments must be of type string or ', e, !1, void 0, n)
}
const NW = new RegExp('[~\\*/\\[\\]]')
function ub(e, t, n) {
  if (t.search(NW) >= 0)
    throw gf(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n)
  try {
    return new vm(...t.split('.'))._internalPath
  } catch {
    throw gf(
      `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      e,
      !1,
      void 0,
      n
    )
  }
}
function gf(e, t, n, i, r) {
  const s = i && !i.isEmpty(),
    o = r !== void 0
  let a = `Function ${t}() called with invalid data`
  n && (a += ' (via `toFirestore()`)'), (a += '. ')
  let l = ''
  return (
    (s || o) && ((l += ' (found'), s && (l += ` in field ${i}`), o && (l += ` in document ${r}`), (l += ')')),
    new Ve(fe.INVALID_ARGUMENT, a + e + l)
  )
}
function u1(e, t) {
  return e.some((n) => n.isEqual(t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class c1 {
  constructor(t, n, i, r, s) {
    ;(this._firestore = t), (this._userDataWriter = n), (this._key = i), (this._document = r), (this._converter = s)
  }
  get id() {
    return this._key.path.lastSegment()
  }
  get ref() {
    return new ni(this._firestore, this._converter, this._key)
  }
  exists() {
    return this._document !== null
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t = new OW(this._firestore, this._userDataWriter, this._key, this._document, null)
        return this._converter.fromFirestore(t)
      }
      return this._userDataWriter.convertValue(this._document.data.value)
    }
  }
  get(t) {
    if (this._document) {
      const n = this._document.data.field(d1('DocumentSnapshot.get', t))
      if (n !== null) return this._userDataWriter.convertValue(n)
    }
  }
}
class OW extends c1 {
  data() {
    return super.data()
  }
}
function d1(e, t) {
  return typeof t == 'string' ? ub(e, t) : t instanceof vm ? t._internalPath : t._delegate._internalPath
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function h1(e) {
  if (e.limitType === 'L' && e.explicitOrderBy.length === 0)
    throw new Ve(fe.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause')
}
class MW {
  convertValue(t, n = 'none') {
    switch (Bo(t)) {
      case 0:
        return null
      case 1:
        return t.booleanValue
      case 2:
        return Ht(t.integerValue || t.doubleValue)
      case 3:
        return this.convertTimestamp(t.timestampValue)
      case 4:
        return this.convertServerTimestamp(t, n)
      case 5:
        return t.stringValue
      case 6:
        return this.convertBytes(Ns(t.bytesValue))
      case 7:
        return this.convertReference(t.referenceValue)
      case 8:
        return this.convertGeoPoint(t.geoPointValue)
      case 9:
        return this.convertArray(t.arrayValue, n)
      case 10:
        return this.convertObject(t.mapValue, n)
      default:
        throw Oe()
    }
  }
  convertObject(t, n) {
    return this.convertObjectMap(t.fields, n)
  }
  convertObjectMap(t, n = 'none') {
    const i = {}
    return (
      la(t, (r, s) => {
        i[r] = this.convertValue(s, n)
      }),
      i
    )
  }
  convertGeoPoint(t) {
    return new pm(Ht(t.latitude), Ht(t.longitude))
  }
  convertArray(t, n) {
    return (t.values || []).map((i) => this.convertValue(i, n))
  }
  convertServerTimestamp(t, n) {
    switch (n) {
      case 'previous':
        const i = D_(t)
        return i == null ? null : this.convertValue(i, n)
      case 'estimate':
        return this.convertTimestamp(yc(t))
      default:
        return null
    }
  }
  convertTimestamp(t) {
    const n = Lr(t)
    return new Dt(n.seconds, n.nanos)
  }
  convertDocumentKey(t, n) {
    const i = pt.fromString(t)
    Fe(yx(i))
    const r = new Fo(i.get(1), i.get(3)),
      s = new Re(i.popFirst(5))
    return (
      r.isEqual(n) ||
        Gn(
          `Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`
        ),
      s
    )
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function LW(e, t, n) {
  let i
  return (i = e ? e.toFirestore(t) : t), i
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Nu {
  constructor(t, n) {
    ;(this.hasPendingWrites = t), (this.fromCache = n)
  }
  isEqual(t) {
    return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache
  }
}
class f1 extends c1 {
  constructor(t, n, i, r, s, o) {
    super(t, n, i, r, o), (this._firestore = t), (this._firestoreImpl = t), (this.metadata = s)
  }
  exists() {
    return super.exists()
  }
  data(t = {}) {
    if (this._document) {
      if (this._converter) {
        const n = new Ph(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null)
        return this._converter.fromFirestore(n, t)
      }
      return this._userDataWriter.convertValue(this._document.data.value, t.serverTimestamps)
    }
  }
  get(t, n = {}) {
    if (this._document) {
      const i = this._document.data.field(d1('DocumentSnapshot.get', t))
      if (i !== null) return this._userDataWriter.convertValue(i, n.serverTimestamps)
    }
  }
}
class Ph extends f1 {
  data(t = {}) {
    return super.data(t)
  }
}
class m1 {
  constructor(t, n, i, r) {
    ;(this._firestore = t),
      (this._userDataWriter = n),
      (this._snapshot = r),
      (this.metadata = new Nu(r.hasPendingWrites, r.fromCache)),
      (this.query = i)
  }
  get docs() {
    const t = []
    return this.forEach((n) => t.push(n)), t
  }
  get size() {
    return this._snapshot.docs.size
  }
  get empty() {
    return this.size === 0
  }
  forEach(t, n) {
    this._snapshot.docs.forEach((i) => {
      t.call(
        n,
        new Ph(
          this._firestore,
          this._userDataWriter,
          i.key,
          i,
          new Nu(this._snapshot.mutatedKeys.has(i.key), this._snapshot.fromCache),
          this.query.converter
        )
      )
    })
  }
  docChanges(t = {}) {
    const n = !!t.includeMetadataChanges
    if (n && this._snapshot.excludesMetadataChanges)
      throw new Ve(
        fe.INVALID_ARGUMENT,
        'To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().'
      )
    return (
      (this._cachedChanges && this._cachedChangesIncludeMetadataChanges === n) ||
        ((this._cachedChanges = (function (r, s) {
          if (r._snapshot.oldDocs.isEmpty()) {
            let o = 0
            return r._snapshot.docChanges.map((a) => {
              const l = new Ph(
                r._firestore,
                r._userDataWriter,
                a.doc.key,
                a.doc,
                new Nu(r._snapshot.mutatedKeys.has(a.doc.key), r._snapshot.fromCache),
                r.query.converter
              )
              return a.doc, { type: 'added', doc: l, oldIndex: -1, newIndex: o++ }
            })
          }
          {
            let o = r._snapshot.oldDocs
            return r._snapshot.docChanges
              .filter((a) => s || a.type !== 3)
              .map((a) => {
                const l = new Ph(
                  r._firestore,
                  r._userDataWriter,
                  a.doc.key,
                  a.doc,
                  new Nu(r._snapshot.mutatedKeys.has(a.doc.key), r._snapshot.fromCache),
                  r.query.converter
                )
                let u = -1,
                  c = -1
                return (
                  a.type !== 0 && ((u = o.indexOf(a.doc.key)), (o = o.delete(a.doc.key))),
                  a.type !== 1 && ((o = o.add(a.doc)), (c = o.indexOf(a.doc.key))),
                  { type: FW(a.type), doc: l, oldIndex: u, newIndex: c }
                )
              })
          }
        })(this, n)),
        (this._cachedChangesIncludeMetadataChanges = n)),
      this._cachedChanges
    )
  }
}
function FW(e) {
  switch (e) {
    case 0:
      return 'added'
    case 2:
    case 3:
      return 'modified'
    case 1:
      return 'removed'
    default:
      return Oe()
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function g1(e) {
  e = Hi(e, ni)
  const t = Hi(e.firestore, Ls)
  return wW(gm(t), e._key).then((n) => v1(t, e, n))
}
class cb extends MW {
  constructor(t) {
    super(), (this.firestore = t)
  }
  convertBytes(t) {
    return new Tl(t)
  }
  convertReference(t) {
    const n = this.convertDocumentKey(t, this.firestore._databaseId)
    return new ni(this.firestore, null, n)
  }
}
function BW(e) {
  e = Hi(e, sd)
  const t = Hi(e.firestore, Ls),
    n = gm(t),
    i = new cb(t)
  return h1(e._query), IW(n, e._query).then((r) => new m1(t, i, e, r))
}
function Gte(e, t, n, ...i) {
  e = Hi(e, ni)
  const r = Hi(e.firestore, Ls),
    s = o1(r)
  let o
  return (
    (o =
      typeof (t = Et(t)) == 'string' || t instanceof vm
        ? DW(s, 'updateDoc', e._key, t, n, i)
        : VW(s, 'updateDoc', e._key, t)),
    hb(r, [o.toMutation(e._key, Kn.exists(!0))])
  )
}
function Kte(e) {
  return hb(Hi(e.firestore, Ls), [new lm(e._key, Kn.none())])
}
function Yte(e, t) {
  const n = Hi(e.firestore, Ls),
    i = TW(e),
    r = LW(e.converter, t)
  return hb(n, [
    xW(o1(e.firestore), 'addDoc', i._key, r, e.converter !== null, {}).toMutation(i._key, Kn.exists(!1)),
  ]).then(() => i)
}
function db(e, ...t) {
  var n, i, r
  e = Et(e)
  let s = { includeMetadataChanges: !1, source: 'default' },
    o = 0
  typeof t[o] != 'object' || k0(t[o]) || ((s = t[o]), o++)
  const a = { includeMetadataChanges: s.includeMetadataChanges, source: s.source }
  if (k0(t[o])) {
    const d = t[o]
    ;(t[o] = (n = d.next) === null || n === void 0 ? void 0 : n.bind(d)),
      (t[o + 1] = (i = d.error) === null || i === void 0 ? void 0 : i.bind(d)),
      (t[o + 2] = (r = d.complete) === null || r === void 0 ? void 0 : r.bind(d))
  }
  let l, u, c
  if (e instanceof ni)
    (u = Hi(e.firestore, Ls)),
      (c = Zc(e._key.path)),
      (l = {
        next: (d) => {
          t[o] && t[o](v1(u, e, d))
        },
        error: t[o + 1],
        complete: t[o + 2],
      })
  else {
    const d = Hi(e, sd)
    ;(u = Hi(d.firestore, Ls)), (c = d._query)
    const f = new cb(u)
    ;(l = {
      next: (m) => {
        t[o] && t[o](new m1(u, f, d, m))
      },
      error: t[o + 1],
      complete: t[o + 2],
    }),
      h1(e._query)
  }
  return (function (f, m, p, v) {
    const y = new ib(v),
      T = new tb(m, y, p)
    return (
      f.asyncQueue.enqueueAndForget(async () => J_(await mf(f), T)),
      () => {
        y.$a(), f.asyncQueue.enqueueAndForget(async () => Z_(await mf(f), T))
      }
    )
  })(gm(u), c, a, l)
}
function hb(e, t) {
  return (function (i, r) {
    const s = new cr()
    return i.asyncQueue.enqueueAndForget(async () => uW(await bW(i), r, s)), s.promise
  })(gm(e), t)
}
function v1(e, t, n) {
  const i = n.docs.get(t._key),
    r = new cb(e)
  return new f1(e, r, t._key, i, new Nu(n.hasPendingWrites, n.fromCache), t.converter)
}
class $W {
  constructor(t) {
    let n
    ;(this.kind = 'persistent'),
      t != null && t.tabManager ? (t.tabManager._initialize(t), (n = t.tabManager)) : ((n = zW()), n._initialize(t)),
      (this._onlineComponentProvider = n._onlineComponentProvider),
      (this._offlineComponentProvider = n._offlineComponentProvider)
  }
  toJSON() {
    return { kind: this.kind }
  }
}
function UW(e) {
  return new $W(e)
}
class jW {
  constructor(t) {
    ;(this.forceOwnership = t), (this.kind = 'persistentSingleTab')
  }
  toJSON() {
    return { kind: this.kind }
  }
  _initialize(t) {
    ;(this._onlineComponentProvider = new Zx()),
      (this._offlineComponentProvider = new vW(
        this._onlineComponentProvider,
        t == null ? void 0 : t.cacheSizeBytes,
        this.forceOwnership
      ))
  }
}
function zW(e) {
  return new jW(void 0)
}
;(function (t, n = !0) {
  ;(function (r) {
    jl = r
  })(zs),
    Xn(
      new $n(
        'firestore',
        (i, { instanceIdentifier: r, options: s }) => {
          const o = i.getProvider('app').getImmediate(),
            a = new Ls(
              new SH(i.getProvider('auth-internal')),
              new AH(i.getProvider('app-check-internal')),
              (function (u, c) {
                if (!Object.prototype.hasOwnProperty.apply(u.options, ['projectId']))
                  throw new Ve(fe.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.')
                return new Fo(u.options.projectId, c)
              })(o, r),
              o
            )
          return (s = Object.assign({ useFetchStreams: n }, s)), a._setSettings(s), a
        },
        'PUBLIC'
      ).setMultipleInstances(!0)
    ),
    nn(TE, '4.6.4', t),
    nn(TE, '4.6.4', 'esm2017')
})()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const p1 = 'firebasestorage.googleapis.com',
  y1 = 'storageBucket',
  HW = 2 * 60 * 1e3,
  WW = 10 * 60 * 1e3
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Kt extends Di {
  constructor(t, n, i = 0) {
    super(Gg(t), `Firebase Storage: ${n} (${Gg(t)})`),
      (this.status_ = i),
      (this.customData = { serverResponse: null }),
      (this._baseMessage = this.message),
      Object.setPrototypeOf(this, Kt.prototype)
  }
  get status() {
    return this.status_
  }
  set status(t) {
    this.status_ = t
  }
  _codeEquals(t) {
    return Gg(t) === this.code
  }
  get serverResponse() {
    return this.customData.serverResponse
  }
  set serverResponse(t) {
    ;(this.customData.serverResponse = t),
      this.customData.serverResponse
        ? (this.message = `${this._baseMessage}
${this.customData.serverResponse}`)
        : (this.message = this._baseMessage)
  }
}
var Gt
;(function (e) {
  ;(e.UNKNOWN = 'unknown'),
    (e.OBJECT_NOT_FOUND = 'object-not-found'),
    (e.BUCKET_NOT_FOUND = 'bucket-not-found'),
    (e.PROJECT_NOT_FOUND = 'project-not-found'),
    (e.QUOTA_EXCEEDED = 'quota-exceeded'),
    (e.UNAUTHENTICATED = 'unauthenticated'),
    (e.UNAUTHORIZED = 'unauthorized'),
    (e.UNAUTHORIZED_APP = 'unauthorized-app'),
    (e.RETRY_LIMIT_EXCEEDED = 'retry-limit-exceeded'),
    (e.INVALID_CHECKSUM = 'invalid-checksum'),
    (e.CANCELED = 'canceled'),
    (e.INVALID_EVENT_NAME = 'invalid-event-name'),
    (e.INVALID_URL = 'invalid-url'),
    (e.INVALID_DEFAULT_BUCKET = 'invalid-default-bucket'),
    (e.NO_DEFAULT_BUCKET = 'no-default-bucket'),
    (e.CANNOT_SLICE_BLOB = 'cannot-slice-blob'),
    (e.SERVER_FILE_WRONG_SIZE = 'server-file-wrong-size'),
    (e.NO_DOWNLOAD_URL = 'no-download-url'),
    (e.INVALID_ARGUMENT = 'invalid-argument'),
    (e.INVALID_ARGUMENT_COUNT = 'invalid-argument-count'),
    (e.APP_DELETED = 'app-deleted'),
    (e.INVALID_ROOT_OPERATION = 'invalid-root-operation'),
    (e.INVALID_FORMAT = 'invalid-format'),
    (e.INTERNAL_ERROR = 'internal-error'),
    (e.UNSUPPORTED_ENVIRONMENT = 'unsupported-environment')
})(Gt || (Gt = {}))
function Gg(e) {
  return 'storage/' + e
}
function fb() {
  const e = 'An unknown error occurred, please check the error payload for server response.'
  return new Kt(Gt.UNKNOWN, e)
}
function qW(e) {
  return new Kt(Gt.OBJECT_NOT_FOUND, "Object '" + e + "' does not exist.")
}
function GW(e) {
  return new Kt(
    Gt.QUOTA_EXCEEDED,
    "Quota for bucket '" + e + "' exceeded, please view quota on https://firebase.google.com/pricing/."
  )
}
function KW() {
  const e = 'User is not authenticated, please authenticate using Firebase Authentication and try again.'
  return new Kt(Gt.UNAUTHENTICATED, e)
}
function YW() {
  return new Kt(Gt.UNAUTHORIZED_APP, 'This app does not have permission to access Firebase Storage on this project.')
}
function QW(e) {
  return new Kt(Gt.UNAUTHORIZED, "User does not have permission to access '" + e + "'.")
}
function XW() {
  return new Kt(Gt.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.')
}
function JW() {
  return new Kt(Gt.CANCELED, 'User canceled the upload/download.')
}
function ZW(e) {
  return new Kt(Gt.INVALID_URL, "Invalid URL '" + e + "'.")
}
function e3(e) {
  return new Kt(Gt.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + e + "'.")
}
function t3() {
  return new Kt(
    Gt.NO_DEFAULT_BUCKET,
    "No default bucket found. Did you set the '" + y1 + "' property when initializing the app?"
  )
}
function n3() {
  return new Kt(Gt.CANNOT_SLICE_BLOB, 'Cannot slice blob for upload. Please retry the upload.')
}
function i3() {
  return new Kt(Gt.NO_DOWNLOAD_URL, 'The given file does not have any download URLs.')
}
function r3(e) {
  return new Kt(
    Gt.UNSUPPORTED_ENVIRONMENT,
    `${e} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`
  )
}
function Ap(e) {
  return new Kt(Gt.INVALID_ARGUMENT, e)
}
function _1() {
  return new Kt(Gt.APP_DELETED, 'The Firebase app was deleted.')
}
function s3(e) {
  return new Kt(
    Gt.INVALID_ROOT_OPERATION,
    "The operation '" +
      e +
      "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png')."
  )
}
function Ju(e, t) {
  return new Kt(Gt.INVALID_FORMAT, "String does not match format '" + e + "': " + t)
}
function Iu(e) {
  throw new Kt(Gt.INTERNAL_ERROR, 'Internal error: ' + e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class di {
  constructor(t, n) {
    ;(this.bucket = t), (this.path_ = n)
  }
  get path() {
    return this.path_
  }
  get isRoot() {
    return this.path.length === 0
  }
  fullServerUrl() {
    const t = encodeURIComponent
    return '/b/' + t(this.bucket) + '/o/' + t(this.path)
  }
  bucketOnlyServerUrl() {
    return '/b/' + encodeURIComponent(this.bucket) + '/o'
  }
  static makeFromBucketSpec(t, n) {
    let i
    try {
      i = di.makeFromUrl(t, n)
    } catch {
      return new di(t, '')
    }
    if (i.path === '') return i
    throw e3(t)
  }
  static makeFromUrl(t, n) {
    let i = null
    const r = '([A-Za-z0-9.\\-_]+)'
    function s(N) {
      N.path.charAt(N.path.length - 1) === '/' && (N.path_ = N.path_.slice(0, -1))
    }
    const o = '(/(.*))?$',
      a = new RegExp('^gs://' + r + o, 'i'),
      l = { bucket: 1, path: 3 }
    function u(N) {
      N.path_ = decodeURIComponent(N.path)
    }
    const c = 'v[A-Za-z0-9_]+',
      d = n.replace(/[.]/g, '\\.'),
      f = '(/([^?#]*).*)?$',
      m = new RegExp(`^https?://${d}/${c}/b/${r}/o${f}`, 'i'),
      p = { bucket: 1, path: 3 },
      v = n === p1 ? '(?:storage.googleapis.com|storage.cloud.google.com)' : n,
      y = '([^?#]*)',
      T = new RegExp(`^https?://${v}/${r}/${y}`, 'i'),
      x = [
        { regex: a, indices: l, postModify: s },
        { regex: m, indices: p, postModify: u },
        { regex: T, indices: { bucket: 1, path: 2 }, postModify: u },
      ]
    for (let N = 0; N < x.length; N++) {
      const V = x[N],
        D = V.regex.exec(t)
      if (D) {
        const I = D[V.indices.bucket]
        let w = D[V.indices.path]
        w || (w = ''), (i = new di(I, w)), V.postModify(i)
        break
      }
    }
    if (i == null) throw ZW(t)
    return i
  }
}
class o3 {
  constructor(t) {
    this.promise_ = Promise.reject(t)
  }
  getPromise() {
    return this.promise_
  }
  cancel(t = !1) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function a3(e, t, n) {
  let i = 1,
    r = null,
    s = null,
    o = !1,
    a = 0
  function l() {
    return a === 2
  }
  let u = !1
  function c(...y) {
    u || ((u = !0), t.apply(null, y))
  }
  function d(y) {
    r = setTimeout(() => {
      ;(r = null), e(m, l())
    }, y)
  }
  function f() {
    s && clearTimeout(s)
  }
  function m(y, ...T) {
    if (u) {
      f()
      return
    }
    if (y) {
      f(), c.call(null, y, ...T)
      return
    }
    if (l() || o) {
      f(), c.call(null, y, ...T)
      return
    }
    i < 64 && (i *= 2)
    let x
    a === 1 ? ((a = 2), (x = 0)) : (x = (i + Math.random()) * 1e3), d(x)
  }
  let p = !1
  function v(y) {
    p || ((p = !0), f(), !u && (r !== null ? (y || (a = 2), clearTimeout(r), d(0)) : y || (a = 1)))
  }
  return (
    d(0),
    (s = setTimeout(() => {
      ;(o = !0), v(!0)
    }, n)),
    v
  )
}
function l3(e) {
  e(!1)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function u3(e) {
  return e !== void 0
}
function c3(e) {
  return typeof e == 'object' && !Array.isArray(e)
}
function mb(e) {
  return typeof e == 'string' || e instanceof String
}
function P0(e) {
  return gb() && e instanceof Blob
}
function gb() {
  return typeof Blob < 'u'
}
function R0(e, t, n, i) {
  if (i < t) throw Ap(`Invalid value for '${e}'. Expected ${t} or greater.`)
  if (i > n) throw Ap(`Invalid value for '${e}'. Expected ${n} or less.`)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function vb(e, t, n) {
  let i = t
  return n == null && (i = `https://${t}`), `${n}://${i}/v0${e}`
}
function b1(e) {
  const t = encodeURIComponent
  let n = '?'
  for (const i in e)
    if (e.hasOwnProperty(i)) {
      const r = t(i) + '=' + t(e[i])
      n = n + r + '&'
    }
  return (n = n.slice(0, -1)), n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var To
;(function (e) {
  ;(e[(e.NO_ERROR = 0)] = 'NO_ERROR'), (e[(e.NETWORK_ERROR = 1)] = 'NETWORK_ERROR'), (e[(e.ABORT = 2)] = 'ABORT')
})(To || (To = {}))
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function d3(e, t) {
  const n = e >= 500 && e < 600,
    r = [408, 429].indexOf(e) !== -1,
    s = t.indexOf(e) !== -1
  return n || r || s
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class h3 {
  constructor(t, n, i, r, s, o, a, l, u, c, d, f = !0) {
    ;(this.url_ = t),
      (this.method_ = n),
      (this.headers_ = i),
      (this.body_ = r),
      (this.successCodes_ = s),
      (this.additionalRetryCodes_ = o),
      (this.callback_ = a),
      (this.errorCallback_ = l),
      (this.timeout_ = u),
      (this.progressCallback_ = c),
      (this.connectionFactory_ = d),
      (this.retry = f),
      (this.pendingConnection_ = null),
      (this.backoffId_ = null),
      (this.canceled_ = !1),
      (this.appDelete_ = !1),
      (this.promise_ = new Promise((m, p) => {
        ;(this.resolve_ = m), (this.reject_ = p), this.start_()
      }))
  }
  start_() {
    const t = (i, r) => {
        if (r) {
          i(!1, new ih(!1, null, !0))
          return
        }
        const s = this.connectionFactory_()
        this.pendingConnection_ = s
        const o = (a) => {
          const l = a.loaded,
            u = a.lengthComputable ? a.total : -1
          this.progressCallback_ !== null && this.progressCallback_(l, u)
        }
        this.progressCallback_ !== null && s.addUploadProgressListener(o),
          s.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
            this.progressCallback_ !== null && s.removeUploadProgressListener(o), (this.pendingConnection_ = null)
            const a = s.getErrorCode() === To.NO_ERROR,
              l = s.getStatus()
            if (!a || (d3(l, this.additionalRetryCodes_) && this.retry)) {
              const c = s.getErrorCode() === To.ABORT
              i(!1, new ih(!1, null, c))
              return
            }
            const u = this.successCodes_.indexOf(l) !== -1
            i(!0, new ih(u, s))
          })
      },
      n = (i, r) => {
        const s = this.resolve_,
          o = this.reject_,
          a = r.connection
        if (r.wasSuccessCode)
          try {
            const l = this.callback_(a, a.getResponse())
            u3(l) ? s(l) : s()
          } catch (l) {
            o(l)
          }
        else if (a !== null) {
          const l = fb()
          ;(l.serverResponse = a.getErrorText()), this.errorCallback_ ? o(this.errorCallback_(a, l)) : o(l)
        } else if (r.canceled) {
          const l = this.appDelete_ ? _1() : JW()
          o(l)
        } else {
          const l = XW()
          o(l)
        }
      }
    this.canceled_ ? n(!1, new ih(!1, null, !0)) : (this.backoffId_ = a3(t, n, this.timeout_))
  }
  getPromise() {
    return this.promise_
  }
  cancel(t) {
    ;(this.canceled_ = !0),
      (this.appDelete_ = t || !1),
      this.backoffId_ !== null && l3(this.backoffId_),
      this.pendingConnection_ !== null && this.pendingConnection_.abort()
  }
}
class ih {
  constructor(t, n, i) {
    ;(this.wasSuccessCode = t), (this.connection = n), (this.canceled = !!i)
  }
}
function f3(e, t) {
  t !== null && t.length > 0 && (e.Authorization = 'Firebase ' + t)
}
function m3(e, t) {
  e['X-Firebase-Storage-Version'] = 'webjs/' + (t ?? 'AppManager')
}
function g3(e, t) {
  t && (e['X-Firebase-GMPID'] = t)
}
function v3(e, t) {
  t !== null && (e['X-Firebase-AppCheck'] = t)
}
function p3(e, t, n, i, r, s, o = !0) {
  const a = b1(e.urlParams),
    l = e.url + a,
    u = Object.assign({}, e.headers)
  return (
    g3(u, t),
    f3(u, n),
    m3(u, s),
    v3(u, i),
    new h3(
      l,
      e.method,
      u,
      e.body,
      e.successCodes,
      e.additionalRetryCodes,
      e.handler,
      e.errorHandler,
      e.timeout,
      e.progressCallback,
      r,
      o
    )
  )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function y3() {
  return typeof BlobBuilder < 'u' ? BlobBuilder : typeof WebKitBlobBuilder < 'u' ? WebKitBlobBuilder : void 0
}
function _3(...e) {
  const t = y3()
  if (t !== void 0) {
    const n = new t()
    for (let i = 0; i < e.length; i++) n.append(e[i])
    return n.getBlob()
  } else {
    if (gb()) return new Blob(e)
    throw new Kt(Gt.UNSUPPORTED_ENVIRONMENT, "This browser doesn't seem to support creating Blobs")
  }
}
function b3(e, t, n) {
  return e.webkitSlice ? e.webkitSlice(t, n) : e.mozSlice ? e.mozSlice(t, n) : e.slice ? e.slice(t, n) : null
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function w3(e) {
  if (typeof atob > 'u') throw r3('base-64')
  return atob(e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const or = { RAW: 'raw', BASE64: 'base64', BASE64URL: 'base64url', DATA_URL: 'data_url' }
class Kg {
  constructor(t, n) {
    ;(this.data = t), (this.contentType = n || null)
  }
}
function I3(e, t) {
  switch (e) {
    case or.RAW:
      return new Kg(w1(t))
    case or.BASE64:
    case or.BASE64URL:
      return new Kg(I1(e, t))
    case or.DATA_URL:
      return new Kg(E3(t), T3(t))
  }
  throw fb()
}
function w1(e) {
  const t = []
  for (let n = 0; n < e.length; n++) {
    let i = e.charCodeAt(n)
    if (i <= 127) t.push(i)
    else if (i <= 2047) t.push(192 | (i >> 6), 128 | (i & 63))
    else if ((i & 64512) === 55296)
      if (!(n < e.length - 1 && (e.charCodeAt(n + 1) & 64512) === 56320)) t.push(239, 191, 189)
      else {
        const s = i,
          o = e.charCodeAt(++n)
        ;(i = 65536 | ((s & 1023) << 10) | (o & 1023)),
          t.push(240 | (i >> 18), 128 | ((i >> 12) & 63), 128 | ((i >> 6) & 63), 128 | (i & 63))
      }
    else (i & 64512) === 56320 ? t.push(239, 191, 189) : t.push(224 | (i >> 12), 128 | ((i >> 6) & 63), 128 | (i & 63))
  }
  return new Uint8Array(t)
}
function S3(e) {
  let t
  try {
    t = decodeURIComponent(e)
  } catch {
    throw Ju(or.DATA_URL, 'Malformed data URL.')
  }
  return w1(t)
}
function I1(e, t) {
  switch (e) {
    case or.BASE64: {
      const r = t.indexOf('-') !== -1,
        s = t.indexOf('_') !== -1
      if (r || s) throw Ju(e, "Invalid character '" + (r ? '-' : '_') + "' found: is it base64url encoded?")
      break
    }
    case or.BASE64URL: {
      const r = t.indexOf('+') !== -1,
        s = t.indexOf('/') !== -1
      if (r || s) throw Ju(e, "Invalid character '" + (r ? '+' : '/') + "' found: is it base64 encoded?")
      t = t.replace(/-/g, '+').replace(/_/g, '/')
      break
    }
  }
  let n
  try {
    n = w3(t)
  } catch (r) {
    throw r.message.includes('polyfill') ? r : Ju(e, 'Invalid character found')
  }
  const i = new Uint8Array(n.length)
  for (let r = 0; r < n.length; r++) i[r] = n.charCodeAt(r)
  return i
}
class S1 {
  constructor(t) {
    ;(this.base64 = !1), (this.contentType = null)
    const n = t.match(/^data:([^,]+)?,/)
    if (n === null) throw Ju(or.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>")
    const i = n[1] || null
    i != null &&
      ((this.base64 = C3(i, ';base64')), (this.contentType = this.base64 ? i.substring(0, i.length - 7) : i)),
      (this.rest = t.substring(t.indexOf(',') + 1))
  }
}
function E3(e) {
  const t = new S1(e)
  return t.base64 ? I1(or.BASE64, t.rest) : S3(t.rest)
}
function T3(e) {
  return new S1(e).contentType
}
function C3(e, t) {
  return e.length >= t.length ? e.substring(e.length - t.length) === t : !1
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class bs {
  constructor(t, n) {
    let i = 0,
      r = ''
    P0(t)
      ? ((this.data_ = t), (i = t.size), (r = t.type))
      : t instanceof ArrayBuffer
      ? (n
          ? (this.data_ = new Uint8Array(t))
          : ((this.data_ = new Uint8Array(t.byteLength)), this.data_.set(new Uint8Array(t))),
        (i = this.data_.length))
      : t instanceof Uint8Array &&
        (n ? (this.data_ = t) : ((this.data_ = new Uint8Array(t.length)), this.data_.set(t)), (i = t.length)),
      (this.size_ = i),
      (this.type_ = r)
  }
  size() {
    return this.size_
  }
  type() {
    return this.type_
  }
  slice(t, n) {
    if (P0(this.data_)) {
      const i = this.data_,
        r = b3(i, t, n)
      return r === null ? null : new bs(r)
    } else {
      const i = new Uint8Array(this.data_.buffer, t, n - t)
      return new bs(i, !0)
    }
  }
  static getBlob(...t) {
    if (gb()) {
      const n = t.map((i) => (i instanceof bs ? i.data_ : i))
      return new bs(_3.apply(null, n))
    } else {
      const n = t.map((o) => (mb(o) ? I3(or.RAW, o).data : o.data_))
      let i = 0
      n.forEach((o) => {
        i += o.byteLength
      })
      const r = new Uint8Array(i)
      let s = 0
      return (
        n.forEach((o) => {
          for (let a = 0; a < o.length; a++) r[s++] = o[a]
        }),
        new bs(r, !0)
      )
    }
  }
  uploadData() {
    return this.data_
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function E1(e) {
  let t
  try {
    t = JSON.parse(e)
  } catch {
    return null
  }
  return c3(t) ? t : null
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function A3(e) {
  if (e.length === 0) return null
  const t = e.lastIndexOf('/')
  return t === -1 ? '' : e.slice(0, t)
}
function k3(e, t) {
  const n = t
    .split('/')
    .filter((i) => i.length > 0)
    .join('/')
  return e.length === 0 ? n : e + '/' + n
}
function T1(e) {
  const t = e.lastIndexOf('/', e.length - 2)
  return t === -1 ? e : e.slice(t + 1)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function P3(e, t) {
  return t
}
class Hn {
  constructor(t, n, i, r) {
    ;(this.server = t), (this.local = n || t), (this.writable = !!i), (this.xform = r || P3)
  }
}
let rh = null
function R3(e) {
  return !mb(e) || e.length < 2 ? e : T1(e)
}
function C1() {
  if (rh) return rh
  const e = []
  e.push(new Hn('bucket')),
    e.push(new Hn('generation')),
    e.push(new Hn('metageneration')),
    e.push(new Hn('name', 'fullPath', !0))
  function t(s, o) {
    return R3(o)
  }
  const n = new Hn('name')
  ;(n.xform = t), e.push(n)
  function i(s, o) {
    return o !== void 0 ? Number(o) : o
  }
  const r = new Hn('size')
  return (
    (r.xform = i),
    e.push(r),
    e.push(new Hn('timeCreated')),
    e.push(new Hn('updated')),
    e.push(new Hn('md5Hash', null, !0)),
    e.push(new Hn('cacheControl', null, !0)),
    e.push(new Hn('contentDisposition', null, !0)),
    e.push(new Hn('contentEncoding', null, !0)),
    e.push(new Hn('contentLanguage', null, !0)),
    e.push(new Hn('contentType', null, !0)),
    e.push(new Hn('metadata', 'customMetadata', !0)),
    (rh = e),
    rh
  )
}
function x3(e, t) {
  function n() {
    const i = e.bucket,
      r = e.fullPath,
      s = new di(i, r)
    return t._makeStorageReference(s)
  }
  Object.defineProperty(e, 'ref', { get: n })
}
function V3(e, t, n) {
  const i = {}
  i.type = 'file'
  const r = n.length
  for (let s = 0; s < r; s++) {
    const o = n[s]
    i[o.local] = o.xform(i, t[o.server])
  }
  return x3(i, e), i
}
function A1(e, t, n) {
  const i = E1(t)
  return i === null ? null : V3(e, i, n)
}
function D3(e, t, n, i) {
  const r = E1(t)
  if (r === null || !mb(r.downloadTokens)) return null
  const s = r.downloadTokens
  if (s.length === 0) return null
  const o = encodeURIComponent
  return s.split(',').map((u) => {
    const c = e.bucket,
      d = e.fullPath,
      f = '/b/' + o(c) + '/o/' + o(d),
      m = vb(f, n, i),
      p = b1({ alt: 'media', token: u })
    return m + p
  })[0]
}
function N3(e, t) {
  const n = {},
    i = t.length
  for (let r = 0; r < i; r++) {
    const s = t[r]
    s.writable && (n[s.server] = e[s.local])
  }
  return JSON.stringify(n)
}
class k1 {
  constructor(t, n, i, r) {
    ;(this.url = t),
      (this.method = n),
      (this.handler = i),
      (this.timeout = r),
      (this.urlParams = {}),
      (this.headers = {}),
      (this.body = null),
      (this.errorHandler = null),
      (this.progressCallback = null),
      (this.successCodes = [200]),
      (this.additionalRetryCodes = [])
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function P1(e) {
  if (!e) throw fb()
}
function O3(e, t) {
  function n(i, r) {
    const s = A1(e, r, t)
    return P1(s !== null), s
  }
  return n
}
function M3(e, t) {
  function n(i, r) {
    const s = A1(e, r, t)
    return P1(s !== null), D3(s, r, e.host, e._protocol)
  }
  return n
}
function R1(e) {
  function t(n, i) {
    let r
    return (
      n.getStatus() === 401
        ? n.getErrorText().includes('Firebase App Check token is invalid')
          ? (r = YW())
          : (r = KW())
        : n.getStatus() === 402
        ? (r = GW(e.bucket))
        : n.getStatus() === 403
        ? (r = QW(e.path))
        : (r = i),
      (r.status = n.getStatus()),
      (r.serverResponse = i.serverResponse),
      r
    )
  }
  return t
}
function L3(e) {
  const t = R1(e)
  function n(i, r) {
    let s = t(i, r)
    return i.getStatus() === 404 && (s = qW(e.path)), (s.serverResponse = r.serverResponse), s
  }
  return n
}
function F3(e, t, n) {
  const i = t.fullServerUrl(),
    r = vb(i, e.host, e._protocol),
    s = 'GET',
    o = e.maxOperationRetryTime,
    a = new k1(r, s, M3(e, n), o)
  return (a.errorHandler = L3(t)), a
}
function B3(e, t) {
  return (e && e.contentType) || (t && t.type()) || 'application/octet-stream'
}
function $3(e, t, n) {
  const i = Object.assign({}, n)
  return (i.fullPath = e.path), (i.size = t.size()), i.contentType || (i.contentType = B3(null, t)), i
}
function U3(e, t, n, i, r) {
  const s = t.bucketOnlyServerUrl(),
    o = { 'X-Goog-Upload-Protocol': 'multipart' }
  function a() {
    let x = ''
    for (let N = 0; N < 2; N++) x = x + Math.random().toString().slice(2)
    return x
  }
  const l = a()
  o['Content-Type'] = 'multipart/related; boundary=' + l
  const u = $3(t, i, r),
    c = N3(u, n),
    d =
      '--' +
      l +
      `\r
Content-Type: application/json; charset=utf-8\r
\r
` +
      c +
      `\r
--` +
      l +
      `\r
Content-Type: ` +
      u.contentType +
      `\r
\r
`,
    f =
      `\r
--` +
      l +
      '--',
    m = bs.getBlob(d, i, f)
  if (m === null) throw n3()
  const p = { name: u.fullPath },
    v = vb(s, e.host, e._protocol),
    y = 'POST',
    T = e.maxUploadRetryTime,
    A = new k1(v, y, O3(e, n), T)
  return (A.urlParams = p), (A.headers = o), (A.body = m.uploadData()), (A.errorHandler = R1(t)), A
}
class j3 {
  constructor() {
    ;(this.sent_ = !1),
      (this.xhr_ = new XMLHttpRequest()),
      this.initXhr(),
      (this.errorCode_ = To.NO_ERROR),
      (this.sendPromise_ = new Promise((t) => {
        this.xhr_.addEventListener('abort', () => {
          ;(this.errorCode_ = To.ABORT), t()
        }),
          this.xhr_.addEventListener('error', () => {
            ;(this.errorCode_ = To.NETWORK_ERROR), t()
          }),
          this.xhr_.addEventListener('load', () => {
            t()
          })
      }))
  }
  send(t, n, i, r) {
    if (this.sent_) throw Iu('cannot .send() more than once')
    if (((this.sent_ = !0), this.xhr_.open(n, t, !0), r !== void 0))
      for (const s in r) r.hasOwnProperty(s) && this.xhr_.setRequestHeader(s, r[s].toString())
    return i !== void 0 ? this.xhr_.send(i) : this.xhr_.send(), this.sendPromise_
  }
  getErrorCode() {
    if (!this.sent_) throw Iu('cannot .getErrorCode() before sending')
    return this.errorCode_
  }
  getStatus() {
    if (!this.sent_) throw Iu('cannot .getStatus() before sending')
    try {
      return this.xhr_.status
    } catch {
      return -1
    }
  }
  getResponse() {
    if (!this.sent_) throw Iu('cannot .getResponse() before sending')
    return this.xhr_.response
  }
  getErrorText() {
    if (!this.sent_) throw Iu('cannot .getErrorText() before sending')
    return this.xhr_.statusText
  }
  abort() {
    this.xhr_.abort()
  }
  getResponseHeader(t) {
    return this.xhr_.getResponseHeader(t)
  }
  addUploadProgressListener(t) {
    this.xhr_.upload != null && this.xhr_.upload.addEventListener('progress', t)
  }
  removeUploadProgressListener(t) {
    this.xhr_.upload != null && this.xhr_.upload.removeEventListener('progress', t)
  }
}
class z3 extends j3 {
  initXhr() {
    this.xhr_.responseType = 'text'
  }
}
function x1() {
  return new z3()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ho {
  constructor(t, n) {
    ;(this._service = t), n instanceof di ? (this._location = n) : (this._location = di.makeFromUrl(n, t.host))
  }
  toString() {
    return 'gs://' + this._location.bucket + '/' + this._location.path
  }
  _newRef(t, n) {
    return new Ho(t, n)
  }
  get root() {
    const t = new di(this._location.bucket, '')
    return this._newRef(this._service, t)
  }
  get bucket() {
    return this._location.bucket
  }
  get fullPath() {
    return this._location.path
  }
  get name() {
    return T1(this._location.path)
  }
  get storage() {
    return this._service
  }
  get parent() {
    const t = A3(this._location.path)
    if (t === null) return null
    const n = new di(this._location.bucket, t)
    return new Ho(this._service, n)
  }
  _throwIfRoot(t) {
    if (this._location.path === '') throw s3(t)
  }
}
function H3(e, t, n) {
  e._throwIfRoot('uploadBytes')
  const i = U3(e.storage, e._location, C1(), new bs(t, !0), n)
  return e.storage.makeRequestWithTokens(i, x1).then((r) => ({ metadata: r, ref: e }))
}
function W3(e) {
  e._throwIfRoot('getDownloadURL')
  const t = F3(e.storage, e._location, C1())
  return e.storage.makeRequestWithTokens(t, x1).then((n) => {
    if (n === null) throw i3()
    return n
  })
}
function q3(e, t) {
  const n = k3(e._location.path, t),
    i = new di(e._location.bucket, n)
  return new Ho(e.storage, i)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function G3(e) {
  return /^[A-Za-z]+:\/\//.test(e)
}
function K3(e, t) {
  return new Ho(e, t)
}
function V1(e, t) {
  if (e instanceof pb) {
    const n = e
    if (n._bucket == null) throw t3()
    const i = new Ho(n, n._bucket)
    return t != null ? V1(i, t) : i
  } else return t !== void 0 ? q3(e, t) : e
}
function Y3(e, t) {
  if (t && G3(t)) {
    if (e instanceof pb) return K3(e, t)
    throw Ap('To use ref(service, url), the first argument must be a Storage instance.')
  } else return V1(e, t)
}
function x0(e, t) {
  const n = t == null ? void 0 : t[y1]
  return n == null ? null : di.makeFromBucketSpec(n, e)
}
function Q3(e, t, n, i = {}) {
  ;(e.host = `${t}:${n}`), (e._protocol = 'http')
  const { mockUserToken: r } = i
  r && (e._overrideAuthToken = typeof r == 'string' ? r : uB(r, e.app.options.projectId))
}
class pb {
  constructor(t, n, i, r, s) {
    ;(this.app = t),
      (this._authProvider = n),
      (this._appCheckProvider = i),
      (this._url = r),
      (this._firebaseVersion = s),
      (this._bucket = null),
      (this._host = p1),
      (this._protocol = 'https'),
      (this._appId = null),
      (this._deleted = !1),
      (this._maxOperationRetryTime = HW),
      (this._maxUploadRetryTime = WW),
      (this._requests = new Set()),
      r != null
        ? (this._bucket = di.makeFromBucketSpec(r, this._host))
        : (this._bucket = x0(this._host, this.app.options))
  }
  get host() {
    return this._host
  }
  set host(t) {
    ;(this._host = t),
      this._url != null
        ? (this._bucket = di.makeFromBucketSpec(this._url, t))
        : (this._bucket = x0(t, this.app.options))
  }
  get maxUploadRetryTime() {
    return this._maxUploadRetryTime
  }
  set maxUploadRetryTime(t) {
    R0('time', 0, Number.POSITIVE_INFINITY, t), (this._maxUploadRetryTime = t)
  }
  get maxOperationRetryTime() {
    return this._maxOperationRetryTime
  }
  set maxOperationRetryTime(t) {
    R0('time', 0, Number.POSITIVE_INFINITY, t), (this._maxOperationRetryTime = t)
  }
  async _getAuthToken() {
    if (this._overrideAuthToken) return this._overrideAuthToken
    const t = this._authProvider.getImmediate({ optional: !0 })
    if (t) {
      const n = await t.getToken()
      if (n !== null) return n.accessToken
    }
    return null
  }
  async _getAppCheckToken() {
    const t = this._appCheckProvider.getImmediate({ optional: !0 })
    return t ? (await t.getToken()).token : null
  }
  _delete() {
    return (
      this._deleted || ((this._deleted = !0), this._requests.forEach((t) => t.cancel()), this._requests.clear()),
      Promise.resolve()
    )
  }
  _makeStorageReference(t) {
    return new Ho(this, t)
  }
  _makeRequest(t, n, i, r, s = !0) {
    if (this._deleted) return new o3(_1())
    {
      const o = p3(t, this._appId, i, r, n, this._firebaseVersion, s)
      return (
        this._requests.add(o),
        o.getPromise().then(
          () => this._requests.delete(o),
          () => this._requests.delete(o)
        ),
        o
      )
    }
  }
  async makeRequestWithTokens(t, n) {
    const [i, r] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()])
    return this._makeRequest(t, n, i, r).getPromise()
  }
}
const V0 = '@firebase/storage',
  D0 = '0.12.6'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const D1 = 'storage'
function Qte(e, t, n) {
  return (e = Et(e)), H3(e, t, n)
}
function Xte(e) {
  return (e = Et(e)), W3(e)
}
function Jte(e, t) {
  return (e = Et(e)), Y3(e, t)
}
function Zte(e = zc(), t) {
  e = Et(e)
  const i = Wr(e, D1).getImmediate({ identifier: t }),
    r = lB('storage')
  return r && X3(i, ...r), i
}
function X3(e, t, n, i = {}) {
  Q3(e, t, n, i)
}
function J3(e, { instanceIdentifier: t }) {
  const n = e.getProvider('app').getImmediate(),
    i = e.getProvider('auth-internal'),
    r = e.getProvider('app-check-internal')
  return new pb(n, i, r, t, zs)
}
function Z3() {
  Xn(new $n(D1, J3, 'PUBLIC').setMultipleInstances(!0)), nn(V0, D0, ''), nn(V0, D0, 'esm2017')
}
Z3()
const Yg = new WeakMap()
function N1(e, t) {
  return Yg.has(t) || Yg.set(t, { f: {}, r: {}, s: {}, u: {} }), Yg.get(t)
}
function e9(e, t, n, i) {
  if (!e) return n
  const [r, s] = O1(e)
  if (!r) return n
  const o = N1(void 0, i)[r] || {},
    a = t || s
  return a && a in o ? o[a] : n
}
function t9(e, t, n, i) {
  if (!e) return
  const [r, s] = O1(e)
  if (!r) return
  const o = N1(void 0, i)[r],
    a = t || s
  if (a)
    return (
      n
        .then((l) => {
          o[a] = l
        })
        .catch(tr),
      a
    )
}
function O1(e) {
  return T4(e) || C4(e) ? ['f', e.path] : A4(e) ? ['r', e.toString()] : k4(e) ? ['s', e.toString()] : []
}
const Qg = new WeakMap()
function n9(e, t, n) {
  const i = s_()
  Qg.has(i) || Qg.set(i, new Map())
  const r = Qg.get(i),
    s = t9(t, n, e, i)
  return s && r.set(s, e), s ? () => r.delete(s) : tr
}
const i9 = {
  toFirestore(e) {
    return e
  },
  fromFirestore(e, t) {
    return e.exists() ? Object.defineProperties(e.data(t), { id: { value: e.id } }) : null
  },
}
function kp(e, t, n, i) {
  if (!S4(e)) return [e, {}]
  const r = [{}, {}],
    s = Object.keys(n).reduce((a, l) => {
      const u = n[l]
      return (a[u.path] = u.data()), a
    }, {})
  function o(a, l, u, c) {
    l = l || {}
    const [d, f] = c
    Object.getOwnPropertyNames(a).forEach((m) => {
      const p = Object.getOwnPropertyDescriptor(a, m)
      p && !p.enumerable && Object.defineProperty(d, m, p)
    })
    for (const m in a) {
      const p = a[m]
      if (p == null || p instanceof Date || p instanceof Dt || p instanceof pm) d[m] = p
      else if (a_(p)) {
        const v = u + m
        ;(d[m] = v in n ? l[m] : p.path), (f[v] = p.converter ? p : p.withConverter(i.converter))
      } else if (Array.isArray(p)) {
        d[m] = Array(p.length)
        for (let v = 0; v < p.length; v++) {
          const y = p[v]
          y && y.path in s && (d[m][v] = s[y.path])
        }
        o(p, l[m] || d[m], u + m + '.', [d[m], f])
      } else ra(p) ? ((d[m] = {}), o(p, l[m], u + m + '.', [d[m], f])) : (d[m] = p)
    }
  }
  return o(e, t, '', r), r
}
const yb = { reset: !1, wait: !0, maxRefDepth: 2, converter: i9, snapshotOptions: { serverTimestamps: 'estimate' } }
function vf(e) {
  for (const t in e) e[t].unsub()
}
function Pp(e, t, n, i, r, s, o, a, l) {
  const [u, c] = kp(i.data(e.snapshotOptions), o_(t, n), r, e)
  s.set(t, n, u), Rp(e, t, n, r, c, s, o, a, l)
}
function r9({ ref: e, target: t, path: n, depth: i, resolve: r, reject: s, ops: o }, a) {
  const l = Object.create(null)
  let u = tr
  return (
    a.once
      ? g1(e)
          .then((c) => {
            c.exists() ? Pp(a, t, n, c, l, o, i, r, s) : (o.set(t, n, null), r())
          })
          .catch(s)
      : (u = db(
          e,
          (c) => {
            c.exists() ? Pp(a, t, n, c, l, o, i, r, s) : (o.set(t, n, null), r())
          },
          s
        )),
    () => {
      u(), vf(l)
    }
  )
}
function Rp(e, t, n, i, r, s, o, a, l) {
  const u = Object.keys(r)
  if (
    (Object.keys(i)
      .filter((v) => u.indexOf(v) < 0)
      .forEach((v) => {
        i[v].unsub(), delete i[v]
      }),
    !u.length || ++o > e.maxRefDepth)
  )
    return a(n)
  let d = 0
  const f = u.length,
    m = Object.create(null)
  function p(v) {
    v in m && ++d >= f && a(n)
  }
  u.forEach((v) => {
    const y = i[v],
      T = r[v],
      A = `${n}.${v}`
    if (((m[A] = !0), y))
      if (y.path !== T.path) y.unsub()
      else return
    i[v] = {
      data: () => o_(t, A),
      unsub: r9({ ref: T, target: t, path: A, depth: o, ops: s, resolve: p.bind(null, A), reject: l }, e),
      path: T.path,
    }
  })
}
function s9(e, t, n, i, r, s) {
  const o = Object.assign({}, yb, s),
    { snapshotListenOptions: a, snapshotOptions: l, wait: u, once: c } = o,
    d = 'value'
  let f = le(u ? [] : e.value)
  u || n.set(e, d, [])
  const m = i
  let p,
    v = tr
  const y = [],
    T = {
      added: ({ newIndex: x, doc: N }) => {
        y.splice(x, 0, Object.create(null))
        const V = y[x],
          [D, I] = kp(N.data(l), void 0, V, o)
        n.add(Er(f), x, D), Rp(o, f, `${d}.${x}`, V, I, n, 0, i.bind(null, N), r)
      },
      modified: ({ oldIndex: x, newIndex: N, doc: V }) => {
        const D = Er(f),
          I = y[x],
          w = D[x],
          [_, S] = kp(V.data(l), w, I, o)
        y.splice(N, 0, I), n.remove(D, x), n.add(D, N, _), Rp(o, f, `${d}.${N}`, I, S, n, 0, i, r)
      },
      removed: ({ oldIndex: x }) => {
        const N = Er(f)
        n.remove(N, x), vf(y.splice(x, 1)[0])
      },
    }
  function A(x) {
    const N = x.docChanges(a)
    if (!p && N.length) {
      p = !0
      let V = 0
      const D = N.length,
        I = Object.create(null)
      for (let w = 0; w < D; w++) I[N[w].doc.id] = !0
      i = (w) => {
        w && w.id in I && ++V >= D && (u && (n.set(e, d, Er(f)), (f = e)), m(Er(f)), (i = tr))
      }
    }
    N.forEach((V) => {
      T[V.type](V)
    }),
      N.length || (u && (n.set(e, d, Er(f)), (f = e)), i(Er(f)))
  }
  return (
    c ? BW(t).then(A).catch(r) : (v = db(t, A, r)),
    (x) => {
      if ((v(), x)) {
        const N = typeof x == 'function' ? x() : []
        n.set(e, d, N)
      }
      y.forEach(vf)
    }
  )
}
function o9(e, t, n, i, r, s) {
  const o = Object.assign({}, yb, s),
    a = 'value',
    l = Object.create(null)
  i = P4(i, () => o_(e, a))
  let u = tr
  function c(d) {
    d.exists() ? Pp(o, e, a, d, l, n, 0, i, r) : (n.set(e, a, null), i(null))
  }
  return (
    o.once ? g1(t).then(c).catch(r) : (u = db(t, c, r)),
    (d) => {
      if ((u(), d)) {
        const f = typeof d == 'function' ? d() : null
        n.set(e, a, f)
      }
      vf(l)
    }
  )
}
const N0 = Symbol()
function M1(e, t) {
  let n = tr
  const i = Object.assign({}, yb, t),
    r = Er(e),
    s = i.target || le()
  x4() && (i.once = !0)
  const o = e9(r, i.ssrKey, N0, s_()),
    a = o !== N0
  a && (s.value = o)
  let l = !a
  const u = le(!1),
    c = le(),
    d = ye(),
    f = Iy()
  let m = tr
  function p() {
    let T = Er(e)
    const A = new Promise((x, N) => {
      if ((n(i.reset), !T)) return (n = tr), x(null)
      ;(u.value = l),
        (l = !0),
        T.converter || (T = T.withConverter(i.converter)),
        (n = (a_(T) ? o9 : s9)(s, T, a9, x, N, i))
    })
      .catch((x) => (d.value === A && (c.value = x), Promise.reject(x)))
      .finally(() => {
        d.value === A && (u.value = !1)
      })
    d.value = A
  }
  let v = tr
  ;(It(e) || typeof e == 'function') && (v = be(e, p)),
    p(),
    r && (m = n9(d.value, r, i.ssrKey)),
    $c() && dA(() => d.value),
    f && gn(y)
  function y(T = i.reset) {
    v(), m(), n(T)
  }
  return Object.defineProperties(s, {
    error: { get: () => c },
    data: { get: () => s },
    pending: { get: () => u },
    promise: { get: () => d },
    stop: { get: () => y },
  })
}
const a9 = { set: (e, t, n) => w4(e, t, n), add: (e, t, n) => e.splice(t, 0, n), remove: (e, t) => e.splice(t, 1) }
function ene(e, t) {
  return M1(e, { target: le([]), ...t })
}
function tne(e, t) {
  return M1(e, t)
}
function l9(e) {
  return c9({ initialUser: e, dependencies: { popupRedirectResolver: Jk, persistence: [Yk, zk, n_] } })
}
const u9 = Symbol('VueFireAuth')
function c9({ dependencies: e, initialUser: t }) {
  return (n, i) => {
    const [r, s] = d9(n, i, t, e)
    O4(r, s)
  }
}
function d9(e, t, n, i, r = Ok(e, i)) {
  const s = V4(e, t).run(() => le(n))
  return D4.set(e, s), t.provide(u9, r), [s, r]
}
function h9(e, { firebaseApp: t, modules: n = [] }) {
  e.provide(rP, t)
  for (const i of n) i(t, e)
}
const L1 = '@firebase/installations',
  _b = '0.6.8'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const F1 = 1e4,
  B1 = `w:${_b}`,
  $1 = 'FIS_v2',
  f9 = 'https://firebaseinstallations.googleapis.com/v1',
  m9 = 60 * 60 * 1e3,
  g9 = 'installations',
  v9 = 'Installations'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const p9 = {
    'missing-app-config-values': 'Missing App configuration value: "{$valueName}"',
    'not-registered': 'Firebase Installation is not registered.',
    'installation-not-found': 'Firebase Installation not found.',
    'request-failed': '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
    'app-offline': 'Could not process request. Application offline.',
    'delete-pending-registration': "Can't delete installation while there is a pending registration request.",
  },
  Wo = new zr(g9, v9, p9)
function U1(e) {
  return e instanceof Di && e.code.includes('request-failed')
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function j1({ projectId: e }) {
  return `${f9}/projects/${e}/installations`
}
function z1(e) {
  return { token: e.token, requestStatus: 2, expiresIn: _9(e.expiresIn), creationTime: Date.now() }
}
async function H1(e, t) {
  const i = (await t.json()).error
  return Wo.create('request-failed', {
    requestName: e,
    serverCode: i.code,
    serverMessage: i.message,
    serverStatus: i.status,
  })
}
function W1({ apiKey: e }) {
  return new Headers({ 'Content-Type': 'application/json', Accept: 'application/json', 'x-goog-api-key': e })
}
function y9(e, { refreshToken: t }) {
  const n = W1(e)
  return n.append('Authorization', b9(t)), n
}
async function q1(e) {
  const t = await e()
  return t.status >= 500 && t.status < 600 ? e() : t
}
function _9(e) {
  return Number(e.replace('s', '000'))
}
function b9(e) {
  return `${$1} ${e}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function w9({ appConfig: e, heartbeatServiceProvider: t }, { fid: n }) {
  const i = j1(e),
    r = W1(e),
    s = t.getImmediate({ optional: !0 })
  if (s) {
    const u = await s.getHeartbeatsHeader()
    u && r.append('x-firebase-client', u)
  }
  const o = { fid: n, authVersion: $1, appId: e.appId, sdkVersion: B1 },
    a = { method: 'POST', headers: r, body: JSON.stringify(o) },
    l = await q1(() => fetch(i, a))
  if (l.ok) {
    const u = await l.json()
    return { fid: u.fid || n, registrationStatus: 2, refreshToken: u.refreshToken, authToken: z1(u.authToken) }
  } else throw await H1('Create Installation', l)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function G1(e) {
  return new Promise((t) => {
    setTimeout(t, e)
  })
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function I9(e) {
  return btoa(String.fromCharCode(...e))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const S9 = /^[cdef][\w-]{21}$/,
  xp = ''
function E9() {
  try {
    const e = new Uint8Array(17)
    ;(self.crypto || self.msCrypto).getRandomValues(e), (e[0] = 112 + (e[0] % 16))
    const n = T9(e)
    return S9.test(n) ? n : xp
  } catch {
    return xp
  }
}
function T9(e) {
  return I9(e).substr(0, 22)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function bm(e) {
  return `${e.appName}!${e.appId}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const K1 = new Map()
function Y1(e, t) {
  const n = bm(e)
  Q1(n, t), C9(n, t)
}
function Q1(e, t) {
  const n = K1.get(e)
  if (n) for (const i of n) i(t)
}
function C9(e, t) {
  const n = A9()
  n && n.postMessage({ key: e, fid: t }), k9()
}
let po = null
function A9() {
  return (
    !po &&
      'BroadcastChannel' in self &&
      ((po = new BroadcastChannel('[Firebase] FID Change')),
      (po.onmessage = (e) => {
        Q1(e.data.key, e.data.fid)
      })),
    po
  )
}
function k9() {
  K1.size === 0 && po && (po.close(), (po = null))
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const P9 = 'firebase-installations-database',
  R9 = 1,
  qo = 'firebase-installations-store'
let Xg = null
function bb() {
  return (
    Xg ||
      (Xg = fk(P9, R9, {
        upgrade: (e, t) => {
          switch (t) {
            case 0:
              e.createObjectStore(qo)
          }
        },
      })),
    Xg
  )
}
async function pf(e, t) {
  const n = bm(e),
    r = (await bb()).transaction(qo, 'readwrite'),
    s = r.objectStore(qo),
    o = await s.get(n)
  return await s.put(t, n), await r.done, (!o || o.fid !== t.fid) && Y1(e, t.fid), t
}
async function X1(e) {
  const t = bm(e),
    i = (await bb()).transaction(qo, 'readwrite')
  await i.objectStore(qo).delete(t), await i.done
}
async function wm(e, t) {
  const n = bm(e),
    r = (await bb()).transaction(qo, 'readwrite'),
    s = r.objectStore(qo),
    o = await s.get(n),
    a = t(o)
  return (
    a === void 0 ? await s.delete(n) : await s.put(a, n), await r.done, a && (!o || o.fid !== a.fid) && Y1(e, a.fid), a
  )
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function wb(e) {
  let t
  const n = await wm(e.appConfig, (i) => {
    const r = x9(i),
      s = V9(e, r)
    return (t = s.registrationPromise), s.installationEntry
  })
  return n.fid === xp ? { installationEntry: await t } : { installationEntry: n, registrationPromise: t }
}
function x9(e) {
  const t = e || { fid: E9(), registrationStatus: 0 }
  return J1(t)
}
function V9(e, t) {
  if (t.registrationStatus === 0) {
    if (!navigator.onLine) {
      const r = Promise.reject(Wo.create('app-offline'))
      return { installationEntry: t, registrationPromise: r }
    }
    const n = { fid: t.fid, registrationStatus: 1, registrationTime: Date.now() },
      i = D9(e, n)
    return { installationEntry: n, registrationPromise: i }
  } else
    return t.registrationStatus === 1 ? { installationEntry: t, registrationPromise: N9(e) } : { installationEntry: t }
}
async function D9(e, t) {
  try {
    const n = await w9(e, t)
    return pf(e.appConfig, n)
  } catch (n) {
    throw (
      (U1(n) && n.customData.serverCode === 409
        ? await X1(e.appConfig)
        : await pf(e.appConfig, { fid: t.fid, registrationStatus: 0 }),
      n)
    )
  }
}
async function N9(e) {
  let t = await O0(e.appConfig)
  for (; t.registrationStatus === 1; ) await G1(100), (t = await O0(e.appConfig))
  if (t.registrationStatus === 0) {
    const { installationEntry: n, registrationPromise: i } = await wb(e)
    return i || n
  }
  return t
}
function O0(e) {
  return wm(e, (t) => {
    if (!t) throw Wo.create('installation-not-found')
    return J1(t)
  })
}
function J1(e) {
  return O9(e) ? { fid: e.fid, registrationStatus: 0 } : e
}
function O9(e) {
  return e.registrationStatus === 1 && e.registrationTime + F1 < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function M9({ appConfig: e, heartbeatServiceProvider: t }, n) {
  const i = L9(e, n),
    r = y9(e, n),
    s = t.getImmediate({ optional: !0 })
  if (s) {
    const u = await s.getHeartbeatsHeader()
    u && r.append('x-firebase-client', u)
  }
  const o = { installation: { sdkVersion: B1, appId: e.appId } },
    a = { method: 'POST', headers: r, body: JSON.stringify(o) },
    l = await q1(() => fetch(i, a))
  if (l.ok) {
    const u = await l.json()
    return z1(u)
  } else throw await H1('Generate Auth Token', l)
}
function L9(e, { fid: t }) {
  return `${j1(e)}/${t}/authTokens:generate`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function Ib(e, t = !1) {
  let n
  const i = await wm(e.appConfig, (s) => {
    if (!Z1(s)) throw Wo.create('not-registered')
    const o = s.authToken
    if (!t && $9(o)) return s
    if (o.requestStatus === 1) return (n = F9(e, t)), s
    {
      if (!navigator.onLine) throw Wo.create('app-offline')
      const a = j9(s)
      return (n = B9(e, a)), a
    }
  })
  return n ? await n : i.authToken
}
async function F9(e, t) {
  let n = await M0(e.appConfig)
  for (; n.authToken.requestStatus === 1; ) await G1(100), (n = await M0(e.appConfig))
  const i = n.authToken
  return i.requestStatus === 0 ? Ib(e, t) : i
}
function M0(e) {
  return wm(e, (t) => {
    if (!Z1(t)) throw Wo.create('not-registered')
    const n = t.authToken
    return z9(n) ? Object.assign(Object.assign({}, t), { authToken: { requestStatus: 0 } }) : t
  })
}
async function B9(e, t) {
  try {
    const n = await M9(e, t),
      i = Object.assign(Object.assign({}, t), { authToken: n })
    return await pf(e.appConfig, i), n
  } catch (n) {
    if (U1(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404)) await X1(e.appConfig)
    else {
      const i = Object.assign(Object.assign({}, t), { authToken: { requestStatus: 0 } })
      await pf(e.appConfig, i)
    }
    throw n
  }
}
function Z1(e) {
  return e !== void 0 && e.registrationStatus === 2
}
function $9(e) {
  return e.requestStatus === 2 && !U9(e)
}
function U9(e) {
  const t = Date.now()
  return t < e.creationTime || e.creationTime + e.expiresIn < t + m9
}
function j9(e) {
  const t = { requestStatus: 1, requestTime: Date.now() }
  return Object.assign(Object.assign({}, e), { authToken: t })
}
function z9(e) {
  return e.requestStatus === 1 && e.requestTime + F1 < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function H9(e) {
  const t = e,
    { installationEntry: n, registrationPromise: i } = await wb(t)
  return i ? i.catch(console.error) : Ib(t).catch(console.error), n.fid
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function W9(e, t = !1) {
  const n = e
  return await q9(n), (await Ib(n, t)).token
}
async function q9(e) {
  const { registrationPromise: t } = await wb(e)
  t && (await t)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function G9(e) {
  if (!e || !e.options) throw Jg('App Configuration')
  if (!e.name) throw Jg('App Name')
  const t = ['projectId', 'apiKey', 'appId']
  for (const n of t) if (!e.options[n]) throw Jg(n)
  return { appName: e.name, projectId: e.options.projectId, apiKey: e.options.apiKey, appId: e.options.appId }
}
function Jg(e) {
  return Wo.create('missing-app-config-values', { valueName: e })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const eV = 'installations',
  K9 = 'installations-internal',
  Y9 = (e) => {
    const t = e.getProvider('app').getImmediate(),
      n = G9(t),
      i = Wr(t, 'heartbeat')
    return { app: t, appConfig: n, heartbeatServiceProvider: i, _delete: () => Promise.resolve() }
  },
  Q9 = (e) => {
    const t = e.getProvider('app').getImmediate(),
      n = Wr(t, eV).getImmediate()
    return { getId: () => H9(n), getToken: (r) => W9(n, r) }
  }
function X9() {
  Xn(new $n(eV, Y9, 'PUBLIC')), Xn(new $n(K9, Q9, 'PRIVATE'))
}
X9()
nn(L1, _b)
nn(L1, _b, 'esm2017')
const L0 = '@firebase/performance',
  Vp = '0.6.8'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const tV = Vp,
  J9 = 'FB-PERF-TRACE-START',
  Z9 = 'FB-PERF-TRACE-STOP',
  Dp = 'FB-PERF-TRACE-MEASURE',
  nV = '_wt_',
  iV = '_fp',
  rV = '_fcp',
  sV = '_fid',
  oV = '@firebase/performance/config',
  aV = '@firebase/performance/configexpire',
  eq = 'performance',
  lV = 'Performance'
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const tq = {
    'trace started': 'Trace {$traceName} was started before.',
    'trace stopped': 'Trace {$traceName} is not running.',
    'nonpositive trace startTime': 'Trace {$traceName} startTime should be positive.',
    'nonpositive trace duration': 'Trace {$traceName} duration should be positive.',
    'no window': 'Window is not available.',
    'no app id': 'App id is not available.',
    'no project id': 'Project id is not available.',
    'no api key': 'Api key is not available.',
    'invalid cc log': 'Attempted to queue invalid cc event',
    'FB not default': 'Performance can only start when Firebase app instance is the default one.',
    'RC response not ok': 'RC response is not ok',
    'invalid attribute name': 'Attribute name {$attributeName} is invalid.',
    'invalid attribute value': 'Attribute value {$attributeValue} is invalid.',
    'invalid custom metric name': 'Custom metric name {$customMetricName} is invalid',
    'invalid String merger input': 'Input for String merger is invalid, contact support team to resolve.',
    'already initialized':
      'initializePerformance() has already been called with different options. To avoid this error, call initializePerformance() with the same options as when it was originally called, or call getPerformance() to return the already initialized instance.',
  },
  Vn = new zr(eq, lV, tq)
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const fr = new na(lV)
fr.logLevel = Je.INFO
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Zg, uV
class fn {
  constructor(t) {
    if (((this.window = t), !t)) throw Vn.create('no window')
    ;(this.performance = t.performance),
      (this.PerformanceObserver = t.PerformanceObserver),
      (this.windowLocation = t.location),
      (this.navigator = t.navigator),
      (this.document = t.document),
      this.navigator && this.navigator.cookieEnabled && (this.localStorage = t.localStorage),
      t.perfMetrics && t.perfMetrics.onFirstInputDelay && (this.onFirstInputDelay = t.perfMetrics.onFirstInputDelay)
  }
  getUrl() {
    return this.windowLocation.href.split('?')[0]
  }
  mark(t) {
    !this.performance || !this.performance.mark || this.performance.mark(t)
  }
  measure(t, n, i) {
    !this.performance || !this.performance.measure || this.performance.measure(t, n, i)
  }
  getEntriesByType(t) {
    return !this.performance || !this.performance.getEntriesByType ? [] : this.performance.getEntriesByType(t)
  }
  getEntriesByName(t) {
    return !this.performance || !this.performance.getEntriesByName ? [] : this.performance.getEntriesByName(t)
  }
  getTimeOrigin() {
    return this.performance && (this.performance.timeOrigin || this.performance.timing.navigationStart)
  }
  requiredApisAvailable() {
    return !fetch || !Promise || !uk()
      ? (fr.info(
          'Firebase Performance cannot start if browser does not support fetch and Promise or cookie is disabled.'
        ),
        !1)
      : jc()
      ? !0
      : (fr.info('IndexedDB is not supported by current browser'), !1)
  }
  setupObserver(t, n) {
    if (!this.PerformanceObserver) return
    new this.PerformanceObserver((r) => {
      for (const s of r.getEntries()) n(s)
    }).observe({ entryTypes: [t] })
  }
  static getInstance() {
    return Zg === void 0 && (Zg = new fn(uV)), Zg
  }
}
function nq(e) {
  uV = e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let cV
function iq(e) {
  const t = e.getId()
  return (
    t.then((n) => {
      cV = n
    }),
    t
  )
}
function Sb() {
  return cV
}
function rq(e) {
  const t = e.getToken()
  return t.then((n) => {}), t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function F0(e, t) {
  const n = e.length - t.length
  if (n < 0 || n > 1) throw Vn.create('invalid String merger input')
  const i = []
  for (let r = 0; r < e.length; r++) i.push(e.charAt(r)), t.length > r && i.push(t.charAt(r))
  return i.join('')
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let ev
class hi {
  constructor() {
    ;(this.instrumentationEnabled = !0),
      (this.dataCollectionEnabled = !0),
      (this.loggingEnabled = !1),
      (this.tracesSamplingRate = 1),
      (this.networkRequestsSamplingRate = 1),
      (this.logEndPointUrl = 'https://firebaselogging.googleapis.com/v0cc/log?format=json_proto'),
      (this.flTransportEndpointUrl = F0('hts/frbslgigp.ogepscmv/ieo/eaylg', 'tp:/ieaeogn-agolai.o/1frlglgc/o')),
      (this.transportKey = F0('AzSC8r6ReiGqFMyfvgow', 'Iayx0u-XT3vksVM-pIV')),
      (this.logSource = 462),
      (this.logTraceAfterSampling = !1),
      (this.logNetworkAfterSampling = !1),
      (this.configTimeToLive = 12)
  }
  getFlTransportFullUrl() {
    return this.flTransportEndpointUrl.concat('?key=', this.transportKey)
  }
  static getInstance() {
    return ev === void 0 && (ev = new hi()), ev
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var ol
;(function (e) {
  ;(e[(e.UNKNOWN = 0)] = 'UNKNOWN'), (e[(e.VISIBLE = 1)] = 'VISIBLE'), (e[(e.HIDDEN = 2)] = 'HIDDEN')
})(ol || (ol = {}))
const sq = ['firebase_', 'google_', 'ga_'],
  oq = new RegExp('^[a-zA-Z]\\w*$'),
  aq = 40,
  lq = 100
function uq() {
  const e = fn.getInstance().navigator
  return e != null && e.serviceWorker ? (e.serviceWorker.controller ? 2 : 3) : 1
}
function dV() {
  switch (fn.getInstance().document.visibilityState) {
    case 'visible':
      return ol.VISIBLE
    case 'hidden':
      return ol.HIDDEN
    default:
      return ol.UNKNOWN
  }
}
function cq() {
  const t = fn.getInstance().navigator.connection
  switch (t && t.effectiveType) {
    case 'slow-2g':
      return 1
    case '2g':
      return 2
    case '3g':
      return 3
    case '4g':
      return 4
    default:
      return 0
  }
}
function dq(e) {
  return e.length === 0 || e.length > aq ? !1 : !sq.some((n) => e.startsWith(n)) && !!e.match(oq)
}
function hq(e) {
  return e.length !== 0 && e.length <= lq
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function hV(e) {
  var t
  const n = (t = e.options) === null || t === void 0 ? void 0 : t.appId
  if (!n) throw Vn.create('no app id')
  return n
}
function fq(e) {
  var t
  const n = (t = e.options) === null || t === void 0 ? void 0 : t.projectId
  if (!n) throw Vn.create('no project id')
  return n
}
function mq(e) {
  var t
  const n = (t = e.options) === null || t === void 0 ? void 0 : t.apiKey
  if (!n) throw Vn.create('no api key')
  return n
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const gq = '0.0.1',
  Bi = { loggingEnabled: !0 },
  vq = 'FIREBASE_INSTALLATIONS_AUTH'
function pq(e, t) {
  const n = yq()
  return n
    ? (B0(n), Promise.resolve())
    : wq(e, t)
        .then(B0)
        .then(
          (i) => _q(i),
          () => {}
        )
}
function yq() {
  const e = fn.getInstance().localStorage
  if (!e) return
  const t = e.getItem(aV)
  if (!t || !Iq(t)) return
  const n = e.getItem(oV)
  if (n)
    try {
      return JSON.parse(n)
    } catch {
      return
    }
}
function _q(e) {
  const t = fn.getInstance().localStorage
  !e ||
    !t ||
    (t.setItem(oV, JSON.stringify(e)),
    t.setItem(aV, String(Date.now() + hi.getInstance().configTimeToLive * 60 * 60 * 1e3)))
}
const bq = 'Could not fetch config, will use default configs'
function wq(e, t) {
  return rq(e.installations)
    .then((n) => {
      const i = fq(e.app),
        r = mq(e.app),
        s = `https://firebaseremoteconfig.googleapis.com/v1/projects/${i}/namespaces/fireperf:fetch?key=${r}`,
        o = new Request(s, {
          method: 'POST',
          headers: { Authorization: `${vq} ${n}` },
          body: JSON.stringify({
            app_instance_id: t,
            app_instance_id_token: n,
            app_id: hV(e.app),
            app_version: tV,
            sdk_version: gq,
          }),
        })
      return fetch(o).then((a) => {
        if (a.ok) return a.json()
        throw Vn.create('RC response not ok')
      })
    })
    .catch(() => {
      fr.info(bq)
    })
}
function B0(e) {
  if (!e) return e
  const t = hi.getInstance(),
    n = e.entries || {}
  return (
    n.fpr_enabled !== void 0
      ? (t.loggingEnabled = String(n.fpr_enabled) === 'true')
      : (t.loggingEnabled = Bi.loggingEnabled),
    n.fpr_log_source ? (t.logSource = Number(n.fpr_log_source)) : Bi.logSource && (t.logSource = Bi.logSource),
    n.fpr_log_endpoint_url
      ? (t.logEndPointUrl = n.fpr_log_endpoint_url)
      : Bi.logEndPointUrl && (t.logEndPointUrl = Bi.logEndPointUrl),
    n.fpr_log_transport_key
      ? (t.transportKey = n.fpr_log_transport_key)
      : Bi.transportKey && (t.transportKey = Bi.transportKey),
    n.fpr_vc_network_request_sampling_rate !== void 0
      ? (t.networkRequestsSamplingRate = Number(n.fpr_vc_network_request_sampling_rate))
      : Bi.networkRequestsSamplingRate !== void 0 && (t.networkRequestsSamplingRate = Bi.networkRequestsSamplingRate),
    n.fpr_vc_trace_sampling_rate !== void 0
      ? (t.tracesSamplingRate = Number(n.fpr_vc_trace_sampling_rate))
      : Bi.tracesSamplingRate !== void 0 && (t.tracesSamplingRate = Bi.tracesSamplingRate),
    (t.logTraceAfterSampling = $0(t.tracesSamplingRate)),
    (t.logNetworkAfterSampling = $0(t.networkRequestsSamplingRate)),
    e
  )
}
function Iq(e) {
  return Number(e) > Date.now()
}
function $0(e) {
  return Math.random() <= e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let Eb = 1,
  tv
function fV(e) {
  return (Eb = 2), (tv = tv || Eq(e)), tv
}
function Sq() {
  return Eb === 3
}
function Eq(e) {
  return Tq()
    .then(() => iq(e.installations))
    .then((t) => pq(e, t))
    .then(
      () => U0(),
      () => U0()
    )
}
function Tq() {
  const e = fn.getInstance().document
  return new Promise((t) => {
    if (e && e.readyState !== 'complete') {
      const n = () => {
        e.readyState === 'complete' && (e.removeEventListener('readystatechange', n), t())
      }
      e.addEventListener('readystatechange', n)
    } else t()
  })
}
function U0() {
  Eb = 3
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Tb = 10 * 1e3,
  Cq = 5.5 * 1e3,
  mV = 3,
  Aq = 1e3
let yf = mV,
  xs = [],
  j0 = !1
function kq() {
  j0 || (Im(Cq), (j0 = !0))
}
function Im(e) {
  setTimeout(() => {
    if (yf !== 0) {
      if (!xs.length) return Im(Tb)
      Pq()
    }
  }, e)
}
function Pq() {
  const e = xs.splice(0, Aq),
    t = e.map((i) => ({ source_extension_json_proto3: i.message, event_time_ms: String(i.eventTime) })),
    n = {
      request_time_ms: String(Date.now()),
      client_info: { client_type: 1, js_client_info: {} },
      log_source: hi.getInstance().logSource,
      log_event: t,
    }
  Rq(n, e).catch(() => {
    ;(xs = [...e, ...xs]), yf--, fr.info(`Tries left: ${yf}.`), Im(Tb)
  })
}
function Rq(e, t) {
  return xq(e)
    .then((n) => (n.ok || fr.info('Call to Firebase backend failed.'), n.json()))
    .then((n) => {
      const i = Number(n.nextRequestWaitMillis)
      let r = Tb
      isNaN(i) || (r = Math.max(i, r))
      const s = n.logResponseDetails
      Array.isArray(s) &&
        s.length > 0 &&
        s[0].responseAction === 'RETRY_REQUEST_LATER' &&
        ((xs = [...t, ...xs]), fr.info('Retry transport request later.')),
        (yf = mV),
        Im(r)
    })
}
function xq(e) {
  const t = hi.getInstance().getFlTransportFullUrl()
  return fetch(t, { method: 'POST', body: JSON.stringify(e) })
}
function Vq(e) {
  if (!e.eventTime || !e.message) throw Vn.create('invalid cc log')
  xs = [...xs, e]
}
function Dq(e) {
  return (...t) => {
    const n = e(...t)
    Vq({ message: n, eventTime: Date.now() })
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ let nv
function gV(e, t) {
  nv || (nv = Dq(Oq)), nv(e, t)
}
function sh(e) {
  const t = hi.getInstance()
  ;(!t.instrumentationEnabled && e.isAuto) ||
    (!t.dataCollectionEnabled && !e.isAuto) ||
    (fn.getInstance().requiredApisAvailable() &&
      ((e.isAuto && dV() !== ol.VISIBLE) ||
        (Sq()
          ? iv(e)
          : fV(e.performanceController).then(
              () => iv(e),
              () => iv(e)
            ))))
}
function iv(e) {
  if (!Sb()) return
  const t = hi.getInstance()
  !t.loggingEnabled || !t.logTraceAfterSampling || setTimeout(() => gV(e, 1), 0)
}
function Nq(e) {
  const t = hi.getInstance()
  if (!t.instrumentationEnabled) return
  const n = e.url,
    i = t.logEndPointUrl.split('?')[0],
    r = t.flTransportEndpointUrl.split('?')[0]
  n === i || n === r || !t.loggingEnabled || !t.logNetworkAfterSampling || setTimeout(() => gV(e, 0), 0)
}
function Oq(e, t) {
  return t === 0 ? Mq(e) : Lq(e)
}
function Mq(e) {
  const t = {
      url: e.url,
      http_method: e.httpMethod || 0,
      http_response_code: 200,
      response_payload_bytes: e.responsePayloadBytes,
      client_start_time_us: e.startTimeUs,
      time_to_response_initiated_us: e.timeToResponseInitiatedUs,
      time_to_response_completed_us: e.timeToResponseCompletedUs,
    },
    n = { application_info: vV(e.performanceController.app), network_request_metric: t }
  return JSON.stringify(n)
}
function Lq(e) {
  const t = { name: e.name, is_auto: e.isAuto, client_start_time_us: e.startTimeUs, duration_us: e.durationUs }
  Object.keys(e.counters).length !== 0 && (t.counters = e.counters)
  const n = e.getAttributes()
  Object.keys(n).length !== 0 && (t.custom_attributes = n)
  const i = { application_info: vV(e.performanceController.app), trace_metric: t }
  return JSON.stringify(i)
}
function vV(e) {
  return {
    google_app_id: hV(e),
    app_instance_id: Sb(),
    web_app_info: {
      sdk_version: tV,
      page_url: fn.getInstance().getUrl(),
      service_worker_status: uq(),
      visibility_state: dV(),
      effective_connection_type: cq(),
    },
    application_process_state: 0,
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Fq = 100,
  Bq = '_',
  $q = [iV, rV, sV]
function Uq(e, t) {
  return e.length === 0 || e.length > Fq ? !1 : (t && t.startsWith(nV) && $q.indexOf(e) > -1) || !e.startsWith(Bq)
}
function jq(e) {
  const t = Math.floor(e)
  return t < e && fr.info(`Metric value should be an Integer, setting the value as : ${t}.`), t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Co {
  constructor(t, n, i = !1, r) {
    ;(this.performanceController = t),
      (this.name = n),
      (this.isAuto = i),
      (this.state = 1),
      (this.customAttributes = {}),
      (this.counters = {}),
      (this.api = fn.getInstance()),
      (this.randomId = Math.floor(Math.random() * 1e6)),
      this.isAuto ||
        ((this.traceStartMark = `${J9}-${this.randomId}-${this.name}`),
        (this.traceStopMark = `${Z9}-${this.randomId}-${this.name}`),
        (this.traceMeasure = r || `${Dp}-${this.randomId}-${this.name}`),
        r && this.calculateTraceMetrics())
  }
  start() {
    if (this.state !== 1) throw Vn.create('trace started', { traceName: this.name })
    this.api.mark(this.traceStartMark), (this.state = 2)
  }
  stop() {
    if (this.state !== 2) throw Vn.create('trace stopped', { traceName: this.name })
    ;(this.state = 3),
      this.api.mark(this.traceStopMark),
      this.api.measure(this.traceMeasure, this.traceStartMark, this.traceStopMark),
      this.calculateTraceMetrics(),
      sh(this)
  }
  record(t, n, i) {
    if (t <= 0) throw Vn.create('nonpositive trace startTime', { traceName: this.name })
    if (n <= 0) throw Vn.create('nonpositive trace duration', { traceName: this.name })
    if (
      ((this.durationUs = Math.floor(n * 1e3)),
      (this.startTimeUs = Math.floor(t * 1e3)),
      i && i.attributes && (this.customAttributes = Object.assign({}, i.attributes)),
      i && i.metrics)
    )
      for (const r of Object.keys(i.metrics))
        isNaN(Number(i.metrics[r])) || (this.counters[r] = Math.floor(Number(i.metrics[r])))
    sh(this)
  }
  incrementMetric(t, n = 1) {
    this.counters[t] === void 0 ? this.putMetric(t, n) : this.putMetric(t, this.counters[t] + n)
  }
  putMetric(t, n) {
    if (Uq(t, this.name)) this.counters[t] = jq(n ?? 0)
    else throw Vn.create('invalid custom metric name', { customMetricName: t })
  }
  getMetric(t) {
    return this.counters[t] || 0
  }
  putAttribute(t, n) {
    const i = dq(t),
      r = hq(n)
    if (i && r) {
      this.customAttributes[t] = n
      return
    }
    if (!i) throw Vn.create('invalid attribute name', { attributeName: t })
    if (!r) throw Vn.create('invalid attribute value', { attributeValue: n })
  }
  getAttribute(t) {
    return this.customAttributes[t]
  }
  removeAttribute(t) {
    this.customAttributes[t] !== void 0 && delete this.customAttributes[t]
  }
  getAttributes() {
    return Object.assign({}, this.customAttributes)
  }
  setStartTime(t) {
    this.startTimeUs = t
  }
  setDuration(t) {
    this.durationUs = t
  }
  calculateTraceMetrics() {
    const t = this.api.getEntriesByName(this.traceMeasure),
      n = t && t[0]
    n &&
      ((this.durationUs = Math.floor(n.duration * 1e3)),
      (this.startTimeUs = Math.floor((n.startTime + this.api.getTimeOrigin()) * 1e3)))
  }
  static createOobTrace(t, n, i, r) {
    const s = fn.getInstance().getUrl()
    if (!s) return
    const o = new Co(t, nV + s, !0),
      a = Math.floor(fn.getInstance().getTimeOrigin() * 1e3)
    o.setStartTime(a),
      n &&
        n[0] &&
        (o.setDuration(Math.floor(n[0].duration * 1e3)),
        o.putMetric('domInteractive', Math.floor(n[0].domInteractive * 1e3)),
        o.putMetric('domContentLoadedEventEnd', Math.floor(n[0].domContentLoadedEventEnd * 1e3)),
        o.putMetric('loadEventEnd', Math.floor(n[0].loadEventEnd * 1e3)))
    const l = 'first-paint',
      u = 'first-contentful-paint'
    if (i) {
      const c = i.find((f) => f.name === l)
      c && c.startTime && o.putMetric(iV, Math.floor(c.startTime * 1e3))
      const d = i.find((f) => f.name === u)
      d && d.startTime && o.putMetric(rV, Math.floor(d.startTime * 1e3)), r && o.putMetric(sV, Math.floor(r * 1e3))
    }
    sh(o)
  }
  static createUserTimingTrace(t, n) {
    const i = new Co(t, n, !1, n)
    sh(i)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function z0(e, t) {
  const n = t
  if (!n || n.responseStart === void 0) return
  const i = fn.getInstance().getTimeOrigin(),
    r = Math.floor((n.startTime + i) * 1e3),
    s = n.responseStart ? Math.floor((n.responseStart - n.startTime) * 1e3) : void 0,
    o = Math.floor((n.responseEnd - n.startTime) * 1e3),
    a = n.name && n.name.split('?')[0],
    l = {
      performanceController: e,
      url: a,
      responsePayloadBytes: n.transferSize,
      startTimeUs: r,
      timeToResponseInitiatedUs: s,
      timeToResponseCompletedUs: o,
    }
  Nq(l)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const zq = 5e3
function H0(e) {
  Sb() && (setTimeout(() => Wq(e), 0), setTimeout(() => Hq(e), 0), setTimeout(() => qq(e), 0))
}
function Hq(e) {
  const t = fn.getInstance(),
    n = t.getEntriesByType('resource')
  for (const i of n) z0(e, i)
  t.setupObserver('resource', (i) => z0(e, i))
}
function Wq(e) {
  const t = fn.getInstance(),
    n = t.getEntriesByType('navigation'),
    i = t.getEntriesByType('paint')
  if (t.onFirstInputDelay) {
    let r = setTimeout(() => {
      Co.createOobTrace(e, n, i), (r = void 0)
    }, zq)
    t.onFirstInputDelay((s) => {
      r && (clearTimeout(r), Co.createOobTrace(e, n, i, s))
    })
  } else Co.createOobTrace(e, n, i)
}
function qq(e) {
  const t = fn.getInstance(),
    n = t.getEntriesByType('measure')
  for (const i of n) W0(e, i)
  t.setupObserver('measure', (i) => W0(e, i))
}
function W0(e, t) {
  const n = t.name
  n.substring(0, Dp.length) !== Dp && Co.createUserTimingTrace(e, n)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Gq {
  constructor(t, n) {
    ;(this.app = t), (this.installations = n), (this.initialized = !1)
  }
  _init(t) {
    this.initialized ||
      ((t == null ? void 0 : t.dataCollectionEnabled) !== void 0 &&
        (this.dataCollectionEnabled = t.dataCollectionEnabled),
      (t == null ? void 0 : t.instrumentationEnabled) !== void 0 &&
        (this.instrumentationEnabled = t.instrumentationEnabled),
      fn.getInstance().requiredApisAvailable()
        ? Gy()
            .then((n) => {
              n &&
                (kq(),
                fV(this).then(
                  () => H0(this),
                  () => H0(this)
                ),
                (this.initialized = !0))
            })
            .catch((n) => {
              fr.info(`Environment doesn't support IndexedDB: ${n}`)
            })
        : fr.info(
            'Firebase Performance cannot start if the browser does not support "Fetch" and "Promise", or cookies are disabled.'
          ))
  }
  set instrumentationEnabled(t) {
    hi.getInstance().instrumentationEnabled = t
  }
  get instrumentationEnabled() {
    return hi.getInstance().instrumentationEnabled
  }
  set dataCollectionEnabled(t) {
    hi.getInstance().dataCollectionEnabled = t
  }
  get dataCollectionEnabled() {
    return hi.getInstance().dataCollectionEnabled
  }
}
const Kq = '[DEFAULT]'
function Yq(e = zc()) {
  return (e = Et(e)), Wr(e, 'performance').getImmediate()
}
const Qq = (e, { options: t }) => {
  const n = e.getProvider('app').getImmediate(),
    i = e.getProvider('installations-internal').getImmediate()
  if (n.name !== Kq) throw Vn.create('FB not default')
  if (typeof window > 'u') throw Vn.create('no window')
  nq(window)
  const r = new Gq(n, i)
  return r._init(t), r
}
function Xq() {
  Xn(new $n('performance', Qq, 'PUBLIC')), nn(L0, Vp), nn(L0, Vp, 'esm2017')
}
Xq()
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const _f = 'analytics',
  Jq = 'firebase_id',
  Zq = 'origin',
  eG = 60 * 1e3,
  tG = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig',
  nG = 'https://www.googletagmanager.com/gtag/js'
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const mi = new na('@firebase/analytics')
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function pV(e) {
  return Promise.all(e.map((t) => t.catch((n) => n)))
}
function iG(e, t) {
  const n = document.createElement('script'),
    i = HU`https://www.googletagmanager.com/gtag/js?l=${e}&id=${t}`
  KU(n, i), (n.async = !0), document.head.appendChild(n)
}
function rG(e) {
  let t = []
  return Array.isArray(window[e]) ? (t = window[e]) : (window[e] = t), t
}
async function sG(e, t, n, i, r, s) {
  const o = i[r]
  try {
    if (o) await t[o]
    else {
      const l = (await pV(n)).find((u) => u.measurementId === r)
      l && (await t[l.appId])
    }
  } catch (a) {
    mi.error(a)
  }
  e('config', r, s)
}
async function oG(e, t, n, i, r) {
  try {
    let s = []
    if (r && r.send_to) {
      let o = r.send_to
      Array.isArray(o) || (o = [o])
      const a = await pV(n)
      for (const l of o) {
        const u = a.find((d) => d.measurementId === l),
          c = u && t[u.appId]
        if (c) s.push(c)
        else {
          s = []
          break
        }
      }
    }
    s.length === 0 && (s = Object.values(t)), await Promise.all(s), e('event', i, r || {})
  } catch (s) {
    mi.error(s)
  }
}
function aG(e, t, n, i) {
  async function r(s, ...o) {
    try {
      if (s === 'event') {
        const [a, l] = o
        await oG(e, t, n, a, l)
      } else if (s === 'config') {
        const [a, l] = o
        await sG(e, t, n, i, a, l)
      } else if (s === 'consent') {
        const [a, l] = o
        e('consent', a, l)
      } else if (s === 'get') {
        const [a, l, u] = o
        e('get', a, l, u)
      } else if (s === 'set') {
        const [a] = o
        e('set', a)
      } else e(s, ...o)
    } catch (a) {
      mi.error(a)
    }
  }
  return r
}
function lG(e, t, n, i, r) {
  let s = function (...o) {
    window[i].push(arguments)
  }
  return (
    window[r] && typeof window[r] == 'function' && (s = window[r]),
    (window[r] = aG(s, e, t, n)),
    { gtagCore: s, wrappedGtag: window[r] }
  )
}
function uG(e) {
  const t = window.document.getElementsByTagName('script')
  for (const n of Object.values(t)) if (n.src && n.src.includes(nG) && n.src.includes(e)) return n
  return null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const cG = {
    'already-exists':
      'A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.',
    'already-initialized':
      'initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.',
    'already-initialized-settings':
      'Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.',
    'interop-component-reg-failed': 'Firebase Analytics Interop Component failed to instantiate: {$reason}',
    'invalid-analytics-context':
      'Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}',
    'indexeddb-unavailable':
      'IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}',
    'fetch-throttle':
      'The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',
    'config-fetch-failed': 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',
    'no-api-key':
      'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
    'no-app-id':
      'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
    'no-client-id': 'The "client_id" field is empty.',
    'invalid-gtag-resource': 'Trusted Types detected an invalid gtag resource: {$gtagURL}.',
  },
  Ri = new zr('analytics', 'Analytics', cG)
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const dG = 30,
  hG = 1e3
class fG {
  constructor(t = {}, n = hG) {
    ;(this.throttleMetadata = t), (this.intervalMillis = n)
  }
  getThrottleMetadata(t) {
    return this.throttleMetadata[t]
  }
  setThrottleMetadata(t, n) {
    this.throttleMetadata[t] = n
  }
  deleteThrottleMetadata(t) {
    delete this.throttleMetadata[t]
  }
}
const yV = new fG()
function mG(e) {
  return new Headers({ Accept: 'application/json', 'x-goog-api-key': e })
}
async function gG(e) {
  var t
  const { appId: n, apiKey: i } = e,
    r = { method: 'GET', headers: mG(i) },
    s = tG.replace('{app-id}', n),
    o = await fetch(s, r)
  if (o.status !== 200 && o.status !== 304) {
    let a = ''
    try {
      const l = await o.json()
      !((t = l.error) === null || t === void 0) && t.message && (a = l.error.message)
    } catch {}
    throw Ri.create('config-fetch-failed', { httpStatus: o.status, responseMessage: a })
  }
  return o.json()
}
async function vG(e, t = yV, n) {
  const { appId: i, apiKey: r, measurementId: s } = e.options
  if (!i) throw Ri.create('no-app-id')
  if (!r) {
    if (s) return { measurementId: s, appId: i }
    throw Ri.create('no-api-key')
  }
  const o = t.getThrottleMetadata(i) || { backoffCount: 0, throttleEndTimeMillis: Date.now() },
    a = new _G()
  return (
    setTimeout(async () => {
      a.abort()
    }, eG),
    _V({ appId: i, apiKey: r, measurementId: s }, o, a, t)
  )
}
async function _V(e, { throttleEndTimeMillis: t, backoffCount: n }, i, r = yV) {
  var s
  const { appId: o, measurementId: a } = e
  try {
    await pG(i, t)
  } catch (l) {
    if (a)
      return (
        mi.warn(
          `Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${
            l == null ? void 0 : l.message
          }]`
        ),
        { appId: o, measurementId: a }
      )
    throw l
  }
  try {
    const l = await gG(e)
    return r.deleteThrottleMetadata(o), l
  } catch (l) {
    const u = l
    if (!yG(u)) {
      if ((r.deleteThrottleMetadata(o), a))
        return (
          mi.warn(
            `Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${
              u == null ? void 0 : u.message
            }]`
          ),
          { appId: o, measurementId: a }
        )
      throw l
    }
    const c =
        Number((s = u == null ? void 0 : u.customData) === null || s === void 0 ? void 0 : s.httpStatus) === 503
          ? uS(n, r.intervalMillis, dG)
          : uS(n, r.intervalMillis),
      d = { throttleEndTimeMillis: Date.now() + c, backoffCount: n + 1 }
    return r.setThrottleMetadata(o, d), mi.debug(`Calling attemptFetch again in ${c} millis`), _V(e, d, i, r)
  }
}
function pG(e, t) {
  return new Promise((n, i) => {
    const r = Math.max(t - Date.now(), 0),
      s = setTimeout(n, r)
    e.addEventListener(() => {
      clearTimeout(s), i(Ri.create('fetch-throttle', { throttleEndTimeMillis: t }))
    })
  })
}
function yG(e) {
  if (!(e instanceof Di) || !e.customData) return !1
  const t = Number(e.customData.httpStatus)
  return t === 429 || t === 500 || t === 503 || t === 504
}
class _G {
  constructor() {
    this.listeners = []
  }
  addEventListener(t) {
    this.listeners.push(t)
  }
  abort() {
    this.listeners.forEach((t) => t())
  }
}
async function bG(e, t, n, i, r) {
  if (r && r.global) {
    e('event', n, i)
    return
  } else {
    const s = await t,
      o = Object.assign(Object.assign({}, i), { send_to: s })
    e('event', n, o)
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function wG() {
  if (jc())
    try {
      await Gy()
    } catch (e) {
      return mi.warn(Ri.create('indexeddb-unavailable', { errorInfo: e == null ? void 0 : e.toString() }).message), !1
    }
  else
    return (
      mi.warn(
        Ri.create('indexeddb-unavailable', { errorInfo: 'IndexedDB is not available in this environment.' }).message
      ),
      !1
    )
  return !0
}
async function IG(e, t, n, i, r, s, o) {
  var a
  const l = vG(e)
  l
    .then((m) => {
      ;(n[m.measurementId] = m.appId),
        e.options.measurementId &&
          m.measurementId !== e.options.measurementId &&
          mi.warn(
            `The measurement ID in the local Firebase config (${e.options.measurementId}) does not match the measurement ID fetched from the server (${m.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`
          )
    })
    .catch((m) => mi.error(m)),
    t.push(l)
  const u = wG().then((m) => {
      if (m) return i.getId()
    }),
    [c, d] = await Promise.all([l, u])
  uG(s) || iG(s, c.measurementId), r('js', new Date())
  const f = (a = o == null ? void 0 : o.config) !== null && a !== void 0 ? a : {}
  return (
    (f[Zq] = 'firebase'), (f.update = !0), d != null && (f[Jq] = d), r('config', c.measurementId, f), c.measurementId
  )
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class SG {
  constructor(t) {
    this.app = t
  }
  _delete() {
    return delete Zu[this.app.options.appId], Promise.resolve()
  }
}
let Zu = {},
  q0 = []
const G0 = {}
let rv = 'dataLayer',
  EG = 'gtag',
  K0,
  bV,
  Y0 = !1
function TG() {
  const e = []
  if (
    (sk() && e.push('This is a browser extension environment.'),
    uk() || e.push('Cookies are not available.'),
    e.length > 0)
  ) {
    const t = e.map((i, r) => `(${r + 1}) ${i}`).join(' '),
      n = Ri.create('invalid-analytics-context', { errorInfo: t })
    mi.warn(n.message)
  }
}
function CG(e, t, n) {
  TG()
  const i = e.options.appId
  if (!i) throw Ri.create('no-app-id')
  if (!e.options.apiKey)
    if (e.options.measurementId)
      mi.warn(
        `The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${e.options.measurementId} provided in the "measurementId" field in the local Firebase config.`
      )
    else throw Ri.create('no-api-key')
  if (Zu[i] != null) throw Ri.create('already-exists', { id: i })
  if (!Y0) {
    rG(rv)
    const { wrappedGtag: s, gtagCore: o } = lG(Zu, q0, G0, rv, EG)
    ;(bV = s), (K0 = o), (Y0 = !0)
  }
  return (Zu[i] = IG(e, q0, G0, t, K0, rv, n)), new SG(e)
}
function AG(e = zc()) {
  e = Et(e)
  const t = Wr(e, _f)
  return t.isInitialized() ? t.getImmediate() : kG(e)
}
function kG(e, t = {}) {
  const n = Wr(e, _f)
  if (n.isInitialized()) {
    const r = n.getImmediate()
    if (fl(t, n.getOptions())) return r
    throw Ri.create('already-initialized')
  }
  return n.initialize({ options: t })
}
function PG(e, t, n, i) {
  ;(e = Et(e)), bG(bV, Zu[e.app.options.appId], t, n, i).catch((r) => mi.error(r))
}
const Q0 = '@firebase/analytics',
  X0 = '0.10.6'
function RG() {
  Xn(
    new $n(
      _f,
      (t, { options: n }) => {
        const i = t.getProvider('app').getImmediate(),
          r = t.getProvider('installations-internal').getImmediate()
        return CG(i, r, n)
      },
      'PUBLIC'
    )
  ),
    Xn(new $n('analytics-internal', e, 'PRIVATE')),
    nn(Q0, X0),
    nn(Q0, X0, 'esm2017')
  function e(t) {
    try {
      const n = t.getProvider(_f).getImmediate()
      return { logEvent: (i, r, s) => PG(n, i, r, s) }
    } catch (n) {
      throw Ri.create('interop-component-reg-failed', { reason: n })
    }
  }
}
RG()
var xG = {
  VITE_FIREBASE_API_KEY: 'AIzaSyDR5ik7GoUZA142kws0i-b6NtfUAivS0WM',
  VITE_FIREBASE_AUTH_DOMAIN: 'alex-set-list-app.firebaseapp.com',
  VITE_FIREBASE_PROJECT_ID: 'alex-set-list-app',
  VITE_FIREBASE_STORAGE_BUCKET: 'alex-set-list-app.appspot.com',
  VITE_FIREBASE_MESSAGING_SENDER_ID: '252093619867',
  VITE_FIREBASE_APP_ID: '1:252093619867:web:fc5d6fbf1420e9d939703e',
  VITE_FIREBASE_MEASUREMENT_ID: 'G-C44WH0WBW0',
  VITE_APP_NAME: "ASLA - Alex' Setlist App",
  VITE_APP_SHORT_NAME: 'ASLA',
  VITE_APP_DESCRIPTION: "Alex' Setlist App",
  VITE_BASE_URL: '/ASLA/',
  BASE_URL: '/ASLA/',
  MODE: 'production',
  DEV: !1,
  PROD: !0,
  SSR: !1,
}
const ro = xG,
  VG = {
    apiKey: ro.VITE_FIREBASE_API_KEY,
    authDomain: ro.VITE_FIREBASE_AUTH_DOMAIN,
    projectId: ro.VITE_FIREBASE_PROJECT_ID,
    storageBucket: ro.VITE_FIREBASE_STORAGE_BUCKET,
    messagingSenderId: ro.VITE_FIREBASE_MESSAGING_SENDER_ID,
    appId: ro.VITE_FIREBASE_APP_ID,
    measurementId: ro.VITE_FIREBASE_MEASUREMENT_ID,
  },
  od = mk(VG),
  nne = FU(od),
  wV = AW(od, { localCache: UW({}) })
Yq(od)
AG(od)
const IV = (e, t) => EW(e, t),
  ine = IV(wV, 'setlist'),
  rne = IV(wV, 'songs'),
  sne = (e, ...t) => {
    const n = { ...e }
    return t.forEach((i) => delete n[i]), n
  }
function ii(e, t) {
  let n
  function i() {
    ;(n = Nl()),
      n.run(() =>
        t.length
          ? t(() => {
              n == null || n.stop(), i()
            })
          : t()
      )
  }
  be(
    e,
    (r) => {
      r && !n ? i() : r || (n == null || n.stop(), (n = void 0))
    },
    { immediate: !0 }
  ),
    gn(() => {
      n == null || n.stop()
    })
}
const ct = typeof window < 'u',
  Cb = ct && 'IntersectionObserver' in window,
  DG = ct && ('ontouchstart' in window || window.navigator.maxTouchPoints > 0),
  J0 = ct && 'EyeDropper' in window
function Z0(e, t, n) {
  NG(e, t), t.set(e, n)
}
function NG(e, t) {
  if (t.has(e)) throw new TypeError('Cannot initialize the same private elements twice on an object')
}
function OG(e, t, n) {
  return e.set(SV(e, t), n), n
}
function so(e, t) {
  return e.get(SV(e, t))
}
function SV(e, t, n) {
  if (typeof e == 'function' ? e === t : e.has(t)) return arguments.length < 3 ? t : n
  throw new TypeError('Private element is not present on this object')
}
function EV(e, t, n) {
  const i = t.length - 1
  if (i < 0) return e === void 0 ? n : e
  for (let r = 0; r < i; r++) {
    if (e == null) return n
    e = e[t[r]]
  }
  return e == null || e[t[i]] === void 0 ? n : e[t[i]]
}
function vr(e, t) {
  if (e === t) return !0
  if ((e instanceof Date && t instanceof Date && e.getTime() !== t.getTime()) || e !== Object(e) || t !== Object(t))
    return !1
  const n = Object.keys(e)
  return n.length !== Object.keys(t).length ? !1 : n.every((i) => vr(e[i], t[i]))
}
function Go(e, t, n) {
  return e == null || !t || typeof t != 'string'
    ? n
    : e[t] !== void 0
    ? e[t]
    : ((t = t.replace(/\[(\w+)\]/g, '.$1')), (t = t.replace(/^\./, '')), EV(e, t.split('.'), n))
}
function Jt(e, t, n) {
  if (t === !0) return e === void 0 ? n : e
  if (t == null || typeof t == 'boolean') return n
  if (e !== Object(e)) {
    if (typeof t != 'function') return n
    const r = t(e, n)
    return typeof r > 'u' ? n : r
  }
  if (typeof t == 'string') return Go(e, t, n)
  if (Array.isArray(t)) return EV(e, t, n)
  if (typeof t != 'function') return n
  const i = t(e, n)
  return typeof i > 'u' ? n : i
}
function ar(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
  return Array.from({ length: e }, (n, i) => t + i)
}
function Se(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'px'
  if (!(e == null || e === '')) return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0
}
function Sc(e) {
  return e !== null && typeof e == 'object' && !Array.isArray(e)
}
function Ab(e) {
  if (e && '$el' in e) {
    const t = e.$el
    return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t
  }
  return e
}
const eT = Object.freeze({
    enter: 13,
    tab: 9,
    delete: 46,
    esc: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    end: 35,
    home: 36,
    del: 46,
    backspace: 8,
    insert: 45,
    pageup: 33,
    pagedown: 34,
    shift: 16,
  }),
  Np = Object.freeze({
    enter: 'Enter',
    tab: 'Tab',
    delete: 'Delete',
    esc: 'Escape',
    space: 'Space',
    up: 'ArrowUp',
    down: 'ArrowDown',
    left: 'ArrowLeft',
    right: 'ArrowRight',
    end: 'End',
    home: 'Home',
    del: 'Delete',
    backspace: 'Backspace',
    insert: 'Insert',
    pageup: 'PageUp',
    pagedown: 'PageDown',
    shift: 'Shift',
  })
function TV(e) {
  return Object.keys(e)
}
function yo(e, t) {
  return t.every((n) => e.hasOwnProperty(n))
}
function kb(e, t) {
  const n = {},
    i = new Set(Object.keys(e))
  for (const r of t) i.has(r) && (n[r] = e[r])
  return n
}
function Op(e, t, n) {
  const i = Object.create(null),
    r = Object.create(null)
  for (const s in e)
    t.some((o) => (o instanceof RegExp ? o.test(s) : o === s)) && !(n != null && n.some((o) => o === s))
      ? (i[s] = e[s])
      : (r[s] = e[s])
  return [i, r]
}
function Qt(e, t) {
  const n = { ...e }
  return t.forEach((i) => delete n[i]), n
}
function Sm(e, t) {
  const n = {}
  return t.forEach((i) => (n[i] = e[i])), n
}
const CV = /^on[^a-z]/,
  Em = (e) => CV.test(e),
  MG = [
    'onAfterscriptexecute',
    'onAnimationcancel',
    'onAnimationend',
    'onAnimationiteration',
    'onAnimationstart',
    'onAuxclick',
    'onBeforeinput',
    'onBeforescriptexecute',
    'onChange',
    'onClick',
    'onCompositionend',
    'onCompositionstart',
    'onCompositionupdate',
    'onContextmenu',
    'onCopy',
    'onCut',
    'onDblclick',
    'onFocusin',
    'onFocusout',
    'onFullscreenchange',
    'onFullscreenerror',
    'onGesturechange',
    'onGestureend',
    'onGesturestart',
    'onGotpointercapture',
    'onInput',
    'onKeydown',
    'onKeypress',
    'onKeyup',
    'onLostpointercapture',
    'onMousedown',
    'onMousemove',
    'onMouseout',
    'onMouseover',
    'onMouseup',
    'onMousewheel',
    'onPaste',
    'onPointercancel',
    'onPointerdown',
    'onPointerenter',
    'onPointerleave',
    'onPointermove',
    'onPointerout',
    'onPointerover',
    'onPointerup',
    'onReset',
    'onSelect',
    'onSubmit',
    'onTouchcancel',
    'onTouchend',
    'onTouchmove',
    'onTouchstart',
    'onTransitioncancel',
    'onTransitionend',
    'onTransitionrun',
    'onTransitionstart',
    'onWheel',
  ],
  LG = ['ArrowUp', 'ArrowDown', 'ArrowRight', 'ArrowLeft', 'Enter', 'Escape', 'Tab', ' ']
function FG(e) {
  return e.isComposing && LG.includes(e.key)
}
function Gs(e) {
  const [t, n] = Op(e, [CV]),
    i = Qt(t, MG),
    [r, s] = Op(n, ['class', 'style', 'id', /^data-/])
  return Object.assign(r, t), Object.assign(s, i), [r, s]
}
function Pt(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e]
}
function BG(e, t) {
  let n = 0
  const i = function () {
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++) s[o] = arguments[o]
    clearTimeout(n), (n = setTimeout(() => e(...s), Lt(t)))
  }
  return (
    (i.clear = () => {
      clearTimeout(n)
    }),
    (i.immediate = e),
    i
  )
}
function qt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  return Math.max(t, Math.min(n, e))
}
function tT(e) {
  const t = e.toString().trim()
  return t.includes('.') ? t.length - t.indexOf('.') - 1 : 0
}
function nT(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '0'
  return e + n.repeat(Math.max(0, t - e.length))
}
function iT(e, t) {
  return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '0').repeat(Math.max(0, t - e.length)) + e
}
function $G(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
  const n = []
  let i = 0
  for (; i < e.length; ) n.push(e.substr(i, t)), (i += t)
  return n
}
function rT(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3
  if (e < t) return `${e} B`
  const n = t === 1024 ? ['Ki', 'Mi', 'Gi'] : ['k', 'M', 'G']
  let i = -1
  for (; Math.abs(e) >= t && i < n.length - 1; ) (e /= t), ++i
  return `${e.toFixed(1)} ${n[i]}B`
}
function Fn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = arguments.length > 2 ? arguments[2] : void 0
  const i = {}
  for (const r in e) i[r] = e[r]
  for (const r in t) {
    const s = e[r],
      o = t[r]
    if (Sc(s) && Sc(o)) {
      i[r] = Fn(s, o, n)
      continue
    }
    if (Array.isArray(s) && Array.isArray(o) && n) {
      i[r] = n(s, o)
      continue
    }
    i[r] = o
  }
  return i
}
function AV(e) {
  return e.map((t) => (t.type === ke ? AV(t.children) : t)).flat()
}
function Ao() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ''
  if (Ao.cache.has(e)) return Ao.cache.get(e)
  const t = e
    .replace(/[^a-z]/gi, '-')
    .replace(/\B([A-Z])/g, '-$1')
    .toLowerCase()
  return Ao.cache.set(e, t), t
}
Ao.cache = new Map()
function Ga(e, t) {
  if (!t || typeof t != 'object') return []
  if (Array.isArray(t)) return t.map((n) => Ga(e, n)).flat(1)
  if (t.suspense) return Ga(e, t.ssContent)
  if (Array.isArray(t.children)) return t.children.map((n) => Ga(e, n)).flat(1)
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e)) return [t.component]
    if (t.component.subTree) return Ga(e, t.component.subTree).flat(1)
  }
  return []
}
var oh = new WeakMap(),
  Va = new WeakMap()
class UG {
  constructor(t) {
    Z0(this, oh, []), Z0(this, Va, 0), (this.size = t)
  }
  push(t) {
    ;(so(oh, this)[so(Va, this)] = t), OG(Va, this, (so(Va, this) + 1) % this.size)
  }
  values() {
    return so(oh, this)
      .slice(so(Va, this))
      .concat(so(oh, this).slice(0, so(Va, this)))
  }
}
function jG(e) {
  return 'touches' in e
    ? { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }
    : { clientX: e.clientX, clientY: e.clientY }
}
function Pb(e) {
  const t = wn({}),
    n = k(e)
  return (
    $t(
      () => {
        for (const i in n.value) t[i] = n.value[i]
      },
      { flush: 'sync' }
    ),
    js(t)
  )
}
function bf(e, t) {
  return e.includes(t)
}
function kV(e) {
  return e[2].toLowerCase() + e.slice(3)
}
const mn = () => [Function, Array]
function sT(e, t) {
  return (
    (t = 'on' + gr(t)), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`])
  )
}
function Rb(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i]
  if (Array.isArray(e)) for (const r of e) r(...n)
  else typeof e == 'function' && e(...n)
}
function Ec(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
  const n = ['button', '[href]', 'input:not([type="hidden"])', 'select', 'textarea', '[tabindex]']
    .map((i) => `${i}${t ? ':not([tabindex="-1"])' : ''}:not([disabled])`)
    .join(', ')
  return [...e.querySelectorAll(n)]
}
function PV(e, t, n) {
  let i,
    r = e.indexOf(document.activeElement)
  const s = t === 'next' ? 1 : -1
  do (r += s), (i = e[r])
  while ((!i || i.offsetParent == null || !((n == null ? void 0 : n(i)) ?? !0)) && r < e.length && r >= 0)
  return i
}
function Cl(e, t) {
  var i, r, s, o
  const n = Ec(e)
  if (!t) (e === document.activeElement || !e.contains(document.activeElement)) && ((i = n[0]) == null || i.focus())
  else if (t === 'first') (r = n[0]) == null || r.focus()
  else if (t === 'last') (s = n.at(-1)) == null || s.focus()
  else if (typeof t == 'number') (o = n[t]) == null || o.focus()
  else {
    const a = PV(n, t)
    a ? a.focus() : Cl(e, t === 'next' ? 'first' : 'last')
  }
}
function ah(e) {
  return e == null || (typeof e == 'string' && e.trim() === '')
}
function RV() {}
function Al(e, t) {
  if (!(ct && typeof CSS < 'u' && typeof CSS.supports < 'u' && CSS.supports(`selector(${t})`))) return null
  try {
    return !!e && e.matches(t)
  } catch {
    return null
  }
}
function Tm(e) {
  return e.some((t) => (cl(t) ? (t.type === In ? !1 : t.type !== ke || Tm(t.children)) : !0)) ? e : null
}
function zG(e, t) {
  if (!ct || e === 0) return t(), () => {}
  const n = window.setTimeout(t, e)
  return () => window.clearTimeout(n)
}
function oT(e, t) {
  const n = ye()
  return (
    $t(
      () => {
        n.value = e()
      },
      { flush: 'sync', ...t }
    ),
    Ol(n)
  )
}
function HG(e, t) {
  const n = e.clientX,
    i = e.clientY,
    r = t.getBoundingClientRect(),
    s = r.left,
    o = r.top,
    a = r.right,
    l = r.bottom
  return n >= s && n <= a && i >= o && i <= l
}
function wf() {
  const e = ye(),
    t = (n) => {
      e.value = n
    }
  return (
    Object.defineProperty(t, 'value', { enumerable: !0, get: () => e.value, set: (n) => (e.value = n) }),
    Object.defineProperty(t, 'el', { enumerable: !0, get: () => Ab(e.value) }),
    t
  )
}
const xV = ['top', 'bottom'],
  WG = ['start', 'end', 'left', 'right']
function Mp(e, t) {
  let [n, i] = e.split(' ')
  return i || (i = bf(xV, n) ? 'start' : bf(WG, n) ? 'top' : 'center'), { side: Lp(n, t), align: Lp(i, t) }
}
function Lp(e, t) {
  return e === 'start' ? (t ? 'right' : 'left') : e === 'end' ? (t ? 'left' : 'right') : e
}
function sv(e) {
  return {
    side: { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[e.side],
    align: e.align,
  }
}
function ov(e) {
  return {
    side: e.side,
    align: { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[e.align],
  }
}
function aT(e) {
  return { side: e.align, align: e.side }
}
function lT(e) {
  return bf(xV, e.side) ? 'y' : 'x'
}
class ko {
  constructor(t) {
    let { x: n, y: i, width: r, height: s } = t
    ;(this.x = n), (this.y = i), (this.width = r), (this.height = s)
  }
  get top() {
    return this.y
  }
  get bottom() {
    return this.y + this.height
  }
  get left() {
    return this.x
  }
  get right() {
    return this.x + this.width
  }
}
function uT(e, t) {
  return {
    x: { before: Math.max(0, t.left - e.left), after: Math.max(0, e.right - t.right) },
    y: { before: Math.max(0, t.top - e.top), after: Math.max(0, e.bottom - t.bottom) },
  }
}
function VV(e) {
  return Array.isArray(e) ? new ko({ x: e[0], y: e[1], width: 0, height: 0 }) : e.getBoundingClientRect()
}
function xb(e) {
  const t = e.getBoundingClientRect(),
    n = getComputedStyle(e),
    i = n.transform
  if (i) {
    let r, s, o, a, l
    if (i.startsWith('matrix3d('))
      (r = i.slice(9, -1).split(/, /)), (s = +r[0]), (o = +r[5]), (a = +r[12]), (l = +r[13])
    else if (i.startsWith('matrix('))
      (r = i.slice(7, -1).split(/, /)), (s = +r[0]), (o = +r[3]), (a = +r[4]), (l = +r[5])
    else return new ko(t)
    const u = n.transformOrigin,
      c = t.x - a - (1 - s) * parseFloat(u),
      d = t.y - l - (1 - o) * parseFloat(u.slice(u.indexOf(' ') + 1)),
      f = s ? t.width / s : e.offsetWidth + 1,
      m = o ? t.height / o : e.offsetHeight + 1
    return new ko({ x: c, y: d, width: f, height: m })
  } else return new ko(t)
}
function _o(e, t, n) {
  if (typeof e.animate > 'u') return { finished: Promise.resolve() }
  let i
  try {
    i = e.animate(t, n)
  } catch {
    return { finished: Promise.resolve() }
  }
  return (
    typeof i.finished > 'u' &&
      (i.finished = new Promise((r) => {
        i.onfinish = () => {
          r(i)
        }
      })),
    i
  )
}
const Rh = new WeakMap()
function qG(e, t) {
  Object.keys(t).forEach((n) => {
    if (Em(n)) {
      const i = kV(n),
        r = Rh.get(e)
      if (t[n] == null)
        r == null ||
          r.forEach((s) => {
            const [o, a] = s
            o === i && (e.removeEventListener(i, a), r.delete(s))
          })
      else if (!r || ![...r].some((s) => s[0] === i && s[1] === t[n])) {
        e.addEventListener(i, t[n])
        const s = r || new Set()
        s.add([i, t[n]]), Rh.has(e) || Rh.set(e, s)
      }
    } else t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n])
  })
}
function GG(e, t) {
  Object.keys(t).forEach((n) => {
    if (Em(n)) {
      const i = kV(n),
        r = Rh.get(e)
      r == null ||
        r.forEach((s) => {
          const [o, a] = s
          o === i && (e.removeEventListener(i, a), r.delete(s))
        })
    } else e.removeAttribute(n)
  })
}
const Da = 2.4,
  cT = 0.2126729,
  dT = 0.7151522,
  hT = 0.072175,
  KG = 0.55,
  YG = 0.58,
  QG = 0.57,
  XG = 0.62,
  lh = 0.03,
  fT = 1.45,
  JG = 5e-4,
  ZG = 1.25,
  eK = 1.25,
  mT = 0.078,
  gT = 12.82051282051282,
  uh = 0.06,
  vT = 0.001
function pT(e, t) {
  const n = (e.r / 255) ** Da,
    i = (e.g / 255) ** Da,
    r = (e.b / 255) ** Da,
    s = (t.r / 255) ** Da,
    o = (t.g / 255) ** Da,
    a = (t.b / 255) ** Da
  let l = n * cT + i * dT + r * hT,
    u = s * cT + o * dT + a * hT
  if ((l <= lh && (l += (lh - l) ** fT), u <= lh && (u += (lh - u) ** fT), Math.abs(u - l) < JG)) return 0
  let c
  if (u > l) {
    const d = (u ** KG - l ** YG) * ZG
    c = d < vT ? 0 : d < mT ? d - d * gT * uh : d - uh
  } else {
    const d = (u ** XG - l ** QG) * eK
    c = d > -vT ? 0 : d > -mT ? d - d * gT * uh : d + uh
  }
  return c * 100
}
function tK(e, t) {
  t = Array.isArray(t)
    ? t
        .slice(0, -1)
        .map((n) => `'${n}'`)
        .join(', ') + ` or '${t.at(-1)}'`
    : `'${t}'`
}
const If = 0.20689655172413793,
  nK = (e) => (e > If ** 3 ? Math.cbrt(e) : e / (3 * If ** 2) + 4 / 29),
  iK = (e) => (e > If ? e ** 3 : 3 * If ** 2 * (e - 4 / 29))
function DV(e) {
  const t = nK,
    n = t(e[1])
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))]
}
function NV(e) {
  const t = iK,
    n = (e[0] + 16) / 116
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883]
}
const rK = [
    [3.2406, -1.5372, -0.4986],
    [-0.9689, 1.8758, 0.0415],
    [0.0557, -0.204, 1.057],
  ],
  sK = (e) => (e <= 0.0031308 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055),
  oK = [
    [0.4124, 0.3576, 0.1805],
    [0.2126, 0.7152, 0.0722],
    [0.0193, 0.1192, 0.9505],
  ],
  aK = (e) => (e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4)
function OV(e) {
  const t = Array(3),
    n = sK,
    i = rK
  for (let r = 0; r < 3; ++r) t[r] = Math.round(qt(n(i[r][0] * e[0] + i[r][1] * e[1] + i[r][2] * e[2])) * 255)
  return { r: t[0], g: t[1], b: t[2] }
}
function Vb(e) {
  let { r: t, g: n, b: i } = e
  const r = [0, 0, 0],
    s = aK,
    o = oK
  ;(t = s(t / 255)), (n = s(n / 255)), (i = s(i / 255))
  for (let a = 0; a < 3; ++a) r[a] = o[a][0] * t + o[a][1] * n + o[a][2] * i
  return r
}
function Fp(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e)
}
function lK(e) {
  return Fp(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e)
}
const yT = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/,
  uK = {
    rgb: (e, t, n, i) => ({ r: e, g: t, b: n, a: i }),
    rgba: (e, t, n, i) => ({ r: e, g: t, b: n, a: i }),
    hsl: (e, t, n, i) => _T({ h: e, s: t, l: n, a: i }),
    hsla: (e, t, n, i) => _T({ h: e, s: t, l: n, a: i }),
    hsv: (e, t, n, i) => Fr({ h: e, s: t, v: n, a: i }),
    hsva: (e, t, n, i) => Fr({ h: e, s: t, v: n, a: i }),
  }
function Ai(e) {
  if (typeof e == 'number') return { r: (e & 16711680) >> 16, g: (e & 65280) >> 8, b: e & 255 }
  if (typeof e == 'string' && yT.test(e)) {
    const { groups: t } = e.match(yT),
      { fn: n, values: i } = t,
      r = i
        .split(/,\s*/)
        .map((s) =>
          s.endsWith('%') && ['hsl', 'hsla', 'hsv', 'hsva'].includes(n) ? parseFloat(s) / 100 : parseFloat(s)
        )
    return uK[n](...r)
  } else if (typeof e == 'string') {
    let t = e.startsWith('#') ? e.slice(1) : e
    return (
      [3, 4].includes(t.length)
        ? (t = t
            .split('')
            .map((n) => n + n)
            .join(''))
        : [6, 8].includes(t.length),
      $V(t)
    )
  } else if (typeof e == 'object') {
    if (yo(e, ['r', 'g', 'b'])) return e
    if (yo(e, ['h', 's', 'l'])) return Fr(Db(e))
    if (yo(e, ['h', 's', 'v'])) return Fr(e)
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`)
}
function Fr(e) {
  const { h: t, s: n, v: i, a: r } = e,
    s = (a) => {
      const l = (a + t / 60) % 6
      return i - i * n * Math.max(Math.min(l, 4 - l, 1), 0)
    },
    o = [s(5), s(3), s(1)].map((a) => Math.round(a * 255))
  return { r: o[0], g: o[1], b: o[2], a: r }
}
function _T(e) {
  return Fr(Db(e))
}
function Cm(e) {
  if (!e) return { h: 0, s: 1, v: 1, a: 1 }
  const t = e.r / 255,
    n = e.g / 255,
    i = e.b / 255,
    r = Math.max(t, n, i),
    s = Math.min(t, n, i)
  let o = 0
  r !== s &&
    (r === t
      ? (o = 60 * (0 + (n - i) / (r - s)))
      : r === n
      ? (o = 60 * (2 + (i - t) / (r - s)))
      : r === i && (o = 60 * (4 + (t - n) / (r - s)))),
    o < 0 && (o = o + 360)
  const a = r === 0 ? 0 : (r - s) / r,
    l = [o, a, r]
  return { h: l[0], s: l[1], v: l[2], a: e.a }
}
function MV(e) {
  const { h: t, s: n, v: i, a: r } = e,
    s = i - (i * n) / 2,
    o = s === 1 || s === 0 ? 0 : (i - s) / Math.min(s, 1 - s)
  return { h: t, s: o, l: s, a: r }
}
function Db(e) {
  const { h: t, s: n, l: i, a: r } = e,
    s = i + n * Math.min(i, 1 - i),
    o = s === 0 ? 0 : 2 - (2 * i) / s
  return { h: t, s: o, v: s, a: r }
}
function LV(e) {
  let { r: t, g: n, b: i, a: r } = e
  return r === void 0 ? `rgb(${t}, ${n}, ${i})` : `rgba(${t}, ${n}, ${i}, ${r})`
}
function FV(e) {
  return LV(Fr(e))
}
function ch(e) {
  const t = Math.round(e).toString(16)
  return ('00'.substr(0, 2 - t.length) + t).toUpperCase()
}
function BV(e) {
  let { r: t, g: n, b: i, a: r } = e
  return `#${[ch(t), ch(n), ch(i), r !== void 0 ? ch(Math.round(r * 255)) : ''].join('')}`
}
function $V(e) {
  e = cK(e)
  let [t, n, i, r] = $G(e, 2).map((s) => parseInt(s, 16))
  return (r = r === void 0 ? r : r / 255), { r: t, g: n, b: i, a: r }
}
function UV(e) {
  const t = $V(e)
  return Cm(t)
}
function jV(e) {
  return BV(Fr(e))
}
function cK(e) {
  return (
    e.startsWith('#') && (e = e.slice(1)),
    (e = e.replace(/([^0-9a-f])/gi, 'F')),
    (e.length === 3 || e.length === 4) &&
      (e = e
        .split('')
        .map((t) => t + t)
        .join('')),
    e.length !== 6 && (e = nT(nT(e, 6), 8, 'F')),
    e
  )
}
function dK(e, t) {
  const n = DV(Vb(e))
  return (n[0] = n[0] + t * 10), OV(NV(n))
}
function hK(e, t) {
  const n = DV(Vb(e))
  return (n[0] = n[0] - t * 10), OV(NV(n))
}
function Bp(e) {
  const t = Ai(e)
  return Vb(t)[1]
}
function fK(e, t) {
  const n = Bp(e),
    i = Bp(t),
    r = Math.max(n, i),
    s = Math.min(n, i)
  return (r + 0.05) / (s + 0.05)
}
function zV(e) {
  const t = Math.abs(pT(Ai(0), Ai(e)))
  return Math.abs(pT(Ai(16777215), Ai(e))) > Math.min(t, 50) ? '#fff' : '#000'
}
function W(e, t) {
  return (n) =>
    Object.keys(e).reduce((i, r) => {
      const o = typeof e[r] == 'object' && e[r] != null && !Array.isArray(e[r]) ? e[r] : { type: e[r] }
      return n && r in n ? (i[r] = { ...o, default: n[r] }) : (i[r] = o), t && !i[r].source && (i[r].source = t), i
    }, {})
}
const Te = W({ class: [String, Array, Object], style: { type: [String, Array, Object], default: null } }, 'component')
function Ut(e, t) {
  const n = $c()
  if (!n) throw new Error(`[Vuetify] ${e} must be called from inside a setup function`)
  return n
}
function pr() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'composables'
  const t = Ut(e).type
  return Ao((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name))
}
let HV = 0,
  xh = new WeakMap()
function pn() {
  const e = Ut('getUid')
  if (xh.has(e)) return xh.get(e)
  {
    const t = HV++
    return xh.set(e, t), t
  }
}
pn.reset = () => {
  ;(HV = 0), (xh = new WeakMap())
}
function mK(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ut('injectSelf')
  const { provides: n } = t
  if (n && e in n) return n[e]
}
const kl = Symbol.for('vuetify:defaults')
function gK(e) {
  return le(e)
}
function Nb() {
  const e = je(kl)
  if (!e) throw new Error('[Vuetify] Could not find defaults instance')
  return e
}
function Ot(e, t) {
  const n = Nb(),
    i = le(e),
    r = k(() => {
      if (Lt(t == null ? void 0 : t.disabled)) return n.value
      const o = Lt(t == null ? void 0 : t.scoped),
        a = Lt(t == null ? void 0 : t.reset),
        l = Lt(t == null ? void 0 : t.root)
      if (i.value == null && !(o || a || l)) return n.value
      let u = Fn(i.value, { prev: n.value })
      if (o) return u
      if (a || l) {
        const c = Number(a || 1 / 0)
        for (let d = 0; d <= c && !(!u || !('prev' in u)); d++) u = u.prev
        return u && typeof l == 'string' && l in u && (u = Fn(Fn(u, { prev: u }), u[l])), u
      }
      return u.prev ? Fn(u.prev, u) : u
    })
  return mt(kl, r), r
}
function vK(e, t) {
  var n, i
  return (
    typeof ((n = e.props) == null ? void 0 : n[t]) < 'u' || typeof ((i = e.props) == null ? void 0 : i[Ao(t)]) < 'u'
  )
}
function pK() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = arguments.length > 1 ? arguments[1] : void 0,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Nb()
  const i = Ut('useDefaults')
  if (((t = t ?? i.type.name ?? i.type.__name), !t)) throw new Error('[Vuetify] Could not determine component name')
  const r = k(() => {
      var l
      return (l = n.value) == null ? void 0 : l[e._as ?? t]
    }),
    s = new Proxy(e, {
      get(l, u) {
        var d, f, m, p, v, y, T
        const c = Reflect.get(l, u)
        return u === 'class' || u === 'style'
          ? [(d = r.value) == null ? void 0 : d[u], c].filter((A) => A != null)
          : typeof u == 'string' && !vK(i.vnode, u)
          ? ((f = r.value) == null ? void 0 : f[u]) !== void 0
            ? (m = r.value) == null
              ? void 0
              : m[u]
            : ((v = (p = n.value) == null ? void 0 : p.global) == null ? void 0 : v[u]) !== void 0
            ? (T = (y = n.value) == null ? void 0 : y.global) == null
              ? void 0
              : T[u]
            : c
          : c
      },
    }),
    o = ye()
  $t(() => {
    if (r.value) {
      const l = Object.entries(r.value).filter((u) => {
        let [c] = u
        return c.startsWith(c[0].toUpperCase())
      })
      o.value = l.length ? Object.fromEntries(l) : void 0
    } else o.value = void 0
  })
  function a() {
    const l = mK(kl, i)
    mt(
      kl,
      k(() => (o.value ? Fn((l == null ? void 0 : l.value) ?? {}, o.value) : l == null ? void 0 : l.value))
    )
  }
  return { props: s, provideSubDefaults: a }
}
function yi(e) {
  if (((e._setup = e._setup ?? e.setup), !e.name)) return e
  if (e._setup) {
    e.props = W(e.props ?? {}, e.name)()
    const t = Object.keys(e.props).filter((n) => n !== 'class' && n !== 'style')
    ;(e.filterProps = function (i) {
      return kb(i, t)
    }),
      (e.props._as = String),
      (e.setup = function (i, r) {
        const s = Nb()
        if (!s.value) return e._setup(i, r)
        const { props: o, provideSubDefaults: a } = pK(i, i._as ?? e.name, s),
          l = e._setup(o, r)
        return a(), l
      })
  }
  return e
}
function ne() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0
  return (t) => (e ? yi : Of)(t)
}
function yK(e, t) {
  return (t.props = e), t
}
function yr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'div',
    n = arguments.length > 2 ? arguments[2] : void 0
  return ne()({
    name: n ?? gr(gi(e.replace(/__/g, '-'))),
    props: { tag: { type: String, default: t }, ...Te() },
    setup(i, r) {
      let { slots: s } = r
      return () => {
        var o
        return Yi(i.tag, { class: [e, i.class], style: i.style }, (o = s.default) == null ? void 0 : o.call(s))
      }
    },
  })
}
function WV(e) {
  if (typeof e.getRootNode != 'function') {
    for (; e.parentNode; ) e = e.parentNode
    return e !== document ? null : document
  }
  const t = e.getRootNode()
  return t !== document && t.getRootNode({ composed: !0 }) !== document ? null : t
}
const Tc = 'cubic-bezier(0.4, 0, 0.2, 1)',
  _K = 'cubic-bezier(0.0, 0, 0.2, 1)',
  bK = 'cubic-bezier(0.4, 0, 1, 1)'
function bT(e, t, n) {
  return Object.keys(e)
    .filter((i) => Em(i) && i.endsWith(t))
    .reduce((i, r) => ((i[r.slice(0, -t.length)] = (s) => e[r](s, n(s))), i), {})
}
function Ob(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
  for (; e; ) {
    if (t ? wK(e) : Mb(e)) return e
    e = e.parentElement
  }
  return document.scrollingElement
}
function Sf(e, t) {
  const n = []
  if (t && e && !t.contains(e)) return n
  for (; e && (Mb(e) && n.push(e), e !== t); ) e = e.parentElement
  return n
}
function Mb(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1
  const t = window.getComputedStyle(e)
  return t.overflowY === 'scroll' || (t.overflowY === 'auto' && e.scrollHeight > e.clientHeight)
}
function wK(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1
  const t = window.getComputedStyle(e)
  return ['scroll', 'auto'].includes(t.overflowY)
}
function IK(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === 'fixed') return !0
    e = e.offsetParent
  }
  return !1
}
function se(e) {
  const t = Ut('useRender')
  t.render = e
}
function xe(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d,
    r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d
  const s = Ut('useProxiedModel'),
    o = le(e[t] !== void 0 ? e[t] : n),
    a = Ao(t),
    u = k(
      a !== t
        ? () => {
            var d, f, m, p
            return (
              e[t],
              !!(
                (((d = s.vnode.props) != null && d.hasOwnProperty(t)) ||
                  ((f = s.vnode.props) != null && f.hasOwnProperty(a))) &&
                (((m = s.vnode.props) != null && m.hasOwnProperty(`onUpdate:${t}`)) ||
                  ((p = s.vnode.props) != null && p.hasOwnProperty(`onUpdate:${a}`)))
              )
            )
          }
        : () => {
            var d, f
            return (
              e[t],
              !!(
                (d = s.vnode.props) != null &&
                d.hasOwnProperty(t) &&
                (f = s.vnode.props) != null &&
                f.hasOwnProperty(`onUpdate:${t}`)
              )
            )
          }
    )
  ii(
    () => !u.value,
    () => {
      be(
        () => e[t],
        (d) => {
          o.value = d
        }
      )
    }
  )
  const c = k({
    get() {
      const d = e[t]
      return i(u.value ? d : o.value)
    },
    set(d) {
      const f = r(d),
        m = ze(u.value ? e[t] : o.value)
      m === f || i(m) === d || ((o.value = f), s == null || s.emit(`update:${t}`, f))
    },
  })
  return Object.defineProperty(c, 'externalValue', { get: () => (u.value ? e[t] : o.value) }), c
}
const SK = {
    badge: 'Badge',
    open: 'Open',
    close: 'Close',
    dismiss: 'Dismiss',
    confirmEdit: { ok: 'OK', cancel: 'Cancel' },
    dataIterator: { noResultsText: 'No matching records found', loadingText: 'Loading items...' },
    dataTable: {
      itemsPerPageText: 'Rows per page:',
      ariaLabel: {
        sortDescending: 'Sorted descending.',
        sortAscending: 'Sorted ascending.',
        sortNone: 'Not sorted.',
        activateNone: 'Activate to remove sorting.',
        activateDescending: 'Activate to sort descending.',
        activateAscending: 'Activate to sort ascending.',
      },
      sortBy: 'Sort by',
    },
    dataFooter: {
      itemsPerPageText: 'Items per page:',
      itemsPerPageAll: 'All',
      nextPage: 'Next page',
      prevPage: 'Previous page',
      firstPage: 'First page',
      lastPage: 'Last page',
      pageText: '{0}-{1} of {2}',
    },
    dateRangeInput: { divider: 'to' },
    datePicker: {
      itemsSelected: '{0} selected',
      range: { title: 'Select dates', header: 'Enter dates' },
      title: 'Select date',
      header: 'Enter date',
      input: { placeholder: 'Enter date' },
    },
    noDataText: 'No data available',
    carousel: { prev: 'Previous visual', next: 'Next visual', ariaLabel: { delimiter: 'Carousel slide {0} of {1}' } },
    calendar: { moreEvents: '{0} more', today: 'Today' },
    input: {
      clear: 'Clear {0}',
      prependAction: '{0} prepended action',
      appendAction: '{0} appended action',
      otp: 'Please enter OTP character {0}',
    },
    fileInput: { counter: '{0} files', counterSize: '{0} files ({1} in total)' },
    timePicker: { am: 'AM', pm: 'PM', title: 'Select Time' },
    pagination: {
      ariaLabel: {
        root: 'Pagination Navigation',
        next: 'Next page',
        previous: 'Previous page',
        page: 'Go to page {0}',
        currentPage: 'Page {0}, Current page',
        first: 'First page',
        last: 'Last page',
      },
    },
    stepper: { next: 'Next', prev: 'Previous' },
    rating: { ariaLabel: { item: 'Rating {0} of {1}' } },
    loading: 'Loading...',
    infiniteScroll: { loadMore: 'Load more', empty: 'No more' },
  },
  wT = '$vuetify.',
  IT = (e, t) => e.replace(/\{(\d+)\}/g, (n, i) => String(t[+i])),
  qV = (e, t, n) =>
    function (i) {
      for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) s[o - 1] = arguments[o]
      if (!i.startsWith(wT)) return IT(i, s)
      const a = i.replace(wT, ''),
        l = e.value && n.value[e.value],
        u = t.value && n.value[t.value]
      let c = Go(l, a, null)
      return c || (`${i}${e.value}`, (c = Go(u, a, null))), c || (c = i), typeof c != 'string' && (c = i), IT(c, s)
    }
function GV(e, t) {
  return (n, i) => new Intl.NumberFormat([e.value, t.value], i).format(n)
}
function av(e, t, n) {
  const i = xe(e, t, e[t] ?? n.value)
  return (
    (i.value = e[t] ?? n.value),
    be(n, (r) => {
      e[t] == null && (i.value = n.value)
    }),
    i
  )
}
function KV(e) {
  return (t) => {
    const n = av(t, 'locale', e.current),
      i = av(t, 'fallback', e.fallback),
      r = av(t, 'messages', e.messages)
    return {
      name: 'vuetify',
      current: n,
      fallback: i,
      messages: r,
      t: qV(n, i, r),
      n: GV(n, i),
      provide: KV({ current: n, fallback: i, messages: r }),
    }
  }
}
function EK(e) {
  const t = ye((e == null ? void 0 : e.locale) ?? 'en'),
    n = ye((e == null ? void 0 : e.fallback) ?? 'en'),
    i = le({ en: SK, ...(e == null ? void 0 : e.messages) })
  return {
    name: 'vuetify',
    current: t,
    fallback: n,
    messages: i,
    t: qV(t, n, i),
    n: GV(t, n),
    provide: KV({ current: t, fallback: n, messages: i }),
  }
}
const Pl = Symbol.for('vuetify:locale')
function TK(e) {
  return e.name != null
}
function CK(e) {
  const t = e != null && e.adapter && TK(e == null ? void 0 : e.adapter) ? (e == null ? void 0 : e.adapter) : EK(e),
    n = PK(t, e)
  return { ...t, ...n }
}
function jt() {
  const e = je(Pl)
  if (!e) throw new Error('[Vuetify] Could not find injected locale instance')
  return e
}
function AK(e) {
  const t = je(Pl)
  if (!t) throw new Error('[Vuetify] Could not find injected locale instance')
  const n = t.provide(e),
    i = RK(n, t.rtl, e),
    r = { ...n, ...i }
  return mt(Pl, r), r
}
function kK() {
  return {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    km: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1,
  }
}
function PK(e, t) {
  const n = le((t == null ? void 0 : t.rtl) ?? kK()),
    i = k(() => n.value[e.current.value] ?? !1)
  return { isRtl: i, rtl: n, rtlClasses: k(() => `v-locale--is-${i.value ? 'rtl' : 'ltr'}`) }
}
function RK(e, t, n) {
  const i = k(() => n.rtl ?? t.value[e.current.value] ?? !1)
  return { isRtl: i, rtl: t, rtlClasses: k(() => `v-locale--is-${i.value ? 'rtl' : 'ltr'}`) }
}
function sn() {
  const e = je(Pl)
  if (!e) throw new Error('[Vuetify] Could not find injected rtl instance')
  return { isRtl: e.isRtl, rtlClasses: e.rtlClasses }
}
const Am = {
  '001': 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  'GB-alt-variant': 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0,
}
function xK(e, t, n) {
  const i = []
  let r = []
  const s = YV(e),
    o = QV(e),
    a = n ?? Am[t.slice(-2).toUpperCase()] ?? 0,
    l = (s.getDay() - a + 7) % 7,
    u = (o.getDay() - a + 7) % 7
  for (let c = 0; c < l; c++) {
    const d = new Date(s)
    d.setDate(d.getDate() - (l - c)), r.push(d)
  }
  for (let c = 1; c <= o.getDate(); c++) {
    const d = new Date(e.getFullYear(), e.getMonth(), c)
    r.push(d), r.length === 7 && (i.push(r), (r = []))
  }
  for (let c = 1; c < 7 - u; c++) {
    const d = new Date(o)
    d.setDate(d.getDate() + c), r.push(d)
  }
  return r.length > 0 && i.push(r), i
}
function VK(e, t, n) {
  const i = n ?? Am[t.slice(-2).toUpperCase()] ?? 0,
    r = new Date(e)
  for (; r.getDay() !== i; ) r.setDate(r.getDate() - 1)
  return r
}
function DK(e, t) {
  const n = new Date(e),
    i = ((Am[t.slice(-2).toUpperCase()] ?? 0) + 6) % 7
  for (; n.getDay() !== i; ) n.setDate(n.getDate() + 1)
  return n
}
function YV(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1)
}
function QV(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0)
}
function NK(e) {
  const t = e.split('-').map(Number)
  return new Date(t[0], t[1] - 1, t[2])
}
const OK = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/
function XV(e) {
  if (e == null) return new Date()
  if (e instanceof Date) return e
  if (typeof e == 'string') {
    let t
    if (OK.test(e)) return NK(e)
    if (((t = Date.parse(e)), !isNaN(t))) return new Date(t)
  }
  return null
}
const ST = new Date(2e3, 0, 2)
function MK(e, t) {
  const n = t ?? Am[e.slice(-2).toUpperCase()] ?? 0
  return ar(7).map((i) => {
    const r = new Date(ST)
    return r.setDate(ST.getDate() + n + i), new Intl.DateTimeFormat(e, { weekday: 'narrow' }).format(r)
  })
}
function LK(e, t, n, i) {
  const r = XV(e) ?? new Date(),
    s = i == null ? void 0 : i[t]
  if (typeof s == 'function') return s(r, t, n)
  let o = {}
  switch (t) {
    case 'fullDate':
      o = { year: 'numeric', month: 'long', day: 'numeric' }
      break
    case 'fullDateWithWeekday':
      o = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }
      break
    case 'normalDate':
      const a = r.getDate(),
        l = new Intl.DateTimeFormat(n, { month: 'long' }).format(r)
      return `${a} ${l}`
    case 'normalDateWithWeekday':
      o = { weekday: 'short', day: 'numeric', month: 'short' }
      break
    case 'shortDate':
      o = { month: 'short', day: 'numeric' }
      break
    case 'year':
      o = { year: 'numeric' }
      break
    case 'month':
      o = { month: 'long' }
      break
    case 'monthShort':
      o = { month: 'short' }
      break
    case 'monthAndYear':
      o = { month: 'long', year: 'numeric' }
      break
    case 'monthAndDate':
      o = { month: 'long', day: 'numeric' }
      break
    case 'weekday':
      o = { weekday: 'long' }
      break
    case 'weekdayShort':
      o = { weekday: 'short' }
      break
    case 'dayOfMonth':
      return new Intl.NumberFormat(n).format(r.getDate())
    case 'hours12h':
      o = { hour: 'numeric', hour12: !0 }
      break
    case 'hours24h':
      o = { hour: 'numeric', hour12: !1 }
      break
    case 'minutes':
      o = { minute: 'numeric' }
      break
    case 'seconds':
      o = { second: 'numeric' }
      break
    case 'fullTime':
      o = { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: !0 }
      break
    case 'fullTime12h':
      o = { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: !0 }
      break
    case 'fullTime24h':
      o = { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: !1 }
      break
    case 'fullDateTime':
      o = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: !0,
      }
      break
    case 'fullDateTime12h':
      o = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: !0,
      }
      break
    case 'fullDateTime24h':
      o = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: !1,
      }
      break
    case 'keyboardDate':
      o = { year: 'numeric', month: '2-digit', day: '2-digit' }
      break
    case 'keyboardDateTime':
      o = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: !1,
      }
      break
    case 'keyboardDateTime12h':
      o = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: !0,
      }
      break
    case 'keyboardDateTime24h':
      o = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: !1,
      }
      break
    default:
      o = s ?? { timeZone: 'UTC', timeZoneName: 'short' }
  }
  return new Intl.DateTimeFormat(n, o).format(r)
}
function FK(e, t) {
  const n = e.toJsDate(t),
    i = n.getFullYear(),
    r = iT(String(n.getMonth() + 1), 2, '0'),
    s = iT(String(n.getDate()), 2, '0')
  return `${i}-${r}-${s}`
}
function BK(e) {
  const [t, n, i] = e.split('-').map(Number)
  return new Date(t, n - 1, i)
}
function $K(e, t) {
  const n = new Date(e)
  return n.setMinutes(n.getMinutes() + t), n
}
function UK(e, t) {
  const n = new Date(e)
  return n.setHours(n.getHours() + t), n
}
function jK(e, t) {
  const n = new Date(e)
  return n.setDate(n.getDate() + t), n
}
function zK(e, t) {
  const n = new Date(e)
  return n.setDate(n.getDate() + t * 7), n
}
function HK(e, t) {
  const n = new Date(e)
  return n.setDate(1), n.setMonth(n.getMonth() + t), n
}
function WK(e) {
  return e.getFullYear()
}
function qK(e) {
  return e.getMonth()
}
function GK(e) {
  return e.getDate()
}
function KK(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 1)
}
function YK(e) {
  return new Date(e.getFullYear(), e.getMonth() - 1, 1)
}
function QK(e) {
  return e.getHours()
}
function XK(e) {
  return e.getMinutes()
}
function JK(e) {
  return new Date(e.getFullYear(), 0, 1)
}
function ZK(e) {
  return new Date(e.getFullYear(), 11, 31)
}
function e7(e, t) {
  return Ef(e, t[0]) && i7(e, t[1])
}
function t7(e) {
  const t = new Date(e)
  return t instanceof Date && !isNaN(t.getTime())
}
function Ef(e, t) {
  return e.getTime() > t.getTime()
}
function n7(e, t) {
  return Ef($p(e), $p(t))
}
function i7(e, t) {
  return e.getTime() < t.getTime()
}
function ET(e, t) {
  return e.getTime() === t.getTime()
}
function r7(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear()
}
function s7(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear()
}
function o7(e, t) {
  return e.getFullYear() === t.getFullYear()
}
function a7(e, t, n) {
  const i = new Date(e),
    r = new Date(t)
  switch (n) {
    case 'years':
      return i.getFullYear() - r.getFullYear()
    case 'quarters':
      return Math.floor((i.getMonth() - r.getMonth() + (i.getFullYear() - r.getFullYear()) * 12) / 4)
    case 'months':
      return i.getMonth() - r.getMonth() + (i.getFullYear() - r.getFullYear()) * 12
    case 'weeks':
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60 * 24 * 7))
    case 'days':
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60 * 24))
    case 'hours':
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60 * 60))
    case 'minutes':
      return Math.floor((i.getTime() - r.getTime()) / (1e3 * 60))
    case 'seconds':
      return Math.floor((i.getTime() - r.getTime()) / 1e3)
    default:
      return i.getTime() - r.getTime()
  }
}
function l7(e, t) {
  const n = new Date(e)
  return n.setHours(t), n
}
function u7(e, t) {
  const n = new Date(e)
  return n.setMinutes(t), n
}
function c7(e, t) {
  const n = new Date(e)
  return n.setMonth(t), n
}
function d7(e, t) {
  const n = new Date(e)
  return n.setDate(t), n
}
function h7(e, t) {
  const n = new Date(e)
  return n.setFullYear(t), n
}
function $p(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0)
}
function f7(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999)
}
class m7 {
  constructor(t) {
    ;(this.locale = t.locale), (this.formats = t.formats)
  }
  date(t) {
    return XV(t)
  }
  toJsDate(t) {
    return t
  }
  toISO(t) {
    return FK(this, t)
  }
  parseISO(t) {
    return BK(t)
  }
  addMinutes(t, n) {
    return $K(t, n)
  }
  addHours(t, n) {
    return UK(t, n)
  }
  addDays(t, n) {
    return jK(t, n)
  }
  addWeeks(t, n) {
    return zK(t, n)
  }
  addMonths(t, n) {
    return HK(t, n)
  }
  getWeekArray(t, n) {
    return xK(t, this.locale, n ? Number(n) : void 0)
  }
  startOfWeek(t, n) {
    return VK(t, this.locale, n ? Number(n) : void 0)
  }
  endOfWeek(t) {
    return DK(t, this.locale)
  }
  startOfMonth(t) {
    return YV(t)
  }
  endOfMonth(t) {
    return QV(t)
  }
  format(t, n) {
    return LK(t, n, this.locale, this.formats)
  }
  isEqual(t, n) {
    return ET(t, n)
  }
  isValid(t) {
    return t7(t)
  }
  isWithinRange(t, n) {
    return e7(t, n)
  }
  isAfter(t, n) {
    return Ef(t, n)
  }
  isAfterDay(t, n) {
    return n7(t, n)
  }
  isBefore(t, n) {
    return !Ef(t, n) && !ET(t, n)
  }
  isSameDay(t, n) {
    return r7(t, n)
  }
  isSameMonth(t, n) {
    return s7(t, n)
  }
  isSameYear(t, n) {
    return o7(t, n)
  }
  setMinutes(t, n) {
    return u7(t, n)
  }
  setHours(t, n) {
    return l7(t, n)
  }
  setMonth(t, n) {
    return c7(t, n)
  }
  setDate(t, n) {
    return d7(t, n)
  }
  setYear(t, n) {
    return h7(t, n)
  }
  getDiff(t, n, i) {
    return a7(t, n, i)
  }
  getWeekdays(t) {
    return MK(this.locale, t ? Number(t) : void 0)
  }
  getYear(t) {
    return WK(t)
  }
  getMonth(t) {
    return qK(t)
  }
  getDate(t) {
    return GK(t)
  }
  getNextMonth(t) {
    return KK(t)
  }
  getPreviousMonth(t) {
    return YK(t)
  }
  getHours(t) {
    return QK(t)
  }
  getMinutes(t) {
    return XK(t)
  }
  startOfDay(t) {
    return $p(t)
  }
  endOfDay(t) {
    return f7(t)
  }
  startOfYear(t) {
    return JK(t)
  }
  endOfYear(t) {
    return ZK(t)
  }
}
const JV = Symbol.for('vuetify:date-options'),
  TT = Symbol.for('vuetify:date-adapter')
function g7(e, t) {
  const n = Fn(
    {
      adapter: m7,
      locale: {
        af: 'af-ZA',
        bg: 'bg-BG',
        ca: 'ca-ES',
        ckb: '',
        cs: 'cs-CZ',
        de: 'de-DE',
        el: 'el-GR',
        en: 'en-US',
        et: 'et-EE',
        fa: 'fa-IR',
        fi: 'fi-FI',
        hr: 'hr-HR',
        hu: 'hu-HU',
        he: 'he-IL',
        id: 'id-ID',
        it: 'it-IT',
        ja: 'ja-JP',
        ko: 'ko-KR',
        lv: 'lv-LV',
        lt: 'lt-LT',
        nl: 'nl-NL',
        no: 'no-NO',
        pl: 'pl-PL',
        pt: 'pt-PT',
        ro: 'ro-RO',
        ru: 'ru-RU',
        sk: 'sk-SK',
        sl: 'sl-SI',
        srCyrl: 'sr-SP',
        srLatn: 'sr-SP',
        sv: 'sv-SE',
        th: 'th-TH',
        tr: 'tr-TR',
        az: 'az-AZ',
        uk: 'uk-UA',
        vi: 'vi-VN',
        zhHans: 'zh-CN',
        zhHant: 'zh-TW',
      },
    },
    e
  )
  return { options: n, instance: ZV(n, t) }
}
function ZV(e, t) {
  const n = wn(
    typeof e.adapter == 'function'
      ? new e.adapter({ locale: e.locale[t.current.value] ?? t.current.value, formats: e.formats })
      : e.adapter
  )
  return (
    be(t.current, (i) => {
      n.locale = e.locale[i] ?? i ?? n.locale
    }),
    n
  )
}
function ad() {
  const e = je(JV)
  if (!e) throw new Error('[Vuetify] Could not find injected date options')
  const t = jt()
  return ZV(e, t)
}
function v7(e, t) {
  const n = e.toJsDate(t)
  let i = n.getFullYear(),
    r = new Date(i, 0, 1)
  if (n < r) (i = i - 1), (r = new Date(i, 0, 1))
  else {
    const a = new Date(i + 1, 0, 1)
    n >= a && ((i = i + 1), (r = a))
  }
  const s = Math.abs(n.getTime() - r.getTime()),
    o = Math.ceil(s / (1e3 * 60 * 60 * 24))
  return Math.floor(o / 7) + 1
}
const km = ['sm', 'md', 'lg', 'xl', 'xxl'],
  Up = Symbol.for('vuetify:display'),
  CT = { mobileBreakpoint: 'lg', thresholds: { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920, xxl: 2560 } },
  p7 = function () {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : CT
    return Fn(CT, e)
  }
function AT(e) {
  return ct && !e ? window.innerWidth : (typeof e == 'object' && e.clientWidth) || 0
}
function kT(e) {
  return ct && !e ? window.innerHeight : (typeof e == 'object' && e.clientHeight) || 0
}
function PT(e) {
  const t = ct && !e ? window.navigator.userAgent : 'ssr'
  function n(p) {
    return !!t.match(p)
  }
  const i = n(/android/i),
    r = n(/iphone|ipad|ipod/i),
    s = n(/cordova/i),
    o = n(/electron/i),
    a = n(/chrome/i),
    l = n(/edge/i),
    u = n(/firefox/i),
    c = n(/opera/i),
    d = n(/win/i),
    f = n(/mac/i),
    m = n(/linux/i)
  return {
    android: i,
    ios: r,
    cordova: s,
    electron: o,
    chrome: a,
    edge: l,
    firefox: u,
    opera: c,
    win: d,
    mac: f,
    linux: m,
    touch: DG,
    ssr: t === 'ssr',
  }
}
function y7(e, t) {
  const { thresholds: n, mobileBreakpoint: i } = p7(e),
    r = ye(kT(t)),
    s = ye(PT(t)),
    o = wn({}),
    a = ye(AT(t))
  function l() {
    ;(r.value = kT()), (a.value = AT())
  }
  function u() {
    l(), (s.value = PT())
  }
  return (
    $t(() => {
      const c = a.value < n.sm,
        d = a.value < n.md && !c,
        f = a.value < n.lg && !(d || c),
        m = a.value < n.xl && !(f || d || c),
        p = a.value < n.xxl && !(m || f || d || c),
        v = a.value >= n.xxl,
        y = c ? 'xs' : d ? 'sm' : f ? 'md' : m ? 'lg' : p ? 'xl' : 'xxl',
        T = typeof i == 'number' ? i : n[i],
        A = a.value < T
      ;(o.xs = c),
        (o.sm = d),
        (o.md = f),
        (o.lg = m),
        (o.xl = p),
        (o.xxl = v),
        (o.smAndUp = !c),
        (o.mdAndUp = !(c || d)),
        (o.lgAndUp = !(c || d || f)),
        (o.xlAndUp = !(c || d || f || m)),
        (o.smAndDown = !(f || m || p || v)),
        (o.mdAndDown = !(m || p || v)),
        (o.lgAndDown = !(p || v)),
        (o.xlAndDown = !v),
        (o.name = y),
        (o.height = r.value),
        (o.width = a.value),
        (o.mobile = A),
        (o.mobileBreakpoint = i),
        (o.platform = s.value),
        (o.thresholds = n)
    }),
    ct && window.addEventListener('resize', l, { passive: !0 }),
    { ...js(o), update: u, ssr: !!t }
  )
}
const ca = W({ mobile: { type: Boolean, default: !1 }, mobileBreakpoint: [Number, String] }, 'display')
function Ni() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  const n = je(Up)
  if (!n) throw new Error('Could not find Vuetify display injection')
  const i = k(() => {
      if (e.mobile != null) return e.mobile
      if (!e.mobileBreakpoint) return n.mobile.value
      const s = typeof e.mobileBreakpoint == 'number' ? e.mobileBreakpoint : n.thresholds.value[e.mobileBreakpoint]
      return n.width.value < s
    }),
    r = k(() => (t ? { [`${t}--mobile`]: i.value } : {}))
  return { ...n, displayClasses: r, mobile: i }
}
const eD = Symbol.for('vuetify:goto')
function tD() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: 'easeInOutCubic',
    patterns: {
      linear: (e) => e,
      easeInQuad: (e) => e ** 2,
      easeOutQuad: (e) => e * (2 - e),
      easeInOutQuad: (e) => (e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e),
      easeInCubic: (e) => e ** 3,
      easeOutCubic: (e) => (--e) ** 3 + 1,
      easeInOutCubic: (e) => (e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1),
      easeInQuart: (e) => e ** 4,
      easeOutQuart: (e) => 1 - (--e) ** 4,
      easeInOutQuart: (e) => (e < 0.5 ? 8 * e ** 4 : 1 - 8 * (--e) ** 4),
      easeInQuint: (e) => e ** 5,
      easeOutQuint: (e) => 1 + (--e) ** 5,
      easeInOutQuint: (e) => (e < 0.5 ? 16 * e ** 5 : 1 + 16 * (--e) ** 5),
    },
  }
}
function _7(e) {
  return Lb(e) ?? (document.scrollingElement || document.body)
}
function Lb(e) {
  return typeof e == 'string' ? document.querySelector(e) : Ab(e)
}
function lv(e, t, n) {
  if (typeof e == 'number') return t && n ? -e : e
  let i = Lb(e),
    r = 0
  for (; i; ) (r += t ? i.offsetLeft : i.offsetTop), (i = i.offsetParent)
  return r
}
function b7(e, t) {
  return { rtl: t.isRtl, options: Fn(tD(), e) }
}
async function RT(e, t, n, i) {
  const r = n ? 'scrollLeft' : 'scrollTop',
    s = Fn((i == null ? void 0 : i.options) ?? tD(), t),
    o = i == null ? void 0 : i.rtl.value,
    a = (typeof e == 'number' ? e : Lb(e)) ?? 0,
    l = s.container === 'parent' && a instanceof HTMLElement ? a.parentElement : _7(s.container),
    u = typeof s.easing == 'function' ? s.easing : s.patterns[s.easing]
  if (!u) throw new TypeError(`Easing function "${s.easing}" not found.`)
  let c
  if (typeof a == 'number') c = lv(a, n, o)
  else if (((c = lv(a, n, o) - lv(l, n, o)), s.layout)) {
    const p = window.getComputedStyle(a).getPropertyValue('--v-layout-top')
    p && (c -= parseInt(p, 10))
  }
  ;(c += s.offset), (c = I7(l, c, !!o, !!n))
  const d = l[r] ?? 0
  if (c === d) return Promise.resolve(c)
  const f = performance.now()
  return new Promise((m) =>
    requestAnimationFrame(function p(v) {
      const T = (v - f) / s.duration,
        A = Math.floor(d + (c - d) * u(qt(T, 0, 1)))
      if (((l[r] = A), T >= 1 && Math.abs(A - l[r]) < 10)) return m(c)
      if (T > 2) return m(l[r])
      requestAnimationFrame(p)
    })
  )
}
function w7() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const t = je(eD),
    { isRtl: n } = sn()
  if (!t) throw new Error('[Vuetify] Could not find injected goto instance')
  const i = { ...t, rtl: k(() => t.rtl.value || n.value) }
  async function r(s, o) {
    return RT(s, Fn(e, o), !1, i)
  }
  return (r.horizontal = async (s, o) => RT(s, Fn(e, o), !0, i)), r
}
function I7(e, t, n, i) {
  const { scrollWidth: r, scrollHeight: s } = e,
    [o, a] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight]
  let l, u
  return (
    i ? (n ? ((l = -(r - o)), (u = 0)) : ((l = 0), (u = r - o))) : ((l = 0), (u = s + -a)), Math.max(Math.min(t, u), l)
  )
}
const S7 = {
    collapse: 'mdi-chevron-up',
    complete: 'mdi-check',
    cancel: 'mdi-close-circle',
    close: 'mdi-close',
    delete: 'mdi-close-circle',
    clear: 'mdi-close-circle',
    success: 'mdi-check-circle',
    info: 'mdi-information',
    warning: 'mdi-alert-circle',
    error: 'mdi-close-circle',
    prev: 'mdi-chevron-left',
    next: 'mdi-chevron-right',
    checkboxOn: 'mdi-checkbox-marked',
    checkboxOff: 'mdi-checkbox-blank-outline',
    checkboxIndeterminate: 'mdi-minus-box',
    delimiter: 'mdi-circle',
    sortAsc: 'mdi-arrow-up',
    sortDesc: 'mdi-arrow-down',
    expand: 'mdi-chevron-down',
    menu: 'mdi-menu',
    subgroup: 'mdi-menu-down',
    dropdown: 'mdi-menu-down',
    radioOn: 'mdi-radiobox-marked',
    radioOff: 'mdi-radiobox-blank',
    edit: 'mdi-pencil',
    ratingEmpty: 'mdi-star-outline',
    ratingFull: 'mdi-star',
    ratingHalf: 'mdi-star-half-full',
    loading: 'mdi-cached',
    first: 'mdi-page-first',
    last: 'mdi-page-last',
    unfold: 'mdi-unfold-more-horizontal',
    file: 'mdi-paperclip',
    plus: 'mdi-plus',
    minus: 'mdi-minus',
    calendar: 'mdi-calendar',
    treeviewCollapse: 'mdi-menu-down',
    treeviewExpand: 'mdi-menu-right',
    eyeDropper: 'mdi-eyedropper',
  },
  E7 = { component: (e) => Yi(Rm, { ...e, class: 'mdi' }) },
  Le = [String, Function, Object, Array],
  jp = Symbol.for('vuetify:icons'),
  Pm = W({ icon: { type: Le }, tag: { type: String, required: !0 } }, 'icon'),
  zp = ne()({
    name: 'VComponentIcon',
    props: Pm(),
    setup(e, t) {
      let { slots: n } = t
      return () => {
        const i = e.icon
        return g(e.tag, null, {
          default: () => {
            var r
            return [e.icon ? g(i, null, null) : (r = n.default) == null ? void 0 : r.call(n)]
          },
        })
      }
    },
  }),
  Fb = yi({
    name: 'VSvgIcon',
    inheritAttrs: !1,
    props: Pm(),
    setup(e, t) {
      let { attrs: n } = t
      return () =>
        g(e.tag, ae(n, { style: null }), {
          default: () => [
            g(
              'svg',
              {
                class: 'v-icon__svg',
                xmlns: 'http://www.w3.org/2000/svg',
                viewBox: '0 0 24 24',
                role: 'img',
                'aria-hidden': 'true',
              },
              [
                Array.isArray(e.icon)
                  ? e.icon.map((i) =>
                      Array.isArray(i) ? g('path', { d: i[0], 'fill-opacity': i[1] }, null) : g('path', { d: i }, null)
                    )
                  : g('path', { d: e.icon }, null),
              ]
            ),
          ],
        })
    },
  }),
  T7 = yi({
    name: 'VLigatureIcon',
    props: Pm(),
    setup(e) {
      return () => g(e.tag, null, { default: () => [e.icon] })
    },
  }),
  Rm = yi({
    name: 'VClassIcon',
    props: Pm(),
    setup(e) {
      return () => g(e.tag, { class: e.icon }, null)
    },
  })
function C7() {
  return { svg: { component: Fb }, class: { component: Rm } }
}
function A7(e) {
  const t = C7(),
    n = (e == null ? void 0 : e.defaultSet) ?? 'mdi'
  return (
    n === 'mdi' && !t.mdi && (t.mdi = E7),
    Fn(
      {
        defaultSet: n,
        sets: t,
        aliases: {
          ...S7,
          vuetify: [
            'M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z',
            ['M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z', 0.6],
          ],
          'vuetify-outline':
            'svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z',
          'vuetify-play': [
            'm6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z',
            [
              'M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z',
              0.6,
            ],
          ],
        },
      },
      e
    )
  )
}
const k7 = (e) => {
    const t = je(jp)
    if (!t) throw new Error('Missing Vuetify Icons provide!')
    return {
      iconData: k(() => {
        var l
        const i = Lt(e)
        if (!i) return { component: zp }
        let r = i
        if (
          (typeof r == 'string' &&
            ((r = r.trim()), r.startsWith('$') && (r = (l = t.aliases) == null ? void 0 : l[r.slice(1)])),
          Array.isArray(r))
        )
          return { component: Fb, icon: r }
        if (typeof r != 'string') return { component: zp, icon: r }
        const s = Object.keys(t.sets).find((u) => typeof r == 'string' && r.startsWith(`${u}:`)),
          o = s ? r.slice(s.length + 1) : r
        return { component: t.sets[s ?? t.defaultSet].component, icon: o }
      }),
    }
  },
  Cc = Symbol.for('vuetify:theme'),
  Ze = W({ theme: String }, 'theme')
function xT() {
  return {
    defaultTheme: 'light',
    variations: { colors: [], lighten: 0, darken: 0 },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: '#FFFFFF',
          surface: '#FFFFFF',
          'surface-bright': '#FFFFFF',
          'surface-light': '#EEEEEE',
          'surface-variant': '#424242',
          'on-surface-variant': '#EEEEEE',
          primary: '#1867C0',
          'primary-darken-1': '#1F5592',
          secondary: '#48A9A6',
          'secondary-darken-1': '#018786',
          error: '#B00020',
          info: '#2196F3',
          success: '#4CAF50',
          warning: '#FB8C00',
        },
        variables: {
          'border-color': '#000000',
          'border-opacity': 0.12,
          'high-emphasis-opacity': 0.87,
          'medium-emphasis-opacity': 0.6,
          'disabled-opacity': 0.38,
          'idle-opacity': 0.04,
          'hover-opacity': 0.04,
          'focus-opacity': 0.12,
          'selected-opacity': 0.08,
          'activated-opacity': 0.12,
          'pressed-opacity': 0.12,
          'dragged-opacity': 0.08,
          'theme-kbd': '#212529',
          'theme-on-kbd': '#FFFFFF',
          'theme-code': '#F5F5F5',
          'theme-on-code': '#000000',
        },
      },
      dark: {
        dark: !0,
        colors: {
          background: '#121212',
          surface: '#212121',
          'surface-bright': '#ccbfd6',
          'surface-light': '#424242',
          'surface-variant': '#a3a3a3',
          'on-surface-variant': '#424242',
          primary: '#2196F3',
          'primary-darken-1': '#277CC1',
          secondary: '#54B6B2',
          'secondary-darken-1': '#48A9A6',
          error: '#CF6679',
          info: '#2196F3',
          success: '#4CAF50',
          warning: '#FB8C00',
        },
        variables: {
          'border-color': '#FFFFFF',
          'border-opacity': 0.12,
          'high-emphasis-opacity': 1,
          'medium-emphasis-opacity': 0.7,
          'disabled-opacity': 0.5,
          'idle-opacity': 0.1,
          'hover-opacity': 0.04,
          'focus-opacity': 0.12,
          'selected-opacity': 0.08,
          'activated-opacity': 0.12,
          'pressed-opacity': 0.16,
          'dragged-opacity': 0.08,
          'theme-kbd': '#212529',
          'theme-on-kbd': '#FFFFFF',
          'theme-code': '#343434',
          'theme-on-code': '#CCCCCC',
        },
      },
    },
  }
}
function P7() {
  var i, r
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : xT()
  const t = xT()
  if (!e) return { ...t, isDisabled: !0 }
  const n = {}
  for (const [s, o] of Object.entries(e.themes ?? {})) {
    const a =
      o.dark || s === 'dark' ? ((i = t.themes) == null ? void 0 : i.dark) : (r = t.themes) == null ? void 0 : r.light
    n[s] = Fn(a, o)
  }
  return Fn(t, { ...e, themes: n })
}
function R7(e) {
  const t = P7(e),
    n = le(t.defaultTheme),
    i = le(t.themes),
    r = k(() => {
      const c = {}
      for (const [d, f] of Object.entries(i.value)) {
        const m = (c[d] = { ...f, colors: { ...f.colors } })
        if (t.variations)
          for (const p of t.variations.colors) {
            const v = m.colors[p]
            if (v)
              for (const y of ['lighten', 'darken']) {
                const T = y === 'lighten' ? dK : hK
                for (const A of ar(t.variations[y], 1)) m.colors[`${p}-${y}-${A}`] = BV(T(Ai(v), A))
              }
          }
        for (const p of Object.keys(m.colors)) {
          if (/^on-[a-z]/.test(p) || m.colors[`on-${p}`]) continue
          const v = `on-${p}`,
            y = Ai(m.colors[p])
          m.colors[v] = zV(y)
        }
      }
      return c
    }),
    s = k(() => r.value[n.value]),
    o = k(() => {
      var p
      const c = []
      ;(p = s.value) != null && p.dark && oo(c, ':root', ['color-scheme: dark']), oo(c, ':root', VT(s.value))
      for (const [v, y] of Object.entries(r.value))
        oo(c, `.v-theme--${v}`, [`color-scheme: ${y.dark ? 'dark' : 'normal'}`, ...VT(y)])
      const d = [],
        f = [],
        m = new Set(Object.values(r.value).flatMap((v) => Object.keys(v.colors)))
      for (const v of m)
        /^on-[a-z]/.test(v)
          ? oo(f, `.${v}`, [`color: rgb(var(--v-theme-${v})) !important`])
          : (oo(d, `.bg-${v}`, [
              `--v-theme-overlay-multiplier: var(--v-theme-${v}-overlay-multiplier)`,
              `background-color: rgb(var(--v-theme-${v})) !important`,
              `color: rgb(var(--v-theme-on-${v})) !important`,
            ]),
            oo(f, `.text-${v}`, [`color: rgb(var(--v-theme-${v})) !important`]),
            oo(f, `.border-${v}`, [`--v-border-color: var(--v-theme-${v})`]))
      return c.push(...d, ...f), c.map((v, y) => (y === 0 ? v : `    ${v}`)).join('')
    })
  function a() {
    return { style: [{ children: o.value, id: 'vuetify-theme-stylesheet', nonce: t.cspNonce || !1 }] }
  }
  function l(c) {
    if (t.isDisabled) return
    const d = c._context.provides.usehead
    if (d)
      if (d.push) {
        const f = d.push(a)
        ct &&
          be(o, () => {
            f.patch(a)
          })
      } else ct ? (d.addHeadObjs(k(a)), $t(() => d.updateDOM())) : d.addHeadObjs(a())
    else {
      let m = function () {
          if (typeof document < 'u' && !f) {
            const p = document.createElement('style')
            ;(p.type = 'text/css'),
              (p.id = 'vuetify-theme-stylesheet'),
              t.cspNonce && p.setAttribute('nonce', t.cspNonce),
              (f = p),
              document.head.appendChild(f)
          }
          f && (f.innerHTML = o.value)
        },
        f = ct ? document.getElementById('vuetify-theme-stylesheet') : null
      ct ? be(o, m, { immediate: !0 }) : m()
    }
  }
  const u = k(() => (t.isDisabled ? void 0 : `v-theme--${n.value}`))
  return {
    install: l,
    isDisabled: t.isDisabled,
    name: n,
    themes: i,
    current: s,
    computedThemes: r,
    themeClasses: u,
    styles: o,
    global: { name: n, current: s },
  }
}
function at(e) {
  Ut('provideTheme')
  const t = je(Cc, null)
  if (!t) throw new Error('Could not find Vuetify theme injection')
  const n = k(() => e.theme ?? t.name.value),
    i = k(() => t.themes.value[n.value]),
    r = k(() => (t.isDisabled ? void 0 : `v-theme--${n.value}`)),
    s = { ...t, name: n, current: i, themeClasses: r }
  return mt(Cc, s), s
}
function nD() {
  Ut('useTheme')
  const e = je(Cc, null)
  if (!e) throw new Error('Could not find Vuetify theme injection')
  return e
}
function oo(e, t, n) {
  e.push(
    `${t} {
`,
    ...n.map(
      (i) => `  ${i};
`
    ),
    `}
`
  )
}
function VT(e) {
  const t = e.dark ? 2 : 1,
    n = e.dark ? 1 : 2,
    i = []
  for (const [r, s] of Object.entries(e.colors)) {
    const o = Ai(s)
    i.push(`--v-theme-${r}: ${o.r},${o.g},${o.b}`),
      r.startsWith('on-') || i.push(`--v-theme-${r}-overlay-multiplier: ${Bp(s) > 0.18 ? t : n}`)
  }
  for (const [r, s] of Object.entries(e.variables)) {
    const o = typeof s == 'string' && s.startsWith('#') ? Ai(s) : void 0,
      a = o ? `${o.r}, ${o.g}, ${o.b}` : void 0
    i.push(`--v-${r}: ${a ?? s}`)
  }
  return i
}
function Gi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'content'
  const n = wf(),
    i = le()
  if (ct) {
    const r = new ResizeObserver((s) => {
      e == null || e(s, r),
        s.length && (t === 'content' ? (i.value = s[0].contentRect) : (i.value = s[0].target.getBoundingClientRect()))
    })
    kn(() => {
      r.disconnect()
    }),
      be(
        () => n.el,
        (s, o) => {
          o && (r.unobserve(o), (i.value = void 0)), s && r.observe(s)
        },
        { flush: 'post' }
      )
  }
  return { resizeRef: n, contentRect: Ol(i) }
}
const Ac = Symbol.for('vuetify:layout'),
  iD = Symbol.for('vuetify:layout-item'),
  DT = 1e3,
  rD = W({ overlaps: { type: Array, default: () => [] }, fullHeight: Boolean }, 'layout'),
  da = W({ name: { type: String }, order: { type: [Number, String], default: 0 }, absolute: Boolean }, 'layout-item')
function sD() {
  const e = je(Ac)
  if (!e) throw new Error('[Vuetify] Could not find injected layout')
  return { layoutIsReady: Xe(), getLayoutItem: e.getLayoutItem, mainRect: e.mainRect, mainStyles: e.mainStyles }
}
function ha(e) {
  const t = je(Ac)
  if (!t) throw new Error('[Vuetify] Could not find injected layout')
  const n = e.id ?? `layout-item-${pn()}`,
    i = Ut('useLayoutItem')
  mt(iD, { id: n })
  const r = ye(!1)
  lA(() => (r.value = !0)), aA(() => (r.value = !1))
  const s = Xe(),
    { layoutItemStyles: o, layoutItemScrimStyles: a } = t.register(i, {
      ...e,
      active: k(() => (r.value ? !1 : e.active.value)),
      id: n,
    })
  return (
    kn(() => t.unregister(n)),
    { layoutItemStyles: o, layoutRect: t.layoutRect, layoutItemScrimStyles: a, layoutIsReady: s }
  )
}
const x7 = (e, t, n, i) => {
  let r = { top: 0, left: 0, right: 0, bottom: 0 }
  const s = [{ id: '', layer: { ...r } }]
  for (const o of e) {
    const a = t.get(o),
      l = n.get(o),
      u = i.get(o)
    if (!a || !l || !u) continue
    const c = { ...r, [a.value]: parseInt(r[a.value], 10) + (u.value ? parseInt(l.value, 10) : 0) }
    s.push({ id: o, layer: c }), (r = c)
  }
  return s
}
function oD(e) {
  const t = je(Ac, null),
    n = k(() => (t ? t.rootZIndex.value - 100 : DT)),
    i = le([]),
    r = wn(new Map()),
    s = wn(new Map()),
    o = wn(new Map()),
    a = wn(new Map()),
    l = wn(new Map()),
    { resizeRef: u, contentRect: c } = Gi(),
    d = oT(() => {
      const V = [...new Set([...o.values()].map((I) => I.value))].sort((I, w) => I - w),
        D = []
      for (const I of V) {
        const w = i.value.filter((_) => {
          var S
          return ((S = o.get(_)) == null ? void 0 : S.value) === I
        })
        D.push(...w)
      }
      return x7(D, r, s, a)
    }),
    f = k(() => !Array.from(l.values()).some((V) => V.value)),
    m = k(() => d.value[d.value.length - 1].layer),
    p = k(() => ({
      '--v-layout-left': Se(m.value.left),
      '--v-layout-right': Se(m.value.right),
      '--v-layout-top': Se(m.value.top),
      '--v-layout-bottom': Se(m.value.bottom),
      ...(f.value ? void 0 : { transition: 'none' }),
    })),
    v = oT(() =>
      d.value.slice(1).map((V, D) => {
        let { id: I } = V
        const { layer: w } = d.value[D],
          _ = s.get(I),
          S = r.get(I)
        return { id: I, ...w, size: Number(_.value), position: S.value }
      })
    ),
    y = (V) => v.value.find((D) => D.id === V),
    T = Ut('createLayout'),
    A = Xe()
  mt(Ac, {
    register: (V, D) => {
      let {
        id: I,
        order: w,
        position: _,
        layoutSize: S,
        elementSize: E,
        active: C,
        disableTransitions: R,
        absolute: B,
      } = D
      o.set(I, w), r.set(I, _), s.set(I, S), a.set(I, C), R && l.set(I, R)
      const $ = Ga(iD, T == null ? void 0 : T.vnode).indexOf(V)
      $ > -1 ? i.value.splice($, 0, I) : i.value.push(I)
      const G = k(() => v.value.findIndex((q) => q.id === I)),
        F = k(() => n.value + d.value.length * 2 - G.value * 2),
        K = k(() => {
          const q = _.value === 'left' || _.value === 'right',
            te = _.value === 'right',
            ce = _.value === 'bottom',
            Ee = E.value ?? S.value,
            me = Ee === 0 ? '%' : 'px',
            oe = {
              [_.value]: 0,
              zIndex: F.value,
              transform: `translate${q ? 'X' : 'Y'}(${
                (C.value ? 0 : -(Ee === 0 ? 100 : Ee)) * (te || ce ? -1 : 1)
              }${me})`,
              position: B.value || n.value !== DT ? 'absolute' : 'fixed',
              ...(f.value ? void 0 : { transition: 'none' }),
            }
          if (G.value < 0) throw new Error(`Layout item "${I}" is missing`)
          const z = v.value[G.value]
          if (!z) throw new Error(`[Vuetify] Could not find layout item "${I}"`)
          return {
            ...oe,
            height: q ? `calc(100% - ${z.top}px - ${z.bottom}px)` : E.value ? `${E.value}px` : void 0,
            left: te ? void 0 : `${z.left}px`,
            right: te ? `${z.right}px` : void 0,
            top: _.value !== 'bottom' ? `${z.top}px` : void 0,
            bottom: _.value !== 'top' ? `${z.bottom}px` : void 0,
            width: q ? (E.value ? `${E.value}px` : void 0) : `calc(100% - ${z.left}px - ${z.right}px)`,
          }
        }),
        j = k(() => ({ zIndex: F.value - 1 }))
      return { layoutItemStyles: K, layoutItemScrimStyles: j, zIndex: F }
    },
    unregister: (V) => {
      o.delete(V), r.delete(V), s.delete(V), a.delete(V), l.delete(V), (i.value = i.value.filter((D) => D !== V))
    },
    mainRect: m,
    mainStyles: p,
    getLayoutItem: y,
    items: v,
    layoutRect: c,
    rootZIndex: n,
    layoutIsReady: A,
  })
  const x = k(() => ['v-layout', { 'v-layout--full-height': e.fullHeight }]),
    N = k(() => ({ zIndex: t ? n.value : void 0, position: t ? 'relative' : void 0, overflow: t ? 'hidden' : void 0 }))
  return {
    layoutClasses: x,
    layoutStyles: N,
    getLayoutItem: y,
    items: v,
    layoutRect: c,
    layoutIsReady: A,
    layoutRef: u,
  }
}
function aD() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const { blueprint: t, ...n } = e,
    i = Fn(t, n),
    { aliases: r = {}, components: s = {}, directives: o = {} } = i,
    a = gK(i.defaults),
    l = y7(i.display, i.ssr),
    u = R7(i.theme),
    c = A7(i.icons),
    d = CK(i.locale),
    f = g7(i.date, d),
    m = b7(i.goTo, d)
  return {
    install: (v) => {
      for (const y in o) v.directive(y, o[y])
      for (const y in s) v.component(y, s[y])
      for (const y in r) v.component(y, yi({ ...r[y], name: y, aliasName: r[y].name }))
      if (
        (u.install(v),
        v.provide(kl, a),
        v.provide(Up, l),
        v.provide(Cc, u),
        v.provide(jp, c),
        v.provide(Pl, d),
        v.provide(JV, f.options),
        v.provide(TT, f.instance),
        v.provide(eD, m),
        ct && i.ssr)
      )
        if (v.$nuxt)
          v.$nuxt.hook('app:suspense:resolve', () => {
            l.update()
          })
        else {
          const { mount: y } = v
          v.mount = function () {
            const T = y(...arguments)
            return Xe(() => l.update()), (v.mount = y), T
          }
        }
      pn.reset(),
        v.mixin({
          computed: {
            $vuetify() {
              return wn({
                defaults: Na.call(this, kl),
                display: Na.call(this, Up),
                theme: Na.call(this, Cc),
                icons: Na.call(this, jp),
                locale: Na.call(this, Pl),
                date: Na.call(this, TT),
              })
            },
          },
        })
    },
    defaults: a,
    display: l,
    theme: u,
    icons: c,
    locale: d,
    date: f,
    goTo: m,
  }
}
const V7 = '3.6.13'
aD.version = V7
function Na(e) {
  var i, r
  const t = this.$,
    n = ((i = t.parent) == null ? void 0 : i.provides) ?? ((r = t.vnode.appContext) == null ? void 0 : r.provides)
  if (n && e in n) return n[e]
}
const D7 = W({ ...Te(), ...rD({ fullHeight: !0 }), ...Ze() }, 'VApp'),
  N7 = ne()({
    name: 'VApp',
    props: D7(),
    setup(e, t) {
      let { slots: n } = t
      const i = at(e),
        { layoutClasses: r, getLayoutItem: s, items: o, layoutRef: a } = oD(e),
        { rtlClasses: l } = sn()
      return (
        se(() =>
          g(
            'div',
            { ref: a, class: ['v-application', i.themeClasses.value, r.value, l.value, e.class], style: [e.style] },
            [
              g('div', { class: 'v-application__wrap' }, [
                g(RA, null, {
                  default: () => {
                    var u
                    return [g(ke, null, [(u = n.default) == null ? void 0 : u.call(n)])]
                  },
                }),
              ]),
            ]
          )
        ),
        { getLayoutItem: s, items: o, theme: i }
      )
    },
  }),
  He = W({ tag: { type: String, default: 'div' } }, 'tag'),
  lD = W({ text: String, ...Te(), ...He() }, 'VToolbarTitle'),
  Bb = ne()({
    name: 'VToolbarTitle',
    props: lD(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() => {
          const i = !!(n.default || n.text || e.text)
          return g(
            e.tag,
            { class: ['v-toolbar-title', e.class], style: e.style },
            {
              default: () => {
                var r
                return [
                  i &&
                    g('div', { class: 'v-toolbar-title__placeholder' }, [
                      n.text ? n.text() : e.text,
                      (r = n.default) == null ? void 0 : r.call(n),
                    ]),
                ]
              },
            }
          )
        }),
        {}
      )
    },
  }),
  O7 = W(
    { disabled: Boolean, group: Boolean, hideOnLeave: Boolean, leaveAbsolute: Boolean, mode: String, origin: String },
    'transition'
  )
function _i(e, t, n) {
  return ne()({
    name: e,
    props: O7({ mode: n, origin: t }),
    setup(i, r) {
      let { slots: s } = r
      const o = {
        onBeforeEnter(a) {
          i.origin && (a.style.transformOrigin = i.origin)
        },
        onLeave(a) {
          if (i.leaveAbsolute) {
            const { offsetTop: l, offsetLeft: u, offsetWidth: c, offsetHeight: d } = a
            ;(a._transitionInitialStyles = {
              position: a.style.position,
              top: a.style.top,
              left: a.style.left,
              width: a.style.width,
              height: a.style.height,
            }),
              (a.style.position = 'absolute'),
              (a.style.top = `${l}px`),
              (a.style.left = `${u}px`),
              (a.style.width = `${c}px`),
              (a.style.height = `${d}px`)
          }
          i.hideOnLeave && a.style.setProperty('display', 'none', 'important')
        },
        onAfterLeave(a) {
          if (i.leaveAbsolute && a != null && a._transitionInitialStyles) {
            const { position: l, top: u, left: c, width: d, height: f } = a._transitionInitialStyles
            delete a._transitionInitialStyles,
              (a.style.position = l || ''),
              (a.style.top = u || ''),
              (a.style.left = c || ''),
              (a.style.width = d || ''),
              (a.style.height = f || '')
          }
        },
      }
      return () => {
        const a = i.group ? Wy : dr
        return Yi(
          a,
          {
            name: i.disabled ? '' : e,
            css: !i.disabled,
            ...(i.group ? void 0 : { mode: i.mode }),
            ...(i.disabled ? {} : o),
          },
          s.default
        )
      }
    },
  })
}
function uD(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'in-out'
  return ne()({
    name: e,
    props: { mode: { type: String, default: n }, disabled: Boolean, group: Boolean },
    setup(i, r) {
      let { slots: s } = r
      const o = i.group ? Wy : dr
      return () => Yi(o, { name: i.disabled ? '' : e, css: !i.disabled, ...(i.disabled ? {} : t) }, s.default)
    },
  })
}
function cD() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ''
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? 'width' : 'height',
    i = gi(`offset-${n}`)
  return {
    onBeforeEnter(o) {
      ;(o._parent = o.parentNode),
        (o._initialStyle = { transition: o.style.transition, overflow: o.style.overflow, [n]: o.style[n] })
    },
    onEnter(o) {
      const a = o._initialStyle
      o.style.setProperty('transition', 'none', 'important'), (o.style.overflow = 'hidden')
      const l = `${o[i]}px`
      ;(o.style[n] = '0'),
        o.offsetHeight,
        (o.style.transition = a.transition),
        e && o._parent && o._parent.classList.add(e),
        requestAnimationFrame(() => {
          o.style[n] = l
        })
    },
    onAfterEnter: s,
    onEnterCancelled: s,
    onLeave(o) {
      ;(o._initialStyle = { transition: '', overflow: o.style.overflow, [n]: o.style[n] }),
        (o.style.overflow = 'hidden'),
        (o.style[n] = `${o[i]}px`),
        o.offsetHeight,
        requestAnimationFrame(() => (o.style[n] = '0'))
    },
    onAfterLeave: r,
    onLeaveCancelled: r,
  }
  function r(o) {
    e && o._parent && o._parent.classList.remove(e), s(o)
  }
  function s(o) {
    const a = o._initialStyle[n]
    ;(o.style.overflow = o._initialStyle.overflow), a != null && (o.style[n] = a), delete o._initialStyle
  }
}
const M7 = W({ target: [Object, Array] }, 'v-dialog-transition'),
  xm = ne()({
    name: 'VDialogTransition',
    props: M7(),
    setup(e, t) {
      let { slots: n } = t
      const i = {
        onBeforeEnter(r) {
          ;(r.style.pointerEvents = 'none'), (r.style.visibility = 'hidden')
        },
        async onEnter(r, s) {
          var f
          await new Promise((m) => requestAnimationFrame(m)),
            await new Promise((m) => requestAnimationFrame(m)),
            (r.style.visibility = '')
          const { x: o, y: a, sx: l, sy: u, speed: c } = OT(e.target, r),
            d = _o(r, [{ transform: `translate(${o}px, ${a}px) scale(${l}, ${u})`, opacity: 0 }, {}], {
              duration: 225 * c,
              easing: _K,
            })
          ;(f = NT(r)) == null ||
            f.forEach((m) => {
              _o(m, [{ opacity: 0 }, { opacity: 0, offset: 0.33 }, {}], { duration: 225 * 2 * c, easing: Tc })
            }),
            d.finished.then(() => s())
        },
        onAfterEnter(r) {
          r.style.removeProperty('pointer-events')
        },
        onBeforeLeave(r) {
          r.style.pointerEvents = 'none'
        },
        async onLeave(r, s) {
          var f
          await new Promise((m) => requestAnimationFrame(m))
          const { x: o, y: a, sx: l, sy: u, speed: c } = OT(e.target, r)
          _o(r, [{}, { transform: `translate(${o}px, ${a}px) scale(${l}, ${u})`, opacity: 0 }], {
            duration: 125 * c,
            easing: bK,
          }).finished.then(() => s()),
            (f = NT(r)) == null ||
              f.forEach((m) => {
                _o(m, [{}, { opacity: 0, offset: 0.2 }, { opacity: 0 }], { duration: 125 * 2 * c, easing: Tc })
              })
        },
        onAfterLeave(r) {
          r.style.removeProperty('pointer-events')
        },
      }
      return () =>
        e.target ? g(dr, ae({ name: 'dialog-transition' }, i, { css: !1 }), n) : g(dr, { name: 'dialog-transition' }, n)
    },
  })
function NT(e) {
  var n
  const t = (n = e.querySelector(':scope > .v-card, :scope > .v-sheet, :scope > .v-list')) == null ? void 0 : n.children
  return t && [...t]
}
function OT(e, t) {
  const n = VV(e),
    i = xb(t),
    [r, s] = getComputedStyle(t)
      .transformOrigin.split(' ')
      .map((T) => parseFloat(T)),
    [o, a] = getComputedStyle(t).getPropertyValue('--v-overlay-anchor-origin').split(' ')
  let l = n.left + n.width / 2
  o === 'left' || a === 'left' ? (l -= n.width / 2) : (o === 'right' || a === 'right') && (l += n.width / 2)
  let u = n.top + n.height / 2
  o === 'top' || a === 'top' ? (u -= n.height / 2) : (o === 'bottom' || a === 'bottom') && (u += n.height / 2)
  const c = n.width / i.width,
    d = n.height / i.height,
    f = Math.max(1, c, d),
    m = c / f || 0,
    p = d / f || 0,
    v = (i.width * i.height) / (window.innerWidth * window.innerHeight),
    y = v > 0.12 ? Math.min(1.5, (v - 0.12) * 10 + 1) : 1
  return { x: l - (r + i.left), y: u - (s + i.top), sx: m, sy: p, speed: y }
}
const L7 = _i('fab-transition', 'center center', 'out-in'),
  F7 = _i('dialog-bottom-transition'),
  B7 = _i('dialog-top-transition'),
  kc = _i('fade-transition'),
  $b = _i('scale-transition'),
  $7 = _i('scroll-x-transition'),
  U7 = _i('scroll-x-reverse-transition'),
  j7 = _i('scroll-y-transition'),
  z7 = _i('scroll-y-reverse-transition'),
  H7 = _i('slide-x-transition'),
  W7 = _i('slide-x-reverse-transition'),
  Ub = _i('slide-y-transition'),
  q7 = _i('slide-y-reverse-transition'),
  Vm = uD('expand-transition', cD()),
  jb = uD('expand-x-transition', cD('', !0)),
  G7 = W(
    { defaults: Object, disabled: Boolean, reset: [Number, String], root: [Boolean, String], scoped: Boolean },
    'VDefaultsProvider'
  ),
  Ge = ne(!1)({
    name: 'VDefaultsProvider',
    props: G7(),
    setup(e, t) {
      let { slots: n } = t
      const { defaults: i, disabled: r, reset: s, root: o, scoped: a } = js(e)
      return (
        Ot(i, { reset: s, root: o, scoped: a, disabled: r }),
        () => {
          var l
          return (l = n.default) == null ? void 0 : l.call(n)
        }
      )
    },
  }),
  on = W(
    {
      height: [Number, String],
      maxHeight: [Number, String],
      maxWidth: [Number, String],
      minHeight: [Number, String],
      minWidth: [Number, String],
      width: [Number, String],
    },
    'dimension'
  )
function an(e) {
  return {
    dimensionStyles: k(() => {
      const n = {},
        i = Se(e.height),
        r = Se(e.maxHeight),
        s = Se(e.maxWidth),
        o = Se(e.minHeight),
        a = Se(e.minWidth),
        l = Se(e.width)
      return (
        i != null && (n.height = i),
        r != null && (n.maxHeight = r),
        s != null && (n.maxWidth = s),
        o != null && (n.minHeight = o),
        a != null && (n.minWidth = a),
        l != null && (n.width = l),
        n
      )
    }),
  }
}
function K7(e) {
  return {
    aspectStyles: k(() => {
      const t = Number(e.aspectRatio)
      return t ? { paddingBottom: String((1 / t) * 100) + '%' } : void 0
    }),
  }
}
const dD = W({ aspectRatio: [String, Number], contentClass: null, inline: Boolean, ...Te(), ...on() }, 'VResponsive'),
  Hp = ne()({
    name: 'VResponsive',
    props: dD(),
    setup(e, t) {
      let { slots: n } = t
      const { aspectStyles: i } = K7(e),
        { dimensionStyles: r } = an(e)
      return (
        se(() => {
          var s
          return g(
            'div',
            { class: ['v-responsive', { 'v-responsive--inline': e.inline }, e.class], style: [r.value, e.style] },
            [
              g('div', { class: 'v-responsive__sizer', style: i.value }, null),
              (s = n.additional) == null ? void 0 : s.call(n),
              n.default && g('div', { class: ['v-responsive__content', e.contentClass] }, [n.default()]),
            ]
          )
        }),
        {}
      )
    },
  })
function zb(e) {
  return Pb(() => {
    const t = [],
      n = {}
    if (e.value.background)
      if (Fp(e.value.background)) {
        if (((n.backgroundColor = e.value.background), !e.value.text && lK(e.value.background))) {
          const i = Ai(e.value.background)
          if (i.a == null || i.a === 1) {
            const r = zV(i)
            ;(n.color = r), (n.caretColor = r)
          }
        }
      } else t.push(`bg-${e.value.background}`)
    return (
      e.value.text &&
        (Fp(e.value.text) ? ((n.color = e.value.text), (n.caretColor = e.value.text)) : t.push(`text-${e.value.text}`)),
      { colorClasses: t, colorStyles: n }
    )
  })
}
function Tn(e, t) {
  const n = k(() => ({ text: It(e) ? e.value : t ? e[t] : null })),
    { colorClasses: i, colorStyles: r } = zb(n)
  return { textColorClasses: i, textColorStyles: r }
}
function gt(e, t) {
  const n = k(() => ({ background: It(e) ? e.value : t ? e[t] : null })),
    { colorClasses: i, colorStyles: r } = zb(n)
  return { backgroundColorClasses: i, backgroundColorStyles: r }
}
const Tt = W({ rounded: { type: [Boolean, Number, String], default: void 0 }, tile: Boolean }, 'rounded')
function Mt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  return {
    roundedClasses: k(() => {
      const i = It(e) ? e.value : e.rounded,
        r = It(e) ? e.value : e.tile,
        s = []
      if (i === !0 || i === '') s.push(`${t}--rounded`)
      else if (typeof i == 'string' || i === 0) for (const o of String(i).split(' ')) s.push(`rounded-${o}`)
      else (r || i === !1) && s.push('rounded-0')
      return s
    }),
  }
}
const Xi = W(
    { transition: { type: [Boolean, String, Object], default: 'fade-transition', validator: (e) => e !== !0 } },
    'transition'
  ),
  Bn = (e, t) => {
    let { slots: n } = t
    const { transition: i, disabled: r, group: s, ...o } = e,
      { component: a = s ? Wy : dr, ...l } = typeof i == 'object' ? i : {}
    return Yi(
      a,
      ae(
        typeof i == 'string' ? { name: r ? '' : i } : l,
        typeof i == 'string'
          ? {}
          : Object.fromEntries(
              Object.entries({ disabled: r, group: s }).filter((u) => {
                let [c, d] = u
                return d !== void 0
              })
            ),
        o
      ),
      n
    )
  }
function Y7(e, t) {
  if (!Cb) return
  const n = t.modifiers || {},
    i = t.value,
    { handler: r, options: s } = typeof i == 'object' ? i : { handler: i, options: {} },
    o = new IntersectionObserver(function () {
      var d
      let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        l = arguments.length > 1 ? arguments[1] : void 0
      const u = (d = e._observe) == null ? void 0 : d[t.instance.$.uid]
      if (!u) return
      const c = a.some((f) => f.isIntersecting)
      r && (!n.quiet || u.init) && (!n.once || c || u.init) && r(c, a, l), c && n.once ? hD(e, t) : (u.init = !0)
    }, s)
  ;(e._observe = Object(e._observe)), (e._observe[t.instance.$.uid] = { init: !1, observer: o }), o.observe(e)
}
function hD(e, t) {
  var i
  const n = (i = e._observe) == null ? void 0 : i[t.instance.$.uid]
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid])
}
const ld = { mounted: Y7, unmounted: hD },
  fD = W(
    {
      alt: String,
      cover: Boolean,
      color: String,
      draggable: { type: [Boolean, String], default: void 0 },
      eager: Boolean,
      gradient: String,
      lazySrc: String,
      options: { type: Object, default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }) },
      sizes: String,
      src: { type: [String, Object], default: '' },
      crossorigin: String,
      referrerpolicy: String,
      srcset: String,
      position: String,
      ...dD(),
      ...Te(),
      ...Tt(),
      ...Xi(),
    },
    'VImg'
  ),
  Br = ne()({
    name: 'VImg',
    directives: { intersect: ld },
    props: fD(),
    emits: { loadstart: (e) => !0, load: (e) => !0, error: (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const { backgroundColorClasses: r, backgroundColorStyles: s } = gt(Q(e, 'color')),
        { roundedClasses: o } = Mt(e),
        a = Ut('VImg'),
        l = ye(''),
        u = le(),
        c = ye(e.eager ? 'loading' : 'idle'),
        d = ye(),
        f = ye(),
        m = k(() =>
          e.src && typeof e.src == 'object'
            ? {
                src: e.src.src,
                srcset: e.srcset || e.src.srcset,
                lazySrc: e.lazySrc || e.src.lazySrc,
                aspect: Number(e.aspectRatio || e.src.aspect || 0),
              }
            : { src: e.src, srcset: e.srcset, lazySrc: e.lazySrc, aspect: Number(e.aspectRatio || 0) }
        ),
        p = k(() => m.value.aspect || d.value / f.value || 0)
      be(
        () => e.src,
        () => {
          v(c.value !== 'idle')
        }
      ),
        be(p, (C, R) => {
          !C && R && u.value && N(u.value)
        }),
        Dy(() => v())
      function v(C) {
        if (!(e.eager && C) && !(Cb && !C && !e.eager)) {
          if (((c.value = 'loading'), m.value.lazySrc)) {
            const R = new Image()
            ;(R.src = m.value.lazySrc), N(R, null)
          }
          m.value.src &&
            Xe(() => {
              var R
              n('loadstart', ((R = u.value) == null ? void 0 : R.currentSrc) || m.value.src),
                setTimeout(() => {
                  var B
                  if (!a.isUnmounted)
                    if ((B = u.value) != null && B.complete) {
                      if ((u.value.naturalWidth || T(), c.value === 'error')) return
                      p.value || N(u.value, null), c.value === 'loading' && y()
                    } else p.value || N(u.value), A()
                })
            })
        }
      }
      function y() {
        var C
        a.isUnmounted ||
          (A(),
          N(u.value),
          (c.value = 'loaded'),
          n('load', ((C = u.value) == null ? void 0 : C.currentSrc) || m.value.src))
      }
      function T() {
        var C
        a.isUnmounted ||
          ((c.value = 'error'), n('error', ((C = u.value) == null ? void 0 : C.currentSrc) || m.value.src))
      }
      function A() {
        const C = u.value
        C && (l.value = C.currentSrc || C.src)
      }
      let x = -1
      kn(() => {
        clearTimeout(x)
      })
      function N(C) {
        let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100
        const B = () => {
          if ((clearTimeout(x), a.isUnmounted)) return
          const { naturalHeight: U, naturalWidth: $ } = C
          U || $
            ? ((d.value = $), (f.value = U))
            : !C.complete && c.value === 'loading' && R != null
            ? (x = window.setTimeout(B, R))
            : (C.currentSrc.endsWith('.svg') || C.currentSrc.startsWith('data:image/svg+xml')) &&
              ((d.value = 1), (f.value = 1))
        }
        B()
      }
      const V = k(() => ({ 'v-img__img--cover': e.cover, 'v-img__img--contain': !e.cover })),
        D = () => {
          var B
          if (!m.value.src || c.value === 'idle') return null
          const C = g(
              'img',
              {
                class: ['v-img__img', V.value],
                style: { objectPosition: e.position },
                src: m.value.src,
                srcset: m.value.srcset,
                alt: e.alt,
                crossorigin: e.crossorigin,
                referrerpolicy: e.referrerpolicy,
                draggable: e.draggable,
                sizes: e.sizes,
                ref: u,
                onLoad: y,
                onError: T,
              },
              null
            ),
            R = (B = i.sources) == null ? void 0 : B.call(i)
          return g(
            Bn,
            { transition: e.transition, appear: !0 },
            {
              default: () => [
                Rt(R ? g('picture', { class: 'v-img__picture' }, [R, C]) : C, [[Qi, c.value === 'loaded']]),
              ],
            }
          )
        },
        I = () =>
          g(
            Bn,
            { transition: e.transition },
            {
              default: () => [
                m.value.lazySrc &&
                  c.value !== 'loaded' &&
                  g(
                    'img',
                    {
                      class: ['v-img__img', 'v-img__img--preload', V.value],
                      style: { objectPosition: e.position },
                      src: m.value.lazySrc,
                      alt: e.alt,
                      crossorigin: e.crossorigin,
                      referrerpolicy: e.referrerpolicy,
                      draggable: e.draggable,
                    },
                    null
                  ),
              ],
            }
          ),
        w = () =>
          i.placeholder
            ? g(
                Bn,
                { transition: e.transition, appear: !0 },
                {
                  default: () => [
                    (c.value === 'loading' || (c.value === 'error' && !i.error)) &&
                      g('div', { class: 'v-img__placeholder' }, [i.placeholder()]),
                  ],
                }
              )
            : null,
        _ = () =>
          i.error
            ? g(
                Bn,
                { transition: e.transition, appear: !0 },
                { default: () => [c.value === 'error' && g('div', { class: 'v-img__error' }, [i.error()])] }
              )
            : null,
        S = () =>
          e.gradient
            ? g('div', { class: 'v-img__gradient', style: { backgroundImage: `linear-gradient(${e.gradient})` } }, null)
            : null,
        E = ye(!1)
      {
        const C = be(p, (R) => {
          R &&
            (requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                E.value = !0
              })
            }),
            C())
        })
      }
      return (
        se(() => {
          const C = Hp.filterProps(e)
          return Rt(
            g(
              Hp,
              ae(
                {
                  class: ['v-img', { 'v-img--booting': !E.value }, r.value, o.value, e.class],
                  style: [{ width: Se(e.width === 'auto' ? d.value : e.width) }, s.value, e.style],
                },
                C,
                { aspectRatio: p.value, 'aria-label': e.alt, role: e.alt ? 'img' : void 0 }
              ),
              {
                additional: () =>
                  g(ke, null, [
                    g(D, null, null),
                    g(I, null, null),
                    g(S, null, null),
                    g(w, null, null),
                    g(_, null, null),
                  ]),
                default: i.default,
              }
            ),
            [[pi('intersect'), { handler: v, options: e.options }, null, { once: !0 }]]
          )
        }),
        { currentSrc: l, image: u, state: c, naturalWidth: d, naturalHeight: f }
      )
    },
  }),
  bi = W({ border: [Boolean, Number, String] }, 'border')
function Oi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  return {
    borderClasses: k(() => {
      const i = It(e) ? e.value : e.border,
        r = []
      if (i === !0 || i === '') r.push(`${t}--border`)
      else if (typeof i == 'string' || i === 0) for (const s of String(i).split(' ')) r.push(`border-${s}`)
      return r
    }),
  }
}
const en = W(
  {
    elevation: {
      type: [Number, String],
      validator(e) {
        const t = parseInt(e)
        return !isNaN(t) && t >= 0 && t <= 24
      },
    },
  },
  'elevation'
)
function yn(e) {
  return {
    elevationClasses: k(() => {
      const n = It(e) ? e.value : e.elevation,
        i = []
      return n == null || i.push(`elevation-${n}`), i
    }),
  }
}
const Q7 = [null, 'prominent', 'default', 'comfortable', 'compact'],
  mD = W(
    {
      absolute: Boolean,
      collapse: Boolean,
      color: String,
      density: { type: String, default: 'default', validator: (e) => Q7.includes(e) },
      extended: Boolean,
      extensionHeight: { type: [Number, String], default: 48 },
      flat: Boolean,
      floating: Boolean,
      height: { type: [Number, String], default: 64 },
      image: String,
      title: String,
      ...bi(),
      ...Te(),
      ...en(),
      ...Tt(),
      ...He({ tag: 'header' }),
      ...Ze(),
    },
    'VToolbar'
  ),
  Wp = ne()({
    name: 'VToolbar',
    props: mD(),
    setup(e, t) {
      var m
      let { slots: n } = t
      const { backgroundColorClasses: i, backgroundColorStyles: r } = gt(Q(e, 'color')),
        { borderClasses: s } = Oi(e),
        { elevationClasses: o } = yn(e),
        { roundedClasses: a } = Mt(e),
        { themeClasses: l } = at(e),
        { rtlClasses: u } = sn(),
        c = ye(!!(e.extended || ((m = n.extension) != null && m.call(n)))),
        d = k(() =>
          parseInt(
            Number(e.height) +
              (e.density === 'prominent' ? Number(e.height) : 0) -
              (e.density === 'comfortable' ? 8 : 0) -
              (e.density === 'compact' ? 16 : 0),
            10
          )
        ),
        f = k(() =>
          c.value
            ? parseInt(
                Number(e.extensionHeight) +
                  (e.density === 'prominent' ? Number(e.extensionHeight) : 0) -
                  (e.density === 'comfortable' ? 4 : 0) -
                  (e.density === 'compact' ? 8 : 0),
                10
              )
            : 0
        )
      return (
        Ot({ VBtn: { variant: 'text' } }),
        se(() => {
          var T
          const p = !!(e.title || n.title),
            v = !!(n.image || e.image),
            y = (T = n.extension) == null ? void 0 : T.call(n)
          return (
            (c.value = !!(e.extended || y)),
            g(
              e.tag,
              {
                class: [
                  'v-toolbar',
                  {
                    'v-toolbar--absolute': e.absolute,
                    'v-toolbar--collapse': e.collapse,
                    'v-toolbar--flat': e.flat,
                    'v-toolbar--floating': e.floating,
                    [`v-toolbar--density-${e.density}`]: !0,
                  },
                  i.value,
                  s.value,
                  o.value,
                  a.value,
                  l.value,
                  u.value,
                  e.class,
                ],
                style: [r.value, e.style],
              },
              {
                default: () => [
                  v &&
                    g('div', { key: 'image', class: 'v-toolbar__image' }, [
                      n.image
                        ? g(
                            Ge,
                            {
                              key: 'image-defaults',
                              disabled: !e.image,
                              defaults: { VImg: { cover: !0, src: e.image } },
                            },
                            n.image
                          )
                        : g(Br, { key: 'image-img', cover: !0, src: e.image }, null),
                    ]),
                  g(
                    Ge,
                    { defaults: { VTabs: { height: Se(d.value) } } },
                    {
                      default: () => {
                        var A, x, N
                        return [
                          g('div', { class: 'v-toolbar__content', style: { height: Se(d.value) } }, [
                            n.prepend &&
                              g('div', { class: 'v-toolbar__prepend' }, [(A = n.prepend) == null ? void 0 : A.call(n)]),
                            p && g(Bb, { key: 'title', text: e.title }, { text: n.title }),
                            (x = n.default) == null ? void 0 : x.call(n),
                            n.append &&
                              g('div', { class: 'v-toolbar__append' }, [(N = n.append) == null ? void 0 : N.call(n)]),
                          ]),
                        ]
                      },
                    }
                  ),
                  g(
                    Ge,
                    { defaults: { VTabs: { height: Se(f.value) } } },
                    {
                      default: () => [
                        g(Vm, null, {
                          default: () => [
                            c.value && g('div', { class: 'v-toolbar__extension', style: { height: Se(f.value) } }, [y]),
                          ],
                        }),
                      ],
                    }
                  ),
                ],
              }
            )
          )
        }),
        { contentHeight: d, extensionHeight: f }
      )
    },
  }),
  X7 = W({ scrollTarget: { type: String }, scrollThreshold: { type: [String, Number], default: 300 } }, 'scroll')
function J7(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  const { canScroll: n } = t
  let i = 0,
    r = 0
  const s = le(null),
    o = ye(0),
    a = ye(0),
    l = ye(0),
    u = ye(!1),
    c = ye(!1),
    d = k(() => Number(e.scrollThreshold)),
    f = k(() => qt((d.value - o.value) / d.value || 0)),
    m = () => {
      const p = s.value
      if (!p || (n && !n.value)) return
      ;(i = o.value), (o.value = 'window' in p ? p.pageYOffset : p.scrollTop)
      const v = p instanceof Window ? document.documentElement.scrollHeight : p.scrollHeight
      if (r !== v) {
        r = v
        return
      }
      ;(c.value = o.value < i), (l.value = Math.abs(o.value - d.value))
    }
  return (
    be(c, () => {
      a.value = a.value || o.value
    }),
    be(u, () => {
      a.value = 0
    }),
    An(() => {
      be(
        () => e.scrollTarget,
        (p) => {
          var y
          const v = p ? document.querySelector(p) : window
          v &&
            v !== s.value &&
            ((y = s.value) == null || y.removeEventListener('scroll', m),
            (s.value = v),
            s.value.addEventListener('scroll', m, { passive: !0 }))
        },
        { immediate: !0 }
      )
    }),
    kn(() => {
      var p
      ;(p = s.value) == null || p.removeEventListener('scroll', m)
    }),
    n && be(n, m, { immediate: !0 }),
    {
      scrollThreshold: d,
      currentScroll: o,
      currentThreshold: l,
      isScrollActive: u,
      scrollRatio: f,
      isScrollingUp: c,
      savedScroll: a,
    }
  )
}
function fa() {
  const e = ye(!1)
  return (
    An(() => {
      window.requestAnimationFrame(() => {
        e.value = !0
      })
    }),
    { ssrBootStyles: k(() => (e.value ? void 0 : { transition: 'none !important' })), isBooted: Ol(e) }
  )
}
const Z7 = W(
    {
      scrollBehavior: String,
      modelValue: { type: Boolean, default: !0 },
      location: { type: String, default: 'top', validator: (e) => ['top', 'bottom'].includes(e) },
      ...mD(),
      ...da(),
      ...X7(),
      height: { type: [Number, String], default: 64 },
    },
    'VAppBar'
  ),
  e8 = ne()({
    name: 'VAppBar',
    props: Z7(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = le(),
        r = xe(e, 'modelValue'),
        s = k(() => {
          var N
          const x = new Set(((N = e.scrollBehavior) == null ? void 0 : N.split(' ')) ?? [])
          return {
            hide: x.has('hide'),
            fullyHide: x.has('fully-hide'),
            inverted: x.has('inverted'),
            collapse: x.has('collapse'),
            elevate: x.has('elevate'),
            fadeImage: x.has('fade-image'),
          }
        }),
        o = k(() => {
          const x = s.value
          return x.hide || x.fullyHide || x.inverted || x.collapse || x.elevate || x.fadeImage || !r.value
        }),
        { currentScroll: a, scrollThreshold: l, isScrollingUp: u, scrollRatio: c } = J7(e, { canScroll: o }),
        d = k(() => s.value.hide || s.value.fullyHide),
        f = k(() => e.collapse || (s.value.collapse && (s.value.inverted ? c.value > 0 : c.value === 0))),
        m = k(
          () =>
            e.flat ||
            (s.value.fullyHide && !r.value) ||
            (s.value.elevate && (s.value.inverted ? a.value > 0 : a.value === 0))
        ),
        p = k(() => (s.value.fadeImage ? (s.value.inverted ? 1 - c.value : c.value) : void 0)),
        v = k(() => {
          var V, D
          const x = Number(((V = i.value) == null ? void 0 : V.contentHeight) ?? e.height),
            N = Number(((D = i.value) == null ? void 0 : D.extensionHeight) ?? 0)
          return d.value ? (a.value < l.value || s.value.fullyHide ? x + N : x) : x + N
        })
      ii(
        k(() => !!e.scrollBehavior),
        () => {
          $t(() => {
            d.value
              ? s.value.inverted
                ? (r.value = a.value > l.value)
                : (r.value = u.value || a.value < l.value)
              : (r.value = !0)
          })
        }
      )
      const { ssrBootStyles: y } = fa(),
        { layoutItemStyles: T, layoutIsReady: A } = ha({
          id: e.name,
          order: k(() => parseInt(e.order, 10)),
          position: Q(e, 'location'),
          layoutSize: v,
          elementSize: ye(void 0),
          active: r,
          absolute: Q(e, 'absolute'),
        })
      return (
        se(() => {
          const x = Wp.filterProps(e)
          return g(
            Wp,
            ae(
              {
                ref: i,
                class: ['v-app-bar', { 'v-app-bar--bottom': e.location === 'bottom' }, e.class],
                style: [{ ...T.value, '--v-toolbar-image-opacity': p.value, height: void 0, ...y.value }, e.style],
              },
              x,
              { collapse: f.value, flat: m.value }
            ),
            n
          )
        }),
        A
      )
    },
  }),
  t8 = [null, 'default', 'comfortable', 'compact'],
  ln = W({ density: { type: String, default: 'default', validator: (e) => t8.includes(e) } }, 'density')
function Un(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  return { densityClasses: k(() => `${t}--density-${e.density}`) }
}
const n8 = ['elevated', 'flat', 'tonal', 'outlined', 'text', 'plain']
function Ks(e, t) {
  return g(ke, null, [
    e && g('span', { key: 'overlay', class: `${t}__overlay` }, null),
    g('span', { key: 'underlay', class: `${t}__underlay` }, null),
  ])
}
const Mi = W(
  { color: String, variant: { type: String, default: 'elevated', validator: (e) => n8.includes(e) } },
  'variant'
)
function ma(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  const n = k(() => {
      const { variant: s } = Lt(e)
      return `${t}--variant-${s}`
    }),
    { colorClasses: i, colorStyles: r } = zb(
      k(() => {
        const { variant: s, color: o } = Lt(e)
        return { [['elevated', 'flat'].includes(s) ? 'background' : 'text']: o }
      })
    )
  return { colorClasses: i, colorStyles: r, variantClasses: n }
}
const gD = W(
    { baseColor: String, divided: Boolean, ...bi(), ...Te(), ...ln(), ...en(), ...Tt(), ...He(), ...Ze(), ...Mi() },
    'VBtnGroup'
  ),
  qp = ne()({
    name: 'VBtnGroup',
    props: gD(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { densityClasses: r } = Un(e),
        { borderClasses: s } = Oi(e),
        { elevationClasses: o } = yn(e),
        { roundedClasses: a } = Mt(e)
      Ot({
        VBtn: {
          height: 'auto',
          baseColor: Q(e, 'baseColor'),
          color: Q(e, 'color'),
          density: Q(e, 'density'),
          flat: !0,
          variant: Q(e, 'variant'),
        },
      }),
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-btn-group',
                { 'v-btn-group--divided': e.divided },
                i.value,
                s.value,
                r.value,
                o.value,
                a.value,
                e.class,
              ],
              style: e.style,
            },
            n
          )
        )
    },
  }),
  ga = W(
    {
      modelValue: { type: null, default: void 0 },
      multiple: Boolean,
      mandatory: [Boolean, String],
      max: Number,
      selectedClass: String,
      disabled: Boolean,
    },
    'group'
  ),
  va = W({ value: null, disabled: Boolean, selectedClass: String }, 'group-item')
function pa(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
  const i = Ut('useGroupItem')
  if (!i) throw new Error('[Vuetify] useGroupItem composable must be used inside a component setup function')
  const r = pn()
  mt(Symbol.for(`${t.description}:id`), r)
  const s = je(t, null)
  if (!s) {
    if (!n) return s
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`)
  }
  const o = Q(e, 'value'),
    a = k(() => !!(s.disabled.value || e.disabled))
  s.register({ id: r, value: o, disabled: a }, i),
    kn(() => {
      s.unregister(r)
    })
  const l = k(() => s.isSelected(r)),
    u = k(() => s.items.value[0].id === r),
    c = k(() => s.items.value[s.items.value.length - 1].id === r),
    d = k(() => l.value && [s.selectedClass.value, e.selectedClass])
  return (
    be(
      l,
      (f) => {
        i.emit('group:selected', { value: f })
      },
      { flush: 'sync' }
    ),
    {
      id: r,
      isSelected: l,
      isFirst: u,
      isLast: c,
      toggle: () => s.select(r, !l.value),
      select: (f) => s.select(r, f),
      selectedClass: d,
      value: o,
      disabled: a,
      group: s,
    }
  )
}
function Ys(e, t) {
  let n = !1
  const i = wn([]),
    r = xe(
      e,
      'modelValue',
      [],
      (f) => (f == null ? [] : vD(i, Pt(f))),
      (f) => {
        const m = r8(i, f)
        return e.multiple ? m : m[0]
      }
    ),
    s = Ut('useGroup')
  function o(f, m) {
    const p = f,
      v = Symbol.for(`${t.description}:id`),
      T = Ga(v, s == null ? void 0 : s.vnode).indexOf(m)
    Lt(p.value) == null && ((p.value = T), (p.useIndexAsValue = !0)), T > -1 ? i.splice(T, 0, p) : i.push(p)
  }
  function a(f) {
    if (n) return
    l()
    const m = i.findIndex((p) => p.id === f)
    i.splice(m, 1)
  }
  function l() {
    const f = i.find((m) => !m.disabled)
    f && e.mandatory === 'force' && !r.value.length && (r.value = [f.id])
  }
  An(() => {
    l()
  }),
    kn(() => {
      n = !0
    }),
    Ny(() => {
      for (let f = 0; f < i.length; f++) i[f].useIndexAsValue && (i[f].value = f)
    })
  function u(f, m) {
    const p = i.find((v) => v.id === f)
    if (!(m && p != null && p.disabled))
      if (e.multiple) {
        const v = r.value.slice(),
          y = v.findIndex((A) => A === f),
          T = ~y
        if (((m = m ?? !T), (T && e.mandatory && v.length <= 1) || (!T && e.max != null && v.length + 1 > e.max)))
          return
        y < 0 && m ? v.push(f) : y >= 0 && !m && v.splice(y, 1), (r.value = v)
      } else {
        const v = r.value.includes(f)
        if (e.mandatory && v) return
        r.value = m ?? !v ? [f] : []
      }
  }
  function c(f) {
    if ((e.multiple, r.value.length)) {
      const m = r.value[0],
        p = i.findIndex((T) => T.id === m)
      let v = (p + f) % i.length,
        y = i[v]
      for (; y.disabled && v !== p; ) (v = (v + f) % i.length), (y = i[v])
      if (y.disabled) return
      r.value = [i[v].id]
    } else {
      const m = i.find((p) => !p.disabled)
      m && (r.value = [m.id])
    }
  }
  const d = {
    register: o,
    unregister: a,
    selected: r,
    select: u,
    disabled: Q(e, 'disabled'),
    prev: () => c(i.length - 1),
    next: () => c(1),
    isSelected: (f) => r.value.includes(f),
    selectedClass: k(() => e.selectedClass),
    items: k(() => i),
    getItemIndex: (f) => i8(i, f),
  }
  return mt(t, d), d
}
function i8(e, t) {
  const n = vD(e, [t])
  return n.length ? e.findIndex((i) => i.id === n[0]) : -1
}
function vD(e, t) {
  const n = []
  return (
    t.forEach((i) => {
      const r = e.find((o) => vr(i, o.value)),
        s = e[i]
      ;(r == null ? void 0 : r.value) != null ? n.push(r.id) : s != null && n.push(s.id)
    }),
    n
  )
}
function r8(e, t) {
  const n = []
  return (
    t.forEach((i) => {
      const r = e.findIndex((s) => s.id === i)
      if (~r) {
        const s = e[r]
        n.push(s.value != null ? s.value : r)
      }
    }),
    n
  )
}
const Hb = Symbol.for('vuetify:v-btn-toggle'),
  s8 = W({ ...gD(), ...ga() }, 'VBtnToggle'),
  o8 = ne()({
    name: 'VBtnToggle',
    props: s8(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isSelected: i, next: r, prev: s, select: o, selected: a } = Ys(e, Hb)
      return (
        se(() => {
          const l = qp.filterProps(e)
          return g(qp, ae({ class: ['v-btn-toggle', e.class] }, l, { style: e.style }), {
            default: () => {
              var u
              return [
                (u = n.default) == null
                  ? void 0
                  : u.call(n, { isSelected: i, next: r, prev: s, select: o, selected: a }),
              ]
            },
          })
        }),
        { next: r, prev: s, select: o }
      )
    },
  }),
  a8 = ['x-small', 'small', 'default', 'large', 'x-large'],
  _r = W({ size: { type: [String, Number], default: 'default' } }, 'size')
function Wl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  return Pb(() => {
    let n, i
    return (
      bf(a8, e.size) ? (n = `${t}--size-${e.size}`) : e.size && (i = { width: Se(e.size), height: Se(e.size) }),
      { sizeClasses: n, sizeStyles: i }
    )
  })
}
const l8 = W(
    {
      color: String,
      disabled: Boolean,
      start: Boolean,
      end: Boolean,
      icon: Le,
      ...Te(),
      ..._r(),
      ...He({ tag: 'i' }),
      ...Ze(),
    },
    'VIcon'
  ),
  ot = ne()({
    name: 'VIcon',
    props: l8(),
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const r = le(),
        { themeClasses: s } = at(e),
        { iconData: o } = k7(k(() => r.value || e.icon)),
        { sizeClasses: a } = Wl(e),
        { textColorClasses: l, textColorStyles: u } = Tn(Q(e, 'color'))
      return (
        se(() => {
          var f, m
          const c = (f = i.default) == null ? void 0 : f.call(i)
          c &&
            (r.value =
              (m = AV(c).filter((p) => p.type === Bc && p.children && typeof p.children == 'string')[0]) == null
                ? void 0
                : m.children)
          const d = !!(n.onClick || n.onClickOnce)
          return g(
            o.value.component,
            {
              tag: e.tag,
              icon: o.value.icon,
              class: [
                'v-icon',
                'notranslate',
                s.value,
                a.value,
                l.value,
                {
                  'v-icon--clickable': d,
                  'v-icon--disabled': e.disabled,
                  'v-icon--start': e.start,
                  'v-icon--end': e.end,
                },
                e.class,
              ],
              style: [
                a.value ? void 0 : { fontSize: Se(e.size), height: Se(e.size), width: Se(e.size) },
                u.value,
                e.style,
              ],
              role: d ? 'button' : void 0,
              'aria-hidden': !d,
              tabindex: d ? (e.disabled ? -1 : 0) : void 0,
            },
            { default: () => [c] }
          )
        }),
        {}
      )
    },
  })
function Dm(e, t) {
  const n = le(),
    i = ye(!1)
  if (Cb) {
    const r = new IntersectionObserver((s) => {
      e == null || e(s, r), (i.value = !!s.find((o) => o.isIntersecting))
    }, t)
    kn(() => {
      r.disconnect()
    }),
      be(
        n,
        (s, o) => {
          o && (r.unobserve(o), (i.value = !1)), s && r.observe(s)
        },
        { flush: 'post' }
      )
  }
  return { intersectionRef: n, isIntersecting: i }
}
const u8 = W(
    {
      bgColor: String,
      color: String,
      indeterminate: [Boolean, String],
      modelValue: { type: [Number, String], default: 0 },
      rotate: { type: [Number, String], default: 0 },
      width: { type: [Number, String], default: 4 },
      ...Te(),
      ..._r(),
      ...He({ tag: 'div' }),
      ...Ze(),
    },
    'VProgressCircular'
  ),
  Rl = ne()({
    name: 'VProgressCircular',
    props: u8(),
    setup(e, t) {
      let { slots: n } = t
      const i = 20,
        r = 2 * Math.PI * i,
        s = le(),
        { themeClasses: o } = at(e),
        { sizeClasses: a, sizeStyles: l } = Wl(e),
        { textColorClasses: u, textColorStyles: c } = Tn(Q(e, 'color')),
        { textColorClasses: d, textColorStyles: f } = Tn(Q(e, 'bgColor')),
        { intersectionRef: m, isIntersecting: p } = Dm(),
        { resizeRef: v, contentRect: y } = Gi(),
        T = k(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))),
        A = k(() => Number(e.width)),
        x = k(() => (l.value ? Number(e.size) : y.value ? y.value.width : Math.max(A.value, 32))),
        N = k(() => (i / (1 - A.value / x.value)) * 2),
        V = k(() => (A.value / x.value) * N.value),
        D = k(() => Se(((100 - T.value) / 100) * r))
      return (
        $t(() => {
          ;(m.value = s.value), (v.value = s.value)
        }),
        se(() =>
          g(
            e.tag,
            {
              ref: s,
              class: [
                'v-progress-circular',
                {
                  'v-progress-circular--indeterminate': !!e.indeterminate,
                  'v-progress-circular--visible': p.value,
                  'v-progress-circular--disable-shrink': e.indeterminate === 'disable-shrink',
                },
                o.value,
                a.value,
                u.value,
                e.class,
              ],
              style: [l.value, c.value, e.style],
              role: 'progressbar',
              'aria-valuemin': '0',
              'aria-valuemax': '100',
              'aria-valuenow': e.indeterminate ? void 0 : T.value,
            },
            {
              default: () => [
                g(
                  'svg',
                  {
                    style: { transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))` },
                    xmlns: 'http://www.w3.org/2000/svg',
                    viewBox: `0 0 ${N.value} ${N.value}`,
                  },
                  [
                    g(
                      'circle',
                      {
                        class: ['v-progress-circular__underlay', d.value],
                        style: f.value,
                        fill: 'transparent',
                        cx: '50%',
                        cy: '50%',
                        r: i,
                        'stroke-width': V.value,
                        'stroke-dasharray': r,
                        'stroke-dashoffset': 0,
                      },
                      null
                    ),
                    g(
                      'circle',
                      {
                        class: 'v-progress-circular__overlay',
                        fill: 'transparent',
                        cx: '50%',
                        cy: '50%',
                        r: i,
                        'stroke-width': V.value,
                        'stroke-dasharray': r,
                        'stroke-dashoffset': D.value,
                      },
                      null
                    ),
                  ]
                ),
                n.default && g('div', { class: 'v-progress-circular__content' }, [n.default({ value: T.value })]),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  MT = { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' },
  Kr = W({ location: String }, 'location')
function ya(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n = arguments.length > 2 ? arguments[2] : void 0
  const { isRtl: i } = sn()
  return {
    locationStyles: k(() => {
      if (!e.location) return {}
      const { side: s, align: o } = Mp(e.location.split(' ').length > 1 ? e.location : `${e.location} center`, i.value)
      function a(u) {
        return n ? n(u) : 0
      }
      const l = {}
      return (
        s !== 'center' && (t ? (l[MT[s]] = `calc(100% - ${a(s)}px)`) : (l[s] = 0)),
        o !== 'center'
          ? t
            ? (l[MT[o]] = `calc(100% - ${a(o)}px)`)
            : (l[o] = 0)
          : (s === 'center'
              ? (l.top = l.left = '50%')
              : (l[{ top: 'left', bottom: 'left', left: 'top', right: 'top' }[s]] = '50%'),
            (l.transform = {
              top: 'translateX(-50%)',
              bottom: 'translateX(-50%)',
              left: 'translateY(-50%)',
              right: 'translateY(-50%)',
              center: 'translate(-50%, -50%)',
            }[s])),
        l
      )
    }),
  }
}
const c8 = W(
    {
      absolute: Boolean,
      active: { type: Boolean, default: !0 },
      bgColor: String,
      bgOpacity: [Number, String],
      bufferValue: { type: [Number, String], default: 0 },
      bufferColor: String,
      bufferOpacity: [Number, String],
      clickable: Boolean,
      color: String,
      height: { type: [Number, String], default: 4 },
      indeterminate: Boolean,
      max: { type: [Number, String], default: 100 },
      modelValue: { type: [Number, String], default: 0 },
      opacity: [Number, String],
      reverse: Boolean,
      stream: Boolean,
      striped: Boolean,
      roundedBar: Boolean,
      ...Te(),
      ...Kr({ location: 'top' }),
      ...Tt(),
      ...He(),
      ...Ze(),
    },
    'VProgressLinear'
  ),
  Nm = ne()({
    name: 'VProgressLinear',
    props: c8(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      var E
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        { isRtl: r, rtlClasses: s } = sn(),
        { themeClasses: o } = at(e),
        { locationStyles: a } = ya(e),
        { textColorClasses: l, textColorStyles: u } = Tn(e, 'color'),
        { backgroundColorClasses: c, backgroundColorStyles: d } = gt(k(() => e.bgColor || e.color)),
        { backgroundColorClasses: f, backgroundColorStyles: m } = gt(k(() => e.bufferColor || e.bgColor || e.color)),
        { backgroundColorClasses: p, backgroundColorStyles: v } = gt(e, 'color'),
        { roundedClasses: y } = Mt(e),
        { intersectionRef: T, isIntersecting: A } = Dm(),
        x = k(() => parseFloat(e.max)),
        N = k(() => parseFloat(e.height)),
        V = k(() => qt((parseFloat(e.bufferValue) / x.value) * 100, 0, 100)),
        D = k(() => qt((parseFloat(i.value) / x.value) * 100, 0, 100)),
        I = k(() => r.value !== e.reverse),
        w = k(() => (e.indeterminate ? 'fade-transition' : 'slide-x-transition')),
        _ = ct && ((E = window.matchMedia) == null ? void 0 : E.call(window, '(forced-colors: active)').matches)
      function S(C) {
        if (!T.value) return
        const { left: R, right: B, width: U } = T.value.getBoundingClientRect(),
          $ = I.value ? U - C.clientX + (B - U) : C.clientX - R
        i.value = Math.round(($ / U) * x.value)
      }
      return (
        se(() =>
          g(
            e.tag,
            {
              ref: T,
              class: [
                'v-progress-linear',
                {
                  'v-progress-linear--absolute': e.absolute,
                  'v-progress-linear--active': e.active && A.value,
                  'v-progress-linear--reverse': I.value,
                  'v-progress-linear--rounded': e.rounded,
                  'v-progress-linear--rounded-bar': e.roundedBar,
                  'v-progress-linear--striped': e.striped,
                },
                y.value,
                o.value,
                s.value,
                e.class,
              ],
              style: [
                {
                  bottom: e.location === 'bottom' ? 0 : void 0,
                  top: e.location === 'top' ? 0 : void 0,
                  height: e.active ? Se(N.value) : 0,
                  '--v-progress-linear-height': Se(N.value),
                  ...(e.absolute ? a.value : {}),
                },
                e.style,
              ],
              role: 'progressbar',
              'aria-hidden': e.active ? 'false' : 'true',
              'aria-valuemin': '0',
              'aria-valuemax': e.max,
              'aria-valuenow': e.indeterminate ? void 0 : D.value,
              onClick: e.clickable && S,
            },
            {
              default: () => [
                e.stream &&
                  g(
                    'div',
                    {
                      key: 'stream',
                      class: ['v-progress-linear__stream', l.value],
                      style: {
                        ...u.value,
                        [I.value ? 'left' : 'right']: Se(-N.value),
                        borderTop: `${Se(N.value / 2)} dotted`,
                        opacity: parseFloat(e.bufferOpacity),
                        top: `calc(50% - ${Se(N.value / 4)})`,
                        width: Se(100 - V.value, '%'),
                        '--v-progress-linear-stream-to': Se(N.value * (I.value ? 1 : -1)),
                      },
                    },
                    null
                  ),
                g(
                  'div',
                  {
                    class: ['v-progress-linear__background', _ ? void 0 : c.value],
                    style: [d.value, { opacity: parseFloat(e.bgOpacity), width: e.stream ? 0 : void 0 }],
                  },
                  null
                ),
                g(
                  'div',
                  {
                    class: ['v-progress-linear__buffer', _ ? void 0 : f.value],
                    style: [m.value, { opacity: parseFloat(e.bufferOpacity), width: Se(V.value, '%') }],
                  },
                  null
                ),
                g(
                  dr,
                  { name: w.value },
                  {
                    default: () => [
                      e.indeterminate
                        ? g('div', { class: 'v-progress-linear__indeterminate' }, [
                            ['long', 'short'].map((C) =>
                              g(
                                'div',
                                {
                                  key: C,
                                  class: ['v-progress-linear__indeterminate', C, _ ? void 0 : p.value],
                                  style: v.value,
                                },
                                null
                              )
                            ),
                          ])
                        : g(
                            'div',
                            {
                              class: ['v-progress-linear__determinate', _ ? void 0 : p.value],
                              style: [v.value, { width: Se(D.value, '%') }],
                            },
                            null
                          ),
                    ],
                  }
                ),
                n.default &&
                  g('div', { class: 'v-progress-linear__content' }, [n.default({ value: D.value, buffer: V.value })]),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  Om = W({ loading: [Boolean, String] }, 'loader')
function ud(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  return { loaderClasses: k(() => ({ [`${t}--loading`]: e.loading })) }
}
function cd(e, t) {
  var i
  let { slots: n } = t
  return g('div', { class: `${e.name}__loader` }, [
    ((i = n.default) == null ? void 0 : i.call(n, { color: e.color, isActive: e.active })) ||
      g(Nm, { absolute: e.absolute, active: e.active, color: e.color, height: '2', indeterminate: !0 }, null),
  ])
}
const d8 = ['static', 'relative', 'fixed', 'absolute', 'sticky'],
  ql = W({ position: { type: String, validator: (e) => d8.includes(e) } }, 'position')
function Gl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  return { positionClasses: k(() => (e.position ? `${t}--${e.position}` : void 0)) }
}
function h8() {
  const e = Ut('useRoute')
  return k(() => {
    var t
    return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route
  })
}
function pD() {
  var e, t
  return (t = (e = Ut('useRouter')) == null ? void 0 : e.proxy) == null ? void 0 : t.$router
}
function dd(e, t) {
  var u, c
  const n = mL('RouterLink'),
    i = k(() => !!(e.href || e.to)),
    r = k(() => (i == null ? void 0 : i.value) || sT(t, 'click') || sT(e, 'click'))
  if (typeof n == 'string' || !('useLink' in n)) return { isLink: i, isClickable: r, href: Q(e, 'href') }
  const s = k(() => ({ ...e, to: Q(() => e.to || '') })),
    o = n.useLink(s.value),
    a = k(() => (e.to ? o : void 0)),
    l = h8()
  return {
    isLink: i,
    isClickable: r,
    route: (u = a.value) == null ? void 0 : u.route,
    navigate: (c = a.value) == null ? void 0 : c.navigate,
    isActive: k(() => {
      var d, f, m
      return a.value
        ? e.exact
          ? l.value
            ? ((m = a.value.isExactActive) == null ? void 0 : m.value) && vr(a.value.route.value.query, l.value.query)
            : ((f = a.value.isExactActive) == null ? void 0 : f.value) ?? !1
          : ((d = a.value.isActive) == null ? void 0 : d.value) ?? !1
        : !1
    }),
    href: k(() => {
      var d
      return e.to ? ((d = a.value) == null ? void 0 : d.route.value.href) : e.href
    }),
  }
}
const hd = W({ href: String, replace: Boolean, to: [String, Object], exact: Boolean }, 'router')
let uv = !1
function f8(e, t) {
  let n = !1,
    i,
    r
  ct &&
    (Xe(() => {
      window.addEventListener('popstate', s),
        (i =
          e == null
            ? void 0
            : e.beforeEach((o, a, l) => {
                uv ? (n ? t(l) : l()) : setTimeout(() => (n ? t(l) : l())), (uv = !0)
              })),
        (r =
          e == null
            ? void 0
            : e.afterEach(() => {
                uv = !1
              }))
    }),
    gn(() => {
      window.removeEventListener('popstate', s), i == null || i(), r == null || r()
    }))
  function s(o) {
    var a
    ;((a = o.state) != null && a.replaced) || ((n = !0), setTimeout(() => (n = !1)))
  }
}
function m8(e, t) {
  be(
    () => {
      var n
      return (n = e.isActive) == null ? void 0 : n.value
    },
    (n) => {
      e.isLink.value &&
        n &&
        t &&
        Xe(() => {
          t(!0)
        })
    },
    { immediate: !0 }
  )
}
const Gp = Symbol('rippleStop'),
  g8 = 80
function LT(e, t) {
  ;(e.style.transform = t), (e.style.webkitTransform = t)
}
function Kp(e) {
  return e.constructor.name === 'TouchEvent'
}
function yD(e) {
  return e.constructor.name === 'KeyboardEvent'
}
const v8 = function (e, t) {
    var d
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i = 0,
      r = 0
    if (!yD(e)) {
      const f = t.getBoundingClientRect(),
        m = Kp(e) ? e.touches[e.touches.length - 1] : e
      ;(i = m.clientX - f.left), (r = m.clientY - f.top)
    }
    let s = 0,
      o = 0.3
    ;(d = t._ripple) != null && d.circle
      ? ((o = 0.15), (s = t.clientWidth / 2), (s = n.center ? s : s + Math.sqrt((i - s) ** 2 + (r - s) ** 2) / 4))
      : (s = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2)
    const a = `${(t.clientWidth - s * 2) / 2}px`,
      l = `${(t.clientHeight - s * 2) / 2}px`,
      u = n.center ? a : `${i - s}px`,
      c = n.center ? l : `${r - s}px`
    return { radius: s, scale: o, x: u, y: c, centerX: a, centerY: l }
  },
  Tf = {
    show(e, t) {
      var m
      let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      if (!((m = t == null ? void 0 : t._ripple) != null && m.enabled)) return
      const i = document.createElement('span'),
        r = document.createElement('span')
      i.appendChild(r), (i.className = 'v-ripple__container'), n.class && (i.className += ` ${n.class}`)
      const { radius: s, scale: o, x: a, y: l, centerX: u, centerY: c } = v8(e, t, n),
        d = `${s * 2}px`
      ;(r.className = 'v-ripple__animation'), (r.style.width = d), (r.style.height = d), t.appendChild(i)
      const f = window.getComputedStyle(t)
      f && f.position === 'static' && ((t.style.position = 'relative'), (t.dataset.previousPosition = 'static')),
        r.classList.add('v-ripple__animation--enter'),
        r.classList.add('v-ripple__animation--visible'),
        LT(r, `translate(${a}, ${l}) scale3d(${o},${o},${o})`),
        (r.dataset.activated = String(performance.now())),
        setTimeout(() => {
          r.classList.remove('v-ripple__animation--enter'),
            r.classList.add('v-ripple__animation--in'),
            LT(r, `translate(${u}, ${c}) scale3d(1,1,1)`)
        }, 0)
    },
    hide(e) {
      var s
      if (!((s = e == null ? void 0 : e._ripple) != null && s.enabled)) return
      const t = e.getElementsByClassName('v-ripple__animation')
      if (t.length === 0) return
      const n = t[t.length - 1]
      if (n.dataset.isHiding) return
      n.dataset.isHiding = 'true'
      const i = performance.now() - Number(n.dataset.activated),
        r = Math.max(250 - i, 0)
      setTimeout(() => {
        n.classList.remove('v-ripple__animation--in'),
          n.classList.add('v-ripple__animation--out'),
          setTimeout(() => {
            var a
            e.getElementsByClassName('v-ripple__animation').length === 1 &&
              e.dataset.previousPosition &&
              ((e.style.position = e.dataset.previousPosition), delete e.dataset.previousPosition),
              ((a = n.parentNode) == null ? void 0 : a.parentNode) === e && e.removeChild(n.parentNode)
          }, 300)
      }, r)
    },
  }
function _D(e) {
  return typeof e > 'u' || !!e
}
function Pc(e) {
  const t = {},
    n = e.currentTarget
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[Gp])) {
    if (((e[Gp] = !0), Kp(e))) (n._ripple.touched = !0), (n._ripple.isTouch = !0)
    else if (n._ripple.isTouch) return
    if (((t.center = n._ripple.centered || yD(e)), n._ripple.class && (t.class = n._ripple.class), Kp(e))) {
      if (n._ripple.showTimerCommit) return
      ;(n._ripple.showTimerCommit = () => {
        Tf.show(e, n, t)
      }),
        (n._ripple.showTimer = window.setTimeout(() => {
          var i
          ;(i = n == null ? void 0 : n._ripple) != null &&
            i.showTimerCommit &&
            (n._ripple.showTimerCommit(), (n._ripple.showTimerCommit = null))
        }, g8))
    } else Tf.show(e, n, t)
  }
}
function FT(e) {
  e[Gp] = !0
}
function ui(e) {
  const t = e.currentTarget
  if (t != null && t._ripple) {
    if ((window.clearTimeout(t._ripple.showTimer), e.type === 'touchend' && t._ripple.showTimerCommit)) {
      t._ripple.showTimerCommit(),
        (t._ripple.showTimerCommit = null),
        (t._ripple.showTimer = window.setTimeout(() => {
          ui(e)
        }))
      return
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1)
    }),
      Tf.hide(t)
  }
}
function bD(e) {
  const t = e.currentTarget
  t != null &&
    t._ripple &&
    (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer))
}
let Rc = !1
function wD(e) {
  !Rc && (e.keyCode === eT.enter || e.keyCode === eT.space) && ((Rc = !0), Pc(e))
}
function ID(e) {
  ;(Rc = !1), ui(e)
}
function SD(e) {
  Rc && ((Rc = !1), ui(e))
}
function ED(e, t, n) {
  const { value: i, modifiers: r } = t,
    s = _D(i)
  if (
    (s || Tf.hide(e),
    (e._ripple = e._ripple ?? {}),
    (e._ripple.enabled = s),
    (e._ripple.centered = r.center),
    (e._ripple.circle = r.circle),
    Sc(i) && i.class && (e._ripple.class = i.class),
    s && !n)
  ) {
    if (r.stop) {
      e.addEventListener('touchstart', FT, { passive: !0 }), e.addEventListener('mousedown', FT)
      return
    }
    e.addEventListener('touchstart', Pc, { passive: !0 }),
      e.addEventListener('touchend', ui, { passive: !0 }),
      e.addEventListener('touchmove', bD, { passive: !0 }),
      e.addEventListener('touchcancel', ui),
      e.addEventListener('mousedown', Pc),
      e.addEventListener('mouseup', ui),
      e.addEventListener('mouseleave', ui),
      e.addEventListener('keydown', wD),
      e.addEventListener('keyup', ID),
      e.addEventListener('blur', SD),
      e.addEventListener('dragstart', ui, { passive: !0 })
  } else !s && n && TD(e)
}
function TD(e) {
  e.removeEventListener('mousedown', Pc),
    e.removeEventListener('touchstart', Pc),
    e.removeEventListener('touchend', ui),
    e.removeEventListener('touchmove', bD),
    e.removeEventListener('touchcancel', ui),
    e.removeEventListener('mouseup', ui),
    e.removeEventListener('mouseleave', ui),
    e.removeEventListener('keydown', wD),
    e.removeEventListener('keyup', ID),
    e.removeEventListener('dragstart', ui),
    e.removeEventListener('blur', SD)
}
function p8(e, t) {
  ED(e, t, !1)
}
function y8(e) {
  delete e._ripple, TD(e)
}
function _8(e, t) {
  if (t.value === t.oldValue) return
  const n = _D(t.oldValue)
  ED(e, t, n)
}
const Yr = { mounted: p8, unmounted: y8, updated: _8 },
  Mm = W(
    {
      active: { type: Boolean, default: void 0 },
      baseColor: String,
      symbol: { type: null, default: Hb },
      flat: Boolean,
      icon: [Boolean, String, Function, Object],
      prependIcon: Le,
      appendIcon: Le,
      block: Boolean,
      readonly: Boolean,
      slim: Boolean,
      stacked: Boolean,
      ripple: { type: [Boolean, Object], default: !0 },
      text: String,
      ...bi(),
      ...Te(),
      ...ln(),
      ...on(),
      ...en(),
      ...va(),
      ...Om(),
      ...Kr(),
      ...ql(),
      ...Tt(),
      ...hd(),
      ..._r(),
      ...He({ tag: 'button' }),
      ...Ze(),
      ...Mi({ variant: 'elevated' }),
    },
    'VBtn'
  ),
  st = ne()({
    name: 'VBtn',
    props: Mm(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { themeClasses: r } = at(e),
        { borderClasses: s } = Oi(e),
        { densityClasses: o } = Un(e),
        { dimensionStyles: a } = an(e),
        { elevationClasses: l } = yn(e),
        { loaderClasses: u } = ud(e),
        { locationStyles: c } = ya(e),
        { positionClasses: d } = Gl(e),
        { roundedClasses: f } = Mt(e),
        { sizeClasses: m, sizeStyles: p } = Wl(e),
        v = pa(e, e.symbol, !1),
        y = dd(e, n),
        T = k(() => {
          var S
          return e.active !== void 0
            ? e.active
            : y.isLink.value
            ? (S = y.isActive) == null
              ? void 0
              : S.value
            : v == null
            ? void 0
            : v.isSelected.value
        }),
        A = k(() => {
          var E, C
          return {
            color:
              ((v == null ? void 0 : v.isSelected.value) &&
                (!y.isLink.value || ((E = y.isActive) == null ? void 0 : E.value))) ||
              !v ||
              ((C = y.isActive) == null ? void 0 : C.value)
                ? e.color ?? e.baseColor
                : e.baseColor,
            variant: e.variant,
          }
        }),
        { colorClasses: x, colorStyles: N, variantClasses: V } = ma(A),
        D = k(() => (v == null ? void 0 : v.disabled.value) || e.disabled),
        I = k(() => e.variant === 'elevated' && !(e.disabled || e.flat || e.border)),
        w = k(() => {
          if (!(e.value === void 0 || typeof e.value == 'symbol'))
            return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value
        })
      function _(S) {
        var E
        D.value ||
          (y.isLink.value && (S.metaKey || S.ctrlKey || S.shiftKey || S.button !== 0 || n.target === '_blank')) ||
          ((E = y.navigate) == null || E.call(y, S), v == null || v.toggle())
      }
      return (
        m8(y, v == null ? void 0 : v.select),
        se(() => {
          const S = y.isLink.value ? 'a' : e.tag,
            E = !!(e.prependIcon || i.prepend),
            C = !!(e.appendIcon || i.append),
            R = !!(e.icon && e.icon !== !0)
          return Rt(
            g(
              S,
              {
                type: S === 'a' ? void 0 : 'button',
                class: [
                  'v-btn',
                  v == null ? void 0 : v.selectedClass.value,
                  {
                    'v-btn--active': T.value,
                    'v-btn--block': e.block,
                    'v-btn--disabled': D.value,
                    'v-btn--elevated': I.value,
                    'v-btn--flat': e.flat,
                    'v-btn--icon': !!e.icon,
                    'v-btn--loading': e.loading,
                    'v-btn--readonly': e.readonly,
                    'v-btn--slim': e.slim,
                    'v-btn--stacked': e.stacked,
                  },
                  r.value,
                  s.value,
                  x.value,
                  o.value,
                  l.value,
                  u.value,
                  d.value,
                  f.value,
                  m.value,
                  V.value,
                  e.class,
                ],
                style: [N.value, a.value, c.value, p.value, e.style],
                'aria-busy': e.loading ? !0 : void 0,
                disabled: D.value || void 0,
                href: y.href.value,
                tabindex: e.loading || e.readonly ? -1 : void 0,
                onClick: _,
                value: w.value,
              },
              {
                default: () => {
                  var B
                  return [
                    Ks(!0, 'v-btn'),
                    !e.icon &&
                      E &&
                      g('span', { key: 'prepend', class: 'v-btn__prepend' }, [
                        i.prepend
                          ? g(
                              Ge,
                              {
                                key: 'prepend-defaults',
                                disabled: !e.prependIcon,
                                defaults: { VIcon: { icon: e.prependIcon } },
                              },
                              i.prepend
                            )
                          : g(ot, { key: 'prepend-icon', icon: e.prependIcon }, null),
                      ]),
                    g('span', { class: 'v-btn__content', 'data-no-activator': '' }, [
                      !i.default && R
                        ? g(ot, { key: 'content-icon', icon: e.icon }, null)
                        : g(
                            Ge,
                            { key: 'content-defaults', disabled: !R, defaults: { VIcon: { icon: e.icon } } },
                            {
                              default: () => {
                                var U
                                return [((U = i.default) == null ? void 0 : U.call(i)) ?? e.text]
                              },
                            }
                          ),
                    ]),
                    !e.icon &&
                      C &&
                      g('span', { key: 'append', class: 'v-btn__append' }, [
                        i.append
                          ? g(
                              Ge,
                              {
                                key: 'append-defaults',
                                disabled: !e.appendIcon,
                                defaults: { VIcon: { icon: e.appendIcon } },
                              },
                              i.append
                            )
                          : g(ot, { key: 'append-icon', icon: e.appendIcon }, null),
                      ]),
                    !!e.loading &&
                      g('span', { key: 'loader', class: 'v-btn__loader' }, [
                        ((B = i.loader) == null ? void 0 : B.call(i)) ??
                          g(
                            Rl,
                            {
                              color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                              indeterminate: !0,
                              width: '2',
                            },
                            null
                          ),
                      ]),
                  ]
                },
              }
            ),
            [[Yr, !D.value && !!e.ripple, '', { center: !!e.icon }]]
          )
        }),
        { group: v }
      )
    },
  }),
  b8 = W({ ...Mm({ icon: '$menu', variant: 'text' }) }, 'VAppBarNavIcon'),
  w8 = ne()({
    name: 'VAppBarNavIcon',
    props: b8(),
    setup(e, t) {
      let { slots: n } = t
      return se(() => g(st, ae(e, { class: ['v-app-bar-nav-icon'] }), n)), {}
    },
  }),
  I8 = ne()({
    name: 'VAppBarTitle',
    props: lD(),
    setup(e, t) {
      let { slots: n } = t
      return se(() => g(Bb, ae(e, { class: 'v-app-bar-title' }), n)), {}
    },
  }),
  CD = yr('v-alert-title'),
  S8 = ['success', 'info', 'warning', 'error'],
  E8 = W(
    {
      border: {
        type: [Boolean, String],
        validator: (e) => typeof e == 'boolean' || ['top', 'end', 'bottom', 'start'].includes(e),
      },
      borderColor: String,
      closable: Boolean,
      closeIcon: { type: Le, default: '$close' },
      closeLabel: { type: String, default: '$vuetify.close' },
      icon: { type: [Boolean, String, Function, Object], default: null },
      modelValue: { type: Boolean, default: !0 },
      prominent: Boolean,
      title: String,
      text: String,
      type: { type: String, validator: (e) => S8.includes(e) },
      ...Te(),
      ...ln(),
      ...on(),
      ...en(),
      ...Kr(),
      ...ql(),
      ...Tt(),
      ...He(),
      ...Ze(),
      ...Mi({ variant: 'flat' }),
    },
    'VAlert'
  ),
  T8 = ne()({
    name: 'VAlert',
    props: E8(),
    emits: { 'click:close': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const r = xe(e, 'modelValue'),
        s = k(() => {
          if (e.icon !== !1) return e.type ? e.icon ?? `$${e.type}` : e.icon
        }),
        o = k(() => ({ color: e.color ?? e.type, variant: e.variant })),
        { themeClasses: a } = at(e),
        { colorClasses: l, colorStyles: u, variantClasses: c } = ma(o),
        { densityClasses: d } = Un(e),
        { dimensionStyles: f } = an(e),
        { elevationClasses: m } = yn(e),
        { locationStyles: p } = ya(e),
        { positionClasses: v } = Gl(e),
        { roundedClasses: y } = Mt(e),
        { textColorClasses: T, textColorStyles: A } = Tn(Q(e, 'borderColor')),
        { t: x } = jt(),
        N = k(() => ({
          'aria-label': x(e.closeLabel),
          onClick(V) {
            ;(r.value = !1), n('click:close', V)
          },
        }))
      return () => {
        const V = !!(i.prepend || s.value),
          D = !!(i.title || e.title),
          I = !!(i.close || e.closable)
        return (
          r.value &&
          g(
            e.tag,
            {
              class: [
                'v-alert',
                e.border && {
                  'v-alert--border': !!e.border,
                  [`v-alert--border-${e.border === !0 ? 'start' : e.border}`]: !0,
                },
                { 'v-alert--prominent': e.prominent },
                a.value,
                l.value,
                d.value,
                m.value,
                v.value,
                y.value,
                c.value,
                e.class,
              ],
              style: [u.value, f.value, p.value, e.style],
              role: 'alert',
            },
            {
              default: () => {
                var w, _
                return [
                  Ks(!1, 'v-alert'),
                  e.border && g('div', { key: 'border', class: ['v-alert__border', T.value], style: A.value }, null),
                  V &&
                    g('div', { key: 'prepend', class: 'v-alert__prepend' }, [
                      i.prepend
                        ? g(
                            Ge,
                            {
                              key: 'prepend-defaults',
                              disabled: !s.value,
                              defaults: { VIcon: { density: e.density, icon: s.value, size: e.prominent ? 44 : 28 } },
                            },
                            i.prepend
                          )
                        : g(
                            ot,
                            { key: 'prepend-icon', density: e.density, icon: s.value, size: e.prominent ? 44 : 28 },
                            null
                          ),
                    ]),
                  g('div', { class: 'v-alert__content' }, [
                    D &&
                      g(
                        CD,
                        { key: 'title' },
                        {
                          default: () => {
                            var S
                            return [((S = i.title) == null ? void 0 : S.call(i)) ?? e.title]
                          },
                        }
                      ),
                    ((w = i.text) == null ? void 0 : w.call(i)) ?? e.text,
                    (_ = i.default) == null ? void 0 : _.call(i),
                  ]),
                  i.append && g('div', { key: 'append', class: 'v-alert__append' }, [i.append()]),
                  I &&
                    g('div', { key: 'close', class: 'v-alert__close' }, [
                      i.close
                        ? g(
                            Ge,
                            {
                              key: 'close-defaults',
                              defaults: { VBtn: { icon: e.closeIcon, size: 'x-small', variant: 'text' } },
                            },
                            {
                              default: () => {
                                var S
                                return [(S = i.close) == null ? void 0 : S.call(i, { props: N.value })]
                              },
                            }
                          )
                        : g(
                            st,
                            ae({ key: 'close-btn', icon: e.closeIcon, size: 'x-small', variant: 'text' }, N.value),
                            null
                          ),
                    ]),
                ]
              },
            }
          )
        )
      }
    },
  }),
  C8 = W(
    {
      start: Boolean,
      end: Boolean,
      icon: Le,
      image: String,
      text: String,
      ...Te(),
      ...ln(),
      ...Tt(),
      ..._r(),
      ...He(),
      ...Ze(),
      ...Mi({ variant: 'flat' }),
    },
    'VAvatar'
  ),
  Vi = ne()({
    name: 'VAvatar',
    props: C8(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { colorClasses: r, colorStyles: s, variantClasses: o } = ma(e),
        { densityClasses: a } = Un(e),
        { roundedClasses: l } = Mt(e),
        { sizeClasses: u, sizeStyles: c } = Wl(e)
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-avatar',
                { 'v-avatar--start': e.start, 'v-avatar--end': e.end },
                i.value,
                r.value,
                a.value,
                l.value,
                u.value,
                o.value,
                e.class,
              ],
              style: [s.value, c.value, e.style],
            },
            {
              default: () => [
                n.default
                  ? g(
                      Ge,
                      {
                        key: 'content-defaults',
                        defaults: { VImg: { cover: !0, image: e.image }, VIcon: { icon: e.icon } },
                      },
                      { default: () => [n.default()] }
                    )
                  : e.image
                  ? g(Br, { key: 'image', src: e.image, alt: '', cover: !0 }, null)
                  : e.icon
                  ? g(ot, { key: 'icon', icon: e.icon }, null)
                  : e.text,
                Ks(!1, 'v-avatar'),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  A8 = W({ text: String, onClick: mn(), ...Te(), ...Ze() }, 'VLabel'),
  Kl = ne()({
    name: 'VLabel',
    props: A8(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() => {
          var i
          return g(
            'label',
            { class: ['v-label', { 'v-label--clickable': !!e.onClick }, e.class], style: e.style, onClick: e.onClick },
            [e.text, (i = n.default) == null ? void 0 : i.call(n)]
          )
        }),
        {}
      )
    },
  }),
  AD = Symbol.for('vuetify:selection-control-group'),
  Wb = W(
    {
      color: String,
      disabled: { type: Boolean, default: null },
      defaultsTarget: String,
      error: Boolean,
      id: String,
      inline: Boolean,
      falseIcon: Le,
      trueIcon: Le,
      ripple: { type: [Boolean, Object], default: !0 },
      multiple: { type: Boolean, default: null },
      name: String,
      readonly: { type: Boolean, default: null },
      modelValue: null,
      type: String,
      valueComparator: { type: Function, default: vr },
      ...Te(),
      ...ln(),
      ...Ze(),
    },
    'SelectionControlGroup'
  ),
  k8 = W({ ...Wb({ defaultsTarget: 'VSelectionControl' }) }, 'VSelectionControlGroup'),
  kD = ne()({
    name: 'VSelectionControlGroup',
    props: k8(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        r = pn(),
        s = k(() => e.id || `v-selection-control-group-${r}`),
        o = k(() => e.name || s.value),
        a = new Set()
      return (
        mt(AD, {
          modelValue: i,
          forceUpdate: () => {
            a.forEach((l) => l())
          },
          onForceUpdate: (l) => {
            a.add(l),
              gn(() => {
                a.delete(l)
              })
          },
        }),
        Ot({
          [e.defaultsTarget]: {
            color: Q(e, 'color'),
            disabled: Q(e, 'disabled'),
            density: Q(e, 'density'),
            error: Q(e, 'error'),
            inline: Q(e, 'inline'),
            modelValue: i,
            multiple: k(() => !!e.multiple || (e.multiple == null && Array.isArray(i.value))),
            name: o,
            falseIcon: Q(e, 'falseIcon'),
            trueIcon: Q(e, 'trueIcon'),
            readonly: Q(e, 'readonly'),
            ripple: Q(e, 'ripple'),
            type: Q(e, 'type'),
            valueComparator: Q(e, 'valueComparator'),
          },
        }),
        se(() => {
          var l
          return g(
            'div',
            {
              class: ['v-selection-control-group', { 'v-selection-control-group--inline': e.inline }, e.class],
              style: e.style,
              role: e.type === 'radio' ? 'radiogroup' : void 0,
            },
            [(l = n.default) == null ? void 0 : l.call(n)]
          )
        }),
        {}
      )
    },
  }),
  Lm = W(
    { label: String, baseColor: String, trueValue: null, falseValue: null, value: null, ...Te(), ...Wb() },
    'VSelectionControl'
  )
function P8(e) {
  const t = je(AD, void 0),
    { densityClasses: n } = Un(e),
    i = xe(e, 'modelValue'),
    r = k(() => (e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0)),
    s = k(() => (e.falseValue !== void 0 ? e.falseValue : !1)),
    o = k(() => !!e.multiple || (e.multiple == null && Array.isArray(i.value))),
    a = k({
      get() {
        const m = t ? t.modelValue.value : i.value
        return o.value ? Pt(m).some((p) => e.valueComparator(p, r.value)) : e.valueComparator(m, r.value)
      },
      set(m) {
        if (e.readonly) return
        const p = m ? r.value : s.value
        let v = p
        o.value && (v = m ? [...Pt(i.value), p] : Pt(i.value).filter((y) => !e.valueComparator(y, r.value))),
          t ? (t.modelValue.value = v) : (i.value = v)
      },
    }),
    { textColorClasses: l, textColorStyles: u } = Tn(
      k(() => {
        if (!(e.error || e.disabled)) return a.value ? e.color : e.baseColor
      })
    ),
    { backgroundColorClasses: c, backgroundColorStyles: d } = gt(
      k(() => (a.value && !e.error && !e.disabled ? e.color : e.baseColor))
    ),
    f = k(() => (a.value ? e.trueIcon : e.falseIcon))
  return {
    group: t,
    densityClasses: n,
    trueValue: r,
    falseValue: s,
    model: a,
    textColorClasses: l,
    textColorStyles: u,
    backgroundColorClasses: c,
    backgroundColorStyles: d,
    icon: f,
  }
}
const Fs = ne()({
    name: 'VSelectionControl',
    directives: { Ripple: Yr },
    inheritAttrs: !1,
    props: Lm(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const {
          group: r,
          densityClasses: s,
          icon: o,
          model: a,
          textColorClasses: l,
          textColorStyles: u,
          backgroundColorClasses: c,
          backgroundColorStyles: d,
          trueValue: f,
        } = P8(e),
        m = pn(),
        p = ye(!1),
        v = ye(!1),
        y = le(),
        T = k(() => e.id || `input-${m}`),
        A = k(() => !e.disabled && !e.readonly)
      r == null ||
        r.onForceUpdate(() => {
          y.value && (y.value.checked = a.value)
        })
      function x(I) {
        A.value && ((p.value = !0), Al(I.target, ':focus-visible') !== !1 && (v.value = !0))
      }
      function N() {
        ;(p.value = !1), (v.value = !1)
      }
      function V(I) {
        I.stopPropagation()
      }
      function D(I) {
        if (!A.value) {
          y.value && (y.value.checked = a.value)
          return
        }
        e.readonly && r && Xe(() => r.forceUpdate()), (a.value = I.target.checked)
      }
      return (
        se(() => {
          var E, C
          const I = i.label ? i.label({ label: e.label, props: { for: T.value } }) : e.label,
            [w, _] = Gs(n),
            S = g(
              'input',
              ae(
                {
                  ref: y,
                  checked: a.value,
                  disabled: !!e.disabled,
                  id: T.value,
                  onBlur: N,
                  onFocus: x,
                  onInput: D,
                  'aria-disabled': !!e.disabled,
                  'aria-label': e.label,
                  type: e.type,
                  value: f.value,
                  name: e.name,
                  'aria-checked': e.type === 'checkbox' ? a.value : void 0,
                },
                _
              ),
              null
            )
          return g(
            'div',
            ae(
              {
                class: [
                  'v-selection-control',
                  {
                    'v-selection-control--dirty': a.value,
                    'v-selection-control--disabled': e.disabled,
                    'v-selection-control--error': e.error,
                    'v-selection-control--focused': p.value,
                    'v-selection-control--focus-visible': v.value,
                    'v-selection-control--inline': e.inline,
                  },
                  s.value,
                  e.class,
                ],
              },
              w,
              { style: e.style }
            ),
            [
              g('div', { class: ['v-selection-control__wrapper', l.value], style: u.value }, [
                (E = i.default) == null ? void 0 : E.call(i, { backgroundColorClasses: c, backgroundColorStyles: d }),
                Rt(
                  g('div', { class: ['v-selection-control__input'] }, [
                    ((C = i.input) == null
                      ? void 0
                      : C.call(i, {
                          model: a,
                          textColorClasses: l,
                          textColorStyles: u,
                          backgroundColorClasses: c,
                          backgroundColorStyles: d,
                          inputNode: S,
                          icon: o.value,
                          props: { onFocus: x, onBlur: N, id: T.value },
                        })) ?? g(ke, null, [o.value && g(ot, { key: 'icon', icon: o.value }, null), S]),
                  ]),
                  [[pi('ripple'), e.ripple && [!e.disabled && !e.readonly, null, ['center', 'circle']]]]
                ),
              ]),
              I && g(Kl, { for: T.value, onClick: V }, { default: () => [I] }),
            ]
          )
        }),
        { isFocused: p, input: y }
      )
    },
  }),
  PD = W(
    {
      indeterminate: Boolean,
      indeterminateIcon: { type: Le, default: '$checkboxIndeterminate' },
      ...Lm({ falseIcon: '$checkboxOff', trueIcon: '$checkboxOn' }),
    },
    'VCheckboxBtn'
  ),
  $r = ne()({
    name: 'VCheckboxBtn',
    props: PD(),
    emits: { 'update:modelValue': (e) => !0, 'update:indeterminate': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'indeterminate'),
        r = xe(e, 'modelValue')
      function s(l) {
        i.value && (i.value = !1)
      }
      const o = k(() => (i.value ? e.indeterminateIcon : e.falseIcon)),
        a = k(() => (i.value ? e.indeterminateIcon : e.trueIcon))
      return (
        se(() => {
          const l = Qt(Fs.filterProps(e), ['modelValue'])
          return g(
            Fs,
            ae(l, {
              modelValue: r.value,
              'onUpdate:modelValue': [(u) => (r.value = u), s],
              class: ['v-checkbox-btn', e.class],
              style: e.style,
              type: 'checkbox',
              falseIcon: o.value,
              trueIcon: a.value,
              'aria-checked': i.value ? 'mixed' : void 0,
            }),
            n
          )
        }),
        {}
      )
    },
  })
function RD(e) {
  const { t } = jt()
  function n(i) {
    let { name: r } = i
    const s = {
        prepend: 'prependAction',
        prependInner: 'prependAction',
        append: 'appendAction',
        appendInner: 'appendAction',
        clear: 'clear',
      }[r],
      o = e[`onClick:${r}`],
      a = o && s ? t(`$vuetify.input.${s}`, e.label ?? '') : void 0
    return g(ot, { icon: e[`${r}Icon`], 'aria-label': a, onClick: o }, null)
  }
  return { InputIcon: n }
}
const R8 = W(
    {
      active: Boolean,
      color: String,
      messages: { type: [Array, String], default: () => [] },
      ...Te(),
      ...Xi({ transition: { component: Ub, leaveAbsolute: !0, group: !0 } }),
    },
    'VMessages'
  ),
  xD = ne()({
    name: 'VMessages',
    props: R8(),
    setup(e, t) {
      let { slots: n } = t
      const i = k(() => Pt(e.messages)),
        { textColorClasses: r, textColorStyles: s } = Tn(k(() => e.color))
      return (
        se(() =>
          g(
            Bn,
            {
              transition: e.transition,
              tag: 'div',
              class: ['v-messages', r.value, e.class],
              style: [s.value, e.style],
              role: 'alert',
              'aria-live': 'polite',
            },
            {
              default: () => [
                e.active &&
                  i.value.map((o, a) =>
                    g('div', { class: 'v-messages__message', key: `${a}-${i.value}` }, [
                      n.message ? n.message({ message: o }) : o,
                    ])
                  ),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  fd = W({ focused: Boolean, 'onUpdate:focused': mn() }, 'focus')
function Qr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr()
  const n = xe(e, 'focused'),
    i = k(() => ({ [`${t}--focused`]: n.value }))
  function r() {
    n.value = !0
  }
  function s() {
    n.value = !1
  }
  return { focusClasses: i, isFocused: n, focus: r, blur: s }
}
const VD = Symbol.for('vuetify:form'),
  x8 = W(
    {
      disabled: Boolean,
      fastFail: Boolean,
      readonly: Boolean,
      modelValue: { type: Boolean, default: null },
      validateOn: { type: String, default: 'input' },
    },
    'form'
  )
function V8(e) {
  const t = xe(e, 'modelValue'),
    n = k(() => e.disabled),
    i = k(() => e.readonly),
    r = ye(!1),
    s = le([]),
    o = le([])
  async function a() {
    const c = []
    let d = !0
    ;(o.value = []), (r.value = !0)
    for (const f of s.value) {
      const m = await f.validate()
      if ((m.length > 0 && ((d = !1), c.push({ id: f.id, errorMessages: m })), !d && e.fastFail)) break
    }
    return (o.value = c), (r.value = !1), { valid: d, errors: o.value }
  }
  function l() {
    s.value.forEach((c) => c.reset())
  }
  function u() {
    s.value.forEach((c) => c.resetValidation())
  }
  return (
    be(
      s,
      () => {
        let c = 0,
          d = 0
        const f = []
        for (const m of s.value)
          m.isValid === !1 ? (d++, f.push({ id: m.id, errorMessages: m.errorMessages })) : m.isValid === !0 && c++
        ;(o.value = f), (t.value = d > 0 ? !1 : c === s.value.length ? !0 : null)
      },
      { deep: !0, flush: 'post' }
    ),
    mt(VD, {
      register: (c) => {
        let { id: d, vm: f, validate: m, reset: p, resetValidation: v } = c
        s.value.some((y) => y.id === d),
          s.value.push({
            id: d,
            validate: m,
            reset: p,
            resetValidation: v,
            vm: Nf(f),
            isValid: null,
            errorMessages: [],
          })
      },
      unregister: (c) => {
        s.value = s.value.filter((d) => d.id !== c)
      },
      update: (c, d, f) => {
        const m = s.value.find((p) => p.id === c)
        m && ((m.isValid = d), (m.errorMessages = f))
      },
      isDisabled: n,
      isReadonly: i,
      isValidating: r,
      isValid: t,
      items: s,
      validateOn: Q(e, 'validateOn'),
    }),
    {
      errors: o,
      isDisabled: n,
      isReadonly: i,
      isValidating: r,
      isValid: t,
      items: s,
      validate: a,
      reset: l,
      resetValidation: u,
    }
  )
}
function Fm() {
  return je(VD, null)
}
const DD = W(
  {
    disabled: { type: Boolean, default: null },
    error: Boolean,
    errorMessages: { type: [Array, String], default: () => [] },
    maxErrors: { type: [Number, String], default: 1 },
    name: String,
    label: String,
    readonly: { type: Boolean, default: null },
    rules: { type: Array, default: () => [] },
    modelValue: null,
    validateOn: String,
    validationValue: null,
    ...fd(),
  },
  'validation'
)
function ND(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pr(),
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : pn()
  const i = xe(e, 'modelValue'),
    r = k(() => (e.validationValue === void 0 ? i.value : e.validationValue)),
    s = Fm(),
    o = le([]),
    a = ye(!0),
    l = k(() => !!(Pt(i.value === '' ? null : i.value).length || Pt(r.value === '' ? null : r.value).length)),
    u = k(() => !!(e.disabled ?? (s == null ? void 0 : s.isDisabled.value))),
    c = k(() => !!(e.readonly ?? (s == null ? void 0 : s.isReadonly.value))),
    d = k(() => {
      var V
      return (V = e.errorMessages) != null && V.length
        ? Pt(e.errorMessages).concat(o.value).slice(0, Math.max(0, +e.maxErrors))
        : o.value
    }),
    f = k(() => {
      let V = (e.validateOn ?? (s == null ? void 0 : s.validateOn.value)) || 'input'
      V === 'lazy' && (V = 'input lazy')
      const D = new Set((V == null ? void 0 : V.split(' ')) ?? [])
      return {
        blur: D.has('blur') || D.has('input'),
        input: D.has('input'),
        submit: D.has('submit'),
        lazy: D.has('lazy'),
      }
    }),
    m = k(() => {
      var V
      return e.error || ((V = e.errorMessages) != null && V.length)
        ? !1
        : e.rules.length
        ? a.value
          ? o.value.length || f.value.lazy
            ? null
            : !0
          : !o.value.length
        : !0
    }),
    p = ye(!1),
    v = k(() => ({
      [`${t}--error`]: m.value === !1,
      [`${t}--dirty`]: l.value,
      [`${t}--disabled`]: u.value,
      [`${t}--readonly`]: c.value,
    })),
    y = Ut('validation'),
    T = k(() => e.name ?? Lt(n))
  Dy(() => {
    s == null || s.register({ id: T.value, vm: y, validate: N, reset: A, resetValidation: x })
  }),
    kn(() => {
      s == null || s.unregister(T.value)
    }),
    An(async () => {
      f.value.lazy || (await N(!0)), s == null || s.update(T.value, m.value, d.value)
    }),
    ii(
      () => f.value.input,
      () => {
        be(r, () => {
          if (r.value != null) N()
          else if (e.focused) {
            const V = be(
              () => e.focused,
              (D) => {
                D || N(), V()
              }
            )
          }
        })
      }
    ),
    ii(
      () => f.value.blur,
      () => {
        be(
          () => e.focused,
          (V) => {
            V || N()
          }
        )
      }
    ),
    be([m, d], () => {
      s == null || s.update(T.value, m.value, d.value)
    })
  async function A() {
    ;(i.value = null), await Xe(), await x()
  }
  async function x() {
    ;(a.value = !0), f.value.lazy ? (o.value = []) : await N(!0)
  }
  async function N() {
    let V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
    const D = []
    p.value = !0
    for (const I of e.rules) {
      if (D.length >= +(e.maxErrors ?? 1)) break
      const _ = await (typeof I == 'function' ? I : () => I)(r.value)
      if (_ !== !0) {
        if (_ !== !1 && typeof _ != 'string') {
          console.warn(`${_} is not a valid value. Rule functions must return boolean true or a string.`)
          continue
        }
        D.push(_ || '')
      }
    }
    return (o.value = D), (p.value = !1), (a.value = V), o.value
  }
  return {
    errorMessages: d,
    isDirty: l,
    isDisabled: u,
    isReadonly: c,
    isPristine: a,
    isValid: m,
    isValidating: p,
    reset: A,
    resetValidation: x,
    validate: N,
    validationClasses: v,
  }
}
const Xr = W(
    {
      id: String,
      appendIcon: Le,
      centerAffix: { type: Boolean, default: !0 },
      prependIcon: Le,
      hideDetails: [Boolean, String],
      hideSpinButtons: Boolean,
      hint: String,
      persistentHint: Boolean,
      messages: { type: [Array, String], default: () => [] },
      direction: { type: String, default: 'horizontal', validator: (e) => ['horizontal', 'vertical'].includes(e) },
      'onClick:prepend': mn(),
      'onClick:append': mn(),
      ...Te(),
      ...ln(),
      ...Sm(on(), ['maxWidth', 'minWidth', 'width']),
      ...Ze(),
      ...DD(),
    },
    'VInput'
  ),
  Cn = ne()({
    name: 'VInput',
    props: { ...Xr() },
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i, emit: r } = t
      const { densityClasses: s } = Un(e),
        { dimensionStyles: o } = an(e),
        { themeClasses: a } = at(e),
        { rtlClasses: l } = sn(),
        { InputIcon: u } = RD(e),
        c = pn(),
        d = k(() => e.id || `input-${c}`),
        f = k(() => `${d.value}-messages`),
        {
          errorMessages: m,
          isDirty: p,
          isDisabled: v,
          isReadonly: y,
          isPristine: T,
          isValid: A,
          isValidating: x,
          reset: N,
          resetValidation: V,
          validate: D,
          validationClasses: I,
        } = ND(e, 'v-input', d),
        w = k(() => ({
          id: d,
          messagesId: f,
          isDirty: p,
          isDisabled: v,
          isReadonly: y,
          isPristine: T,
          isValid: A,
          isValidating: x,
          reset: N,
          resetValidation: V,
          validate: D,
        })),
        _ = k(() => {
          var S
          return ((S = e.errorMessages) != null && S.length) || (!T.value && m.value.length)
            ? m.value
            : e.hint && (e.persistentHint || e.focused)
            ? e.hint
            : e.messages
        })
      return (
        se(() => {
          var B, U, $, G
          const S = !!(i.prepend || e.prependIcon),
            E = !!(i.append || e.appendIcon),
            C = _.value.length > 0,
            R = !e.hideDetails || (e.hideDetails === 'auto' && (C || !!i.details))
          return g(
            'div',
            {
              class: [
                'v-input',
                `v-input--${e.direction}`,
                { 'v-input--center-affix': e.centerAffix, 'v-input--hide-spin-buttons': e.hideSpinButtons },
                s.value,
                a.value,
                l.value,
                I.value,
                e.class,
              ],
              style: [o.value, e.style],
            },
            [
              S &&
                g('div', { key: 'prepend', class: 'v-input__prepend' }, [
                  (B = i.prepend) == null ? void 0 : B.call(i, w.value),
                  e.prependIcon && g(u, { key: 'prepend-icon', name: 'prepend' }, null),
                ]),
              i.default &&
                g('div', { class: 'v-input__control' }, [(U = i.default) == null ? void 0 : U.call(i, w.value)]),
              E &&
                g('div', { key: 'append', class: 'v-input__append' }, [
                  e.appendIcon && g(u, { key: 'append-icon', name: 'append' }, null),
                  ($ = i.append) == null ? void 0 : $.call(i, w.value),
                ]),
              R &&
                g('div', { class: 'v-input__details' }, [
                  g(xD, { id: f.value, active: C, messages: _.value }, { message: i.message }),
                  (G = i.details) == null ? void 0 : G.call(i, w.value),
                ]),
            ]
          )
        }),
        { reset: N, resetValidation: V, validate: D, isValid: A, errorMessages: m }
      )
    },
  }),
  D8 = W({ ...Xr(), ...Qt(PD(), ['inline']) }, 'VCheckbox'),
  N8 = ne()({
    name: 'VCheckbox',
    inheritAttrs: !1,
    props: D8(),
    emits: { 'update:modelValue': (e) => !0, 'update:focused': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const r = xe(e, 'modelValue'),
        { isFocused: s, focus: o, blur: a } = Qr(e),
        l = pn(),
        u = k(() => e.id || `checkbox-${l}`)
      return (
        se(() => {
          const [c, d] = Gs(n),
            f = Cn.filterProps(e),
            m = $r.filterProps(e)
          return g(
            Cn,
            ae({ class: ['v-checkbox', e.class] }, c, f, {
              modelValue: r.value,
              'onUpdate:modelValue': (p) => (r.value = p),
              id: u.value,
              focused: s.value,
              style: e.style,
            }),
            {
              ...i,
              default: (p) => {
                let { id: v, messagesId: y, isDisabled: T, isReadonly: A, isValid: x } = p
                return g(
                  $r,
                  ae(m, { id: v.value, 'aria-describedby': y.value, disabled: T.value, readonly: A.value }, d, {
                    error: x.value === !1,
                    modelValue: r.value,
                    'onUpdate:modelValue': (N) => (r.value = N),
                    onFocus: o,
                    onBlur: a,
                  }),
                  i
                )
              },
            }
          )
        }),
        {}
      )
    },
  })
function O8(e) {
  let { selectedElement: t, containerElement: n, isRtl: i, isHorizontal: r } = e
  const s = xc(r, n),
    o = OD(r, i, n),
    a = xc(r, t),
    l = MD(r, t),
    u = a * 0.4
  return o > l ? l - u : o + s < l + a ? l - s + a + u : o
}
function M8(e) {
  let { selectedElement: t, containerElement: n, isHorizontal: i } = e
  const r = xc(i, n),
    s = MD(i, t),
    o = xc(i, t)
  return s - r / 2 + o / 2
}
function BT(e, t) {
  const n = e ? 'scrollWidth' : 'scrollHeight'
  return (t == null ? void 0 : t[n]) || 0
}
function L8(e, t) {
  const n = e ? 'clientWidth' : 'clientHeight'
  return (t == null ? void 0 : t[n]) || 0
}
function OD(e, t, n) {
  if (!n) return 0
  const { scrollLeft: i, offsetWidth: r, scrollWidth: s } = n
  return e ? (t ? s - r + i : i) : n.scrollTop
}
function xc(e, t) {
  const n = e ? 'offsetWidth' : 'offsetHeight'
  return (t == null ? void 0 : t[n]) || 0
}
function MD(e, t) {
  const n = e ? 'offsetLeft' : 'offsetTop'
  return (t == null ? void 0 : t[n]) || 0
}
const LD = Symbol.for('vuetify:v-slide-group'),
  qb = W(
    {
      centerActive: Boolean,
      direction: { type: String, default: 'horizontal' },
      symbol: { type: null, default: LD },
      nextIcon: { type: Le, default: '$next' },
      prevIcon: { type: Le, default: '$prev' },
      showArrows: {
        type: [Boolean, String],
        validator: (e) => typeof e == 'boolean' || ['always', 'desktop', 'mobile'].includes(e),
      },
      ...Te(),
      ...ca({ mobile: null }),
      ...He(),
      ...ga({ selectedClass: 'v-slide-group-item--active' }),
    },
    'VSlideGroup'
  ),
  Vc = ne()({
    name: 'VSlideGroup',
    props: qb(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isRtl: i } = sn(),
        { displayClasses: r, mobile: s } = Ni(e),
        o = Ys(e, e.symbol),
        a = ye(!1),
        l = ye(0),
        u = ye(0),
        c = ye(0),
        d = k(() => e.direction === 'horizontal'),
        { resizeRef: f, contentRect: m } = Gi(),
        { resizeRef: p, contentRect: v } = Gi(),
        y = w7(),
        T = k(() => ({ container: f.el, duration: 200, easing: 'easeOutQuart' })),
        A = k(() => (o.selected.value.length ? o.items.value.findIndex((j) => j.id === o.selected.value[0]) : -1)),
        x = k(() =>
          o.selected.value.length
            ? o.items.value.findIndex((j) => j.id === o.selected.value[o.selected.value.length - 1])
            : -1
        )
      if (ct) {
        let j = -1
        be(
          () => [o.selected.value, m.value, v.value, d.value],
          () => {
            cancelAnimationFrame(j),
              (j = requestAnimationFrame(() => {
                if (m.value && v.value) {
                  const q = d.value ? 'width' : 'height'
                  ;(u.value = m.value[q]), (c.value = v.value[q]), (a.value = u.value + 1 < c.value)
                }
                if (A.value >= 0 && p.el) {
                  const q = p.el.children[x.value]
                  V(q, e.centerActive)
                }
              }))
          }
        )
      }
      const N = ye(!1)
      function V(j, q) {
        let te = 0
        q
          ? (te = M8({ containerElement: f.el, isHorizontal: d.value, selectedElement: j }))
          : (te = O8({ containerElement: f.el, isHorizontal: d.value, isRtl: i.value, selectedElement: j })),
          D(te)
      }
      function D(j) {
        if (!ct || !f.el) return
        const q = xc(d.value, f.el),
          te = OD(d.value, i.value, f.el)
        if (!(BT(d.value, f.el) <= q || Math.abs(j - te) < 16)) {
          if (d.value && i.value && f.el) {
            const { scrollWidth: Ee, offsetWidth: me } = f.el
            j = Ee - me - j
          }
          d.value ? y.horizontal(j, T.value) : y(j, T.value)
        }
      }
      function I(j) {
        const { scrollTop: q, scrollLeft: te } = j.target
        l.value = d.value ? te : q
      }
      function w(j) {
        if (((N.value = !0), !(!a.value || !p.el))) {
          for (const q of j.composedPath())
            for (const te of p.el.children)
              if (te === q) {
                V(te)
                return
              }
        }
      }
      function _(j) {
        N.value = !1
      }
      let S = !1
      function E(j) {
        var q
        !S && !N.value && !(j.relatedTarget && (q = p.el) != null && q.contains(j.relatedTarget)) && B(), (S = !1)
      }
      function C() {
        S = !0
      }
      function R(j) {
        if (!p.el) return
        function q(te) {
          j.preventDefault(), B(te)
        }
        d.value
          ? j.key === 'ArrowRight'
            ? q(i.value ? 'prev' : 'next')
            : j.key === 'ArrowLeft' && q(i.value ? 'next' : 'prev')
          : j.key === 'ArrowDown'
          ? q('next')
          : j.key === 'ArrowUp' && q('prev'),
          j.key === 'Home' ? q('first') : j.key === 'End' && q('last')
      }
      function B(j) {
        var te, ce
        if (!p.el) return
        let q
        if (!j) q = Ec(p.el)[0]
        else if (j === 'next') {
          if (((q = (te = p.el.querySelector(':focus')) == null ? void 0 : te.nextElementSibling), !q))
            return B('first')
        } else if (j === 'prev') {
          if (((q = (ce = p.el.querySelector(':focus')) == null ? void 0 : ce.previousElementSibling), !q))
            return B('last')
        } else j === 'first' ? (q = p.el.firstElementChild) : j === 'last' && (q = p.el.lastElementChild)
        q && q.focus({ preventScroll: !0 })
      }
      function U(j) {
        const q = d.value && i.value ? -1 : 1,
          te = (j === 'prev' ? -q : q) * u.value
        let ce = l.value + te
        if (d.value && i.value && f.el) {
          const { scrollWidth: Ee, offsetWidth: me } = f.el
          ce += Ee - me
        }
        D(ce)
      }
      const $ = k(() => ({ next: o.next, prev: o.prev, select: o.select, isSelected: o.isSelected })),
        G = k(() => {
          switch (e.showArrows) {
            case 'always':
              return !0
            case 'desktop':
              return !s.value
            case !0:
              return a.value || Math.abs(l.value) > 0
            case 'mobile':
              return s.value || a.value || Math.abs(l.value) > 0
            default:
              return !s.value && (a.value || Math.abs(l.value) > 0)
          }
        }),
        F = k(() => Math.abs(l.value) > 1),
        K = k(() => {
          if (!f.value) return !1
          const j = BT(d.value, f.el),
            q = L8(d.value, f.el)
          return j - q - Math.abs(l.value) > 1
        })
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-slide-group',
                {
                  'v-slide-group--vertical': !d.value,
                  'v-slide-group--has-affixes': G.value,
                  'v-slide-group--is-overflowing': a.value,
                },
                r.value,
                e.class,
              ],
              style: e.style,
              tabindex: N.value || o.selected.value.length ? -1 : 0,
              onFocus: E,
            },
            {
              default: () => {
                var j, q, te
                return [
                  G.value &&
                    g(
                      'div',
                      {
                        key: 'prev',
                        class: ['v-slide-group__prev', { 'v-slide-group__prev--disabled': !F.value }],
                        onMousedown: C,
                        onClick: () => F.value && U('prev'),
                      },
                      [
                        ((j = n.prev) == null ? void 0 : j.call(n, $.value)) ??
                          g(kc, null, { default: () => [g(ot, { icon: i.value ? e.nextIcon : e.prevIcon }, null)] }),
                      ]
                    ),
                  g('div', { key: 'container', ref: f, class: 'v-slide-group__container', onScroll: I }, [
                    g('div', { ref: p, class: 'v-slide-group__content', onFocusin: w, onFocusout: _, onKeydown: R }, [
                      (q = n.default) == null ? void 0 : q.call(n, $.value),
                    ]),
                  ]),
                  G.value &&
                    g(
                      'div',
                      {
                        key: 'next',
                        class: ['v-slide-group__next', { 'v-slide-group__next--disabled': !K.value }],
                        onMousedown: C,
                        onClick: () => K.value && U('next'),
                      },
                      [
                        ((te = n.next) == null ? void 0 : te.call(n, $.value)) ??
                          g(kc, null, { default: () => [g(ot, { icon: i.value ? e.prevIcon : e.nextIcon }, null)] }),
                      ]
                    ),
                ]
              },
            }
          )
        ),
        { selected: o.selected, scrollTo: U, scrollOffset: l, focus: B }
      )
    },
  }),
  FD = Symbol.for('vuetify:v-chip-group'),
  F8 = W(
    {
      column: Boolean,
      filter: Boolean,
      valueComparator: { type: Function, default: vr },
      ...qb(),
      ...Te(),
      ...ga({ selectedClass: 'v-chip--selected' }),
      ...He(),
      ...Ze(),
      ...Mi({ variant: 'tonal' }),
    },
    'VChipGroup'
  ),
  B8 = ne()({
    name: 'VChipGroup',
    props: F8(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { isSelected: r, select: s, next: o, prev: a, selected: l } = Ys(e, FD)
      return (
        Ot({
          VChip: { color: Q(e, 'color'), disabled: Q(e, 'disabled'), filter: Q(e, 'filter'), variant: Q(e, 'variant') },
        }),
        se(() => {
          const u = Vc.filterProps(e)
          return g(
            Vc,
            ae(u, { class: ['v-chip-group', { 'v-chip-group--column': e.column }, i.value, e.class], style: e.style }),
            {
              default: () => {
                var c
                return [
                  (c = n.default) == null
                    ? void 0
                    : c.call(n, { isSelected: r, select: s, next: o, prev: a, selected: l.value }),
                ]
              },
            }
          )
        }),
        {}
      )
    },
  }),
  $8 = W(
    {
      activeClass: String,
      appendAvatar: String,
      appendIcon: Le,
      closable: Boolean,
      closeIcon: { type: Le, default: '$delete' },
      closeLabel: { type: String, default: '$vuetify.close' },
      draggable: Boolean,
      filter: Boolean,
      filterIcon: { type: String, default: '$complete' },
      label: Boolean,
      link: { type: Boolean, default: void 0 },
      pill: Boolean,
      prependAvatar: String,
      prependIcon: Le,
      ripple: { type: [Boolean, Object], default: !0 },
      text: String,
      modelValue: { type: Boolean, default: !0 },
      onClick: mn(),
      onClickOnce: mn(),
      ...bi(),
      ...Te(),
      ...ln(),
      ...en(),
      ...va(),
      ...Tt(),
      ...hd(),
      ..._r(),
      ...He({ tag: 'span' }),
      ...Ze(),
      ...Mi({ variant: 'tonal' }),
    },
    'VChip'
  ),
  Yl = ne()({
    name: 'VChip',
    directives: { Ripple: Yr },
    props: $8(),
    emits: { 'click:close': (e) => !0, 'update:modelValue': (e) => !0, 'group:selected': (e) => !0, click: (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const { t: s } = jt(),
        { borderClasses: o } = Oi(e),
        { colorClasses: a, colorStyles: l, variantClasses: u } = ma(e),
        { densityClasses: c } = Un(e),
        { elevationClasses: d } = yn(e),
        { roundedClasses: f } = Mt(e),
        { sizeClasses: m } = Wl(e),
        { themeClasses: p } = at(e),
        v = xe(e, 'modelValue'),
        y = pa(e, FD, !1),
        T = dd(e, n),
        A = k(() => e.link !== !1 && T.isLink.value),
        x = k(() => !e.disabled && e.link !== !1 && (!!y || e.link || T.isClickable.value)),
        N = k(() => ({
          'aria-label': s(e.closeLabel),
          onClick(I) {
            I.preventDefault(), I.stopPropagation(), (v.value = !1), i('click:close', I)
          },
        }))
      function V(I) {
        var w
        i('click', I), x.value && ((w = T.navigate) == null || w.call(T, I), y == null || y.toggle())
      }
      function D(I) {
        ;(I.key === 'Enter' || I.key === ' ') && (I.preventDefault(), V(I))
      }
      return () => {
        const I = T.isLink.value ? 'a' : e.tag,
          w = !!(e.appendIcon || e.appendAvatar),
          _ = !!(w || r.append),
          S = !!(r.close || e.closable),
          E = !!(r.filter || e.filter) && y,
          C = !!(e.prependIcon || e.prependAvatar),
          R = !!(C || r.prepend),
          B = !y || y.isSelected.value
        return (
          v.value &&
          Rt(
            g(
              I,
              {
                class: [
                  'v-chip',
                  {
                    'v-chip--disabled': e.disabled,
                    'v-chip--label': e.label,
                    'v-chip--link': x.value,
                    'v-chip--filter': E,
                    'v-chip--pill': e.pill,
                  },
                  p.value,
                  o.value,
                  B ? a.value : void 0,
                  c.value,
                  d.value,
                  f.value,
                  m.value,
                  u.value,
                  y == null ? void 0 : y.selectedClass.value,
                  e.class,
                ],
                style: [B ? l.value : void 0, e.style],
                disabled: e.disabled || void 0,
                draggable: e.draggable,
                href: T.href.value,
                tabindex: x.value ? 0 : void 0,
                onClick: V,
                onKeydown: x.value && !A.value && D,
              },
              {
                default: () => {
                  var U
                  return [
                    Ks(x.value, 'v-chip'),
                    E &&
                      g(
                        jb,
                        { key: 'filter' },
                        {
                          default: () => [
                            Rt(
                              g('div', { class: 'v-chip__filter' }, [
                                r.filter
                                  ? g(
                                      Ge,
                                      {
                                        key: 'filter-defaults',
                                        disabled: !e.filterIcon,
                                        defaults: { VIcon: { icon: e.filterIcon } },
                                      },
                                      r.filter
                                    )
                                  : g(ot, { key: 'filter-icon', icon: e.filterIcon }, null),
                              ]),
                              [[Qi, y.isSelected.value]]
                            ),
                          ],
                        }
                      ),
                    R &&
                      g('div', { key: 'prepend', class: 'v-chip__prepend' }, [
                        r.prepend
                          ? g(
                              Ge,
                              {
                                key: 'prepend-defaults',
                                disabled: !C,
                                defaults: {
                                  VAvatar: { image: e.prependAvatar, start: !0 },
                                  VIcon: { icon: e.prependIcon, start: !0 },
                                },
                              },
                              r.prepend
                            )
                          : g(ke, null, [
                              e.prependIcon && g(ot, { key: 'prepend-icon', icon: e.prependIcon, start: !0 }, null),
                              e.prependAvatar &&
                                g(Vi, { key: 'prepend-avatar', image: e.prependAvatar, start: !0 }, null),
                            ]),
                      ]),
                    g('div', { class: 'v-chip__content', 'data-no-activator': '' }, [
                      ((U = r.default) == null
                        ? void 0
                        : U.call(r, {
                            isSelected: y == null ? void 0 : y.isSelected.value,
                            selectedClass: y == null ? void 0 : y.selectedClass.value,
                            select: y == null ? void 0 : y.select,
                            toggle: y == null ? void 0 : y.toggle,
                            value: y == null ? void 0 : y.value.value,
                            disabled: e.disabled,
                          })) ?? e.text,
                    ]),
                    _ &&
                      g('div', { key: 'append', class: 'v-chip__append' }, [
                        r.append
                          ? g(
                              Ge,
                              {
                                key: 'append-defaults',
                                disabled: !w,
                                defaults: {
                                  VAvatar: { end: !0, image: e.appendAvatar },
                                  VIcon: { end: !0, icon: e.appendIcon },
                                },
                              },
                              r.append
                            )
                          : g(ke, null, [
                              e.appendIcon && g(ot, { key: 'append-icon', end: !0, icon: e.appendIcon }, null),
                              e.appendAvatar && g(Vi, { key: 'append-avatar', end: !0, image: e.appendAvatar }, null),
                            ]),
                      ]),
                    S &&
                      g('button', ae({ key: 'close', class: 'v-chip__close', type: 'button' }, N.value), [
                        r.close
                          ? g(
                              Ge,
                              { key: 'close-defaults', defaults: { VIcon: { icon: e.closeIcon, size: 'x-small' } } },
                              r.close
                            )
                          : g(ot, { key: 'close-icon', icon: e.closeIcon, size: 'x-small' }, null),
                      ]),
                  ]
                },
              }
            ),
            [[pi('ripple'), x.value && e.ripple, null]]
          )
        )
      }
    },
  }),
  Yp = Symbol.for('vuetify:list')
function BD() {
  const e = je(Yp, { hasPrepend: ye(!1), updateHasPrepend: () => null }),
    t = {
      hasPrepend: ye(!1),
      updateHasPrepend: (n) => {
        n && (t.hasPrepend.value = n)
      },
    }
  return mt(Yp, t), e
}
function $D() {
  return je(Yp, null)
}
const Gb = (e) => {
    const t = {
      activate: (n) => {
        let { id: i, value: r, activated: s } = n
        return (i = ze(i)), (e && !r && s.size === 1 && s.has(i)) || (r ? s.add(i) : s.delete(i)), s
      },
      in: (n, i, r) => {
        let s = new Set()
        if (n != null)
          for (const o of Pt(n)) s = t.activate({ id: o, value: !0, activated: new Set(s), children: i, parents: r })
        return s
      },
      out: (n) => Array.from(n),
    }
    return t
  },
  UD = (e) => {
    const t = Gb(e)
    return {
      activate: (i) => {
        let { activated: r, id: s, ...o } = i
        s = ze(s)
        const a = r.has(s) ? new Set([s]) : new Set()
        return t.activate({ ...o, id: s, activated: a })
      },
      in: (i, r, s) => {
        let o = new Set()
        if (i != null) {
          const a = Pt(i)
          a.length && (o = t.in(a.slice(0, 1), r, s))
        }
        return o
      },
      out: (i, r, s) => t.out(i, r, s),
    }
  },
  U8 = (e) => {
    const t = Gb(e)
    return {
      activate: (i) => {
        let { id: r, activated: s, children: o, ...a } = i
        return (r = ze(r)), o.has(r) ? s : t.activate({ id: r, activated: s, children: o, ...a })
      },
      in: t.in,
      out: t.out,
    }
  },
  j8 = (e) => {
    const t = UD(e)
    return {
      activate: (i) => {
        let { id: r, activated: s, children: o, ...a } = i
        return (r = ze(r)), o.has(r) ? s : t.activate({ id: r, activated: s, children: o, ...a })
      },
      in: t.in,
      out: t.out,
    }
  },
  z8 = {
    open: (e) => {
      let { id: t, value: n, opened: i, parents: r } = e
      if (n) {
        const s = new Set()
        s.add(t)
        let o = r.get(t)
        for (; o != null; ) s.add(o), (o = r.get(o))
        return s
      } else return i.delete(t), i
    },
    select: () => null,
  },
  jD = {
    open: (e) => {
      let { id: t, value: n, opened: i, parents: r } = e
      if (n) {
        let s = r.get(t)
        for (i.add(t); s != null && s !== t; ) i.add(s), (s = r.get(s))
        return i
      } else i.delete(t)
      return i
    },
    select: () => null,
  },
  H8 = {
    open: jD.open,
    select: (e) => {
      let { id: t, value: n, opened: i, parents: r } = e
      if (!n) return i
      const s = []
      let o = r.get(t)
      for (; o != null; ) s.push(o), (o = r.get(o))
      return new Set(s)
    },
  },
  Kb = (e) => {
    const t = {
      select: (n) => {
        let { id: i, value: r, selected: s } = n
        if (((i = ze(i)), e && !r)) {
          const o = Array.from(s.entries()).reduce((a, l) => {
            let [u, c] = l
            return c === 'on' && a.push(u), a
          }, [])
          if (o.length === 1 && o[0] === i) return s
        }
        return s.set(i, r ? 'on' : 'off'), s
      },
      in: (n, i, r) => {
        let s = new Map()
        for (const o of n || []) s = t.select({ id: o, value: !0, selected: new Map(s), children: i, parents: r })
        return s
      },
      out: (n) => {
        const i = []
        for (const [r, s] of n.entries()) s === 'on' && i.push(r)
        return i
      },
    }
    return t
  },
  zD = (e) => {
    const t = Kb(e)
    return {
      select: (i) => {
        let { selected: r, id: s, ...o } = i
        s = ze(s)
        const a = r.has(s) ? new Map([[s, r.get(s)]]) : new Map()
        return t.select({ ...o, id: s, selected: a })
      },
      in: (i, r, s) => {
        let o = new Map()
        return i != null && i.length && (o = t.in(i.slice(0, 1), r, s)), o
      },
      out: (i, r, s) => t.out(i, r, s),
    }
  },
  W8 = (e) => {
    const t = Kb(e)
    return {
      select: (i) => {
        let { id: r, selected: s, children: o, ...a } = i
        return (r = ze(r)), o.has(r) ? s : t.select({ id: r, selected: s, children: o, ...a })
      },
      in: t.in,
      out: t.out,
    }
  },
  q8 = (e) => {
    const t = zD(e)
    return {
      select: (i) => {
        let { id: r, selected: s, children: o, ...a } = i
        return (r = ze(r)), o.has(r) ? s : t.select({ id: r, selected: s, children: o, ...a })
      },
      in: t.in,
      out: t.out,
    }
  },
  G8 = (e) => {
    const t = {
      select: (n) => {
        let { id: i, value: r, selected: s, children: o, parents: a } = n
        i = ze(i)
        const l = new Map(s),
          u = [i]
        for (; u.length; ) {
          const d = u.shift()
          s.set(d, r ? 'on' : 'off'), o.has(d) && u.push(...o.get(d))
        }
        let c = a.get(i)
        for (; c; ) {
          const d = o.get(c),
            f = d.every((p) => s.get(p) === 'on'),
            m = d.every((p) => !s.has(p) || s.get(p) === 'off')
          s.set(c, f ? 'on' : m ? 'off' : 'indeterminate'), (c = a.get(c))
        }
        return e &&
          !r &&
          Array.from(s.entries()).reduce((f, m) => {
            let [p, v] = m
            return v === 'on' && f.push(p), f
          }, []).length === 0
          ? l
          : s
      },
      in: (n, i, r) => {
        let s = new Map()
        for (const o of n || []) s = t.select({ id: o, value: !0, selected: new Map(s), children: i, parents: r })
        return s
      },
      out: (n, i) => {
        const r = []
        for (const [s, o] of n.entries()) o === 'on' && !i.has(s) && r.push(s)
        return r
      },
    }
    return t
  },
  Dc = Symbol.for('vuetify:nested'),
  HD = {
    id: ye(),
    root: {
      register: () => null,
      unregister: () => null,
      parents: le(new Map()),
      children: le(new Map()),
      open: () => null,
      openOnSelect: () => null,
      activate: () => null,
      select: () => null,
      activatable: le(!1),
      selectable: le(!1),
      opened: le(new Set()),
      activated: le(new Set()),
      selected: le(new Map()),
      selectedValues: le([]),
    },
  },
  K8 = W(
    {
      activatable: Boolean,
      selectable: Boolean,
      activeStrategy: [String, Function, Object],
      selectStrategy: [String, Function, Object],
      openStrategy: [String, Object],
      opened: null,
      activated: null,
      selected: null,
      mandatory: Boolean,
    },
    'nested'
  ),
  Y8 = (e) => {
    let t = !1
    const n = le(new Map()),
      i = le(new Map()),
      r = xe(
        e,
        'opened',
        e.opened,
        (m) => new Set(m),
        (m) => [...m.values()]
      ),
      s = k(() => {
        if (typeof e.activeStrategy == 'object') return e.activeStrategy
        if (typeof e.activeStrategy == 'function') return e.activeStrategy(e.mandatory)
        switch (e.activeStrategy) {
          case 'leaf':
            return U8(e.mandatory)
          case 'single-leaf':
            return j8(e.mandatory)
          case 'independent':
            return Gb(e.mandatory)
          case 'single-independent':
          default:
            return UD(e.mandatory)
        }
      }),
      o = k(() => {
        if (typeof e.selectStrategy == 'object') return e.selectStrategy
        if (typeof e.selectStrategy == 'function') return e.selectStrategy(e.mandatory)
        switch (e.selectStrategy) {
          case 'single-leaf':
            return q8(e.mandatory)
          case 'leaf':
            return W8(e.mandatory)
          case 'independent':
            return Kb(e.mandatory)
          case 'single-independent':
            return zD(e.mandatory)
          case 'classic':
          default:
            return G8(e.mandatory)
        }
      }),
      a = k(() => {
        if (typeof e.openStrategy == 'object') return e.openStrategy
        switch (e.openStrategy) {
          case 'list':
            return H8
          case 'single':
            return z8
          case 'multiple':
          default:
            return jD
        }
      }),
      l = xe(
        e,
        'activated',
        e.activated,
        (m) => s.value.in(m, n.value, i.value),
        (m) => s.value.out(m, n.value, i.value)
      ),
      u = xe(
        e,
        'selected',
        e.selected,
        (m) => o.value.in(m, n.value, i.value),
        (m) => o.value.out(m, n.value, i.value)
      )
    kn(() => {
      t = !0
    })
    function c(m) {
      const p = []
      let v = m
      for (; v != null; ) p.unshift(v), (v = i.value.get(v))
      return p
    }
    const d = Ut('nested'),
      f = {
        id: ye(),
        root: {
          opened: r,
          activatable: Q(e, 'activatable'),
          selectable: Q(e, 'selectable'),
          activated: l,
          selected: u,
          selectedValues: k(() => {
            const m = []
            for (const [p, v] of u.value.entries()) v === 'on' && m.push(p)
            return m
          }),
          register: (m, p, v) => {
            p && m !== p && i.value.set(m, p),
              v && n.value.set(m, []),
              p != null && n.value.set(p, [...(n.value.get(p) || []), m])
          },
          unregister: (m) => {
            if (t) return
            n.value.delete(m)
            const p = i.value.get(m)
            if (p) {
              const v = n.value.get(p) ?? []
              n.value.set(
                p,
                v.filter((y) => y !== m)
              )
            }
            i.value.delete(m), r.value.delete(m)
          },
          open: (m, p, v) => {
            d.emit('click:open', { id: m, value: p, path: c(m), event: v })
            const y = a.value.open({
              id: m,
              value: p,
              opened: new Set(r.value),
              children: n.value,
              parents: i.value,
              event: v,
            })
            y && (r.value = y)
          },
          openOnSelect: (m, p, v) => {
            const y = a.value.select({
              id: m,
              value: p,
              selected: new Map(u.value),
              opened: new Set(r.value),
              children: n.value,
              parents: i.value,
              event: v,
            })
            y && (r.value = y)
          },
          select: (m, p, v) => {
            d.emit('click:select', { id: m, value: p, path: c(m), event: v })
            const y = o.value.select({
              id: m,
              value: p,
              selected: new Map(u.value),
              children: n.value,
              parents: i.value,
              event: v,
            })
            y && (u.value = y), f.root.openOnSelect(m, p, v)
          },
          activate: (m, p, v) => {
            if (!e.activatable) return f.root.select(m, !0, v)
            d.emit('click:activate', { id: m, value: p, path: c(m), event: v })
            const y = s.value.activate({
              id: m,
              value: p,
              activated: new Set(l.value),
              children: n.value,
              parents: i.value,
              event: v,
            })
            y && (l.value = y)
          },
          children: n,
          parents: i,
        },
      }
    return mt(Dc, f), f.root
  },
  WD = (e, t) => {
    const n = je(Dc, HD),
      i = Symbol(pn()),
      r = k(() => (e.value !== void 0 ? e.value : i)),
      s = {
        ...n,
        id: r,
        open: (o, a) => n.root.open(r.value, o, a),
        openOnSelect: (o, a) => n.root.openOnSelect(r.value, o, a),
        isOpen: k(() => n.root.opened.value.has(r.value)),
        parent: k(() => n.root.parents.value.get(r.value)),
        activate: (o, a) => n.root.activate(r.value, o, a),
        isActivated: k(() => n.root.activated.value.has(ze(r.value))),
        select: (o, a) => n.root.select(r.value, o, a),
        isSelected: k(() => n.root.selected.value.get(ze(r.value)) === 'on'),
        isIndeterminate: k(() => n.root.selected.value.get(r.value) === 'indeterminate'),
        isLeaf: k(() => !n.root.children.value.get(r.value)),
        isGroupActivator: n.isGroupActivator,
      }
    return (
      !n.isGroupActivator && n.root.register(r.value, n.id.value, t),
      kn(() => {
        !n.isGroupActivator && n.root.unregister(r.value)
      }),
      t && mt(Dc, s),
      s
    )
  },
  Q8 = () => {
    const e = je(Dc, HD)
    mt(Dc, { ...e, isGroupActivator: !0 })
  },
  X8 = yi({
    name: 'VListGroupActivator',
    setup(e, t) {
      let { slots: n } = t
      return (
        Q8(),
        () => {
          var i
          return (i = n.default) == null ? void 0 : i.call(n)
        }
      )
    },
  }),
  J8 = W(
    {
      activeColor: String,
      baseColor: String,
      color: String,
      collapseIcon: { type: Le, default: '$collapse' },
      expandIcon: { type: Le, default: '$expand' },
      prependIcon: Le,
      appendIcon: Le,
      fluid: Boolean,
      subgroup: Boolean,
      title: String,
      value: null,
      ...Te(),
      ...He(),
    },
    'VListGroup'
  ),
  Qp = ne()({
    name: 'VListGroup',
    props: J8(),
    setup(e, t) {
      let { slots: n } = t
      const { isOpen: i, open: r, id: s } = WD(Q(e, 'value'), !0),
        o = k(() => `v-list-group--id-${String(s.value)}`),
        a = $D(),
        { isBooted: l } = fa()
      function u(m) {
        m.stopPropagation(), r(!i.value, m)
      }
      const c = k(() => ({ onClick: u, class: 'v-list-group__header', id: o.value })),
        d = k(() => (i.value ? e.collapseIcon : e.expandIcon)),
        f = k(() => ({
          VListItem: {
            active: i.value,
            activeColor: e.activeColor,
            baseColor: e.baseColor,
            color: e.color,
            prependIcon: e.prependIcon || (e.subgroup && d.value),
            appendIcon: e.appendIcon || (!e.subgroup && d.value),
            title: e.title,
            value: e.value,
          },
        }))
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-list-group',
                {
                  'v-list-group--prepend': a == null ? void 0 : a.hasPrepend.value,
                  'v-list-group--fluid': e.fluid,
                  'v-list-group--subgroup': e.subgroup,
                  'v-list-group--open': i.value,
                },
                e.class,
              ],
              style: e.style,
            },
            {
              default: () => [
                n.activator &&
                  g(
                    Ge,
                    { defaults: f.value },
                    {
                      default: () => [
                        g(X8, null, { default: () => [n.activator({ props: c.value, isOpen: i.value })] }),
                      ],
                    }
                  ),
                g(
                  Bn,
                  { transition: { component: Vm }, disabled: !l.value },
                  {
                    default: () => {
                      var m
                      return [
                        Rt(
                          g('div', { class: 'v-list-group__items', role: 'group', 'aria-labelledby': o.value }, [
                            (m = n.default) == null ? void 0 : m.call(n),
                          ]),
                          [[Qi, i.value]]
                        ),
                      ]
                    },
                  }
                ),
              ],
            }
          )
        ),
        { isOpen: i }
      )
    },
  }),
  Z8 = W({ opacity: [Number, String], ...Te(), ...He() }, 'VListItemSubtitle'),
  qD = ne()({
    name: 'VListItemSubtitle',
    props: Z8(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() =>
          g(
            e.tag,
            {
              class: ['v-list-item-subtitle', e.class],
              style: [{ '--v-list-item-subtitle-opacity': e.opacity }, e.style],
            },
            n
          )
        ),
        {}
      )
    },
  }),
  GD = yr('v-list-item-title'),
  eY = W(
    {
      active: { type: Boolean, default: void 0 },
      activeClass: String,
      activeColor: String,
      appendAvatar: String,
      appendIcon: Le,
      baseColor: String,
      disabled: Boolean,
      lines: [Boolean, String],
      link: { type: Boolean, default: void 0 },
      nav: Boolean,
      prependAvatar: String,
      prependIcon: Le,
      ripple: { type: [Boolean, Object], default: !0 },
      slim: Boolean,
      subtitle: [String, Number],
      title: [String, Number],
      value: null,
      onClick: mn(),
      onClickOnce: mn(),
      ...bi(),
      ...Te(),
      ...ln(),
      ...on(),
      ...en(),
      ...Tt(),
      ...hd(),
      ...He(),
      ...Ze(),
      ...Mi({ variant: 'text' }),
    },
    'VListItem'
  ),
  Ur = ne()({
    name: 'VListItem',
    directives: { Ripple: Yr },
    props: eY(),
    emits: { click: (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i, emit: r } = t
      const s = dd(e, n),
        o = k(() => (e.value === void 0 ? s.href.value : e.value)),
        {
          activate: a,
          isActivated: l,
          select: u,
          isSelected: c,
          isIndeterminate: d,
          isGroupActivator: f,
          root: m,
          parent: p,
          openOnSelect: v,
        } = WD(o, !1),
        y = $D(),
        T = k(() => {
          var j
          return (
            e.active !== !1 &&
            (e.active || ((j = s.isActive) == null ? void 0 : j.value) || (m.activatable.value ? l.value : c.value))
          )
        }),
        A = k(() => e.link !== !1 && s.isLink.value),
        x = k(
          () =>
            !e.disabled &&
            e.link !== !1 &&
            (e.link || s.isClickable.value || (!!y && (m.selectable.value || m.activatable.value || e.value != null)))
        ),
        N = k(() => e.rounded || e.nav),
        V = k(() => e.color ?? e.activeColor),
        D = k(() => ({ color: T.value ? V.value ?? e.baseColor : e.baseColor, variant: e.variant }))
      be(
        () => {
          var j
          return (j = s.isActive) == null ? void 0 : j.value
        },
        (j) => {
          j && p.value != null && m.open(p.value, !0), j && v(j)
        },
        { immediate: !0 }
      )
      const { themeClasses: I } = at(e),
        { borderClasses: w } = Oi(e),
        { colorClasses: _, colorStyles: S, variantClasses: E } = ma(D),
        { densityClasses: C } = Un(e),
        { dimensionStyles: R } = an(e),
        { elevationClasses: B } = yn(e),
        { roundedClasses: U } = Mt(N),
        $ = k(() => (e.lines ? `v-list-item--${e.lines}-line` : void 0)),
        G = k(() => ({ isActive: T.value, select: u, isSelected: c.value, isIndeterminate: d.value }))
      function F(j) {
        var q
        r('click', j),
          x.value &&
            ((q = s.navigate) == null || q.call(s, j),
            !f && (m.activatable.value ? a(!l.value, j) : (m.selectable.value || e.value != null) && u(!c.value, j)))
      }
      function K(j) {
        ;(j.key === 'Enter' || j.key === ' ') && (j.preventDefault(), F(j))
      }
      return (
        se(() => {
          const j = A.value ? 'a' : e.tag,
            q = i.title || e.title != null,
            te = i.subtitle || e.subtitle != null,
            ce = !!(e.appendAvatar || e.appendIcon),
            Ee = !!(ce || i.append),
            me = !!(e.prependAvatar || e.prependIcon),
            oe = !!(me || i.prepend)
          return (
            y == null || y.updateHasPrepend(oe),
            e.activeColor && tK('active-color', ['color', 'base-color']),
            Rt(
              g(
                j,
                {
                  class: [
                    'v-list-item',
                    {
                      'v-list-item--active': T.value,
                      'v-list-item--disabled': e.disabled,
                      'v-list-item--link': x.value,
                      'v-list-item--nav': e.nav,
                      'v-list-item--prepend': !oe && (y == null ? void 0 : y.hasPrepend.value),
                      'v-list-item--slim': e.slim,
                      [`${e.activeClass}`]: e.activeClass && T.value,
                    },
                    I.value,
                    w.value,
                    _.value,
                    C.value,
                    B.value,
                    $.value,
                    U.value,
                    E.value,
                    e.class,
                  ],
                  style: [S.value, R.value, e.style],
                  href: s.href.value,
                  tabindex: x.value ? (y ? -2 : 0) : void 0,
                  onClick: F,
                  onKeydown: x.value && !A.value && K,
                },
                {
                  default: () => {
                    var z
                    return [
                      Ks(x.value || T.value, 'v-list-item'),
                      oe &&
                        g('div', { key: 'prepend', class: 'v-list-item__prepend' }, [
                          i.prepend
                            ? g(
                                Ge,
                                {
                                  key: 'prepend-defaults',
                                  disabled: !me,
                                  defaults: {
                                    VAvatar: { density: e.density, image: e.prependAvatar },
                                    VIcon: { density: e.density, icon: e.prependIcon },
                                    VListItemAction: { start: !0 },
                                  },
                                },
                                {
                                  default: () => {
                                    var ue
                                    return [(ue = i.prepend) == null ? void 0 : ue.call(i, G.value)]
                                  },
                                }
                              )
                            : g(ke, null, [
                                e.prependAvatar &&
                                  g(Vi, { key: 'prepend-avatar', density: e.density, image: e.prependAvatar }, null),
                                e.prependIcon &&
                                  g(ot, { key: 'prepend-icon', density: e.density, icon: e.prependIcon }, null),
                              ]),
                          g('div', { class: 'v-list-item__spacer' }, null),
                        ]),
                      g('div', { class: 'v-list-item__content', 'data-no-activator': '' }, [
                        q &&
                          g(
                            GD,
                            { key: 'title' },
                            {
                              default: () => {
                                var ue
                                return [((ue = i.title) == null ? void 0 : ue.call(i, { title: e.title })) ?? e.title]
                              },
                            }
                          ),
                        te &&
                          g(
                            qD,
                            { key: 'subtitle' },
                            {
                              default: () => {
                                var ue
                                return [
                                  ((ue = i.subtitle) == null ? void 0 : ue.call(i, { subtitle: e.subtitle })) ??
                                    e.subtitle,
                                ]
                              },
                            }
                          ),
                        (z = i.default) == null ? void 0 : z.call(i, G.value),
                      ]),
                      Ee &&
                        g('div', { key: 'append', class: 'v-list-item__append' }, [
                          i.append
                            ? g(
                                Ge,
                                {
                                  key: 'append-defaults',
                                  disabled: !ce,
                                  defaults: {
                                    VAvatar: { density: e.density, image: e.appendAvatar },
                                    VIcon: { density: e.density, icon: e.appendIcon },
                                    VListItemAction: { end: !0 },
                                  },
                                },
                                {
                                  default: () => {
                                    var ue
                                    return [(ue = i.append) == null ? void 0 : ue.call(i, G.value)]
                                  },
                                }
                              )
                            : g(ke, null, [
                                e.appendIcon &&
                                  g(ot, { key: 'append-icon', density: e.density, icon: e.appendIcon }, null),
                                e.appendAvatar &&
                                  g(Vi, { key: 'append-avatar', density: e.density, image: e.appendAvatar }, null),
                              ]),
                          g('div', { class: 'v-list-item__spacer' }, null),
                        ]),
                    ]
                  },
                }
              ),
              [[pi('ripple'), x.value && e.ripple]]
            )
          )
        }),
        { activate: a, isActivated: l, isGroupActivator: f, isSelected: c, list: y, select: u }
      )
    },
  }),
  tY = W({ color: String, inset: Boolean, sticky: Boolean, title: String, ...Te(), ...He() }, 'VListSubheader'),
  KD = ne()({
    name: 'VListSubheader',
    props: tY(),
    setup(e, t) {
      let { slots: n } = t
      const { textColorClasses: i, textColorStyles: r } = Tn(Q(e, 'color'))
      return (
        se(() => {
          const s = !!(n.default || e.title)
          return g(
            e.tag,
            {
              class: [
                'v-list-subheader',
                { 'v-list-subheader--inset': e.inset, 'v-list-subheader--sticky': e.sticky },
                i.value,
                e.class,
              ],
              style: [{ textColorStyles: r }, e.style],
            },
            {
              default: () => {
                var o
                return [
                  s &&
                    g('div', { class: 'v-list-subheader__text' }, [
                      ((o = n.default) == null ? void 0 : o.call(n)) ?? e.title,
                    ]),
                ]
              },
            }
          )
        }),
        {}
      )
    },
  }),
  nY = W(
    {
      color: String,
      inset: Boolean,
      length: [Number, String],
      opacity: [Number, String],
      thickness: [Number, String],
      vertical: Boolean,
      ...Te(),
      ...Ze(),
    },
    'VDivider'
  ),
  md = ne()({
    name: 'VDivider',
    props: nY(),
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { themeClasses: r } = at(e),
        { textColorClasses: s, textColorStyles: o } = Tn(Q(e, 'color')),
        a = k(() => {
          const l = {}
          return (
            e.length && (l[e.vertical ? 'height' : 'width'] = Se(e.length)),
            e.thickness && (l[e.vertical ? 'borderRightWidth' : 'borderTopWidth'] = Se(e.thickness)),
            l
          )
        })
      return (
        se(() => {
          const l = g(
            'hr',
            {
              class: [
                { 'v-divider': !0, 'v-divider--inset': e.inset, 'v-divider--vertical': e.vertical },
                r.value,
                s.value,
                e.class,
              ],
              style: [a.value, o.value, { '--v-border-opacity': e.opacity }, e.style],
              'aria-orientation': !n.role || n.role === 'separator' ? (e.vertical ? 'vertical' : 'horizontal') : void 0,
              role: `${n.role || 'separator'}`,
            },
            null
          )
          return i.default
            ? g(
                'div',
                {
                  class: [
                    'v-divider__wrapper',
                    { 'v-divider__wrapper--vertical': e.vertical, 'v-divider__wrapper--inset': e.inset },
                  ],
                },
                [l, g('div', { class: 'v-divider__content' }, [i.default()]), l]
              )
            : l
        }),
        {}
      )
    },
  }),
  iY = W({ items: Array, returnObject: Boolean }, 'VListChildren'),
  YD = ne()({
    name: 'VListChildren',
    props: iY(),
    setup(e, t) {
      let { slots: n } = t
      return (
        BD(),
        () => {
          var i, r
          return (
            ((i = n.default) == null ? void 0 : i.call(n)) ??
            ((r = e.items) == null
              ? void 0
              : r.map((s) => {
                  var f, m
                  let { children: o, props: a, type: l, raw: u } = s
                  if (l === 'divider')
                    return ((f = n.divider) == null ? void 0 : f.call(n, { props: a })) ?? g(md, a, null)
                  if (l === 'subheader')
                    return ((m = n.subheader) == null ? void 0 : m.call(n, { props: a })) ?? g(KD, a, null)
                  const c = {
                      subtitle: n.subtitle
                        ? (p) => {
                            var v
                            return (v = n.subtitle) == null ? void 0 : v.call(n, { ...p, item: u })
                          }
                        : void 0,
                      prepend: n.prepend
                        ? (p) => {
                            var v
                            return (v = n.prepend) == null ? void 0 : v.call(n, { ...p, item: u })
                          }
                        : void 0,
                      append: n.append
                        ? (p) => {
                            var v
                            return (v = n.append) == null ? void 0 : v.call(n, { ...p, item: u })
                          }
                        : void 0,
                      title: n.title
                        ? (p) => {
                            var v
                            return (v = n.title) == null ? void 0 : v.call(n, { ...p, item: u })
                          }
                        : void 0,
                    },
                    d = Qp.filterProps(a)
                  return o
                    ? g(Qp, ae({ value: a == null ? void 0 : a.value }, d), {
                        activator: (p) => {
                          let { props: v } = p
                          const y = { ...a, ...v, value: e.returnObject ? u : a.value }
                          return n.header ? n.header({ props: y }) : g(Ur, y, c)
                        },
                        default: () => g(YD, { items: o, returnObject: e.returnObject }, n),
                      })
                    : n.item
                    ? n.item({ props: a })
                    : g(Ur, ae(a, { value: e.returnObject ? u : a.value }), c)
                }))
          )
        }
      )
    },
  }),
  QD = W(
    {
      items: { type: Array, default: () => [] },
      itemTitle: { type: [String, Array, Function], default: 'title' },
      itemValue: { type: [String, Array, Function], default: 'value' },
      itemChildren: { type: [Boolean, String, Array, Function], default: 'children' },
      itemProps: { type: [Boolean, String, Array, Function], default: 'props' },
      returnObject: Boolean,
      valueComparator: { type: Function, default: vr },
    },
    'list-items'
  )
function ws(e, t) {
  const n = Jt(t, e.itemTitle, t),
    i = Jt(t, e.itemValue, n),
    r = Jt(t, e.itemChildren),
    s =
      e.itemProps === !0
        ? typeof t == 'object' && t != null && !Array.isArray(t)
          ? 'children' in t
            ? Qt(t, ['children'])
            : t
          : void 0
        : Jt(t, e.itemProps),
    o = { title: n, value: i, ...s }
  return {
    title: String(o.title ?? ''),
    value: o.value,
    props: o,
    children: Array.isArray(r) ? XD(e, r) : void 0,
    raw: t,
  }
}
function XD(e, t) {
  const n = []
  for (const i of t) n.push(ws(e, i))
  return n
}
function Yb(e) {
  const t = k(() => XD(e, e.items)),
    n = k(() => t.value.some((s) => s.value === null))
  function i(s) {
    return (
      n.value || (s = s.filter((o) => o !== null)),
      s.map((o) =>
        e.returnObject && typeof o == 'string'
          ? ws(e, o)
          : t.value.find((a) => e.valueComparator(o, a.value)) || ws(e, o)
      )
    )
  }
  function r(s) {
    return e.returnObject
      ? s.map((o) => {
          let { raw: a } = o
          return a
        })
      : s.map((o) => {
          let { value: a } = o
          return a
        })
  }
  return { items: t, transformIn: i, transformOut: r }
}
function rY(e) {
  return typeof e == 'string' || typeof e == 'number' || typeof e == 'boolean'
}
function sY(e, t) {
  const n = Jt(t, e.itemType, 'item'),
    i = rY(t) ? t : Jt(t, e.itemTitle),
    r = Jt(t, e.itemValue, void 0),
    s = Jt(t, e.itemChildren),
    o = e.itemProps === !0 ? Qt(t, ['children']) : Jt(t, e.itemProps),
    a = { title: i, value: r, ...o }
  return { type: n, title: a.title, value: a.value, props: a, children: n === 'item' && s ? JD(e, s) : void 0, raw: t }
}
function JD(e, t) {
  const n = []
  for (const i of t) n.push(sY(e, i))
  return n
}
function oY(e) {
  return { items: k(() => JD(e, e.items)) }
}
const aY = W(
    {
      baseColor: String,
      activeColor: String,
      activeClass: String,
      bgColor: String,
      disabled: Boolean,
      expandIcon: String,
      collapseIcon: String,
      lines: { type: [Boolean, String], default: 'one' },
      slim: Boolean,
      nav: Boolean,
      'onClick:open': mn(),
      'onClick:select': mn(),
      'onUpdate:opened': mn(),
      ...K8({ selectStrategy: 'single-leaf', openStrategy: 'list' }),
      ...bi(),
      ...Te(),
      ...ln(),
      ...on(),
      ...en(),
      itemType: { type: String, default: 'type' },
      ...QD(),
      ...Tt(),
      ...He(),
      ...Ze(),
      ...Mi({ variant: 'text' }),
    },
    'VList'
  ),
  Bm = ne()({
    name: 'VList',
    props: aY(),
    emits: {
      'update:selected': (e) => !0,
      'update:activated': (e) => !0,
      'update:opened': (e) => !0,
      'click:open': (e) => !0,
      'click:activate': (e) => !0,
      'click:select': (e) => !0,
    },
    setup(e, t) {
      let { slots: n } = t
      const { items: i } = oY(e),
        { themeClasses: r } = at(e),
        { backgroundColorClasses: s, backgroundColorStyles: o } = gt(Q(e, 'bgColor')),
        { borderClasses: a } = Oi(e),
        { densityClasses: l } = Un(e),
        { dimensionStyles: u } = an(e),
        { elevationClasses: c } = yn(e),
        { roundedClasses: d } = Mt(e),
        { children: f, open: m, parents: p, select: v } = Y8(e),
        y = k(() => (e.lines ? `v-list--${e.lines}-line` : void 0)),
        T = Q(e, 'activeColor'),
        A = Q(e, 'baseColor'),
        x = Q(e, 'color')
      BD(),
        Ot({
          VListGroup: {
            activeColor: T,
            baseColor: A,
            color: x,
            expandIcon: Q(e, 'expandIcon'),
            collapseIcon: Q(e, 'collapseIcon'),
          },
          VListItem: {
            activeClass: Q(e, 'activeClass'),
            activeColor: T,
            baseColor: A,
            color: x,
            density: Q(e, 'density'),
            disabled: Q(e, 'disabled'),
            lines: Q(e, 'lines'),
            nav: Q(e, 'nav'),
            slim: Q(e, 'slim'),
            variant: Q(e, 'variant'),
          },
        })
      const N = ye(!1),
        V = le()
      function D(C) {
        N.value = !0
      }
      function I(C) {
        N.value = !1
      }
      function w(C) {
        var R
        !N.value && !(C.relatedTarget && (R = V.value) != null && R.contains(C.relatedTarget)) && E()
      }
      function _(C) {
        const R = C.target
        if (!(!V.value || ['INPUT', 'TEXTAREA'].includes(R.tagName))) {
          if (C.key === 'ArrowDown') E('next')
          else if (C.key === 'ArrowUp') E('prev')
          else if (C.key === 'Home') E('first')
          else if (C.key === 'End') E('last')
          else return
          C.preventDefault()
        }
      }
      function S(C) {
        N.value = !0
      }
      function E(C) {
        if (V.value) return Cl(V.value, C)
      }
      return (
        se(() =>
          g(
            e.tag,
            {
              ref: V,
              class: [
                'v-list',
                { 'v-list--disabled': e.disabled, 'v-list--nav': e.nav, 'v-list--slim': e.slim },
                r.value,
                s.value,
                a.value,
                l.value,
                c.value,
                y.value,
                d.value,
                e.class,
              ],
              style: [o.value, u.value, e.style],
              tabindex: e.disabled || N.value ? -1 : 0,
              role: 'listbox',
              'aria-activedescendant': void 0,
              onFocusin: D,
              onFocusout: I,
              onFocus: w,
              onKeydown: _,
              onMousedown: S,
            },
            { default: () => [g(YD, { items: i.value, returnObject: e.returnObject }, n)] }
          )
        ),
        { open: m, select: v, focus: E, children: f, parents: p }
      )
    },
  }),
  lY = yr('v-list-img'),
  uY = W({ start: Boolean, end: Boolean, ...Te(), ...He() }, 'VListItemAction'),
  cY = ne()({
    name: 'VListItemAction',
    props: uY(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-list-item-action',
                { 'v-list-item-action--start': e.start, 'v-list-item-action--end': e.end },
                e.class,
              ],
              style: e.style,
            },
            n
          )
        ),
        {}
      )
    },
  }),
  dY = W({ start: Boolean, end: Boolean, ...Te(), ...He() }, 'VListItemMedia'),
  hY = ne()({
    name: 'VListItemMedia',
    props: dY(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-list-item-media',
                { 'v-list-item-media--start': e.start, 'v-list-item-media--end': e.end },
                e.class,
              ],
              style: e.style,
            },
            n
          )
        ),
        {}
      )
    },
  })
function cv(e, t) {
  return { x: e.x + t.x, y: e.y + t.y }
}
function fY(e, t) {
  return { x: e.x - t.x, y: e.y - t.y }
}
function $T(e, t) {
  if (e.side === 'top' || e.side === 'bottom') {
    const { side: n, align: i } = e,
      r = i === 'left' ? 0 : i === 'center' ? t.width / 2 : i === 'right' ? t.width : i,
      s = n === 'top' ? 0 : n === 'bottom' ? t.height : n
    return cv({ x: r, y: s }, t)
  } else if (e.side === 'left' || e.side === 'right') {
    const { side: n, align: i } = e,
      r = n === 'left' ? 0 : n === 'right' ? t.width : n,
      s = i === 'top' ? 0 : i === 'center' ? t.height / 2 : i === 'bottom' ? t.height : i
    return cv({ x: r, y: s }, t)
  }
  return cv({ x: t.width / 2, y: t.height / 2 }, t)
}
const ZD = { static: vY, connected: yY },
  mY = W(
    {
      locationStrategy: {
        type: [String, Function],
        default: 'static',
        validator: (e) => typeof e == 'function' || e in ZD,
      },
      location: { type: String, default: 'bottom' },
      origin: { type: String, default: 'auto' },
      offset: [Number, String, Array],
    },
    'VOverlay-location-strategies'
  )
function gY(e, t) {
  const n = le({}),
    i = le()
  ct &&
    ii(
      () => !!(t.isActive.value && e.locationStrategy),
      (s) => {
        var o, a
        be(() => e.locationStrategy, s),
          gn(() => {
            window.removeEventListener('resize', r), (i.value = void 0)
          }),
          window.addEventListener('resize', r, { passive: !0 }),
          typeof e.locationStrategy == 'function'
            ? (i.value = (o = e.locationStrategy(t, e, n)) == null ? void 0 : o.updateLocation)
            : (i.value = (a = ZD[e.locationStrategy](t, e, n)) == null ? void 0 : a.updateLocation)
      }
    )
  function r(s) {
    var o
    ;(o = i.value) == null || o.call(i, s)
  }
  return { contentStyles: n, updateLocation: i }
}
function vY() {}
function pY(e, t) {
  t ? e.style.removeProperty('left') : e.style.removeProperty('right')
  const n = xb(e)
  return (
    t ? (n.x += parseFloat(e.style.right || 0)) : (n.x -= parseFloat(e.style.left || 0)),
    (n.y -= parseFloat(e.style.top || 0)),
    n
  )
}
function yY(e, t, n) {
  ;(Array.isArray(e.target.value) || IK(e.target.value)) &&
    Object.assign(n.value, { position: 'fixed', top: 0, [e.isRtl.value ? 'right' : 'left']: 0 })
  const { preferredAnchor: r, preferredOrigin: s } = Pb(() => {
      const p = Mp(t.location, e.isRtl.value),
        v = t.origin === 'overlap' ? p : t.origin === 'auto' ? sv(p) : Mp(t.origin, e.isRtl.value)
      return p.side === v.side && p.align === ov(v).align
        ? { preferredAnchor: aT(p), preferredOrigin: aT(v) }
        : { preferredAnchor: p, preferredOrigin: v }
    }),
    [o, a, l, u] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map((p) =>
      k(() => {
        const v = parseFloat(t[p])
        return isNaN(v) ? 1 / 0 : v
      })
    ),
    c = k(() => {
      if (Array.isArray(t.offset)) return t.offset
      if (typeof t.offset == 'string') {
        const p = t.offset.split(' ').map(parseFloat)
        return p.length < 2 && p.push(0), p
      }
      return typeof t.offset == 'number' ? [t.offset, 0] : [0, 0]
    })
  let d = !1
  const f = new ResizeObserver(() => {
    d && m()
  })
  be(
    [e.target, e.contentEl],
    (p, v) => {
      let [y, T] = p,
        [A, x] = v
      A && !Array.isArray(A) && f.unobserve(A),
        y && !Array.isArray(y) && f.observe(y),
        x && f.unobserve(x),
        T && f.observe(T)
    },
    { immediate: !0 }
  ),
    gn(() => {
      f.disconnect()
    })
  function m() {
    if (((d = !1), requestAnimationFrame(() => (d = !0)), !e.target.value || !e.contentEl.value)) return
    const p = VV(e.target.value),
      v = pY(e.contentEl.value, e.isRtl.value),
      y = Sf(e.contentEl.value),
      T = 12
    y.length ||
      (y.push(document.documentElement),
      (e.contentEl.value.style.top && e.contentEl.value.style.left) ||
        ((v.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0)),
        (v.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0))))
    const A = y.reduce((E, C) => {
      const R = C.getBoundingClientRect(),
        B = new ko({
          x: C === document.documentElement ? 0 : R.x,
          y: C === document.documentElement ? 0 : R.y,
          width: C.clientWidth,
          height: C.clientHeight,
        })
      return E
        ? new ko({
            x: Math.max(E.left, B.left),
            y: Math.max(E.top, B.top),
            width: Math.min(E.right, B.right) - Math.max(E.left, B.left),
            height: Math.min(E.bottom, B.bottom) - Math.max(E.top, B.top),
          })
        : B
    }, void 0)
    ;(A.x += T), (A.y += T), (A.width -= T * 2), (A.height -= T * 2)
    let x = { anchor: r.value, origin: s.value }
    function N(E) {
      const C = new ko(v),
        R = $T(E.anchor, p),
        B = $T(E.origin, C)
      let { x: U, y: $ } = fY(R, B)
      switch (E.anchor.side) {
        case 'top':
          $ -= c.value[0]
          break
        case 'bottom':
          $ += c.value[0]
          break
        case 'left':
          U -= c.value[0]
          break
        case 'right':
          U += c.value[0]
          break
      }
      switch (E.anchor.align) {
        case 'top':
          $ -= c.value[1]
          break
        case 'bottom':
          $ += c.value[1]
          break
        case 'left':
          U -= c.value[1]
          break
        case 'right':
          U += c.value[1]
          break
      }
      return (
        (C.x += U),
        (C.y += $),
        (C.width = Math.min(C.width, l.value)),
        (C.height = Math.min(C.height, u.value)),
        { overflows: uT(C, A), x: U, y: $ }
      )
    }
    let V = 0,
      D = 0
    const I = { x: 0, y: 0 },
      w = { x: !1, y: !1 }
    let _ = -1
    for (; !(_++ > 10); ) {
      const { x: E, y: C, overflows: R } = N(x)
      ;(V += E), (D += C), (v.x += E), (v.y += C)
      {
        const B = lT(x.anchor),
          U = R.x.before || R.x.after,
          $ = R.y.before || R.y.after
        let G = !1
        if (
          (['x', 'y'].forEach((F) => {
            if ((F === 'x' && U && !w.x) || (F === 'y' && $ && !w.y)) {
              const K = { anchor: { ...x.anchor }, origin: { ...x.origin } },
                j = F === 'x' ? (B === 'y' ? ov : sv) : B === 'y' ? sv : ov
              ;(K.anchor = j(K.anchor)), (K.origin = j(K.origin))
              const { overflows: q } = N(K)
              ;((q[F].before <= R[F].before && q[F].after <= R[F].after) ||
                q[F].before + q[F].after < (R[F].before + R[F].after) / 2) &&
                ((x = K), (G = w[F] = !0))
            }
          }),
          G)
        )
          continue
      }
      R.x.before && ((V += R.x.before), (v.x += R.x.before)),
        R.x.after && ((V -= R.x.after), (v.x -= R.x.after)),
        R.y.before && ((D += R.y.before), (v.y += R.y.before)),
        R.y.after && ((D -= R.y.after), (v.y -= R.y.after))
      {
        const B = uT(v, A)
        ;(I.x = A.width - B.x.before - B.x.after),
          (I.y = A.height - B.y.before - B.y.after),
          (V += B.x.before),
          (v.x += B.x.before),
          (D += B.y.before),
          (v.y += B.y.before)
      }
      break
    }
    const S = lT(x.anchor)
    return (
      Object.assign(n.value, {
        '--v-overlay-anchor-origin': `${x.anchor.side} ${x.anchor.align}`,
        transformOrigin: `${x.origin.side} ${x.origin.align}`,
        top: Se(dv(D)),
        left: e.isRtl.value ? void 0 : Se(dv(V)),
        right: e.isRtl.value ? Se(dv(-V)) : void 0,
        minWidth: Se(S === 'y' ? Math.min(o.value, p.width) : o.value),
        maxWidth: Se(UT(qt(I.x, o.value === 1 / 0 ? 0 : o.value, l.value))),
        maxHeight: Se(UT(qt(I.y, a.value === 1 / 0 ? 0 : a.value, u.value))),
      }),
      { available: I, contentBox: v }
    )
  }
  return (
    be(
      () => [r.value, s.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight],
      () => m()
    ),
    Xe(() => {
      const p = m()
      if (!p) return
      const { available: v, contentBox: y } = p
      y.height > v.y &&
        requestAnimationFrame(() => {
          m(),
            requestAnimationFrame(() => {
              m()
            })
        })
    }),
    { updateLocation: m }
  )
}
function dv(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio
}
function UT(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio
}
let Xp = !0
const Cf = []
function _Y(e) {
  !Xp || Cf.length ? (Cf.push(e), Jp()) : ((Xp = !1), e(), Jp())
}
let jT = -1
function Jp() {
  cancelAnimationFrame(jT),
    (jT = requestAnimationFrame(() => {
      const e = Cf.shift()
      e && e(), Cf.length ? Jp() : (Xp = !0)
    }))
}
const Vh = { none: null, close: IY, block: SY, reposition: EY },
  bY = W(
    {
      scrollStrategy: {
        type: [String, Function],
        default: 'block',
        validator: (e) => typeof e == 'function' || e in Vh,
      },
    },
    'VOverlay-scroll-strategies'
  )
function wY(e, t) {
  if (!ct) return
  let n
  $t(async () => {
    n == null || n.stop(),
      t.isActive.value &&
        e.scrollStrategy &&
        ((n = Nl()),
        await new Promise((i) => setTimeout(i)),
        n.active &&
          n.run(() => {
            var i
            typeof e.scrollStrategy == 'function'
              ? e.scrollStrategy(t, e, n)
              : (i = Vh[e.scrollStrategy]) == null || i.call(Vh, t, e, n)
          }))
  }),
    gn(() => {
      n == null || n.stop()
    })
}
function IY(e) {
  function t(n) {
    e.isActive.value = !1
  }
  eN(e.targetEl.value ?? e.contentEl.value, t)
}
function SY(e, t) {
  var o
  const n = (o = e.root.value) == null ? void 0 : o.offsetParent,
    i = [
      ...new Set([
        ...Sf(e.targetEl.value, t.contained ? n : void 0),
        ...Sf(e.contentEl.value, t.contained ? n : void 0),
      ]),
    ].filter((a) => !a.classList.contains('v-overlay-scroll-blocked')),
    r = window.innerWidth - document.documentElement.offsetWidth,
    s = ((a) => Mb(a) && a)(n || document.documentElement)
  s && e.root.value.classList.add('v-overlay--scroll-blocked'),
    i.forEach((a, l) => {
      a.style.setProperty('--v-body-scroll-x', Se(-a.scrollLeft)),
        a.style.setProperty('--v-body-scroll-y', Se(-a.scrollTop)),
        a !== document.documentElement && a.style.setProperty('--v-scrollbar-offset', Se(r)),
        a.classList.add('v-overlay-scroll-blocked')
    }),
    gn(() => {
      i.forEach((a, l) => {
        const u = parseFloat(a.style.getPropertyValue('--v-body-scroll-x')),
          c = parseFloat(a.style.getPropertyValue('--v-body-scroll-y')),
          d = a.style.scrollBehavior
        ;(a.style.scrollBehavior = 'auto'),
          a.style.removeProperty('--v-body-scroll-x'),
          a.style.removeProperty('--v-body-scroll-y'),
          a.style.removeProperty('--v-scrollbar-offset'),
          a.classList.remove('v-overlay-scroll-blocked'),
          (a.scrollLeft = -u),
          (a.scrollTop = -c),
          (a.style.scrollBehavior = d)
      }),
        s && e.root.value.classList.remove('v-overlay--scroll-blocked')
    })
}
function EY(e, t, n) {
  let i = !1,
    r = -1,
    s = -1
  function o(a) {
    _Y(() => {
      var c, d
      const l = performance.now()
      ;(d = (c = e.updateLocation).value) == null || d.call(c, a), (i = (performance.now() - l) / (1e3 / 60) > 2)
    })
  }
  ;(s = (typeof requestIdleCallback > 'u' ? (a) => a() : requestIdleCallback)(() => {
    n.run(() => {
      eN(e.targetEl.value ?? e.contentEl.value, (a) => {
        i
          ? (cancelAnimationFrame(r),
            (r = requestAnimationFrame(() => {
              r = requestAnimationFrame(() => {
                o(a)
              })
            })))
          : o(a)
      })
    })
  })),
    gn(() => {
      typeof cancelIdleCallback < 'u' && cancelIdleCallback(s), cancelAnimationFrame(r)
    })
}
function eN(e, t) {
  const n = [document, ...Sf(e)]
  n.forEach((i) => {
    i.addEventListener('scroll', t, { passive: !0 })
  }),
    gn(() => {
      n.forEach((i) => {
        i.removeEventListener('scroll', t)
      })
    })
}
const Zp = Symbol.for('vuetify:v-menu'),
  Qb = W({ closeDelay: [Number, String], openDelay: [Number, String] }, 'delay')
function Xb(e, t) {
  let n = () => {}
  function i(o) {
    n == null || n()
    const a = Number(o ? e.openDelay : e.closeDelay)
    return new Promise((l) => {
      n = zG(a, () => {
        t == null || t(o), l(o)
      })
    })
  }
  function r() {
    return i(!0)
  }
  function s() {
    return i(!1)
  }
  return { clearDelay: n, runOpenDelay: r, runCloseDelay: s }
}
const TY = W(
  {
    target: [String, Object],
    activator: [String, Object],
    activatorProps: { type: Object, default: () => ({}) },
    openOnClick: { type: Boolean, default: void 0 },
    openOnHover: Boolean,
    openOnFocus: { type: Boolean, default: void 0 },
    closeOnContentClick: Boolean,
    ...Qb(),
  },
  'VOverlay-activator'
)
function CY(e, t) {
  let { isActive: n, isTop: i } = t
  const r = Ut('useActivator'),
    s = le()
  let o = !1,
    a = !1,
    l = !0
  const u = k(() => e.openOnFocus || (e.openOnFocus == null && e.openOnHover)),
    c = k(() => e.openOnClick || (e.openOnClick == null && !e.openOnHover && !u.value)),
    { runOpenDelay: d, runCloseDelay: f } = Xb(e, (I) => {
      I === ((e.openOnHover && o) || (u.value && a)) &&
        !(e.openOnHover && n.value && !i.value) &&
        (n.value !== I && (l = !0), (n.value = I))
    }),
    m = le(),
    p = {
      onClick: (I) => {
        I.stopPropagation(),
          (s.value = I.currentTarget || I.target),
          n.value || (m.value = [I.clientX, I.clientY]),
          (n.value = !n.value)
      },
      onMouseenter: (I) => {
        var w
        ;((w = I.sourceCapabilities) != null && w.firesTouchEvents) ||
          ((o = !0), (s.value = I.currentTarget || I.target), d())
      },
      onMouseleave: (I) => {
        ;(o = !1), f()
      },
      onFocus: (I) => {
        Al(I.target, ':focus-visible') !== !1 &&
          ((a = !0), I.stopPropagation(), (s.value = I.currentTarget || I.target), d())
      },
      onBlur: (I) => {
        ;(a = !1), I.stopPropagation(), f()
      },
    },
    v = k(() => {
      const I = {}
      return (
        c.value && (I.onClick = p.onClick),
        e.openOnHover && ((I.onMouseenter = p.onMouseenter), (I.onMouseleave = p.onMouseleave)),
        u.value && ((I.onFocus = p.onFocus), (I.onBlur = p.onBlur)),
        I
      )
    }),
    y = k(() => {
      const I = {}
      if (
        (e.openOnHover &&
          ((I.onMouseenter = () => {
            ;(o = !0), d()
          }),
          (I.onMouseleave = () => {
            ;(o = !1), f()
          })),
        u.value &&
          ((I.onFocusin = () => {
            ;(a = !0), d()
          }),
          (I.onFocusout = () => {
            ;(a = !1), f()
          })),
        e.closeOnContentClick)
      ) {
        const w = je(Zp, null)
        I.onClick = () => {
          ;(n.value = !1), w == null || w.closeParents()
        }
      }
      return I
    }),
    T = k(() => {
      const I = {}
      return (
        e.openOnHover &&
          ((I.onMouseenter = () => {
            l && ((o = !0), (l = !1), d())
          }),
          (I.onMouseleave = () => {
            ;(o = !1), f()
          })),
        I
      )
    })
  be(i, (I) => {
    I && ((e.openOnHover && !o && (!u.value || !a)) || (u.value && !a && (!e.openOnHover || !o))) && (n.value = !1)
  }),
    be(
      n,
      (I) => {
        I ||
          setTimeout(() => {
            m.value = void 0
          })
      },
      { flush: 'post' }
    )
  const A = wf()
  $t(() => {
    A.value &&
      Xe(() => {
        s.value = A.el
      })
  })
  const x = wf(),
    N = k(() => (e.target === 'cursor' && m.value ? m.value : x.value ? x.el : tN(e.target, r) || s.value)),
    V = k(() => (Array.isArray(N.value) ? void 0 : N.value))
  let D
  return (
    be(
      () => !!e.activator,
      (I) => {
        I && ct
          ? ((D = Nl()),
            D.run(() => {
              AY(e, r, { activatorEl: s, activatorEvents: v })
            }))
          : D && D.stop()
      },
      { flush: 'post', immediate: !0 }
    ),
    gn(() => {
      D == null || D.stop()
    }),
    {
      activatorEl: s,
      activatorRef: A,
      target: N,
      targetEl: V,
      targetRef: x,
      activatorEvents: v,
      contentEvents: y,
      scrimEvents: T,
    }
  )
}
function AY(e, t, n) {
  let { activatorEl: i, activatorEvents: r } = n
  be(
    () => e.activator,
    (l, u) => {
      if (u && l !== u) {
        const c = a(u)
        c && o(c)
      }
      l && Xe(() => s())
    },
    { immediate: !0 }
  ),
    be(
      () => e.activatorProps,
      () => {
        s()
      }
    ),
    gn(() => {
      o()
    })
  function s() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a(),
      u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps
    l && qG(l, ae(r.value, u))
  }
  function o() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a(),
      u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps
    l && GG(l, ae(r.value, u))
  }
  function a() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator
    const u = tN(l, t)
    return (i.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0), i.value
  }
}
function tN(e, t) {
  var i, r
  if (!e) return
  let n
  if (e === 'parent') {
    let s = (r = (i = t == null ? void 0 : t.proxy) == null ? void 0 : i.$el) == null ? void 0 : r.parentNode
    for (; s != null && s.hasAttribute('data-no-activator'); ) s = s.parentNode
    n = s
  } else typeof e == 'string' ? (n = document.querySelector(e)) : '$el' in e ? (n = e.$el) : (n = e)
  return n
}
function nN() {
  if (!ct) return ye(!1)
  const { ssr: e } = Ni()
  if (e) {
    const t = ye(!1)
    return (
      An(() => {
        t.value = !0
      }),
      t
    )
  } else return ye(!0)
}
const Jb = W({ eager: Boolean }, 'lazy')
function Zb(e, t) {
  const n = ye(!1),
    i = k(() => n.value || e.eager || t.value)
  be(t, () => (n.value = !0))
  function r() {
    e.eager || (n.value = !1)
  }
  return { isBooted: n, hasContent: i, onAfterLeave: r }
}
function _a() {
  const t = Ut('useScopeId').vnode.scopeId
  return { scopeId: t ? { [t]: '' } : void 0 }
}
const zT = Symbol.for('vuetify:stack'),
  Su = wn([])
function kY(e, t, n) {
  const i = Ut('useStack'),
    r = !n,
    s = je(zT, void 0),
    o = wn({ activeChildren: new Set() })
  mt(zT, o)
  const a = ye(+t.value)
  ii(e, () => {
    var d
    const c = (d = Su.at(-1)) == null ? void 0 : d[1]
    ;(a.value = c ? c + 10 : +t.value),
      r && Su.push([i.uid, a.value]),
      s == null || s.activeChildren.add(i.uid),
      gn(() => {
        if (r) {
          const f = ze(Su).findIndex((m) => m[0] === i.uid)
          Su.splice(f, 1)
        }
        s == null || s.activeChildren.delete(i.uid)
      })
  })
  const l = ye(!0)
  r &&
    $t(() => {
      var d
      const c = ((d = Su.at(-1)) == null ? void 0 : d[0]) === i.uid
      setTimeout(() => (l.value = c))
    })
  const u = k(() => !o.activeChildren.size)
  return { globalTop: Ol(l), localTop: u, stackStyles: k(() => ({ zIndex: a.value })) }
}
function PY(e) {
  return {
    teleportTarget: k(() => {
      const n = e()
      if (n === !0 || !ct) return
      const i = n === !1 ? document.body : typeof n == 'string' ? document.querySelector(n) : n
      if (i == null) return
      let r = i.querySelector(':scope > .v-overlay-container')
      return r || ((r = document.createElement('div')), (r.className = 'v-overlay-container'), i.appendChild(r)), r
    }),
  }
}
function RY() {
  return !0
}
function iN(e, t, n) {
  if (!e || rN(e, n) === !1) return !1
  const i = WV(t)
  if (typeof ShadowRoot < 'u' && i instanceof ShadowRoot && i.host === e.target) return !1
  const r = ((typeof n.value == 'object' && n.value.include) || (() => []))()
  return r.push(t), !r.some((s) => (s == null ? void 0 : s.contains(e.target)))
}
function rN(e, t) {
  return ((typeof t.value == 'object' && t.value.closeConditional) || RY)(e)
}
function xY(e, t, n) {
  const i = typeof n.value == 'function' ? n.value : n.value.handler
  t._clickOutside.lastMousedownWasOutside &&
    iN(e, t, n) &&
    setTimeout(() => {
      rN(e, n) && i && i(e)
    }, 0)
}
function HT(e, t) {
  const n = WV(e)
  t(document), typeof ShadowRoot < 'u' && n instanceof ShadowRoot && t(n)
}
const sN = {
  mounted(e, t) {
    const n = (r) => xY(r, e, t),
      i = (r) => {
        e._clickOutside.lastMousedownWasOutside = iN(r, e, t)
      }
    HT(e, (r) => {
      r.addEventListener('click', n, !0), r.addEventListener('mousedown', i, !0)
    }),
      e._clickOutside || (e._clickOutside = { lastMousedownWasOutside: !1 }),
      (e._clickOutside[t.instance.$.uid] = { onClick: n, onMousedown: i })
  },
  unmounted(e, t) {
    e._clickOutside &&
      (HT(e, (n) => {
        var s
        if (!n || !((s = e._clickOutside) != null && s[t.instance.$.uid])) return
        const { onClick: i, onMousedown: r } = e._clickOutside[t.instance.$.uid]
        n.removeEventListener('click', i, !0), n.removeEventListener('mousedown', r, !0)
      }),
      delete e._clickOutside[t.instance.$.uid])
  },
}
function VY(e) {
  const { modelValue: t, color: n, ...i } = e
  return g(
    dr,
    { name: 'fade-transition', appear: !0 },
    {
      default: () => [
        e.modelValue &&
          g(
            'div',
            ae(
              {
                class: ['v-overlay__scrim', e.color.backgroundColorClasses.value],
                style: e.color.backgroundColorStyles.value,
              },
              i
            ),
            null
          ),
      ],
    }
  )
}
const gd = W(
    {
      absolute: Boolean,
      attach: [Boolean, String, Object],
      closeOnBack: { type: Boolean, default: !0 },
      contained: Boolean,
      contentClass: null,
      contentProps: null,
      disabled: Boolean,
      opacity: [Number, String],
      noClickAnimation: Boolean,
      modelValue: Boolean,
      persistent: Boolean,
      scrim: { type: [Boolean, String], default: !0 },
      zIndex: { type: [Number, String], default: 2e3 },
      ...TY(),
      ...Te(),
      ...on(),
      ...Jb(),
      ...mY(),
      ...bY(),
      ...Ze(),
      ...Xi(),
    },
    'VOverlay'
  ),
  mr = ne()({
    name: 'VOverlay',
    directives: { ClickOutside: sN },
    inheritAttrs: !1,
    props: { _disableGlobalStack: Boolean, ...gd() },
    emits: { 'click:outside': (e) => !0, 'update:modelValue': (e) => !0, afterEnter: () => !0, afterLeave: () => !0 },
    setup(e, t) {
      let { slots: n, attrs: i, emit: r } = t
      const s = xe(e, 'modelValue'),
        o = k({
          get: () => s.value,
          set: (me) => {
            ;(me && e.disabled) || (s.value = me)
          },
        }),
        { themeClasses: a } = at(e),
        { rtlClasses: l, isRtl: u } = sn(),
        { hasContent: c, onAfterLeave: d } = Zb(e, o),
        f = gt(k(() => (typeof e.scrim == 'string' ? e.scrim : null))),
        { globalTop: m, localTop: p, stackStyles: v } = kY(o, Q(e, 'zIndex'), e._disableGlobalStack),
        {
          activatorEl: y,
          activatorRef: T,
          target: A,
          targetEl: x,
          targetRef: N,
          activatorEvents: V,
          contentEvents: D,
          scrimEvents: I,
        } = CY(e, { isActive: o, isTop: p }),
        { teleportTarget: w } = PY(() => {
          var z
          const me = e.attach || e.contained
          if (me) return me
          const oe = (z = y == null ? void 0 : y.value) == null ? void 0 : z.getRootNode()
          return oe instanceof ShadowRoot ? oe : !1
        }),
        { dimensionStyles: _ } = an(e),
        S = nN(),
        { scopeId: E } = _a()
      be(
        () => e.disabled,
        (me) => {
          me && (o.value = !1)
        }
      )
      const C = le(),
        R = le(),
        B = le(),
        { contentStyles: U, updateLocation: $ } = gY(e, { isRtl: u, contentEl: B, target: A, isActive: o })
      wY(e, { root: C, contentEl: B, targetEl: x, isActive: o, updateLocation: $ })
      function G(me) {
        r('click:outside', me), e.persistent ? te() : (o.value = !1)
      }
      function F(me) {
        return o.value && m.value && (!e.scrim || me.target === R.value)
      }
      ct &&
        be(
          o,
          (me) => {
            me ? window.addEventListener('keydown', K) : window.removeEventListener('keydown', K)
          },
          { immediate: !0 }
        ),
        kn(() => {
          ct && window.removeEventListener('keydown', K)
        })
      function K(me) {
        var oe, z
        me.key === 'Escape' &&
          m.value &&
          (e.persistent
            ? te()
            : ((o.value = !1),
              (oe = B.value) != null && oe.contains(document.activeElement) && ((z = y.value) == null || z.focus())))
      }
      const j = pD()
      ii(
        () => e.closeOnBack,
        () => {
          f8(j, (me) => {
            m.value && o.value ? (me(!1), e.persistent ? te() : (o.value = !1)) : me()
          })
        }
      )
      const q = le()
      be(
        () => o.value && (e.absolute || e.contained) && w.value == null,
        (me) => {
          if (me) {
            const oe = Ob(C.value)
            oe && oe !== document.scrollingElement && (q.value = oe.scrollTop)
          }
        }
      )
      function te() {
        e.noClickAnimation ||
          (B.value &&
            _o(B.value, [{ transformOrigin: 'center' }, { transform: 'scale(1.03)' }, { transformOrigin: 'center' }], {
              duration: 150,
              easing: Tc,
            }))
      }
      function ce() {
        r('afterEnter')
      }
      function Ee() {
        d(), r('afterLeave')
      }
      return (
        se(() => {
          var me
          return g(ke, null, [
            (me = n.activator) == null
              ? void 0
              : me.call(n, { isActive: o.value, targetRef: N, props: ae({ ref: T }, V.value, e.activatorProps) }),
            S.value &&
              c.value &&
              g(
                DL,
                { disabled: !w.value, to: w.value },
                {
                  default: () => [
                    g(
                      'div',
                      ae(
                        {
                          class: [
                            'v-overlay',
                            {
                              'v-overlay--absolute': e.absolute || e.contained,
                              'v-overlay--active': o.value,
                              'v-overlay--contained': e.contained,
                            },
                            a.value,
                            l.value,
                            e.class,
                          ],
                          style: [v.value, { '--v-overlay-opacity': e.opacity, top: Se(q.value) }, e.style],
                          ref: C,
                        },
                        E,
                        i
                      ),
                      [
                        g(VY, ae({ color: f, modelValue: o.value && !!e.scrim, ref: R }, I.value), null),
                        g(
                          Bn,
                          {
                            appear: !0,
                            persisted: !0,
                            transition: e.transition,
                            target: A.value,
                            onAfterEnter: ce,
                            onAfterLeave: Ee,
                          },
                          {
                            default: () => {
                              var oe
                              return [
                                Rt(
                                  g(
                                    'div',
                                    ae(
                                      {
                                        ref: B,
                                        class: ['v-overlay__content', e.contentClass],
                                        style: [_.value, U.value],
                                      },
                                      D.value,
                                      e.contentProps
                                    ),
                                    [(oe = n.default) == null ? void 0 : oe.call(n, { isActive: o })]
                                  ),
                                  [
                                    [Qi, o.value],
                                    [
                                      pi('click-outside'),
                                      { handler: G, closeConditional: F, include: () => [y.value] },
                                    ],
                                  ]
                                ),
                              ]
                            },
                          }
                        ),
                      ]
                    ),
                  ],
                }
              ),
          ])
        }),
        {
          activatorEl: y,
          scrimEl: R,
          target: A,
          animateClick: te,
          contentEl: B,
          globalTop: m,
          localTop: p,
          updateLocation: $,
        }
      )
    },
  }),
  hv = Symbol('Forwarded refs')
function fv(e, t) {
  let n = e
  for (; n; ) {
    const i = Reflect.getOwnPropertyDescriptor(n, t)
    if (i) return i
    n = Object.getPrototypeOf(n)
  }
}
function Li(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i]
  return (
    (e[hv] = n),
    new Proxy(e, {
      get(r, s) {
        if (Reflect.has(r, s)) return Reflect.get(r, s)
        if (!(typeof s == 'symbol' || s.startsWith('$') || s.startsWith('__'))) {
          for (const o of n)
            if (o.value && Reflect.has(o.value, s)) {
              const a = Reflect.get(o.value, s)
              return typeof a == 'function' ? a.bind(o.value) : a
            }
        }
      },
      has(r, s) {
        if (Reflect.has(r, s)) return !0
        if (typeof s == 'symbol' || s.startsWith('$') || s.startsWith('__')) return !1
        for (const o of n) if (o.value && Reflect.has(o.value, s)) return !0
        return !1
      },
      set(r, s, o) {
        if (Reflect.has(r, s)) return Reflect.set(r, s, o)
        if (typeof s == 'symbol' || s.startsWith('$') || s.startsWith('__')) return !1
        for (const a of n) if (a.value && Reflect.has(a.value, s)) return Reflect.set(a.value, s, o)
        return !1
      },
      getOwnPropertyDescriptor(r, s) {
        var a
        const o = Reflect.getOwnPropertyDescriptor(r, s)
        if (o) return o
        if (!(typeof s == 'symbol' || s.startsWith('$') || s.startsWith('__'))) {
          for (const l of n) {
            if (!l.value) continue
            const u =
              fv(l.value, s) ?? ('_' in l.value ? fv((a = l.value._) == null ? void 0 : a.setupState, s) : void 0)
            if (u) return u
          }
          for (const l of n) {
            const u = l.value && l.value[hv]
            if (!u) continue
            const c = u.slice()
            for (; c.length; ) {
              const d = c.shift(),
                f = fv(d.value, s)
              if (f) return f
              const m = d.value && d.value[hv]
              m && c.push(...m)
            }
          }
        }
      },
    })
  )
}
const oN = W(
    {
      id: String,
      ...Qt(
        gd({
          closeDelay: 250,
          closeOnContentClick: !0,
          locationStrategy: 'connected',
          openDelay: 300,
          scrim: !1,
          scrollStrategy: 'reposition',
          transition: { component: xm },
        }),
        ['absolute']
      ),
    },
    'VMenu'
  ),
  xl = ne()({
    name: 'VMenu',
    props: oN(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        { scopeId: r } = _a(),
        s = pn(),
        o = k(() => e.id || `v-menu-${s}`),
        a = le(),
        l = je(Zp, null),
        u = ye(0)
      mt(Zp, {
        register() {
          ++u.value
        },
        unregister() {
          --u.value
        },
        closeParents(v) {
          setTimeout(() => {
            !u.value &&
              !e.persistent &&
              (v == null || (v && !HG(v, a.value.contentEl))) &&
              ((i.value = !1), l == null || l.closeParents())
          }, 40)
        },
      })
      async function c(v) {
        var A, x, N
        const y = v.relatedTarget,
          T = v.target
        await Xe(),
          i.value &&
            y !== T &&
            (A = a.value) != null &&
            A.contentEl &&
            (x = a.value) != null &&
            x.globalTop &&
            ![document, a.value.contentEl].includes(T) &&
            !a.value.contentEl.contains(T) &&
            ((N = Ec(a.value.contentEl)[0]) == null || N.focus())
      }
      be(i, (v) => {
        v
          ? (l == null || l.register(), document.addEventListener('focusin', c, { once: !0 }))
          : (l == null || l.unregister(), document.removeEventListener('focusin', c))
      })
      function d(v) {
        l == null || l.closeParents(v)
      }
      function f(v) {
        var y, T, A
        if (!e.disabled)
          if (v.key === 'Tab' || (v.key === 'Enter' && !e.closeOnContentClick)) {
            if (
              v.key === 'Enter' &&
              (v.target instanceof HTMLTextAreaElement ||
                (v.target instanceof HTMLInputElement && v.target.closest('form')))
            )
              return
            v.key === 'Enter' && v.preventDefault(),
              PV(
                Ec((y = a.value) == null ? void 0 : y.contentEl, !1),
                v.shiftKey ? 'prev' : 'next',
                (N) => N.tabIndex >= 0
              ) || ((i.value = !1), (A = (T = a.value) == null ? void 0 : T.activatorEl) == null || A.focus())
          } else
            ['Enter', ' '].includes(v.key) && e.closeOnContentClick && ((i.value = !1), l == null || l.closeParents())
      }
      function m(v) {
        var T
        if (e.disabled) return
        const y = (T = a.value) == null ? void 0 : T.contentEl
        y && i.value
          ? v.key === 'ArrowDown'
            ? (v.preventDefault(), Cl(y, 'next'))
            : v.key === 'ArrowUp' && (v.preventDefault(), Cl(y, 'prev'))
          : ['ArrowDown', 'ArrowUp'].includes(v.key) &&
            ((i.value = !0), v.preventDefault(), setTimeout(() => setTimeout(() => m(v))))
      }
      const p = k(() =>
        ae(
          { 'aria-haspopup': 'menu', 'aria-expanded': String(i.value), 'aria-owns': o.value, onKeydown: m },
          e.activatorProps
        )
      )
      return (
        se(() => {
          const v = mr.filterProps(e)
          return g(
            mr,
            ae(
              { ref: a, id: o.value, class: ['v-menu', e.class], style: e.style },
              v,
              {
                modelValue: i.value,
                'onUpdate:modelValue': (y) => (i.value = y),
                absolute: !0,
                activatorProps: p.value,
                'onClick:outside': d,
                onKeydown: f,
              },
              r
            ),
            {
              activator: n.activator,
              default: function () {
                for (var y = arguments.length, T = new Array(y), A = 0; A < y; A++) T[A] = arguments[A]
                return g(
                  Ge,
                  { root: 'VMenu' },
                  {
                    default: () => {
                      var x
                      return [(x = n.default) == null ? void 0 : x.call(n, ...T)]
                    },
                  }
                )
              },
            }
          )
        }),
        Li({ id: o, ΨopenChildren: u }, a)
      )
    },
  }),
  DY = W(
    {
      active: Boolean,
      disabled: Boolean,
      max: [Number, String],
      value: { type: [Number, String], default: 0 },
      ...Te(),
      ...Xi({ transition: { component: Ub } }),
    },
    'VCounter'
  ),
  $m = ne()({
    name: 'VCounter',
    functional: !0,
    props: DY(),
    setup(e, t) {
      let { slots: n } = t
      const i = k(() => (e.max ? `${e.value} / ${e.max}` : String(e.value)))
      return (
        se(() =>
          g(
            Bn,
            { transition: e.transition },
            {
              default: () => [
                Rt(
                  g(
                    'div',
                    {
                      class: [
                        'v-counter',
                        { 'text-error': e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max) },
                        e.class,
                      ],
                      style: e.style,
                    },
                    [n.default ? n.default({ counter: i.value, max: e.max, value: e.value }) : i.value]
                  ),
                  [[Qi, e.active]]
                ),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  NY = W({ floating: Boolean, ...Te() }, 'VFieldLabel'),
  Ou = ne()({
    name: 'VFieldLabel',
    props: NY(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() =>
          g(
            Kl,
            {
              class: ['v-field-label', { 'v-field-label--floating': e.floating }, e.class],
              style: e.style,
              'aria-hidden': e.floating || void 0,
            },
            n
          )
        ),
        {}
      )
    },
  }),
  OY = ['underlined', 'outlined', 'filled', 'solo', 'solo-inverted', 'solo-filled', 'plain'],
  vd = W(
    {
      appendInnerIcon: Le,
      bgColor: String,
      clearable: Boolean,
      clearIcon: { type: Le, default: '$clear' },
      active: Boolean,
      centerAffix: { type: Boolean, default: void 0 },
      color: String,
      baseColor: String,
      dirty: Boolean,
      disabled: { type: Boolean, default: null },
      error: Boolean,
      flat: Boolean,
      label: String,
      persistentClear: Boolean,
      prependInnerIcon: Le,
      reverse: Boolean,
      singleLine: Boolean,
      variant: { type: String, default: 'filled', validator: (e) => OY.includes(e) },
      'onClick:clear': mn(),
      'onClick:appendInner': mn(),
      'onClick:prependInner': mn(),
      ...Te(),
      ...Om(),
      ...Tt(),
      ...Ze(),
    },
    'VField'
  ),
  Ql = ne()({
    name: 'VField',
    inheritAttrs: !1,
    props: { id: String, ...fd(), ...vd() },
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const { themeClasses: s } = at(e),
        { loaderClasses: o } = ud(e),
        { focusClasses: a, isFocused: l, focus: u, blur: c } = Qr(e),
        { InputIcon: d } = RD(e),
        { roundedClasses: f } = Mt(e),
        { rtlClasses: m } = sn(),
        p = k(() => e.dirty || e.active),
        v = k(() => !e.singleLine && !!(e.label || r.label)),
        y = pn(),
        T = k(() => e.id || `input-${y}`),
        A = k(() => `${T.value}-messages`),
        x = le(),
        N = le(),
        V = le(),
        D = k(() => ['plain', 'underlined'].includes(e.variant)),
        { backgroundColorClasses: I, backgroundColorStyles: w } = gt(Q(e, 'bgColor')),
        { textColorClasses: _, textColorStyles: S } = Tn(
          k(() => (e.error || e.disabled ? void 0 : p.value && l.value ? e.color : e.baseColor))
        )
      be(
        p,
        (B) => {
          if (v.value) {
            const U = x.value.$el,
              $ = N.value.$el
            requestAnimationFrame(() => {
              const G = xb(U),
                F = $.getBoundingClientRect(),
                K = F.x - G.x,
                j = F.y - G.y - (G.height / 2 - F.height / 2),
                q = F.width / 0.75,
                te = Math.abs(q - G.width) > 1 ? { maxWidth: Se(q) } : void 0,
                ce = getComputedStyle(U),
                Ee = getComputedStyle($),
                me = parseFloat(ce.transitionDuration) * 1e3 || 150,
                oe = parseFloat(Ee.getPropertyValue('--v-field-label-scale')),
                z = Ee.getPropertyValue('color')
              ;(U.style.visibility = 'visible'),
                ($.style.visibility = 'hidden'),
                _o(
                  U,
                  { transform: `translate(${K}px, ${j}px) scale(${oe})`, color: z, ...te },
                  { duration: me, easing: Tc, direction: B ? 'normal' : 'reverse' }
                ).finished.then(() => {
                  U.style.removeProperty('visibility'), $.style.removeProperty('visibility')
                })
            })
          }
        },
        { flush: 'post' }
      )
      const E = k(() => ({ isActive: p, isFocused: l, controlRef: V, blur: c, focus: u }))
      function C(B) {
        B.target !== document.activeElement && B.preventDefault()
      }
      function R(B) {
        var U
        ;(B.key !== 'Enter' && B.key !== ' ') ||
          (B.preventDefault(),
          B.stopPropagation(),
          (U = e['onClick:clear']) == null || U.call(e, new MouseEvent('click')))
      }
      return (
        se(() => {
          var K, j, q
          const B = e.variant === 'outlined',
            U = !!(r['prepend-inner'] || e.prependInnerIcon),
            $ = !!(e.clearable || r.clear),
            G = !!(r['append-inner'] || e.appendInnerIcon || $),
            F = () => (r.label ? r.label({ ...E.value, label: e.label, props: { for: T.value } }) : e.label)
          return g(
            'div',
            ae(
              {
                class: [
                  'v-field',
                  {
                    'v-field--active': p.value,
                    'v-field--appended': G,
                    'v-field--center-affix': e.centerAffix ?? !D.value,
                    'v-field--disabled': e.disabled,
                    'v-field--dirty': e.dirty,
                    'v-field--error': e.error,
                    'v-field--flat': e.flat,
                    'v-field--has-background': !!e.bgColor,
                    'v-field--persistent-clear': e.persistentClear,
                    'v-field--prepended': U,
                    'v-field--reverse': e.reverse,
                    'v-field--single-line': e.singleLine,
                    'v-field--no-label': !F(),
                    [`v-field--variant-${e.variant}`]: !0,
                  },
                  s.value,
                  I.value,
                  a.value,
                  o.value,
                  f.value,
                  m.value,
                  e.class,
                ],
                style: [w.value, e.style],
                onClick: C,
              },
              n
            ),
            [
              g('div', { class: 'v-field__overlay' }, null),
              g(
                cd,
                {
                  name: 'v-field',
                  active: !!e.loading,
                  color: e.error ? 'error' : typeof e.loading == 'string' ? e.loading : e.color,
                },
                { default: r.loader }
              ),
              U &&
                g('div', { key: 'prepend', class: 'v-field__prepend-inner' }, [
                  e.prependInnerIcon && g(d, { key: 'prepend-icon', name: 'prependInner' }, null),
                  (K = r['prepend-inner']) == null ? void 0 : K.call(r, E.value),
                ]),
              g('div', { class: 'v-field__field', 'data-no-activator': '' }, [
                ['filled', 'solo', 'solo-inverted', 'solo-filled'].includes(e.variant) &&
                  v.value &&
                  g(
                    Ou,
                    { key: 'floating-label', ref: N, class: [_.value], floating: !0, for: T.value, style: S.value },
                    { default: () => [F()] }
                  ),
                g(Ou, { ref: x, for: T.value }, { default: () => [F()] }),
                (j = r.default) == null
                  ? void 0
                  : j.call(r, {
                      ...E.value,
                      props: { id: T.value, class: 'v-field__input', 'aria-describedby': A.value },
                      focus: u,
                      blur: c,
                    }),
              ]),
              $ &&
                g(
                  jb,
                  { key: 'clear' },
                  {
                    default: () => [
                      Rt(
                        g(
                          'div',
                          {
                            class: 'v-field__clearable',
                            onMousedown: (te) => {
                              te.preventDefault(), te.stopPropagation()
                            },
                          },
                          [
                            g(
                              Ge,
                              { defaults: { VIcon: { icon: e.clearIcon } } },
                              {
                                default: () => [
                                  r.clear
                                    ? r.clear({
                                        ...E.value,
                                        props: { onKeydown: R, onFocus: u, onBlur: c, onClick: e['onClick:clear'] },
                                      })
                                    : g(d, { name: 'clear', onKeydown: R, onFocus: u, onBlur: c }, null),
                                ],
                              }
                            ),
                          ]
                        ),
                        [[Qi, e.dirty]]
                      ),
                    ],
                  }
                ),
              G &&
                g('div', { key: 'append', class: 'v-field__append-inner' }, [
                  (q = r['append-inner']) == null ? void 0 : q.call(r, E.value),
                  e.appendInnerIcon && g(d, { key: 'append-icon', name: 'appendInner' }, null),
                ]),
              g('div', { class: ['v-field__outline', _.value], style: S.value }, [
                B &&
                  g(ke, null, [
                    g('div', { class: 'v-field__outline__start' }, null),
                    v.value &&
                      g('div', { class: 'v-field__outline__notch' }, [
                        g(Ou, { ref: N, floating: !0, for: T.value }, { default: () => [F()] }),
                      ]),
                    g('div', { class: 'v-field__outline__end' }, null),
                  ]),
                D.value && v.value && g(Ou, { ref: N, floating: !0, for: T.value }, { default: () => [F()] }),
              ]),
            ]
          )
        }),
        { controlRef: V }
      )
    },
  })
function ew(e) {
  const t = Object.keys(Ql.props).filter((n) => !Em(n) && n !== 'class' && n !== 'style')
  return kb(e, t)
}
const MY = ['color', 'file', 'time', 'date', 'datetime-local', 'week', 'month'],
  Um = W(
    {
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: [Number, Function],
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      suffix: String,
      role: String,
      type: { type: String, default: 'text' },
      modelModifiers: Object,
      ...Xr(),
      ...vd(),
    },
    'VTextField'
  ),
  Ko = ne()({
    name: 'VTextField',
    directives: { Intersect: ld },
    inheritAttrs: !1,
    props: Um(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const s = xe(e, 'modelValue'),
        { isFocused: o, focus: a, blur: l } = Qr(e),
        u = k(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(s.value)
            : typeof e.counterValue == 'number'
            ? e.counterValue
            : (s.value ?? '').toString().length
        ),
        c = k(() => {
          if (n.maxlength) return n.maxlength
          if (!(!e.counter || (typeof e.counter != 'number' && typeof e.counter != 'string'))) return e.counter
        }),
        d = k(() => ['plain', 'underlined'].includes(e.variant))
      function f(D, I) {
        var w, _
        !e.autofocus || !D || (_ = (w = I[0].target) == null ? void 0 : w.focus) == null || _.call(w)
      }
      const m = le(),
        p = le(),
        v = le(),
        y = k(() => MY.includes(e.type) || e.persistentPlaceholder || o.value || e.active)
      function T() {
        var D
        v.value !== document.activeElement && ((D = v.value) == null || D.focus()), o.value || a()
      }
      function A(D) {
        i('mousedown:control', D), D.target !== v.value && (T(), D.preventDefault())
      }
      function x(D) {
        T(), i('click:control', D)
      }
      function N(D) {
        D.stopPropagation(),
          T(),
          Xe(() => {
            ;(s.value = null), Rb(e['onClick:clear'], D)
          })
      }
      function V(D) {
        var w
        const I = D.target
        if (
          ((s.value = I.value),
          (w = e.modelModifiers) != null && w.trim && ['text', 'search', 'password', 'tel', 'url'].includes(e.type))
        ) {
          const _ = [I.selectionStart, I.selectionEnd]
          Xe(() => {
            ;(I.selectionStart = _[0]), (I.selectionEnd = _[1])
          })
        }
      }
      return (
        se(() => {
          const D = !!(r.counter || (e.counter !== !1 && e.counter != null)),
            I = !!(D || r.details),
            [w, _] = Gs(n),
            { modelValue: S, ...E } = Cn.filterProps(e),
            C = ew(e)
          return g(
            Cn,
            ae(
              {
                ref: m,
                modelValue: s.value,
                'onUpdate:modelValue': (R) => (s.value = R),
                class: [
                  'v-text-field',
                  {
                    'v-text-field--prefixed': e.prefix,
                    'v-text-field--suffixed': e.suffix,
                    'v-input--plain-underlined': d.value,
                  },
                  e.class,
                ],
                style: e.style,
              },
              w,
              E,
              { centerAffix: !d.value, focused: o.value }
            ),
            {
              ...r,
              default: (R) => {
                let { id: B, isDisabled: U, isDirty: $, isReadonly: G, isValid: F } = R
                return g(
                  Ql,
                  ae(
                    {
                      ref: p,
                      onMousedown: A,
                      onClick: x,
                      'onClick:clear': N,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner'],
                      role: e.role,
                    },
                    C,
                    {
                      id: B.value,
                      active: y.value || $.value,
                      dirty: $.value || e.dirty,
                      disabled: U.value,
                      focused: o.value,
                      error: F.value === !1,
                    }
                  ),
                  {
                    ...r,
                    default: (K) => {
                      let {
                        props: { class: j, ...q },
                      } = K
                      const te = Rt(
                        g(
                          'input',
                          ae(
                            {
                              ref: v,
                              value: s.value,
                              onInput: V,
                              autofocus: e.autofocus,
                              readonly: G.value,
                              disabled: U.value,
                              name: e.name,
                              placeholder: e.placeholder,
                              size: 1,
                              type: e.type,
                              onFocus: T,
                              onBlur: l,
                            },
                            q,
                            _
                          ),
                          null
                        ),
                        [[pi('intersect'), { handler: f }, null, { once: !0 }]]
                      )
                      return g(ke, null, [
                        e.prefix &&
                          g('span', { class: 'v-text-field__prefix' }, [
                            g('span', { class: 'v-text-field__prefix__text' }, [e.prefix]),
                          ]),
                        r.default
                          ? g('div', { class: j, 'data-no-activator': '' }, [r.default(), te])
                          : Nr(te, { class: j }),
                        e.suffix &&
                          g('span', { class: 'v-text-field__suffix' }, [
                            g('span', { class: 'v-text-field__suffix__text' }, [e.suffix]),
                          ]),
                      ])
                    },
                  }
                )
              },
              details: I
                ? (R) => {
                    var B
                    return g(ke, null, [
                      (B = r.details) == null ? void 0 : B.call(r, R),
                      D &&
                        g(ke, null, [
                          g('span', null, null),
                          g(
                            $m,
                            {
                              active: e.persistentCounter || o.value,
                              value: u.value,
                              max: c.value,
                              disabled: e.disabled,
                            },
                            r.counter
                          ),
                        ]),
                    ])
                  }
                : void 0,
            }
          )
        }),
        Li({}, m, p, v)
      )
    },
  }),
  LY = W({ renderless: Boolean, ...Te() }, 'VVirtualScrollItem'),
  aN = ne()({
    name: 'VVirtualScrollItem',
    inheritAttrs: !1,
    props: LY(),
    emits: { 'update:height': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const { resizeRef: s, contentRect: o } = Gi(void 0, 'border')
      be(
        () => {
          var a
          return (a = o.value) == null ? void 0 : a.height
        },
        (a) => {
          a != null && i('update:height', a)
        }
      ),
        se(() => {
          var a, l
          return e.renderless
            ? g(ke, null, [(a = r.default) == null ? void 0 : a.call(r, { itemRef: s })])
            : g('div', ae({ ref: s, class: ['v-virtual-scroll__item', e.class], style: e.style }, n), [
                (l = r.default) == null ? void 0 : l.call(r),
              ])
        })
    },
  }),
  FY = -1,
  BY = 1,
  mv = 100,
  lN = W({ itemHeight: { type: [Number, String], default: null }, height: [Number, String] }, 'virtual')
function uN(e, t) {
  const n = Ni(),
    i = ye(0)
  $t(() => {
    i.value = parseFloat(e.itemHeight || 0)
  })
  const r = ye(0),
    s = ye(Math.ceil((parseInt(e.height) || n.height.value) / (i.value || 16)) || 1),
    o = ye(0),
    a = ye(0),
    l = le(),
    u = le()
  let c = 0
  const { resizeRef: d, contentRect: f } = Gi()
  $t(() => {
    d.value = l.value
  })
  const m = k(() => {
      var K
      return l.value === document.documentElement
        ? n.height.value
        : ((K = f.value) == null ? void 0 : K.height) || parseInt(e.height) || 0
    }),
    p = k(() => !!(l.value && u.value && m.value && i.value))
  let v = Array.from({ length: t.value.length }),
    y = Array.from({ length: t.value.length })
  const T = ye(0)
  let A = -1
  function x(K) {
    return v[K] || i.value
  }
  const N = BG(() => {
      const K = performance.now()
      y[0] = 0
      const j = t.value.length
      for (let q = 1; q <= j - 1; q++) y[q] = (y[q - 1] || 0) + x(q - 1)
      T.value = Math.max(T.value, performance.now() - K)
    }, T),
    V = be(p, (K) => {
      K &&
        (V(),
        (c = u.value.offsetTop),
        N.immediate(),
        U(),
        ~A &&
          Xe(() => {
            ct &&
              window.requestAnimationFrame(() => {
                G(A), (A = -1)
              })
          }))
    })
  gn(() => {
    N.clear()
  })
  function D(K, j) {
    const q = v[K],
      te = i.value
    ;(i.value = te ? Math.min(i.value, j) : j), (q !== j || te !== i.value) && ((v[K] = j), N())
  }
  function I(K) {
    return (K = qt(K, 0, t.value.length - 1)), y[K] || 0
  }
  function w(K) {
    return $Y(y, K)
  }
  let _ = 0,
    S = 0,
    E = 0
  be(m, (K, j) => {
    j &&
      (U(),
      K < j &&
        requestAnimationFrame(() => {
          ;(S = 0), U()
        }))
  })
  function C() {
    if (!l.value || !u.value) return
    const K = l.value.scrollTop,
      j = performance.now()
    j - E > 500 ? ((S = Math.sign(K - _)), (c = u.value.offsetTop)) : (S = K - _), (_ = K), (E = j), U()
  }
  function R() {
    !l.value || !u.value || ((S = 0), (E = 0), U())
  }
  let B = -1
  function U() {
    cancelAnimationFrame(B), (B = requestAnimationFrame($))
  }
  function $() {
    if (!l.value || !m.value) return
    const K = _ - c,
      j = Math.sign(S),
      q = Math.max(0, K - mv),
      te = qt(w(q), 0, t.value.length),
      ce = K + m.value + mv,
      Ee = qt(w(ce) + 1, te + 1, t.value.length)
    if ((j !== FY || te < r.value) && (j !== BY || Ee > s.value)) {
      const me = I(r.value) - I(te),
        oe = I(Ee) - I(s.value)
      Math.max(me, oe) > mv
        ? ((r.value = te), (s.value = Ee))
        : (te <= 0 && (r.value = te), Ee >= t.value.length && (s.value = Ee))
    }
    ;(o.value = I(r.value)), (a.value = I(t.value.length) - I(s.value))
  }
  function G(K) {
    const j = I(K)
    !l.value || (K && !j) ? (A = K) : (l.value.scrollTop = j)
  }
  const F = k(() => t.value.slice(r.value, s.value).map((K, j) => ({ raw: K, index: j + r.value })))
  return (
    be(
      t,
      () => {
        ;(v = Array.from({ length: t.value.length })), (y = Array.from({ length: t.value.length })), N.immediate(), U()
      },
      { deep: !0 }
    ),
    {
      containerRef: l,
      markerRef: u,
      computedItems: F,
      paddingTop: o,
      paddingBottom: a,
      scrollToIndex: G,
      handleScroll: C,
      handleScrollend: R,
      handleItemResize: D,
    }
  )
}
function $Y(e, t) {
  let n = e.length - 1,
    i = 0,
    r = 0,
    s = null,
    o = -1
  if (e[n] < t) return n
  for (; i <= n; )
    if (((r = (i + n) >> 1), (s = e[r]), s > t)) n = r - 1
    else if (s < t) (o = r), (i = r + 1)
    else return s === t ? r : i
  return o
}
const UY = W(
    { items: { type: Array, default: () => [] }, renderless: Boolean, ...lN(), ...Te(), ...on() },
    'VVirtualScroll'
  ),
  jm = ne()({
    name: 'VVirtualScroll',
    props: UY(),
    setup(e, t) {
      let { slots: n } = t
      const i = Ut('VVirtualScroll'),
        { dimensionStyles: r } = an(e),
        {
          containerRef: s,
          markerRef: o,
          handleScroll: a,
          handleScrollend: l,
          handleItemResize: u,
          scrollToIndex: c,
          paddingTop: d,
          paddingBottom: f,
          computedItems: m,
        } = uN(e, Q(e, 'items'))
      return (
        ii(
          () => e.renderless,
          () => {
            function p() {
              var T, A
              const y = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1)
                ? 'addEventListener'
                : 'removeEventListener'
              s.value === document.documentElement
                ? (document[y]('scroll', a, { passive: !0 }), document[y]('scrollend', l))
                : ((T = s.value) == null || T[y]('scroll', a, { passive: !0 }),
                  (A = s.value) == null || A[y]('scrollend', l))
            }
            An(() => {
              ;(s.value = Ob(i.vnode.el, !0)), p(!0)
            }),
              gn(p)
          }
        ),
        se(() => {
          const p = m.value.map((v) =>
            g(
              aN,
              { key: v.index, renderless: e.renderless, 'onUpdate:height': (y) => u(v.index, y) },
              {
                default: (y) => {
                  var T
                  return (T = n.default) == null ? void 0 : T.call(n, { item: v.raw, index: v.index, ...y })
                },
              }
            )
          )
          return e.renderless
            ? g(ke, null, [
                g('div', { ref: o, class: 'v-virtual-scroll__spacer', style: { paddingTop: Se(d.value) } }, null),
                p,
                g('div', { class: 'v-virtual-scroll__spacer', style: { paddingBottom: Se(f.value) } }, null),
              ])
            : g(
                'div',
                {
                  ref: s,
                  class: ['v-virtual-scroll', e.class],
                  onScrollPassive: a,
                  onScrollend: l,
                  style: [r.value, e.style],
                },
                [
                  g(
                    'div',
                    {
                      ref: o,
                      class: 'v-virtual-scroll__container',
                      style: { paddingTop: Se(d.value), paddingBottom: Se(f.value) },
                    },
                    [p]
                  ),
                ]
              )
        }),
        { scrollToIndex: c }
      )
    },
  })
function tw(e, t) {
  const n = ye(!1)
  let i
  function r(a) {
    cancelAnimationFrame(i),
      (n.value = !0),
      (i = requestAnimationFrame(() => {
        i = requestAnimationFrame(() => {
          n.value = !1
        })
      }))
  }
  async function s() {
    await new Promise((a) => requestAnimationFrame(a)),
      await new Promise((a) => requestAnimationFrame(a)),
      await new Promise((a) => requestAnimationFrame(a)),
      await new Promise((a) => {
        if (n.value) {
          const l = be(n, () => {
            l(), a()
          })
        } else a()
      })
  }
  async function o(a) {
    var c, d
    if (
      (a.key === 'Tab' && ((c = t.value) == null || c.focus()), !['PageDown', 'PageUp', 'Home', 'End'].includes(a.key))
    )
      return
    const l = (d = e.value) == null ? void 0 : d.$el
    if (!l) return
    ;(a.key === 'Home' || a.key === 'End') &&
      l.scrollTo({ top: a.key === 'Home' ? 0 : l.scrollHeight, behavior: 'smooth' }),
      await s()
    const u = l.querySelectorAll(':scope > :not(.v-virtual-scroll__spacer)')
    if (a.key === 'PageDown' || a.key === 'Home') {
      const f = l.getBoundingClientRect().top
      for (const m of u)
        if (m.getBoundingClientRect().top >= f) {
          m.focus()
          break
        }
    } else {
      const f = l.getBoundingClientRect().bottom
      for (const m of [...u].reverse())
        if (m.getBoundingClientRect().bottom <= f) {
          m.focus()
          break
        }
    }
  }
  return { onListScroll: r, onListKeydown: o }
}
const nw = W(
    {
      chips: Boolean,
      closableChips: Boolean,
      closeText: { type: String, default: '$vuetify.close' },
      openText: { type: String, default: '$vuetify.open' },
      eager: Boolean,
      hideNoData: Boolean,
      hideSelected: Boolean,
      listProps: { type: Object },
      menu: Boolean,
      menuIcon: { type: Le, default: '$dropdown' },
      menuProps: { type: Object },
      multiple: Boolean,
      noDataText: { type: String, default: '$vuetify.noDataText' },
      openOnClear: Boolean,
      itemColor: String,
      ...QD({ itemChildren: !1 }),
    },
    'Select'
  ),
  jY = W(
    {
      ...nw(),
      ...Qt(Um({ modelValue: null, role: 'combobox' }), ['validationValue', 'dirty', 'appendInnerIcon']),
      ...Xi({ transition: { component: xm } }),
    },
    'VSelect'
  ),
  iw = ne()({
    name: 'VSelect',
    props: jY(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0, 'update:menu': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = jt(),
        r = le(),
        s = le(),
        o = le(),
        a = xe(e, 'menu'),
        l = k({
          get: () => a.value,
          set: (F) => {
            var K
            ;(a.value && !F && (K = s.value) != null && K.ΨopenChildren) || (a.value = F)
          },
        }),
        { items: u, transformIn: c, transformOut: d } = Yb(e),
        f = xe(
          e,
          'modelValue',
          [],
          (F) => c(F === null ? [null] : Pt(F)),
          (F) => {
            const K = d(F)
            return e.multiple ? K : K[0] ?? null
          }
        ),
        m = k(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(f.value)
            : typeof e.counterValue == 'number'
            ? e.counterValue
            : f.value.length
        ),
        p = Fm(),
        v = k(() => f.value.map((F) => F.value)),
        y = ye(!1),
        T = k(() => (l.value ? e.closeText : e.openText))
      let A = '',
        x
      const N = k(() =>
          e.hideSelected ? u.value.filter((F) => !f.value.some((K) => e.valueComparator(K, F))) : u.value
        ),
        V = k(() => (e.hideNoData && !N.value.length) || e.readonly || (p == null ? void 0 : p.isReadonly.value)),
        D = k(() => {
          var F
          return {
            ...e.menuProps,
            activatorProps: {
              ...(((F = e.menuProps) == null ? void 0 : F.activatorProps) || {}),
              'aria-haspopup': 'listbox',
            },
          }
        }),
        I = le(),
        { onListScroll: w, onListKeydown: _ } = tw(I, r)
      function S(F) {
        e.openOnClear && (l.value = !0)
      }
      function E() {
        V.value || (l.value = !l.value)
      }
      function C(F) {
        var ce, Ee
        if (!F.key || e.readonly || (p != null && p.isReadonly.value)) return
        ;['Enter', ' ', 'ArrowDown', 'ArrowUp', 'Home', 'End'].includes(F.key) && F.preventDefault(),
          ['Enter', 'ArrowDown', ' '].includes(F.key) && (l.value = !0),
          ['Escape', 'Tab'].includes(F.key) && (l.value = !1),
          F.key === 'Home'
            ? (ce = I.value) == null || ce.focus('first')
            : F.key === 'End' && ((Ee = I.value) == null || Ee.focus('last'))
        const K = 1e3
        function j(me) {
          const oe = me.key.length === 1,
            z = !me.ctrlKey && !me.metaKey && !me.altKey
          return oe && z
        }
        if (e.multiple || !j(F)) return
        const q = performance.now()
        q - x > K && (A = ''), (A += F.key.toLowerCase()), (x = q)
        const te = u.value.find((me) => me.title.toLowerCase().startsWith(A))
        if (te !== void 0) {
          f.value = [te]
          const me = N.value.indexOf(te)
          ct &&
            window.requestAnimationFrame(() => {
              var oe
              me >= 0 && ((oe = o.value) == null || oe.scrollToIndex(me))
            })
        }
      }
      function R(F) {
        let K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
        if (!F.props.disabled)
          if (e.multiple) {
            const j = f.value.findIndex((te) => e.valueComparator(te.value, F.value)),
              q = K ?? !~j
            if (~j) {
              const te = q ? [...f.value, F] : [...f.value]
              te.splice(j, 1), (f.value = te)
            } else q && (f.value = [...f.value, F])
          } else {
            const j = K !== !1
            ;(f.value = j ? [F] : []),
              Xe(() => {
                l.value = !1
              })
          }
      }
      function B(F) {
        var K
        ;((K = I.value) != null && K.$el.contains(F.relatedTarget)) || (l.value = !1)
      }
      function U() {
        var F
        y.value && ((F = r.value) == null || F.focus())
      }
      function $(F) {
        y.value = !0
      }
      function G(F) {
        if (F == null) f.value = []
        else if (Al(r.value, ':autofill') || Al(r.value, ':-webkit-autofill')) {
          const K = u.value.find((j) => j.title === F)
          K && R(K)
        } else r.value && (r.value.value = '')
      }
      return (
        be(l, () => {
          if (!e.hideSelected && l.value && f.value.length) {
            const F = N.value.findIndex((K) => f.value.some((j) => e.valueComparator(j.value, K.value)))
            ct &&
              window.requestAnimationFrame(() => {
                var K
                F >= 0 && ((K = o.value) == null || K.scrollToIndex(F))
              })
          }
        }),
        be(
          () => e.items,
          (F, K) => {
            l.value || (y.value && !K.length && F.length && (l.value = !0))
          }
        ),
        se(() => {
          const F = !!(e.chips || n.chip),
            K = !!(!e.hideNoData || N.value.length || n['prepend-item'] || n['append-item'] || n['no-data']),
            j = f.value.length > 0,
            q = Ko.filterProps(e),
            te = j || (!y.value && e.label && !e.persistentPlaceholder) ? void 0 : e.placeholder
          return g(
            Ko,
            ae({ ref: r }, q, {
              modelValue: f.value.map((ce) => ce.props.value).join(', '),
              'onUpdate:modelValue': G,
              focused: y.value,
              'onUpdate:focused': (ce) => (y.value = ce),
              validationValue: f.externalValue,
              counterValue: m.value,
              dirty: j,
              class: [
                'v-select',
                {
                  'v-select--active-menu': l.value,
                  'v-select--chips': !!e.chips,
                  [`v-select--${e.multiple ? 'multiple' : 'single'}`]: !0,
                  'v-select--selected': f.value.length,
                  'v-select--selection-slot': !!n.selection,
                },
                e.class,
              ],
              style: e.style,
              inputmode: 'none',
              placeholder: te,
              'onClick:clear': S,
              'onMousedown:control': E,
              onBlur: B,
              onKeydown: C,
              'aria-label': i(T.value),
              title: i(T.value),
            }),
            {
              ...n,
              default: () =>
                g(ke, null, [
                  g(
                    xl,
                    ae(
                      {
                        ref: s,
                        modelValue: l.value,
                        'onUpdate:modelValue': (ce) => (l.value = ce),
                        activator: 'parent',
                        contentClass: 'v-select__content',
                        disabled: V.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterLeave: U,
                      },
                      D.value
                    ),
                    {
                      default: () => [
                        K &&
                          g(
                            Bm,
                            ae(
                              {
                                ref: I,
                                selected: v.value,
                                selectStrategy: e.multiple ? 'independent' : 'single-independent',
                                onMousedown: (ce) => ce.preventDefault(),
                                onKeydown: _,
                                onFocusin: $,
                                onScrollPassive: w,
                                tabindex: '-1',
                                'aria-live': 'polite',
                                color: e.itemColor ?? e.color,
                              },
                              e.listProps
                            ),
                            {
                              default: () => {
                                var ce, Ee, me
                                return [
                                  (ce = n['prepend-item']) == null ? void 0 : ce.call(n),
                                  !N.value.length &&
                                    !e.hideNoData &&
                                    (((Ee = n['no-data']) == null ? void 0 : Ee.call(n)) ??
                                      g(Ur, { title: i(e.noDataText) }, null)),
                                  g(
                                    jm,
                                    { ref: o, renderless: !0, items: N.value },
                                    {
                                      default: (oe) => {
                                        var pe
                                        let { item: z, index: ue, itemRef: de } = oe
                                        const Z = ae(z.props, { ref: de, key: ue, onClick: () => R(z, null) })
                                        return (
                                          ((pe = n.item) == null
                                            ? void 0
                                            : pe.call(n, { item: z, index: ue, props: Z })) ??
                                          g(Ur, ae(Z, { role: 'option' }), {
                                            prepend: (re) => {
                                              let { isSelected: O } = re
                                              return g(ke, null, [
                                                e.multiple && !e.hideSelected
                                                  ? g(
                                                      $r,
                                                      { key: z.value, modelValue: O, ripple: !1, tabindex: '-1' },
                                                      null
                                                    )
                                                  : void 0,
                                                z.props.prependAvatar && g(Vi, { image: z.props.prependAvatar }, null),
                                                z.props.prependIcon && g(ot, { icon: z.props.prependIcon }, null),
                                              ])
                                            },
                                          })
                                        )
                                      },
                                    }
                                  ),
                                  (me = n['append-item']) == null ? void 0 : me.call(n),
                                ]
                              },
                            }
                          ),
                      ],
                    }
                  ),
                  f.value.map((ce, Ee) => {
                    function me(de) {
                      de.stopPropagation(), de.preventDefault(), R(ce, !1)
                    }
                    const oe = {
                        'onClick:close': me,
                        onKeydown(de) {
                          ;(de.key !== 'Enter' && de.key !== ' ') || (de.preventDefault(), de.stopPropagation(), me(de))
                        },
                        onMousedown(de) {
                          de.preventDefault(), de.stopPropagation()
                        },
                        modelValue: !0,
                        'onUpdate:modelValue': void 0,
                      },
                      z = F ? !!n.chip : !!n.selection,
                      ue = z
                        ? Tm(F ? n.chip({ item: ce, index: Ee, props: oe }) : n.selection({ item: ce, index: Ee }))
                        : void 0
                    if (!(z && !ue))
                      return g('div', { key: ce.value, class: 'v-select__selection' }, [
                        F
                          ? n.chip
                            ? g(
                                Ge,
                                {
                                  key: 'chip-defaults',
                                  defaults: { VChip: { closable: e.closableChips, size: 'small', text: ce.title } },
                                },
                                { default: () => [ue] }
                              )
                            : g(
                                Yl,
                                ae(
                                  {
                                    key: 'chip',
                                    closable: e.closableChips,
                                    size: 'small',
                                    text: ce.title,
                                    disabled: ce.props.disabled,
                                  },
                                  oe
                                ),
                                null
                              )
                          : ue ??
                            g('span', { class: 'v-select__selection-text' }, [
                              ce.title,
                              e.multiple &&
                                Ee < f.value.length - 1 &&
                                g('span', { class: 'v-select__selection-comma' }, [Or(',')]),
                            ]),
                      ])
                  }),
                ]),
              'append-inner': function () {
                var oe
                for (var ce = arguments.length, Ee = new Array(ce), me = 0; me < ce; me++) Ee[me] = arguments[me]
                return g(ke, null, [
                  (oe = n['append-inner']) == null ? void 0 : oe.call(n, ...Ee),
                  e.menuIcon ? g(ot, { class: 'v-select__menu-icon', icon: e.menuIcon }, null) : void 0,
                ])
              },
            }
          )
        }),
        Li({ isFocused: y, menu: l, select: R }, r)
      )
    },
  }),
  zY = (e, t, n) =>
    e == null || t == null ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()),
  pd = W(
    {
      customFilter: Function,
      customKeyFilter: Object,
      filterKeys: [Array, String],
      filterMode: { type: String, default: 'intersection' },
      noFilter: Boolean,
    },
    'filter'
  )
function HY(e, t, n) {
  var a
  const i = [],
    r = (n == null ? void 0 : n.default) ?? zY,
    s = n != null && n.filterKeys ? Pt(n.filterKeys) : !1,
    o = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length
  if (!(e != null && e.length)) return i
  e: for (let l = 0; l < e.length; l++) {
    const [u, c = u] = Pt(e[l]),
      d = {},
      f = {}
    let m = -1
    if ((t || o > 0) && !(n != null && n.noFilter)) {
      if (typeof u == 'object') {
        const y = s || Object.keys(c)
        for (const T of y) {
          const A = Jt(c, T),
            x = (a = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : a[T]
          if (((m = x ? x(A, t, u) : r(A, t, u)), m !== -1 && m !== !1)) x ? (d[T] = m) : (f[T] = m)
          else if ((n == null ? void 0 : n.filterMode) === 'every') continue e
        }
      } else (m = r(u, t, u)), m !== -1 && m !== !1 && (f.title = m)
      const p = Object.keys(f).length,
        v = Object.keys(d).length
      if (
        (!p && !v) ||
        ((n == null ? void 0 : n.filterMode) === 'union' && v !== o && !p) ||
        ((n == null ? void 0 : n.filterMode) === 'intersection' && (v !== o || !p))
      )
        continue
    }
    i.push({ index: l, matches: { ...f, ...d } })
  }
  return i
}
function yd(e, t, n, i) {
  const r = le([]),
    s = le(new Map()),
    o = k(() => (i != null && i.transform ? Lt(t).map((l) => [l, i.transform(l)]) : Lt(t)))
  $t(() => {
    const l = typeof n == 'function' ? n() : Lt(n),
      u = typeof l != 'string' && typeof l != 'number' ? '' : String(l),
      c = HY(o.value, u, {
        customKeyFilter: { ...e.customKeyFilter, ...Lt(i == null ? void 0 : i.customKeyFilter) },
        default: e.customFilter,
        filterKeys: e.filterKeys,
        filterMode: e.filterMode,
        noFilter: e.noFilter,
      }),
      d = Lt(t),
      f = [],
      m = new Map()
    c.forEach((p) => {
      let { index: v, matches: y } = p
      const T = d[v]
      f.push(T), m.set(T.value, y)
    }),
      (r.value = f),
      (s.value = m)
  })
  function a(l) {
    return s.value.get(l.value)
  }
  return { filteredItems: r, filteredMatches: s, getMatches: a }
}
function WY(e, t, n) {
  if (t == null) return e
  if (Array.isArray(t)) throw new Error('Multiple matches is not implemented')
  return typeof t == 'number' && ~t
    ? g(ke, null, [
        g('span', { class: 'v-autocomplete__unmask' }, [e.substr(0, t)]),
        g('span', { class: 'v-autocomplete__mask' }, [e.substr(t, n)]),
        g('span', { class: 'v-autocomplete__unmask' }, [e.substr(t + n)]),
      ])
    : e
}
const qY = W(
    {
      autoSelectFirst: { type: [Boolean, String] },
      clearOnSelect: Boolean,
      search: String,
      ...pd({ filterKeys: ['title'] }),
      ...nw(),
      ...Qt(Um({ modelValue: null, role: 'combobox' }), ['validationValue', 'dirty', 'appendInnerIcon']),
      ...Xi({ transition: !1 }),
    },
    'VAutocomplete'
  ),
  GY = ne()({
    name: 'VAutocomplete',
    props: qY(),
    emits: {
      'update:focused': (e) => !0,
      'update:search': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:menu': (e) => !0,
    },
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = jt(),
        r = le(),
        s = ye(!1),
        o = ye(!0),
        a = ye(!1),
        l = le(),
        u = le(),
        c = xe(e, 'menu'),
        d = k({
          get: () => c.value,
          set: (Z) => {
            var pe
            ;(c.value && !Z && (pe = l.value) != null && pe.ΨopenChildren) || (c.value = Z)
          },
        }),
        f = ye(-1),
        m = k(() => {
          var Z
          return (Z = r.value) == null ? void 0 : Z.color
        }),
        p = k(() => (d.value ? e.closeText : e.openText)),
        { items: v, transformIn: y, transformOut: T } = Yb(e),
        { textColorClasses: A, textColorStyles: x } = Tn(m),
        N = xe(e, 'search', ''),
        V = xe(
          e,
          'modelValue',
          [],
          (Z) => y(Z === null ? [null] : Pt(Z)),
          (Z) => {
            const pe = T(Z)
            return e.multiple ? pe : pe[0] ?? null
          }
        ),
        D = k(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(V.value)
            : typeof e.counterValue == 'number'
            ? e.counterValue
            : V.value.length
        ),
        I = Fm(),
        { filteredItems: w, getMatches: _ } = yd(e, v, () => (o.value ? '' : N.value)),
        S = k(() => (e.hideSelected ? w.value.filter((Z) => !V.value.some((pe) => pe.value === Z.value)) : w.value)),
        E = k(() => !!(e.chips || n.chip)),
        C = k(() => E.value || !!n.selection),
        R = k(() => V.value.map((Z) => Z.props.value)),
        B = k(() => {
          var pe
          return (
            (e.autoSelectFirst === !0 ||
              (e.autoSelectFirst === 'exact' && N.value === ((pe = S.value[0]) == null ? void 0 : pe.title))) &&
            S.value.length > 0 &&
            !o.value &&
            !a.value
          )
        }),
        U = k(() => (e.hideNoData && !S.value.length) || e.readonly || (I == null ? void 0 : I.isReadonly.value)),
        $ = le(),
        { onListScroll: G, onListKeydown: F } = tw($, r)
      function K(Z) {
        e.openOnClear && (d.value = !0), (N.value = '')
      }
      function j() {
        U.value || (d.value = !0)
      }
      function q(Z) {
        U.value || (s.value && (Z.preventDefault(), Z.stopPropagation()), (d.value = !d.value))
      }
      function te(Z) {
        var O, L, H
        if (e.readonly || (I != null && I.isReadonly.value)) return
        const pe = r.value.selectionStart,
          re = V.value.length
        if (
          ((f.value > -1 || ['Enter', 'ArrowDown', 'ArrowUp'].includes(Z.key)) && Z.preventDefault(),
          ['Enter', 'ArrowDown'].includes(Z.key) && (d.value = !0),
          ['Escape'].includes(Z.key) && (d.value = !1),
          B.value &&
            ['Enter', 'Tab'].includes(Z.key) &&
            !V.value.some((X) => {
              let { value: ee } = X
              return ee === S.value[0].value
            }) &&
            de(S.value[0]),
          Z.key === 'ArrowDown' && B.value && ((O = $.value) == null || O.focus('next')),
          ['Backspace', 'Delete'].includes(Z.key))
        ) {
          if (!e.multiple && C.value && V.value.length > 0 && !N.value) return de(V.value[0], !1)
          if (~f.value) {
            const X = f.value
            de(V.value[f.value], !1), (f.value = X >= re - 1 ? re - 2 : X)
          } else Z.key === 'Backspace' && !N.value && (f.value = re - 1)
        }
        if (e.multiple) {
          if (Z.key === 'ArrowLeft') {
            if (f.value < 0 && pe > 0) return
            const X = f.value > -1 ? f.value - 1 : re - 1
            V.value[X]
              ? (f.value = X)
              : ((f.value = -1),
                r.value.setSelectionRange(
                  (L = N.value) == null ? void 0 : L.length,
                  (H = N.value) == null ? void 0 : H.length
                ))
          }
          if (Z.key === 'ArrowRight') {
            if (f.value < 0) return
            const X = f.value + 1
            V.value[X] ? (f.value = X) : ((f.value = -1), r.value.setSelectionRange(0, 0))
          }
        }
      }
      function ce(Z) {
        if (Al(r.value, ':autofill') || Al(r.value, ':-webkit-autofill')) {
          const pe = v.value.find((re) => re.title === Z.target.value)
          pe && de(pe)
        }
      }
      function Ee() {
        var Z
        s.value && ((o.value = !0), (Z = r.value) == null || Z.focus())
      }
      function me(Z) {
        ;(s.value = !0),
          setTimeout(() => {
            a.value = !0
          })
      }
      function oe(Z) {
        a.value = !1
      }
      function z(Z) {
        ;(Z == null || (Z === '' && !e.multiple && !C.value)) && (V.value = [])
      }
      const ue = ye(!1)
      function de(Z) {
        let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
        if (!(!Z || Z.props.disabled))
          if (e.multiple) {
            const re = V.value.findIndex((L) => e.valueComparator(L.value, Z.value)),
              O = pe ?? !~re
            if (~re) {
              const L = O ? [...V.value, Z] : [...V.value]
              L.splice(re, 1), (V.value = L)
            } else O && (V.value = [...V.value, Z])
            e.clearOnSelect && (N.value = '')
          } else {
            const re = pe !== !1
            ;(V.value = re ? [Z] : []),
              (N.value = re && !C.value ? Z.title : ''),
              Xe(() => {
                ;(d.value = !1), (o.value = !0)
              })
          }
      }
      return (
        be(s, (Z, pe) => {
          var re
          Z !== pe &&
            (Z
              ? ((ue.value = !0),
                (N.value =
                  e.multiple || C.value ? '' : String(((re = V.value.at(-1)) == null ? void 0 : re.props.title) ?? '')),
                (o.value = !0),
                Xe(() => (ue.value = !1)))
              : (!e.multiple && N.value == null && (V.value = []),
                (d.value = !1),
                V.value.some((O) => {
                  let { title: L } = O
                  return L === N.value
                }) || (N.value = ''),
                (f.value = -1)))
        }),
        be(N, (Z) => {
          !s.value || ue.value || (Z && (d.value = !0), (o.value = !Z))
        }),
        be(d, () => {
          if (!e.hideSelected && d.value && V.value.length) {
            const Z = S.value.findIndex((pe) => V.value.some((re) => pe.value === re.value))
            ct &&
              window.requestAnimationFrame(() => {
                var pe
                Z >= 0 && ((pe = u.value) == null || pe.scrollToIndex(Z))
              })
          }
        }),
        be(
          () => e.items,
          (Z, pe) => {
            d.value || (s.value && !pe.length && Z.length && (d.value = !0))
          }
        ),
        se(() => {
          const Z = !!(!e.hideNoData || S.value.length || n['prepend-item'] || n['append-item'] || n['no-data']),
            pe = V.value.length > 0,
            re = Ko.filterProps(e)
          return g(
            Ko,
            ae({ ref: r }, re, {
              modelValue: N.value,
              'onUpdate:modelValue': [(O) => (N.value = O), z],
              focused: s.value,
              'onUpdate:focused': (O) => (s.value = O),
              validationValue: V.externalValue,
              counterValue: D.value,
              dirty: pe,
              onChange: ce,
              class: [
                'v-autocomplete',
                `v-autocomplete--${e.multiple ? 'multiple' : 'single'}`,
                {
                  'v-autocomplete--active-menu': d.value,
                  'v-autocomplete--chips': !!e.chips,
                  'v-autocomplete--selection-slot': !!C.value,
                  'v-autocomplete--selecting-index': f.value > -1,
                },
                e.class,
              ],
              style: e.style,
              readonly: e.readonly,
              placeholder: pe ? void 0 : e.placeholder,
              'onClick:clear': K,
              'onMousedown:control': j,
              onKeydown: te,
            }),
            {
              ...n,
              default: () =>
                g(ke, null, [
                  g(
                    xl,
                    ae(
                      {
                        ref: l,
                        modelValue: d.value,
                        'onUpdate:modelValue': (O) => (d.value = O),
                        activator: 'parent',
                        contentClass: 'v-autocomplete__content',
                        disabled: U.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterLeave: Ee,
                      },
                      e.menuProps
                    ),
                    {
                      default: () => [
                        Z &&
                          g(
                            Bm,
                            ae(
                              {
                                ref: $,
                                selected: R.value,
                                selectStrategy: e.multiple ? 'independent' : 'single-independent',
                                onMousedown: (O) => O.preventDefault(),
                                onKeydown: F,
                                onFocusin: me,
                                onFocusout: oe,
                                onScrollPassive: G,
                                tabindex: '-1',
                                'aria-live': 'polite',
                                color: e.itemColor ?? e.color,
                              },
                              e.listProps
                            ),
                            {
                              default: () => {
                                var O, L, H
                                return [
                                  (O = n['prepend-item']) == null ? void 0 : O.call(n),
                                  !S.value.length &&
                                    !e.hideNoData &&
                                    (((L = n['no-data']) == null ? void 0 : L.call(n)) ??
                                      g(Ur, { title: i(e.noDataText) }, null)),
                                  g(
                                    jm,
                                    { ref: u, renderless: !0, items: S.value },
                                    {
                                      default: (X) => {
                                        var _e
                                        let { item: ee, index: he, itemRef: ge } = X
                                        const Ie = ae(ee.props, {
                                          ref: ge,
                                          key: he,
                                          active: B.value && he === 0 ? !0 : void 0,
                                          onClick: () => de(ee, null),
                                        })
                                        return (
                                          ((_e = n.item) == null
                                            ? void 0
                                            : _e.call(n, { item: ee, index: he, props: Ie })) ??
                                          g(Ur, ae(Ie, { role: 'option' }), {
                                            prepend: (ve) => {
                                              let { isSelected: Ae } = ve
                                              return g(ke, null, [
                                                e.multiple && !e.hideSelected
                                                  ? g(
                                                      $r,
                                                      { key: ee.value, modelValue: Ae, ripple: !1, tabindex: '-1' },
                                                      null
                                                    )
                                                  : void 0,
                                                ee.props.prependAvatar &&
                                                  g(Vi, { image: ee.props.prependAvatar }, null),
                                                ee.props.prependIcon && g(ot, { icon: ee.props.prependIcon }, null),
                                              ])
                                            },
                                            title: () => {
                                              var ve, Ae
                                              return o.value
                                                ? ee.title
                                                : WY(
                                                    ee.title,
                                                    (ve = _(ee)) == null ? void 0 : ve.title,
                                                    ((Ae = N.value) == null ? void 0 : Ae.length) ?? 0
                                                  )
                                            },
                                          })
                                        )
                                      },
                                    }
                                  ),
                                  (H = n['append-item']) == null ? void 0 : H.call(n),
                                ]
                              },
                            }
                          ),
                      ],
                    }
                  ),
                  V.value.map((O, L) => {
                    function H(ge) {
                      ge.stopPropagation(), ge.preventDefault(), de(O, !1)
                    }
                    const X = {
                        'onClick:close': H,
                        onKeydown(ge) {
                          ;(ge.key !== 'Enter' && ge.key !== ' ') || (ge.preventDefault(), ge.stopPropagation(), H(ge))
                        },
                        onMousedown(ge) {
                          ge.preventDefault(), ge.stopPropagation()
                        },
                        modelValue: !0,
                        'onUpdate:modelValue': void 0,
                      },
                      ee = E.value ? !!n.chip : !!n.selection,
                      he = ee
                        ? Tm(E.value ? n.chip({ item: O, index: L, props: X }) : n.selection({ item: O, index: L }))
                        : void 0
                    if (!(ee && !he))
                      return g(
                        'div',
                        {
                          key: O.value,
                          class: [
                            'v-autocomplete__selection',
                            L === f.value && ['v-autocomplete__selection--selected', A.value],
                          ],
                          style: L === f.value ? x.value : {},
                        },
                        [
                          E.value
                            ? n.chip
                              ? g(
                                  Ge,
                                  {
                                    key: 'chip-defaults',
                                    defaults: { VChip: { closable: e.closableChips, size: 'small', text: O.title } },
                                  },
                                  { default: () => [he] }
                                )
                              : g(
                                  Yl,
                                  ae(
                                    {
                                      key: 'chip',
                                      closable: e.closableChips,
                                      size: 'small',
                                      text: O.title,
                                      disabled: O.props.disabled,
                                    },
                                    X
                                  ),
                                  null
                                )
                            : he ??
                              g('span', { class: 'v-autocomplete__selection-text' }, [
                                O.title,
                                e.multiple &&
                                  L < V.value.length - 1 &&
                                  g('span', { class: 'v-autocomplete__selection-comma' }, [Or(',')]),
                              ]),
                        ]
                      )
                  }),
                ]),
              'append-inner': function () {
                var X
                for (var O = arguments.length, L = new Array(O), H = 0; H < O; H++) L[H] = arguments[H]
                return g(ke, null, [
                  (X = n['append-inner']) == null ? void 0 : X.call(n, ...L),
                  e.menuIcon
                    ? g(
                        ot,
                        {
                          class: 'v-autocomplete__menu-icon',
                          icon: e.menuIcon,
                          onMousedown: q,
                          onClick: RV,
                          'aria-label': i(p.value),
                          title: i(p.value),
                          tabindex: '-1',
                        },
                        null
                      )
                    : void 0,
                ])
              },
            }
          )
        }),
        Li({ isFocused: s, isPristine: o, menu: d, search: N, filteredItems: w, select: de }, r)
      )
    },
  }),
  KY = W(
    {
      bordered: Boolean,
      color: String,
      content: [Number, String],
      dot: Boolean,
      floating: Boolean,
      icon: Le,
      inline: Boolean,
      label: { type: String, default: '$vuetify.badge' },
      max: [Number, String],
      modelValue: { type: Boolean, default: !0 },
      offsetX: [Number, String],
      offsetY: [Number, String],
      textColor: String,
      ...Te(),
      ...Kr({ location: 'top end' }),
      ...Tt(),
      ...He(),
      ...Ze(),
      ...Xi({ transition: 'scale-rotate-transition' }),
    },
    'VBadge'
  ),
  YY = ne()({
    name: 'VBadge',
    inheritAttrs: !1,
    props: KY(),
    setup(e, t) {
      const { backgroundColorClasses: n, backgroundColorStyles: i } = gt(Q(e, 'color')),
        { roundedClasses: r } = Mt(e),
        { t: s } = jt(),
        { textColorClasses: o, textColorStyles: a } = Tn(Q(e, 'textColor')),
        { themeClasses: l } = nD(),
        { locationStyles: u } = ya(
          e,
          !0,
          (c) =>
            (e.floating ? (e.dot ? 2 : 4) : e.dot ? 8 : 12) +
            (['top', 'bottom'].includes(c) ? +(e.offsetY ?? 0) : ['left', 'right'].includes(c) ? +(e.offsetX ?? 0) : 0)
        )
      return (
        se(() => {
          const c = Number(e.content),
            d = !e.max || isNaN(c) ? e.content : c <= +e.max ? c : `${e.max}+`,
            [f, m] = Op(t.attrs, ['aria-atomic', 'aria-label', 'aria-live', 'role', 'title'])
          return g(
            e.tag,
            ae(
              {
                class: [
                  'v-badge',
                  {
                    'v-badge--bordered': e.bordered,
                    'v-badge--dot': e.dot,
                    'v-badge--floating': e.floating,
                    'v-badge--inline': e.inline,
                  },
                  e.class,
                ],
              },
              m,
              { style: e.style }
            ),
            {
              default: () => {
                var p, v
                return [
                  g('div', { class: 'v-badge__wrapper' }, [
                    (v = (p = t.slots).default) == null ? void 0 : v.call(p),
                    g(
                      Bn,
                      { transition: e.transition },
                      {
                        default: () => {
                          var y, T
                          return [
                            Rt(
                              g(
                                'span',
                                ae(
                                  {
                                    class: ['v-badge__badge', l.value, n.value, r.value, o.value],
                                    style: [i.value, a.value, e.inline ? {} : u.value],
                                    'aria-atomic': 'true',
                                    'aria-label': s(e.label, c),
                                    'aria-live': 'polite',
                                    role: 'status',
                                  },
                                  f
                                ),
                                [
                                  e.dot
                                    ? void 0
                                    : t.slots.badge
                                    ? (T = (y = t.slots).badge) == null
                                      ? void 0
                                      : T.call(y)
                                    : e.icon
                                    ? g(ot, { icon: e.icon }, null)
                                    : d,
                                ]
                              ),
                              [[Qi, e.modelValue]]
                            ),
                          ]
                        },
                      }
                    ),
                  ]),
                ]
              },
            }
          )
        }),
        {}
      )
    },
  }),
  QY = W({ color: String, density: String, ...Te() }, 'VBannerActions'),
  cN = ne()({
    name: 'VBannerActions',
    props: QY(),
    setup(e, t) {
      let { slots: n } = t
      return (
        Ot({ VBtn: { color: e.color, density: e.density, slim: !0, variant: 'text' } }),
        se(() => {
          var i
          return g('div', { class: ['v-banner-actions', e.class], style: e.style }, [
            (i = n.default) == null ? void 0 : i.call(n),
          ])
        }),
        {}
      )
    },
  }),
  dN = yr('v-banner-text'),
  XY = W(
    {
      avatar: String,
      bgColor: String,
      color: String,
      icon: Le,
      lines: String,
      stacked: Boolean,
      sticky: Boolean,
      text: String,
      ...bi(),
      ...Te(),
      ...ln(),
      ...on(),
      ...ca({ mobile: null }),
      ...en(),
      ...Kr(),
      ...ql(),
      ...Tt(),
      ...He(),
      ...Ze(),
    },
    'VBanner'
  ),
  JY = ne()({
    name: 'VBanner',
    props: XY(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: i, backgroundColorStyles: r } = gt(e, 'bgColor'),
        { borderClasses: s } = Oi(e),
        { densityClasses: o } = Un(e),
        { displayClasses: a, mobile: l } = Ni(e),
        { dimensionStyles: u } = an(e),
        { elevationClasses: c } = yn(e),
        { locationStyles: d } = ya(e),
        { positionClasses: f } = Gl(e),
        { roundedClasses: m } = Mt(e),
        { themeClasses: p } = at(e),
        v = Q(e, 'color'),
        y = Q(e, 'density')
      Ot({ VBannerActions: { color: v, density: y } }),
        se(() => {
          const T = !!(e.text || n.text),
            A = !!(e.avatar || e.icon),
            x = !!(A || n.prepend)
          return g(
            e.tag,
            {
              class: [
                'v-banner',
                {
                  'v-banner--stacked': e.stacked || l.value,
                  'v-banner--sticky': e.sticky,
                  [`v-banner--${e.lines}-line`]: !!e.lines,
                },
                p.value,
                i.value,
                s.value,
                o.value,
                a.value,
                c.value,
                f.value,
                m.value,
                e.class,
              ],
              style: [r.value, u.value, d.value, e.style],
              role: 'banner',
            },
            {
              default: () => {
                var N
                return [
                  x &&
                    g('div', { key: 'prepend', class: 'v-banner__prepend' }, [
                      n.prepend
                        ? g(
                            Ge,
                            {
                              key: 'prepend-defaults',
                              disabled: !A,
                              defaults: {
                                VAvatar: { color: v.value, density: y.value, icon: e.icon, image: e.avatar },
                              },
                            },
                            n.prepend
                          )
                        : g(
                            Vi,
                            { key: 'prepend-avatar', color: v.value, density: y.value, icon: e.icon, image: e.avatar },
                            null
                          ),
                    ]),
                  g('div', { class: 'v-banner__content' }, [
                    T &&
                      g(
                        dN,
                        { key: 'text' },
                        {
                          default: () => {
                            var V
                            return [((V = n.text) == null ? void 0 : V.call(n)) ?? e.text]
                          },
                        }
                      ),
                    (N = n.default) == null ? void 0 : N.call(n),
                  ]),
                  n.actions && g(cN, { key: 'actions' }, n.actions),
                ]
              },
            }
          )
        })
    },
  }),
  ZY = W(
    {
      baseColor: String,
      bgColor: String,
      color: String,
      grow: Boolean,
      mode: { type: String, validator: (e) => !e || ['horizontal', 'shift'].includes(e) },
      height: { type: [Number, String], default: 56 },
      active: { type: Boolean, default: !0 },
      ...bi(),
      ...Te(),
      ...ln(),
      ...en(),
      ...Tt(),
      ...da({ name: 'bottom-navigation' }),
      ...He({ tag: 'header' }),
      ...ga({ selectedClass: 'v-btn--selected' }),
      ...Ze(),
    },
    'VBottomNavigation'
  ),
  eQ = ne()({
    name: 'VBottomNavigation',
    props: ZY(),
    emits: { 'update:active': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = nD(),
        { borderClasses: r } = Oi(e),
        { backgroundColorClasses: s, backgroundColorStyles: o } = gt(Q(e, 'bgColor')),
        { densityClasses: a } = Un(e),
        { elevationClasses: l } = yn(e),
        { roundedClasses: u } = Mt(e),
        { ssrBootStyles: c } = fa(),
        d = k(() => Number(e.height) - (e.density === 'comfortable' ? 8 : 0) - (e.density === 'compact' ? 16 : 0)),
        f = xe(e, 'active', e.active),
        { layoutItemStyles: m, layoutIsReady: p } = ha({
          id: e.name,
          order: k(() => parseInt(e.order, 10)),
          position: k(() => 'bottom'),
          layoutSize: k(() => (f.value ? d.value : 0)),
          elementSize: d,
          active: f,
          absolute: Q(e, 'absolute'),
        })
      return (
        Ys(e, Hb),
        Ot(
          {
            VBtn: {
              baseColor: Q(e, 'baseColor'),
              color: Q(e, 'color'),
              density: Q(e, 'density'),
              stacked: k(() => e.mode !== 'horizontal'),
              variant: 'text',
            },
          },
          { scoped: !0 }
        ),
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-bottom-navigation',
                {
                  'v-bottom-navigation--active': f.value,
                  'v-bottom-navigation--grow': e.grow,
                  'v-bottom-navigation--shift': e.mode === 'shift',
                },
                i.value,
                s.value,
                r.value,
                a.value,
                l.value,
                u.value,
                e.class,
              ],
              style: [o.value, m.value, { height: Se(d.value) }, c.value, e.style],
            },
            { default: () => [n.default && g('div', { class: 'v-bottom-navigation__content' }, [n.default()])] }
          )
        ),
        p
      )
    },
  }),
  hN = W(
    {
      fullscreen: Boolean,
      retainFocus: { type: Boolean, default: !0 },
      scrollable: Boolean,
      ...gd({ origin: 'center center', scrollStrategy: 'block', transition: { component: xm }, zIndex: 2400 }),
    },
    'VDialog'
  ),
  ey = ne()({
    name: 'VDialog',
    props: hN(),
    emits: { 'update:modelValue': (e) => !0, afterLeave: () => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const r = xe(e, 'modelValue'),
        { scopeId: s } = _a(),
        o = le()
      function a(c) {
        var m, p
        const d = c.relatedTarget,
          f = c.target
        if (
          d !== f &&
          (m = o.value) != null &&
          m.contentEl &&
          (p = o.value) != null &&
          p.globalTop &&
          ![document, o.value.contentEl].includes(f) &&
          !o.value.contentEl.contains(f)
        ) {
          const v = Ec(o.value.contentEl)
          if (!v.length) return
          const y = v[0],
            T = v[v.length - 1]
          d === y ? T.focus() : y.focus()
        }
      }
      ct &&
        be(
          () => r.value && e.retainFocus,
          (c) => {
            c ? document.addEventListener('focusin', a) : document.removeEventListener('focusin', a)
          },
          { immediate: !0 }
        )
      function l() {
        var c
        ;(c = o.value) != null &&
          c.contentEl &&
          !o.value.contentEl.contains(document.activeElement) &&
          o.value.contentEl.focus({ preventScroll: !0 })
      }
      function u() {
        n('afterLeave')
      }
      return (
        be(r, async (c) => {
          var d
          c || (await Xe(), (d = o.value.activatorEl) == null || d.focus({ preventScroll: !0 }))
        }),
        se(() => {
          const c = mr.filterProps(e),
            d = ae({ 'aria-haspopup': 'dialog', 'aria-expanded': String(r.value) }, e.activatorProps),
            f = ae({ tabindex: -1 }, e.contentProps)
          return g(
            mr,
            ae(
              {
                ref: o,
                class: [
                  'v-dialog',
                  { 'v-dialog--fullscreen': e.fullscreen, 'v-dialog--scrollable': e.scrollable },
                  e.class,
                ],
                style: e.style,
              },
              c,
              {
                modelValue: r.value,
                'onUpdate:modelValue': (m) => (r.value = m),
                'aria-modal': 'true',
                activatorProps: d,
                contentProps: f,
                role: 'dialog',
                onAfterEnter: l,
                onAfterLeave: u,
              },
              s
            ),
            {
              activator: i.activator,
              default: function () {
                for (var m = arguments.length, p = new Array(m), v = 0; v < m; v++) p[v] = arguments[v]
                return g(
                  Ge,
                  { root: 'VDialog' },
                  {
                    default: () => {
                      var y
                      return [(y = i.default) == null ? void 0 : y.call(i, ...p)]
                    },
                  }
                )
              },
            }
          )
        }),
        Li({}, o)
      )
    },
  }),
  tQ = W({ inset: Boolean, ...hN({ transition: 'bottom-sheet-transition' }) }, 'VBottomSheet'),
  nQ = ne()({
    name: 'VBottomSheet',
    props: tQ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue')
      return (
        se(() => {
          const r = ey.filterProps(e)
          return g(
            ey,
            ae(r, {
              contentClass: ['v-bottom-sheet__content', e.contentClass],
              modelValue: i.value,
              'onUpdate:modelValue': (s) => (i.value = s),
              class: ['v-bottom-sheet', { 'v-bottom-sheet--inset': e.inset }, e.class],
              style: e.style,
            }),
            n
          )
        }),
        {}
      )
    },
  }),
  iQ = W({ divider: [Number, String], ...Te() }, 'VBreadcrumbsDivider'),
  fN = ne()({
    name: 'VBreadcrumbsDivider',
    props: iQ(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() => {
          var i
          return g('li', { class: ['v-breadcrumbs-divider', e.class], style: e.style }, [
            ((i = n == null ? void 0 : n.default) == null ? void 0 : i.call(n)) ?? e.divider,
          ])
        }),
        {}
      )
    },
  }),
  rQ = W(
    {
      active: Boolean,
      activeClass: String,
      activeColor: String,
      color: String,
      disabled: Boolean,
      title: String,
      ...Te(),
      ...hd(),
      ...He({ tag: 'li' }),
    },
    'VBreadcrumbsItem'
  ),
  mN = ne()({
    name: 'VBreadcrumbsItem',
    props: rQ(),
    setup(e, t) {
      let { slots: n, attrs: i } = t
      const r = dd(e, i),
        s = k(() => {
          var u
          return e.active || ((u = r.isActive) == null ? void 0 : u.value)
        }),
        o = k(() => (s.value ? e.activeColor : e.color)),
        { textColorClasses: a, textColorStyles: l } = Tn(o)
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-breadcrumbs-item',
                {
                  'v-breadcrumbs-item--active': s.value,
                  'v-breadcrumbs-item--disabled': e.disabled,
                  [`${e.activeClass}`]: s.value && e.activeClass,
                },
                a.value,
                e.class,
              ],
              style: [l.value, e.style],
              'aria-current': s.value ? 'page' : void 0,
            },
            {
              default: () => {
                var u, c
                return [
                  r.isLink.value
                    ? g(
                        'a',
                        {
                          class: 'v-breadcrumbs-item--link',
                          href: r.href.value,
                          'aria-current': s.value ? 'page' : void 0,
                          onClick: r.navigate,
                        },
                        [((c = n.default) == null ? void 0 : c.call(n)) ?? e.title]
                      )
                    : ((u = n.default) == null ? void 0 : u.call(n)) ?? e.title,
                ]
              },
            }
          )
        ),
        {}
      )
    },
  }),
  sQ = W(
    {
      activeClass: String,
      activeColor: String,
      bgColor: String,
      color: String,
      disabled: Boolean,
      divider: { type: String, default: '/' },
      icon: Le,
      items: { type: Array, default: () => [] },
      ...Te(),
      ...ln(),
      ...Tt(),
      ...He({ tag: 'ul' }),
    },
    'VBreadcrumbs'
  ),
  oQ = ne()({
    name: 'VBreadcrumbs',
    props: sQ(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: i, backgroundColorStyles: r } = gt(Q(e, 'bgColor')),
        { densityClasses: s } = Un(e),
        { roundedClasses: o } = Mt(e)
      Ot({
        VBreadcrumbsDivider: { divider: Q(e, 'divider') },
        VBreadcrumbsItem: {
          activeClass: Q(e, 'activeClass'),
          activeColor: Q(e, 'activeColor'),
          color: Q(e, 'color'),
          disabled: Q(e, 'disabled'),
        },
      })
      const a = k(() =>
        e.items.map((l) => (typeof l == 'string' ? { item: { title: l }, raw: l } : { item: l, raw: l }))
      )
      return (
        se(() => {
          const l = !!(n.prepend || e.icon)
          return g(
            e.tag,
            { class: ['v-breadcrumbs', i.value, s.value, o.value, e.class], style: [r.value, e.style] },
            {
              default: () => {
                var u
                return [
                  l &&
                    g('li', { key: 'prepend', class: 'v-breadcrumbs__prepend' }, [
                      n.prepend
                        ? g(
                            Ge,
                            {
                              key: 'prepend-defaults',
                              disabled: !e.icon,
                              defaults: { VIcon: { icon: e.icon, start: !0 } },
                            },
                            n.prepend
                          )
                        : g(ot, { key: 'prepend-icon', start: !0, icon: e.icon }, null),
                    ]),
                  a.value.map((c, d, f) => {
                    var v
                    let { item: m, raw: p } = c
                    return g(ke, null, [
                      ((v = n.item) == null ? void 0 : v.call(n, { item: m, index: d })) ??
                        g(mN, ae({ key: d, disabled: d >= f.length - 1 }, typeof m == 'string' ? { title: m } : m), {
                          default: n.title
                            ? () => {
                                var y
                                return (y = n.title) == null ? void 0 : y.call(n, { item: m, index: d })
                              }
                            : void 0,
                        }),
                      d < f.length - 1 &&
                        g(fN, null, {
                          default: n.divider
                            ? () => {
                                var y
                                return (y = n.divider) == null ? void 0 : y.call(n, { item: p, index: d })
                              }
                            : void 0,
                        }),
                    ])
                  }),
                  (u = n.default) == null ? void 0 : u.call(n),
                ]
              },
            }
          )
        }),
        {}
      )
    },
  }),
  gN = ne()({
    name: 'VCardActions',
    props: Te(),
    setup(e, t) {
      let { slots: n } = t
      return (
        Ot({ VBtn: { slim: !0, variant: 'text' } }),
        se(() => {
          var i
          return g('div', { class: ['v-card-actions', e.class], style: e.style }, [
            (i = n.default) == null ? void 0 : i.call(n),
          ])
        }),
        {}
      )
    },
  }),
  aQ = W({ opacity: [Number, String], ...Te(), ...He() }, 'VCardSubtitle'),
  vN = ne()({
    name: 'VCardSubtitle',
    props: aQ(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() =>
          g(
            e.tag,
            { class: ['v-card-subtitle', e.class], style: [{ '--v-card-subtitle-opacity': e.opacity }, e.style] },
            n
          )
        ),
        {}
      )
    },
  }),
  pN = yr('v-card-title'),
  lQ = W(
    {
      appendAvatar: String,
      appendIcon: Le,
      prependAvatar: String,
      prependIcon: Le,
      subtitle: [String, Number],
      title: [String, Number],
      ...Te(),
      ...ln(),
    },
    'VCardItem'
  ),
  yN = ne()({
    name: 'VCardItem',
    props: lQ(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() => {
          var u
          const i = !!(e.prependAvatar || e.prependIcon),
            r = !!(i || n.prepend),
            s = !!(e.appendAvatar || e.appendIcon),
            o = !!(s || n.append),
            a = !!(e.title != null || n.title),
            l = !!(e.subtitle != null || n.subtitle)
          return g('div', { class: ['v-card-item', e.class], style: e.style }, [
            r &&
              g('div', { key: 'prepend', class: 'v-card-item__prepend' }, [
                n.prepend
                  ? g(
                      Ge,
                      {
                        key: 'prepend-defaults',
                        disabled: !i,
                        defaults: {
                          VAvatar: { density: e.density, image: e.prependAvatar },
                          VIcon: { density: e.density, icon: e.prependIcon },
                        },
                      },
                      n.prepend
                    )
                  : g(ke, null, [
                      e.prependAvatar &&
                        g(Vi, { key: 'prepend-avatar', density: e.density, image: e.prependAvatar }, null),
                      e.prependIcon && g(ot, { key: 'prepend-icon', density: e.density, icon: e.prependIcon }, null),
                    ]),
              ]),
            g('div', { class: 'v-card-item__content' }, [
              a &&
                g(
                  pN,
                  { key: 'title' },
                  {
                    default: () => {
                      var c
                      return [((c = n.title) == null ? void 0 : c.call(n)) ?? e.title]
                    },
                  }
                ),
              l &&
                g(
                  vN,
                  { key: 'subtitle' },
                  {
                    default: () => {
                      var c
                      return [((c = n.subtitle) == null ? void 0 : c.call(n)) ?? e.subtitle]
                    },
                  }
                ),
              (u = n.default) == null ? void 0 : u.call(n),
            ]),
            o &&
              g('div', { key: 'append', class: 'v-card-item__append' }, [
                n.append
                  ? g(
                      Ge,
                      {
                        key: 'append-defaults',
                        disabled: !s,
                        defaults: {
                          VAvatar: { density: e.density, image: e.appendAvatar },
                          VIcon: { density: e.density, icon: e.appendIcon },
                        },
                      },
                      n.append
                    )
                  : g(ke, null, [
                      e.appendIcon && g(ot, { key: 'append-icon', density: e.density, icon: e.appendIcon }, null),
                      e.appendAvatar &&
                        g(Vi, { key: 'append-avatar', density: e.density, image: e.appendAvatar }, null),
                    ]),
              ]),
          ])
        }),
        {}
      )
    },
  }),
  uQ = W({ opacity: [Number, String], ...Te(), ...He() }, 'VCardText'),
  _N = ne()({
    name: 'VCardText',
    props: uQ(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() =>
          g(e.tag, { class: ['v-card-text', e.class], style: [{ '--v-card-text-opacity': e.opacity }, e.style] }, n)
        ),
        {}
      )
    },
  }),
  cQ = W(
    {
      appendAvatar: String,
      appendIcon: Le,
      disabled: Boolean,
      flat: Boolean,
      hover: Boolean,
      image: String,
      link: { type: Boolean, default: void 0 },
      prependAvatar: String,
      prependIcon: Le,
      ripple: { type: [Boolean, Object], default: !0 },
      subtitle: [String, Number],
      text: [String, Number],
      title: [String, Number],
      ...bi(),
      ...Te(),
      ...ln(),
      ...on(),
      ...en(),
      ...Om(),
      ...Kr(),
      ...ql(),
      ...Tt(),
      ...hd(),
      ...He(),
      ...Ze(),
      ...Mi({ variant: 'elevated' }),
    },
    'VCard'
  ),
  dQ = ne()({
    name: 'VCard',
    directives: { Ripple: Yr },
    props: cQ(),
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { themeClasses: r } = at(e),
        { borderClasses: s } = Oi(e),
        { colorClasses: o, colorStyles: a, variantClasses: l } = ma(e),
        { densityClasses: u } = Un(e),
        { dimensionStyles: c } = an(e),
        { elevationClasses: d } = yn(e),
        { loaderClasses: f } = ud(e),
        { locationStyles: m } = ya(e),
        { positionClasses: p } = Gl(e),
        { roundedClasses: v } = Mt(e),
        y = dd(e, n),
        T = k(() => e.link !== !1 && y.isLink.value),
        A = k(() => !e.disabled && e.link !== !1 && (e.link || y.isClickable.value))
      return (
        se(() => {
          const x = T.value ? 'a' : e.tag,
            N = !!(i.title || e.title != null),
            V = !!(i.subtitle || e.subtitle != null),
            D = N || V,
            I = !!(i.append || e.appendAvatar || e.appendIcon),
            w = !!(i.prepend || e.prependAvatar || e.prependIcon),
            _ = !!(i.image || e.image),
            S = D || w || I,
            E = !!(i.text || e.text != null)
          return Rt(
            g(
              x,
              {
                class: [
                  'v-card',
                  {
                    'v-card--disabled': e.disabled,
                    'v-card--flat': e.flat,
                    'v-card--hover': e.hover && !(e.disabled || e.flat),
                    'v-card--link': A.value,
                  },
                  r.value,
                  s.value,
                  o.value,
                  u.value,
                  d.value,
                  f.value,
                  p.value,
                  v.value,
                  l.value,
                  e.class,
                ],
                style: [a.value, c.value, m.value, e.style],
                href: y.href.value,
                onClick: A.value && y.navigate,
                tabindex: e.disabled ? -1 : void 0,
              },
              {
                default: () => {
                  var C
                  return [
                    _ &&
                      g('div', { key: 'image', class: 'v-card__image' }, [
                        i.image
                          ? g(
                              Ge,
                              {
                                key: 'image-defaults',
                                disabled: !e.image,
                                defaults: { VImg: { cover: !0, src: e.image } },
                              },
                              i.image
                            )
                          : g(Br, { key: 'image-img', cover: !0, src: e.image }, null),
                      ]),
                    g(
                      cd,
                      {
                        name: 'v-card',
                        active: !!e.loading,
                        color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                      },
                      { default: i.loader }
                    ),
                    S &&
                      g(
                        yN,
                        {
                          key: 'item',
                          prependAvatar: e.prependAvatar,
                          prependIcon: e.prependIcon,
                          title: e.title,
                          subtitle: e.subtitle,
                          appendAvatar: e.appendAvatar,
                          appendIcon: e.appendIcon,
                        },
                        { default: i.item, prepend: i.prepend, title: i.title, subtitle: i.subtitle, append: i.append }
                      ),
                    E &&
                      g(
                        _N,
                        { key: 'text' },
                        {
                          default: () => {
                            var R
                            return [((R = i.text) == null ? void 0 : R.call(i)) ?? e.text]
                          },
                        }
                      ),
                    (C = i.default) == null ? void 0 : C.call(i),
                    i.actions && g(gN, null, { default: i.actions }),
                    Ks(A.value, 'v-card'),
                  ]
                },
              }
            ),
            [[pi('ripple'), A.value && e.ripple]]
          )
        }),
        {}
      )
    },
  }),
  hQ = (e) => {
    const { touchstartX: t, touchendX: n, touchstartY: i, touchendY: r } = e,
      s = 0.5,
      o = 16
    ;(e.offsetX = n - t),
      (e.offsetY = r - i),
      Math.abs(e.offsetY) < s * Math.abs(e.offsetX) &&
        (e.left && n < t - o && e.left(e), e.right && n > t + o && e.right(e)),
      Math.abs(e.offsetX) < s * Math.abs(e.offsetY) && (e.up && r < i - o && e.up(e), e.down && r > i + o && e.down(e))
  }
function fQ(e, t) {
  var i
  const n = e.changedTouches[0]
  ;(t.touchstartX = n.clientX),
    (t.touchstartY = n.clientY),
    (i = t.start) == null || i.call(t, { originalEvent: e, ...t })
}
function mQ(e, t) {
  var i
  const n = e.changedTouches[0]
  ;(t.touchendX = n.clientX),
    (t.touchendY = n.clientY),
    (i = t.end) == null || i.call(t, { originalEvent: e, ...t }),
    hQ(t)
}
function gQ(e, t) {
  var i
  const n = e.changedTouches[0]
  ;(t.touchmoveX = n.clientX), (t.touchmoveY = n.clientY), (i = t.move) == null || i.call(t, { originalEvent: e, ...t })
}
function vQ() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end,
  }
  return { touchstart: (n) => fQ(n, t), touchend: (n) => mQ(n, t), touchmove: (n) => gQ(n, t) }
}
function pQ(e, t) {
  var a
  const n = t.value,
    i = n != null && n.parent ? e.parentElement : e,
    r = (n == null ? void 0 : n.options) ?? { passive: !0 },
    s = (a = t.instance) == null ? void 0 : a.$.uid
  if (!i || !s) return
  const o = vQ(t.value)
  ;(i._touchHandlers = i._touchHandlers ?? Object.create(null)),
    (i._touchHandlers[s] = o),
    TV(o).forEach((l) => {
      i.addEventListener(l, o[l], r)
    })
}
function yQ(e, t) {
  var s, o
  const n = (s = t.value) != null && s.parent ? e.parentElement : e,
    i = (o = t.instance) == null ? void 0 : o.$.uid
  if (!(n != null && n._touchHandlers) || !i) return
  const r = n._touchHandlers[i]
  TV(r).forEach((a) => {
    n.removeEventListener(a, r[a])
  }),
    delete n._touchHandlers[i]
}
const rw = { mounted: pQ, unmounted: yQ },
  bN = Symbol.for('vuetify:v-window'),
  wN = Symbol.for('vuetify:v-window-group'),
  zm = W(
    {
      continuous: Boolean,
      nextIcon: { type: [Boolean, String, Function, Object], default: '$next' },
      prevIcon: { type: [Boolean, String, Function, Object], default: '$prev' },
      reverse: Boolean,
      showArrows: { type: [Boolean, String], validator: (e) => typeof e == 'boolean' || e === 'hover' },
      touch: { type: [Object, Boolean], default: void 0 },
      direction: { type: String, default: 'horizontal' },
      modelValue: null,
      disabled: Boolean,
      selectedClass: { type: String, default: 'v-window-item--active' },
      mandatory: { type: [Boolean, String], default: 'force' },
      ...Te(),
      ...He(),
      ...Ze(),
    },
    'VWindow'
  ),
  Yo = ne()({
    name: 'VWindow',
    directives: { Touch: rw },
    props: zm(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { isRtl: r } = sn(),
        { t: s } = jt(),
        o = Ys(e, wN),
        a = le(),
        l = k(() => (r.value ? !e.reverse : e.reverse)),
        u = ye(!1),
        c = k(() => {
          const N = e.direction === 'vertical' ? 'y' : 'x',
            D = (l.value ? !u.value : u.value) ? '-reverse' : ''
          return `v-window-${N}${D}-transition`
        }),
        d = ye(0),
        f = le(void 0),
        m = k(() => o.items.value.findIndex((N) => o.selected.value.includes(N.id)))
      be(m, (N, V) => {
        const D = o.items.value.length,
          I = D - 1
        D <= 2
          ? (u.value = N < V)
          : N === I && V === 0
          ? (u.value = !0)
          : N === 0 && V === I
          ? (u.value = !1)
          : (u.value = N < V)
      }),
        mt(bN, { transition: c, isReversed: u, transitionCount: d, transitionHeight: f, rootRef: a })
      const p = k(() => e.continuous || m.value !== 0),
        v = k(() => e.continuous || m.value !== o.items.value.length - 1)
      function y() {
        p.value && o.prev()
      }
      function T() {
        v.value && o.next()
      }
      const A = k(() => {
          const N = [],
            V = {
              icon: r.value ? e.nextIcon : e.prevIcon,
              class: `v-window__${l.value ? 'right' : 'left'}`,
              onClick: o.prev,
              'aria-label': s('$vuetify.carousel.prev'),
            }
          N.push(p.value ? (n.prev ? n.prev({ props: V }) : g(st, V, null)) : g('div', null, null))
          const D = {
            icon: r.value ? e.prevIcon : e.nextIcon,
            class: `v-window__${l.value ? 'left' : 'right'}`,
            onClick: o.next,
            'aria-label': s('$vuetify.carousel.next'),
          }
          return N.push(v.value ? (n.next ? n.next({ props: D }) : g(st, D, null)) : g('div', null, null)), N
        }),
        x = k(() =>
          e.touch === !1
            ? e.touch
            : {
                ...{
                  left: () => {
                    l.value ? y() : T()
                  },
                  right: () => {
                    l.value ? T() : y()
                  },
                  start: (V) => {
                    let { originalEvent: D } = V
                    D.stopPropagation()
                  },
                },
                ...(e.touch === !0 ? {} : e.touch),
              }
        )
      return (
        se(() =>
          Rt(
            g(
              e.tag,
              {
                ref: a,
                class: ['v-window', { 'v-window--show-arrows-on-hover': e.showArrows === 'hover' }, i.value, e.class],
                style: e.style,
              },
              {
                default: () => {
                  var N, V
                  return [
                    g('div', { class: 'v-window__container', style: { height: f.value } }, [
                      (N = n.default) == null ? void 0 : N.call(n, { group: o }),
                      e.showArrows !== !1 && g('div', { class: 'v-window__controls' }, [A.value]),
                    ]),
                    (V = n.additional) == null ? void 0 : V.call(n, { group: o }),
                  ]
                },
              }
            ),
            [[pi('touch'), x.value]]
          )
        ),
        { group: o }
      )
    },
  }),
  _Q = W(
    {
      color: String,
      cycle: Boolean,
      delimiterIcon: { type: Le, default: '$delimiter' },
      height: { type: [Number, String], default: 500 },
      hideDelimiters: Boolean,
      hideDelimiterBackground: Boolean,
      interval: { type: [Number, String], default: 6e3, validator: (e) => Number(e) > 0 },
      progress: [Boolean, String],
      verticalDelimiters: [Boolean, String],
      ...zm({ continuous: !0, mandatory: 'force', showArrows: !0 }),
    },
    'VCarousel'
  ),
  bQ = ne()({
    name: 'VCarousel',
    props: _Q(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        { t: r } = jt(),
        s = le()
      let o = -1
      be(i, l),
        be(() => e.interval, l),
        be(
          () => e.cycle,
          (u) => {
            u ? l() : window.clearTimeout(o)
          }
        ),
        An(a)
      function a() {
        !e.cycle || !s.value || (o = window.setTimeout(s.value.group.next, +e.interval > 0 ? +e.interval : 6e3))
      }
      function l() {
        window.clearTimeout(o), window.requestAnimationFrame(a)
      }
      return (
        se(() => {
          const u = Yo.filterProps(e)
          return g(
            Yo,
            ae({ ref: s }, u, {
              modelValue: i.value,
              'onUpdate:modelValue': (c) => (i.value = c),
              class: [
                'v-carousel',
                {
                  'v-carousel--hide-delimiter-background': e.hideDelimiterBackground,
                  'v-carousel--vertical-delimiters': e.verticalDelimiters,
                },
                e.class,
              ],
              style: [{ height: Se(e.height) }, e.style],
            }),
            {
              default: n.default,
              additional: (c) => {
                let { group: d } = c
                return g(ke, null, [
                  !e.hideDelimiters &&
                    g(
                      'div',
                      {
                        class: 'v-carousel__controls',
                        style: {
                          left: e.verticalDelimiters === 'left' && e.verticalDelimiters ? 0 : 'auto',
                          right: e.verticalDelimiters === 'right' ? 0 : 'auto',
                        },
                      },
                      [
                        d.items.value.length > 0 &&
                          g(
                            Ge,
                            {
                              defaults: {
                                VBtn: { color: e.color, icon: e.delimiterIcon, size: 'x-small', variant: 'text' },
                              },
                              scoped: !0,
                            },
                            {
                              default: () => [
                                d.items.value.map((f, m) => {
                                  const p = {
                                    id: `carousel-item-${f.id}`,
                                    'aria-label': r(
                                      '$vuetify.carousel.ariaLabel.delimiter',
                                      m + 1,
                                      d.items.value.length
                                    ),
                                    class: ['v-carousel__controls__item', d.isSelected(f.id) && 'v-btn--active'],
                                    onClick: () => d.select(f.id, !0),
                                  }
                                  return n.item ? n.item({ props: p, item: f }) : g(st, ae(f, p), null)
                                }),
                              ],
                            }
                          ),
                      ]
                    ),
                  e.progress &&
                    g(
                      Nm,
                      {
                        class: 'v-carousel__progress',
                        color: typeof e.progress == 'string' ? e.progress : void 0,
                        modelValue: ((d.getItemIndex(i.value) + 1) / d.items.value.length) * 100,
                      },
                      null
                    ),
                ])
              },
              prev: n.prev,
              next: n.next,
            }
          )
        }),
        {}
      )
    },
  }),
  Hm = W(
    {
      reverseTransition: { type: [Boolean, String], default: void 0 },
      transition: { type: [Boolean, String], default: void 0 },
      ...Te(),
      ...va(),
      ...Jb(),
    },
    'VWindowItem'
  ),
  Qo = ne()({
    name: 'VWindowItem',
    directives: { Touch: rw },
    props: Hm(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = je(bN),
        r = pa(e, wN),
        { isBooted: s } = fa()
      if (!i || !r) throw new Error('[Vuetify] VWindowItem must be used inside VWindow')
      const o = ye(!1),
        a = k(() => s.value && (i.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1))
      function l() {
        !o.value ||
          !i ||
          ((o.value = !1),
          i.transitionCount.value > 0 &&
            ((i.transitionCount.value -= 1), i.transitionCount.value === 0 && (i.transitionHeight.value = void 0)))
      }
      function u() {
        var p
        o.value ||
          !i ||
          ((o.value = !0),
          i.transitionCount.value === 0 &&
            (i.transitionHeight.value = Se((p = i.rootRef.value) == null ? void 0 : p.clientHeight)),
          (i.transitionCount.value += 1))
      }
      function c() {
        l()
      }
      function d(p) {
        o.value &&
          Xe(() => {
            !a.value || !o.value || !i || (i.transitionHeight.value = Se(p.clientHeight))
          })
      }
      const f = k(() => {
          const p = i.isReversed.value ? e.reverseTransition : e.transition
          return a.value
            ? {
                name: typeof p != 'string' ? i.transition.value : p,
                onBeforeEnter: u,
                onAfterEnter: l,
                onEnterCancelled: c,
                onBeforeLeave: u,
                onAfterLeave: l,
                onLeaveCancelled: c,
                onEnter: d,
              }
            : !1
        }),
        { hasContent: m } = Zb(e, r.isSelected)
      return (
        se(() =>
          g(
            Bn,
            { transition: f.value, disabled: !s.value },
            {
              default: () => {
                var p
                return [
                  Rt(
                    g('div', { class: ['v-window-item', r.selectedClass.value, e.class], style: e.style }, [
                      m.value && ((p = n.default) == null ? void 0 : p.call(n)),
                    ]),
                    [[Qi, r.isSelected.value]]
                  ),
                ]
              },
            }
          )
        ),
        { groupItem: r }
      )
    },
  }),
  wQ = W({ ...fD(), ...Hm() }, 'VCarouselItem'),
  IQ = ne()({
    name: 'VCarouselItem',
    inheritAttrs: !1,
    props: wQ(),
    setup(e, t) {
      let { slots: n, attrs: i } = t
      se(() => {
        const r = Br.filterProps(e),
          s = Qo.filterProps(e)
        return g(Qo, ae({ class: ['v-carousel-item', e.class] }, s), { default: () => [g(Br, ae(i, r), n)] })
      })
    },
  }),
  SQ = yr('v-code'),
  EQ = W(
    {
      color: { type: Object },
      disabled: Boolean,
      dotSize: { type: [Number, String], default: 10 },
      height: { type: [Number, String], default: 150 },
      width: { type: [Number, String], default: 300 },
      ...Te(),
    },
    'VColorPickerCanvas'
  ),
  TQ = yi({
    name: 'VColorPickerCanvas',
    props: EQ(),
    emits: { 'update:color': (e) => !0, 'update:position': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const i = ye(!1),
        r = le(),
        s = ye(parseFloat(e.width)),
        o = ye(parseFloat(e.height)),
        a = le({ x: 0, y: 0 }),
        l = k({
          get: () => a.value,
          set(y) {
            var x, N
            if (!r.value) return
            const { x: T, y: A } = y
            ;(a.value = y),
              n('update:color', {
                h: ((x = e.color) == null ? void 0 : x.h) ?? 0,
                s: qt(T, 0, s.value) / s.value,
                v: 1 - qt(A, 0, o.value) / o.value,
                a: ((N = e.color) == null ? void 0 : N.a) ?? 1,
              })
          },
        }),
        u = k(() => {
          const { x: y, y: T } = l.value,
            A = parseInt(e.dotSize, 10) / 2
          return { width: Se(e.dotSize), height: Se(e.dotSize), transform: `translate(${Se(y - A)}, ${Se(T - A)})` }
        }),
        { resizeRef: c } = Gi((y) => {
          var x
          if (!((x = c.el) != null && x.offsetParent)) return
          const { width: T, height: A } = y[0].contentRect
          ;(s.value = T), (o.value = A)
        })
      function d(y, T, A) {
        const { left: x, top: N, width: V, height: D } = A
        l.value = { x: qt(y - x, 0, V), y: qt(T - N, 0, D) }
      }
      function f(y) {
        y.type === 'mousedown' && y.preventDefault(),
          !e.disabled &&
            (m(y),
            window.addEventListener('mousemove', m),
            window.addEventListener('mouseup', p),
            window.addEventListener('touchmove', m),
            window.addEventListener('touchend', p))
      }
      function m(y) {
        if (e.disabled || !r.value) return
        i.value = !0
        const T = jG(y)
        d(T.clientX, T.clientY, r.value.getBoundingClientRect())
      }
      function p() {
        window.removeEventListener('mousemove', m),
          window.removeEventListener('mouseup', p),
          window.removeEventListener('touchmove', m),
          window.removeEventListener('touchend', p)
      }
      function v() {
        var N
        if (!r.value) return
        const y = r.value,
          T = y.getContext('2d')
        if (!T) return
        const A = T.createLinearGradient(0, 0, y.width, 0)
        A.addColorStop(0, 'hsla(0, 0%, 100%, 1)'),
          A.addColorStop(1, `hsla(${((N = e.color) == null ? void 0 : N.h) ?? 0}, 100%, 50%, 1)`),
          (T.fillStyle = A),
          T.fillRect(0, 0, y.width, y.height)
        const x = T.createLinearGradient(0, 0, 0, y.height)
        x.addColorStop(0, 'hsla(0, 0%, 0%, 0)'),
          x.addColorStop(1, 'hsla(0, 0%, 0%, 1)'),
          (T.fillStyle = x),
          T.fillRect(0, 0, y.width, y.height)
      }
      return (
        be(
          () => {
            var y
            return (y = e.color) == null ? void 0 : y.h
          },
          v,
          { immediate: !0 }
        ),
        be(
          () => [s.value, o.value],
          (y, T) => {
            v(), (a.value = { x: (l.value.x * y[0]) / T[0], y: (l.value.y * y[1]) / T[1] })
          },
          { flush: 'post' }
        ),
        be(
          () => e.color,
          () => {
            if (i.value) {
              i.value = !1
              return
            }
            a.value = e.color ? { x: e.color.s * s.value, y: (1 - e.color.v) * o.value } : { x: 0, y: 0 }
          },
          { deep: !0, immediate: !0 }
        ),
        An(() => v()),
        se(() =>
          g(
            'div',
            {
              ref: c,
              class: ['v-color-picker-canvas', e.class],
              style: e.style,
              onMousedown: f,
              onTouchstartPassive: f,
            },
            [
              g('canvas', { ref: r, width: s.value, height: o.value }, null),
              e.color &&
                g(
                  'div',
                  {
                    class: ['v-color-picker-canvas__dot', { 'v-color-picker-canvas__dot--disabled': e.disabled }],
                    style: u.value,
                  },
                  null
                ),
            ]
          )
        ),
        {}
      )
    },
  })
function CQ(e, t) {
  if (t) {
    const { a: n, ...i } = e
    return i
  }
  return e
}
function AQ(e, t) {
  if (t == null || typeof t == 'string') {
    const n = jV(e)
    return e.a === 1 ? n.slice(0, 7) : n
  }
  if (typeof t == 'object') {
    let n
    return (
      yo(t, ['r', 'g', 'b']) ? (n = Fr(e)) : yo(t, ['h', 's', 'l']) ? (n = MV(e)) : yo(t, ['h', 's', 'v']) && (n = e),
      CQ(n, !yo(t, ['a']) && e.a === 1)
    )
  }
  return e
}
const Ka = { h: 0, s: 0, v: 0, a: 1 },
  ty = {
    inputProps: { type: 'number', min: 0 },
    inputs: [
      { label: 'R', max: 255, step: 1, getValue: (e) => Math.round(e.r), getColor: (e, t) => ({ ...e, r: Number(t) }) },
      { label: 'G', max: 255, step: 1, getValue: (e) => Math.round(e.g), getColor: (e, t) => ({ ...e, g: Number(t) }) },
      { label: 'B', max: 255, step: 1, getValue: (e) => Math.round(e.b), getColor: (e, t) => ({ ...e, b: Number(t) }) },
      {
        label: 'A',
        max: 1,
        step: 0.01,
        getValue: (e) => {
          let { a: t } = e
          return t != null ? Math.round(t * 100) / 100 : 1
        },
        getColor: (e, t) => ({ ...e, a: Number(t) }),
      },
    ],
    to: Fr,
    from: Cm,
  }
var wC
const kQ = { ...ty, inputs: (wC = ty.inputs) == null ? void 0 : wC.slice(0, 3) },
  ny = {
    inputProps: { type: 'number', min: 0 },
    inputs: [
      { label: 'H', max: 360, step: 1, getValue: (e) => Math.round(e.h), getColor: (e, t) => ({ ...e, h: Number(t) }) },
      {
        label: 'S',
        max: 1,
        step: 0.01,
        getValue: (e) => Math.round(e.s * 100) / 100,
        getColor: (e, t) => ({ ...e, s: Number(t) }),
      },
      {
        label: 'L',
        max: 1,
        step: 0.01,
        getValue: (e) => Math.round(e.l * 100) / 100,
        getColor: (e, t) => ({ ...e, l: Number(t) }),
      },
      {
        label: 'A',
        max: 1,
        step: 0.01,
        getValue: (e) => {
          let { a: t } = e
          return t != null ? Math.round(t * 100) / 100 : 1
        },
        getColor: (e, t) => ({ ...e, a: Number(t) }),
      },
    ],
    to: MV,
    from: Db,
  },
  PQ = { ...ny, inputs: ny.inputs.slice(0, 3) },
  IN = {
    inputProps: { type: 'text' },
    inputs: [{ label: 'HEXA', getValue: (e) => e, getColor: (e, t) => t }],
    to: jV,
    from: UV,
  },
  RQ = { ...IN, inputs: [{ label: 'HEX', getValue: (e) => e.slice(0, 7), getColor: (e, t) => t }] },
  Po = { rgb: kQ, rgba: ty, hsl: PQ, hsla: ny, hex: RQ, hexa: IN },
  xQ = (e) => {
    let { label: t, ...n } = e
    return g('div', { class: 'v-color-picker-edit__input' }, [g('input', n, null), g('span', null, [t])])
  },
  VQ = W(
    {
      color: Object,
      disabled: Boolean,
      mode: { type: String, default: 'rgba', validator: (e) => Object.keys(Po).includes(e) },
      modes: {
        type: Array,
        default: () => Object.keys(Po),
        validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Po).includes(t)),
      },
      ...Te(),
    },
    'VColorPickerEdit'
  ),
  DQ = yi({
    name: 'VColorPickerEdit',
    props: VQ(),
    emits: { 'update:color': (e) => !0, 'update:mode': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const i = k(() => e.modes.map((s) => ({ ...Po[s], name: s }))),
        r = k(() => {
          var a
          const s = i.value.find((l) => l.name === e.mode)
          if (!s) return []
          const o = e.color ? s.to(e.color) : null
          return (a = s.inputs) == null
            ? void 0
            : a.map((l) => {
                let { getValue: u, getColor: c, ...d } = l
                return {
                  ...s.inputProps,
                  ...d,
                  disabled: e.disabled,
                  value: o && u(o),
                  onChange: (f) => {
                    const m = f.target
                    m && n('update:color', s.from(c(o ?? s.to(Ka), m.value)))
                  },
                }
              })
        })
      return (
        se(() => {
          var s
          return g('div', { class: ['v-color-picker-edit', e.class], style: e.style }, [
            (s = r.value) == null ? void 0 : s.map((o) => g(xQ, o, null)),
            i.value.length > 1 &&
              g(
                st,
                {
                  icon: '$unfold',
                  size: 'x-small',
                  variant: 'plain',
                  onClick: () => {
                    const o = i.value.findIndex((a) => a.name === e.mode)
                    n('update:mode', i.value[(o + 1) % i.value.length].name)
                  },
                },
                null
              ),
          ])
        }),
        {}
      )
    },
  }),
  sw = Symbol.for('vuetify:v-slider')
function iy(e, t, n) {
  const i = n === 'vertical',
    r = t.getBoundingClientRect(),
    s = 'touches' in e ? e.touches[0] : e
  return i ? s.clientY - (r.top + r.height / 2) : s.clientX - (r.left + r.width / 2)
}
function NQ(e, t) {
  return 'touches' in e && e.touches.length
    ? e.touches[0][t]
    : 'changedTouches' in e && e.changedTouches.length
    ? e.changedTouches[0][t]
    : e[t]
}
const SN = W(
    {
      disabled: { type: Boolean, default: null },
      error: Boolean,
      readonly: { type: Boolean, default: null },
      max: { type: [Number, String], default: 100 },
      min: { type: [Number, String], default: 0 },
      step: { type: [Number, String], default: 0 },
      thumbColor: String,
      thumbLabel: {
        type: [Boolean, String],
        default: void 0,
        validator: (e) => typeof e == 'boolean' || e === 'always',
      },
      thumbSize: { type: [Number, String], default: 20 },
      showTicks: { type: [Boolean, String], default: !1, validator: (e) => typeof e == 'boolean' || e === 'always' },
      ticks: { type: [Array, Object] },
      tickSize: { type: [Number, String], default: 2 },
      color: String,
      trackColor: String,
      trackFillColor: String,
      trackSize: { type: [Number, String], default: 4 },
      direction: { type: String, default: 'horizontal', validator: (e) => ['vertical', 'horizontal'].includes(e) },
      reverse: Boolean,
      ...Tt(),
      ...en({ elevation: 2 }),
      ripple: { type: Boolean, default: !0 },
    },
    'Slider'
  ),
  EN = (e) => {
    const t = k(() => parseFloat(e.min)),
      n = k(() => parseFloat(e.max)),
      i = k(() => (+e.step > 0 ? parseFloat(e.step) : 0)),
      r = k(() => Math.max(tT(i.value), tT(t.value)))
    function s(o) {
      if (((o = parseFloat(o)), i.value <= 0)) return o
      const a = qt(o, t.value, n.value),
        l = t.value % i.value,
        u = Math.round((a - l) / i.value) * i.value + l
      return parseFloat(Math.min(u, n.value).toFixed(r.value))
    }
    return { min: t, max: n, step: i, decimals: r, roundValue: s }
  },
  TN = (e) => {
    let { props: t, steps: n, onSliderStart: i, onSliderMove: r, onSliderEnd: s, getActiveThumb: o } = e
    const { isRtl: a } = sn(),
      l = Q(t, 'reverse'),
      u = k(() => t.direction === 'vertical'),
      c = k(() => u.value !== l.value),
      { min: d, max: f, step: m, decimals: p, roundValue: v } = n,
      y = k(() => parseInt(t.thumbSize, 10)),
      T = k(() => parseInt(t.tickSize, 10)),
      A = k(() => parseInt(t.trackSize, 10)),
      x = k(() => (f.value - d.value) / m.value),
      N = Q(t, 'disabled'),
      V = k(() => (t.error || t.disabled ? void 0 : t.thumbColor ?? t.color)),
      D = k(() => (t.error || t.disabled ? void 0 : t.trackColor ?? t.color)),
      I = k(() => (t.error || t.disabled ? void 0 : t.trackFillColor ?? t.color)),
      w = ye(!1),
      _ = ye(0),
      S = le(),
      E = le()
    function C(oe) {
      var H
      const z = t.direction === 'vertical',
        ue = z ? 'top' : 'left',
        de = z ? 'height' : 'width',
        Z = z ? 'clientY' : 'clientX',
        { [ue]: pe, [de]: re } = (H = S.value) == null ? void 0 : H.$el.getBoundingClientRect(),
        O = NQ(oe, Z)
      let L = Math.min(Math.max((O - pe - _.value) / re, 0), 1) || 0
      return (z ? c.value : c.value !== a.value) && (L = 1 - L), v(d.value + L * (f.value - d.value))
    }
    const R = (oe) => {
        s({ value: C(oe) }), (w.value = !1), (_.value = 0)
      },
      B = (oe) => {
        ;(E.value = o(oe)),
          E.value &&
            (E.value.focus(),
            (w.value = !0),
            E.value.contains(oe.target)
              ? (_.value = iy(oe, E.value, t.direction))
              : ((_.value = 0), r({ value: C(oe) })),
            i({ value: C(oe) }))
      },
      U = { passive: !0, capture: !0 }
    function $(oe) {
      r({ value: C(oe) })
    }
    function G(oe) {
      oe.stopPropagation(),
        oe.preventDefault(),
        R(oe),
        window.removeEventListener('mousemove', $, U),
        window.removeEventListener('mouseup', G)
    }
    function F(oe) {
      var z
      R(oe),
        window.removeEventListener('touchmove', $, U),
        (z = oe.target) == null || z.removeEventListener('touchend', F)
    }
    function K(oe) {
      var z
      B(oe),
        window.addEventListener('touchmove', $, U),
        (z = oe.target) == null || z.addEventListener('touchend', F, { passive: !1 })
    }
    function j(oe) {
      oe.preventDefault(),
        B(oe),
        window.addEventListener('mousemove', $, U),
        window.addEventListener('mouseup', G, { passive: !1 })
    }
    const q = (oe) => {
        const z = ((oe - d.value) / (f.value - d.value)) * 100
        return qt(isNaN(z) ? 0 : z, 0, 100)
      },
      te = Q(t, 'showTicks'),
      ce = k(() =>
        te.value
          ? t.ticks
            ? Array.isArray(t.ticks)
              ? t.ticks.map((oe) => ({ value: oe, position: q(oe), label: oe.toString() }))
              : Object.keys(t.ticks).map((oe) => ({
                  value: parseFloat(oe),
                  position: q(parseFloat(oe)),
                  label: t.ticks[oe],
                }))
            : x.value !== 1 / 0
            ? ar(x.value + 1).map((oe) => {
                const z = d.value + oe * m.value
                return { value: z, position: q(z) }
              })
            : []
          : []
      ),
      Ee = k(() =>
        ce.value.some((oe) => {
          let { label: z } = oe
          return !!z
        })
      ),
      me = {
        activeThumbRef: E,
        color: Q(t, 'color'),
        decimals: p,
        disabled: N,
        direction: Q(t, 'direction'),
        elevation: Q(t, 'elevation'),
        hasLabels: Ee,
        isReversed: l,
        indexFromEnd: c,
        min: d,
        max: f,
        mousePressed: w,
        numTicks: x,
        onSliderMousedown: j,
        onSliderTouchstart: K,
        parsedTicks: ce,
        parseMouseMove: C,
        position: q,
        readonly: Q(t, 'readonly'),
        rounded: Q(t, 'rounded'),
        roundValue: v,
        showTicks: te,
        startOffset: _,
        step: m,
        thumbSize: y,
        thumbColor: V,
        thumbLabel: Q(t, 'thumbLabel'),
        ticks: Q(t, 'ticks'),
        tickSize: T,
        trackColor: D,
        trackContainerRef: S,
        trackFillColor: I,
        trackSize: A,
        vertical: u,
      }
    return mt(sw, me), me
  },
  OQ = W(
    {
      focused: Boolean,
      max: { type: Number, required: !0 },
      min: { type: Number, required: !0 },
      modelValue: { type: Number, required: !0 },
      position: { type: Number, required: !0 },
      ripple: { type: [Boolean, Object], default: !0 },
      name: String,
      ...Te(),
    },
    'VSliderThumb'
  ),
  ry = ne()({
    name: 'VSliderThumb',
    directives: { Ripple: Yr },
    props: OQ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const r = je(sw),
        { isRtl: s, rtlClasses: o } = sn()
      if (!r) throw new Error('[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider')
      const {
          thumbColor: a,
          step: l,
          disabled: u,
          thumbSize: c,
          thumbLabel: d,
          direction: f,
          isReversed: m,
          vertical: p,
          readonly: v,
          elevation: y,
          mousePressed: T,
          decimals: A,
          indexFromEnd: x,
        } = r,
        N = k(() => (u.value ? void 0 : y.value)),
        { elevationClasses: V } = yn(N),
        { textColorClasses: D, textColorStyles: I } = Tn(a),
        { pageup: w, pagedown: _, end: S, home: E, left: C, right: R, down: B, up: U } = Np,
        $ = [w, _, S, E, C, R, B, U],
        G = k(() => (l.value ? [1, 2, 3] : [1, 5, 10]))
      function F(j, q) {
        if (!$.includes(j.key)) return
        j.preventDefault()
        const te = l.value || 0.1,
          ce = (e.max - e.min) / te
        if ([C, R, B, U].includes(j.key)) {
          const me = (p.value ? [s.value ? C : R, m.value ? B : U] : x.value !== s.value ? [C, U] : [R, U]).includes(
              j.key
            )
              ? 1
              : -1,
            oe = j.shiftKey ? 2 : j.ctrlKey ? 1 : 0
          q = q + me * te * G.value[oe]
        } else if (j.key === E) q = e.min
        else if (j.key === S) q = e.max
        else {
          const Ee = j.key === _ ? 1 : -1
          q = q - Ee * te * (ce > 100 ? ce / 10 : 10)
        }
        return Math.max(e.min, Math.min(e.max, q))
      }
      function K(j) {
        const q = F(j, e.modelValue)
        q != null && i('update:modelValue', q)
      }
      return (
        se(() => {
          const j = Se(x.value ? 100 - e.position : e.position, '%')
          return g(
            'div',
            {
              class: [
                'v-slider-thumb',
                { 'v-slider-thumb--focused': e.focused, 'v-slider-thumb--pressed': e.focused && T.value },
                e.class,
                o.value,
              ],
              style: [{ '--v-slider-thumb-position': j, '--v-slider-thumb-size': Se(c.value) }, e.style],
              role: 'slider',
              tabindex: u.value ? -1 : 0,
              'aria-label': e.name,
              'aria-valuemin': e.min,
              'aria-valuemax': e.max,
              'aria-valuenow': e.modelValue,
              'aria-readonly': !!v.value,
              'aria-orientation': f.value,
              onKeydown: v.value ? void 0 : K,
            },
            [
              g('div', { class: ['v-slider-thumb__surface', D.value, V.value], style: { ...I.value } }, null),
              Rt(g('div', { class: ['v-slider-thumb__ripple', D.value], style: I.value }, null), [
                [pi('ripple'), e.ripple, null, { circle: !0, center: !0 }],
              ]),
              g(
                $b,
                { origin: 'bottom center' },
                {
                  default: () => {
                    var q
                    return [
                      Rt(
                        g('div', { class: 'v-slider-thumb__label-container' }, [
                          g('div', { class: ['v-slider-thumb__label'] }, [
                            g('div', null, [
                              ((q = n['thumb-label']) == null ? void 0 : q.call(n, { modelValue: e.modelValue })) ??
                                e.modelValue.toFixed(l.value ? A.value : 1),
                            ]),
                          ]),
                        ]),
                        [[Qi, (d.value && e.focused) || d.value === 'always']]
                      ),
                    ]
                  },
                }
              ),
            ]
          )
        }),
        {}
      )
    },
  }),
  MQ = W({ start: { type: Number, required: !0 }, stop: { type: Number, required: !0 }, ...Te() }, 'VSliderTrack'),
  CN = ne()({
    name: 'VSliderTrack',
    props: MQ(),
    emits: {},
    setup(e, t) {
      let { slots: n } = t
      const i = je(sw)
      if (!i) throw new Error('[Vuetify] v-slider-track must be inside v-slider or v-range-slider')
      const {
          color: r,
          parsedTicks: s,
          rounded: o,
          showTicks: a,
          tickSize: l,
          trackColor: u,
          trackFillColor: c,
          trackSize: d,
          vertical: f,
          min: m,
          max: p,
          indexFromEnd: v,
        } = i,
        { roundedClasses: y } = Mt(o),
        { backgroundColorClasses: T, backgroundColorStyles: A } = gt(c),
        { backgroundColorClasses: x, backgroundColorStyles: N } = gt(u),
        V = k(() => `inset-${f.value ? 'block' : 'inline'}-${v.value ? 'end' : 'start'}`),
        D = k(() => (f.value ? 'height' : 'width')),
        I = k(() => ({ [V.value]: '0%', [D.value]: '100%' })),
        w = k(() => e.stop - e.start),
        _ = k(() => ({ [V.value]: Se(e.start, '%'), [D.value]: Se(w.value, '%') })),
        S = k(() =>
          a.value
            ? (f.value ? s.value.slice().reverse() : s.value).map((C, R) => {
                var U
                const B = C.value !== m.value && C.value !== p.value ? Se(C.position, '%') : void 0
                return g(
                  'div',
                  {
                    key: C.value,
                    class: [
                      'v-slider-track__tick',
                      {
                        'v-slider-track__tick--filled': C.position >= e.start && C.position <= e.stop,
                        'v-slider-track__tick--first': C.value === m.value,
                        'v-slider-track__tick--last': C.value === p.value,
                      },
                    ],
                    style: { [V.value]: B },
                  },
                  [
                    (C.label || n['tick-label']) &&
                      g('div', { class: 'v-slider-track__tick-label' }, [
                        ((U = n['tick-label']) == null ? void 0 : U.call(n, { tick: C, index: R })) ?? C.label,
                      ]),
                  ]
                )
              })
            : []
        )
      return (
        se(() =>
          g(
            'div',
            {
              class: ['v-slider-track', y.value, e.class],
              style: [{ '--v-slider-track-size': Se(d.value), '--v-slider-tick-size': Se(l.value) }, e.style],
            },
            [
              g(
                'div',
                {
                  class: [
                    'v-slider-track__background',
                    x.value,
                    { 'v-slider-track__background--opacity': !!r.value || !c.value },
                  ],
                  style: { ...I.value, ...N.value },
                },
                null
              ),
              g('div', { class: ['v-slider-track__fill', T.value], style: { ..._.value, ...A.value } }, null),
              a.value &&
                g(
                  'div',
                  { class: ['v-slider-track__ticks', { 'v-slider-track__ticks--always-show': a.value === 'always' }] },
                  [S.value]
                ),
            ]
          )
        ),
        {}
      )
    },
  }),
  LQ = W({ ...fd(), ...SN(), ...Xr(), modelValue: { type: [Number, String], default: 0 } }, 'VSlider'),
  sy = ne()({
    name: 'VSlider',
    props: LQ(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0, start: (e) => !0, end: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const r = le(),
        { rtlClasses: s } = sn(),
        o = EN(e),
        a = xe(e, 'modelValue', void 0, (D) => o.roundValue(D ?? o.min.value)),
        {
          min: l,
          max: u,
          mousePressed: c,
          roundValue: d,
          onSliderMousedown: f,
          onSliderTouchstart: m,
          trackContainerRef: p,
          position: v,
          hasLabels: y,
          readonly: T,
        } = TN({
          props: e,
          steps: o,
          onSliderStart: () => {
            i('start', a.value)
          },
          onSliderEnd: (D) => {
            let { value: I } = D
            const w = d(I)
            ;(a.value = w), i('end', w)
          },
          onSliderMove: (D) => {
            let { value: I } = D
            return (a.value = d(I))
          },
          getActiveThumb: () => {
            var D
            return (D = r.value) == null ? void 0 : D.$el
          },
        }),
        { isFocused: A, focus: x, blur: N } = Qr(e),
        V = k(() => v(a.value))
      return (
        se(() => {
          const D = Cn.filterProps(e),
            I = !!(e.label || n.label || n.prepend)
          return g(
            Cn,
            ae(
              {
                class: [
                  'v-slider',
                  {
                    'v-slider--has-labels': !!n['tick-label'] || y.value,
                    'v-slider--focused': A.value,
                    'v-slider--pressed': c.value,
                    'v-slider--disabled': e.disabled,
                  },
                  s.value,
                  e.class,
                ],
                style: e.style,
              },
              D,
              { focused: A.value }
            ),
            {
              ...n,
              prepend: I
                ? (w) => {
                    var _, S
                    return g(ke, null, [
                      ((_ = n.label) == null ? void 0 : _.call(n, w)) ??
                        (e.label ? g(Kl, { id: w.id.value, class: 'v-slider__label', text: e.label }, null) : void 0),
                      (S = n.prepend) == null ? void 0 : S.call(n, w),
                    ])
                  }
                : void 0,
              default: (w) => {
                let { id: _, messagesId: S } = w
                return g(
                  'div',
                  {
                    class: 'v-slider__container',
                    onMousedown: T.value ? void 0 : f,
                    onTouchstartPassive: T.value ? void 0 : m,
                  },
                  [
                    g(
                      'input',
                      {
                        id: _.value,
                        name: e.name || _.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: '-1',
                        value: a.value,
                      },
                      null
                    ),
                    g(CN, { ref: p, start: 0, stop: V.value }, { 'tick-label': n['tick-label'] }),
                    g(
                      ry,
                      {
                        ref: r,
                        'aria-describedby': S.value,
                        focused: A.value,
                        min: l.value,
                        max: u.value,
                        modelValue: a.value,
                        'onUpdate:modelValue': (E) => (a.value = E),
                        position: V.value,
                        elevation: e.elevation,
                        onFocus: x,
                        onBlur: N,
                        ripple: e.ripple,
                        name: e.name,
                      },
                      { 'thumb-label': n['thumb-label'] }
                    ),
                  ]
                )
              },
            }
          )
        }),
        {}
      )
    },
  }),
  FQ = W({ color: { type: Object }, disabled: Boolean, hideAlpha: Boolean, ...Te() }, 'VColorPickerPreview'),
  BQ = yi({
    name: 'VColorPickerPreview',
    props: FQ(),
    emits: { 'update:color': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const i = new AbortController()
      Oy(() => i.abort())
      async function r() {
        if (!J0) return
        const s = new window.EyeDropper()
        try {
          const o = await s.open({ signal: i.signal }),
            a = UV(o.sRGBHex)
          n('update:color', { ...(e.color ?? Ka), ...a })
        } catch {}
      }
      return (
        se(() => {
          var s, o
          return g(
            'div',
            {
              class: ['v-color-picker-preview', { 'v-color-picker-preview--hide-alpha': e.hideAlpha }, e.class],
              style: e.style,
            },
            [
              J0 &&
                g('div', { class: 'v-color-picker-preview__eye-dropper', key: 'eyeDropper' }, [
                  g(st, { onClick: r, icon: '$eyeDropper', variant: 'plain', density: 'comfortable' }, null),
                ]),
              g('div', { class: 'v-color-picker-preview__dot' }, [
                g('div', { style: { background: FV(e.color ?? Ka) } }, null),
              ]),
              g('div', { class: 'v-color-picker-preview__sliders' }, [
                g(
                  sy,
                  {
                    class: 'v-color-picker-preview__track v-color-picker-preview__hue',
                    modelValue: (s = e.color) == null ? void 0 : s.h,
                    'onUpdate:modelValue': (a) => n('update:color', { ...(e.color ?? Ka), h: a }),
                    step: 0,
                    min: 0,
                    max: 360,
                    disabled: e.disabled,
                    thumbSize: 14,
                    trackSize: 8,
                    trackFillColor: 'white',
                    hideDetails: !0,
                  },
                  null
                ),
                !e.hideAlpha &&
                  g(
                    sy,
                    {
                      class: 'v-color-picker-preview__track v-color-picker-preview__alpha',
                      modelValue: ((o = e.color) == null ? void 0 : o.a) ?? 1,
                      'onUpdate:modelValue': (a) => n('update:color', { ...(e.color ?? Ka), a }),
                      step: 1 / 256,
                      min: 0,
                      max: 1,
                      disabled: e.disabled,
                      thumbSize: 14,
                      trackSize: 8,
                      trackFillColor: 'white',
                      hideDetails: !0,
                    },
                    null
                  ),
              ]),
            ]
          )
        }),
        {}
      )
    },
  }),
  $Q = {
    base: '#f44336',
    lighten5: '#ffebee',
    lighten4: '#ffcdd2',
    lighten3: '#ef9a9a',
    lighten2: '#e57373',
    lighten1: '#ef5350',
    darken1: '#e53935',
    darken2: '#d32f2f',
    darken3: '#c62828',
    darken4: '#b71c1c',
    accent1: '#ff8a80',
    accent2: '#ff5252',
    accent3: '#ff1744',
    accent4: '#d50000',
  },
  UQ = {
    base: '#e91e63',
    lighten5: '#fce4ec',
    lighten4: '#f8bbd0',
    lighten3: '#f48fb1',
    lighten2: '#f06292',
    lighten1: '#ec407a',
    darken1: '#d81b60',
    darken2: '#c2185b',
    darken3: '#ad1457',
    darken4: '#880e4f',
    accent1: '#ff80ab',
    accent2: '#ff4081',
    accent3: '#f50057',
    accent4: '#c51162',
  },
  jQ = {
    base: '#9c27b0',
    lighten5: '#f3e5f5',
    lighten4: '#e1bee7',
    lighten3: '#ce93d8',
    lighten2: '#ba68c8',
    lighten1: '#ab47bc',
    darken1: '#8e24aa',
    darken2: '#7b1fa2',
    darken3: '#6a1b9a',
    darken4: '#4a148c',
    accent1: '#ea80fc',
    accent2: '#e040fb',
    accent3: '#d500f9',
    accent4: '#aa00ff',
  },
  zQ = {
    base: '#673ab7',
    lighten5: '#ede7f6',
    lighten4: '#d1c4e9',
    lighten3: '#b39ddb',
    lighten2: '#9575cd',
    lighten1: '#7e57c2',
    darken1: '#5e35b1',
    darken2: '#512da8',
    darken3: '#4527a0',
    darken4: '#311b92',
    accent1: '#b388ff',
    accent2: '#7c4dff',
    accent3: '#651fff',
    accent4: '#6200ea',
  },
  HQ = {
    base: '#3f51b5',
    lighten5: '#e8eaf6',
    lighten4: '#c5cae9',
    lighten3: '#9fa8da',
    lighten2: '#7986cb',
    lighten1: '#5c6bc0',
    darken1: '#3949ab',
    darken2: '#303f9f',
    darken3: '#283593',
    darken4: '#1a237e',
    accent1: '#8c9eff',
    accent2: '#536dfe',
    accent3: '#3d5afe',
    accent4: '#304ffe',
  },
  WQ = {
    base: '#2196f3',
    lighten5: '#e3f2fd',
    lighten4: '#bbdefb',
    lighten3: '#90caf9',
    lighten2: '#64b5f6',
    lighten1: '#42a5f5',
    darken1: '#1e88e5',
    darken2: '#1976d2',
    darken3: '#1565c0',
    darken4: '#0d47a1',
    accent1: '#82b1ff',
    accent2: '#448aff',
    accent3: '#2979ff',
    accent4: '#2962ff',
  },
  qQ = {
    base: '#03a9f4',
    lighten5: '#e1f5fe',
    lighten4: '#b3e5fc',
    lighten3: '#81d4fa',
    lighten2: '#4fc3f7',
    lighten1: '#29b6f6',
    darken1: '#039be5',
    darken2: '#0288d1',
    darken3: '#0277bd',
    darken4: '#01579b',
    accent1: '#80d8ff',
    accent2: '#40c4ff',
    accent3: '#00b0ff',
    accent4: '#0091ea',
  },
  GQ = {
    base: '#00bcd4',
    lighten5: '#e0f7fa',
    lighten4: '#b2ebf2',
    lighten3: '#80deea',
    lighten2: '#4dd0e1',
    lighten1: '#26c6da',
    darken1: '#00acc1',
    darken2: '#0097a7',
    darken3: '#00838f',
    darken4: '#006064',
    accent1: '#84ffff',
    accent2: '#18ffff',
    accent3: '#00e5ff',
    accent4: '#00b8d4',
  },
  KQ = {
    base: '#009688',
    lighten5: '#e0f2f1',
    lighten4: '#b2dfdb',
    lighten3: '#80cbc4',
    lighten2: '#4db6ac',
    lighten1: '#26a69a',
    darken1: '#00897b',
    darken2: '#00796b',
    darken3: '#00695c',
    darken4: '#004d40',
    accent1: '#a7ffeb',
    accent2: '#64ffda',
    accent3: '#1de9b6',
    accent4: '#00bfa5',
  },
  YQ = {
    base: '#4caf50',
    lighten5: '#e8f5e9',
    lighten4: '#c8e6c9',
    lighten3: '#a5d6a7',
    lighten2: '#81c784',
    lighten1: '#66bb6a',
    darken1: '#43a047',
    darken2: '#388e3c',
    darken3: '#2e7d32',
    darken4: '#1b5e20',
    accent1: '#b9f6ca',
    accent2: '#69f0ae',
    accent3: '#00e676',
    accent4: '#00c853',
  },
  QQ = {
    base: '#8bc34a',
    lighten5: '#f1f8e9',
    lighten4: '#dcedc8',
    lighten3: '#c5e1a5',
    lighten2: '#aed581',
    lighten1: '#9ccc65',
    darken1: '#7cb342',
    darken2: '#689f38',
    darken3: '#558b2f',
    darken4: '#33691e',
    accent1: '#ccff90',
    accent2: '#b2ff59',
    accent3: '#76ff03',
    accent4: '#64dd17',
  },
  XQ = {
    base: '#cddc39',
    lighten5: '#f9fbe7',
    lighten4: '#f0f4c3',
    lighten3: '#e6ee9c',
    lighten2: '#dce775',
    lighten1: '#d4e157',
    darken1: '#c0ca33',
    darken2: '#afb42b',
    darken3: '#9e9d24',
    darken4: '#827717',
    accent1: '#f4ff81',
    accent2: '#eeff41',
    accent3: '#c6ff00',
    accent4: '#aeea00',
  },
  JQ = {
    base: '#ffeb3b',
    lighten5: '#fffde7',
    lighten4: '#fff9c4',
    lighten3: '#fff59d',
    lighten2: '#fff176',
    lighten1: '#ffee58',
    darken1: '#fdd835',
    darken2: '#fbc02d',
    darken3: '#f9a825',
    darken4: '#f57f17',
    accent1: '#ffff8d',
    accent2: '#ffff00',
    accent3: '#ffea00',
    accent4: '#ffd600',
  },
  ZQ = {
    base: '#ffc107',
    lighten5: '#fff8e1',
    lighten4: '#ffecb3',
    lighten3: '#ffe082',
    lighten2: '#ffd54f',
    lighten1: '#ffca28',
    darken1: '#ffb300',
    darken2: '#ffa000',
    darken3: '#ff8f00',
    darken4: '#ff6f00',
    accent1: '#ffe57f',
    accent2: '#ffd740',
    accent3: '#ffc400',
    accent4: '#ffab00',
  },
  eX = {
    base: '#ff9800',
    lighten5: '#fff3e0',
    lighten4: '#ffe0b2',
    lighten3: '#ffcc80',
    lighten2: '#ffb74d',
    lighten1: '#ffa726',
    darken1: '#fb8c00',
    darken2: '#f57c00',
    darken3: '#ef6c00',
    darken4: '#e65100',
    accent1: '#ffd180',
    accent2: '#ffab40',
    accent3: '#ff9100',
    accent4: '#ff6d00',
  },
  tX = {
    base: '#ff5722',
    lighten5: '#fbe9e7',
    lighten4: '#ffccbc',
    lighten3: '#ffab91',
    lighten2: '#ff8a65',
    lighten1: '#ff7043',
    darken1: '#f4511e',
    darken2: '#e64a19',
    darken3: '#d84315',
    darken4: '#bf360c',
    accent1: '#ff9e80',
    accent2: '#ff6e40',
    accent3: '#ff3d00',
    accent4: '#dd2c00',
  },
  nX = {
    base: '#795548',
    lighten5: '#efebe9',
    lighten4: '#d7ccc8',
    lighten3: '#bcaaa4',
    lighten2: '#a1887f',
    lighten1: '#8d6e63',
    darken1: '#6d4c41',
    darken2: '#5d4037',
    darken3: '#4e342e',
    darken4: '#3e2723',
  },
  iX = {
    base: '#607d8b',
    lighten5: '#eceff1',
    lighten4: '#cfd8dc',
    lighten3: '#b0bec5',
    lighten2: '#90a4ae',
    lighten1: '#78909c',
    darken1: '#546e7a',
    darken2: '#455a64',
    darken3: '#37474f',
    darken4: '#263238',
  },
  rX = {
    base: '#9e9e9e',
    lighten5: '#fafafa',
    lighten4: '#f5f5f5',
    lighten3: '#eeeeee',
    lighten2: '#e0e0e0',
    lighten1: '#bdbdbd',
    darken1: '#757575',
    darken2: '#616161',
    darken3: '#424242',
    darken4: '#212121',
  },
  sX = { black: '#000000', white: '#ffffff', transparent: '#ffffff00' },
  oX = {
    red: $Q,
    pink: UQ,
    purple: jQ,
    deepPurple: zQ,
    indigo: HQ,
    blue: WQ,
    lightBlue: qQ,
    cyan: GQ,
    teal: KQ,
    green: YQ,
    lightGreen: QQ,
    lime: XQ,
    yellow: JQ,
    amber: ZQ,
    orange: eX,
    deepOrange: tX,
    brown: nX,
    blueGrey: iX,
    grey: rX,
    shades: sX,
  },
  aX = W(
    {
      swatches: { type: Array, default: () => lX(oX) },
      disabled: Boolean,
      color: Object,
      maxHeight: [Number, String],
      ...Te(),
    },
    'VColorPickerSwatches'
  )
function lX(e) {
  return Object.keys(e).map((t) => {
    const n = e[t]
    return n.base
      ? [n.base, n.darken4, n.darken3, n.darken2, n.darken1, n.lighten1, n.lighten2, n.lighten3, n.lighten4, n.lighten5]
      : [n.black, n.white, n.transparent]
  })
}
const uX = yi({
    name: 'VColorPickerSwatches',
    props: aX(),
    emits: { 'update:color': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      return (
        se(() =>
          g('div', { class: ['v-color-picker-swatches', e.class], style: [{ maxHeight: Se(e.maxHeight) }, e.style] }, [
            g('div', null, [
              e.swatches.map((i) =>
                g('div', { class: 'v-color-picker-swatches__swatch' }, [
                  i.map((r) => {
                    const s = Ai(r),
                      o = Cm(s),
                      a = LV(s)
                    return g(
                      'div',
                      { class: 'v-color-picker-swatches__color', onClick: () => o && n('update:color', o) },
                      [
                        g('div', { style: { background: a } }, [
                          e.color && vr(e.color, o)
                            ? g(
                                ot,
                                { size: 'x-small', icon: '$success', color: fK(r, '#FFFFFF') > 2 ? 'white' : 'black' },
                                null
                              )
                            : void 0,
                        ]),
                      ]
                    )
                  }),
                ])
              ),
            ]),
          ])
        ),
        {}
      )
    },
  }),
  Wm = W({ color: String, ...bi(), ...Te(), ...on(), ...en(), ...Kr(), ...ql(), ...Tt(), ...He(), ...Ze() }, 'VSheet'),
  Xo = ne()({
    name: 'VSheet',
    props: Wm(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { backgroundColorClasses: r, backgroundColorStyles: s } = gt(Q(e, 'color')),
        { borderClasses: o } = Oi(e),
        { dimensionStyles: a } = an(e),
        { elevationClasses: l } = yn(e),
        { locationStyles: u } = ya(e),
        { positionClasses: c } = Gl(e),
        { roundedClasses: d } = Mt(e)
      return (
        se(() =>
          g(
            e.tag,
            {
              class: ['v-sheet', i.value, r.value, o.value, l.value, c.value, d.value, e.class],
              style: [s.value, a.value, u.value, e.style],
            },
            n
          )
        ),
        {}
      )
    },
  }),
  cX = W(
    {
      canvasHeight: { type: [String, Number], default: 150 },
      disabled: Boolean,
      dotSize: { type: [Number, String], default: 10 },
      hideCanvas: Boolean,
      hideSliders: Boolean,
      hideInputs: Boolean,
      mode: { type: String, default: 'rgba', validator: (e) => Object.keys(Po).includes(e) },
      modes: {
        type: Array,
        default: () => Object.keys(Po),
        validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Po).includes(t)),
      },
      showSwatches: Boolean,
      swatches: Array,
      swatchesMaxHeight: { type: [Number, String], default: 150 },
      modelValue: { type: [Object, String] },
      ...Qt(Wm({ width: 300 }), ['height', 'location', 'minHeight', 'maxHeight', 'minWidth', 'maxWidth']),
    },
    'VColorPicker'
  ),
  dX = yi({
    name: 'VColorPicker',
    props: cX(),
    emits: { 'update:modelValue': (e) => !0, 'update:mode': (e) => !0 },
    setup(e) {
      const t = xe(e, 'mode'),
        n = le(null),
        i = xe(
          e,
          'modelValue',
          void 0,
          (l) => {
            if (l == null || l === '') return null
            let u
            try {
              u = Cm(Ai(l))
            } catch {
              return null
            }
            return u
          },
          (l) => (l ? AQ(l, e.modelValue) : null)
        ),
        r = k(() => (i.value ? { ...i.value, h: n.value ?? i.value.h } : null)),
        { rtlClasses: s } = sn()
      let o = !0
      be(
        i,
        (l) => {
          if (!o) {
            o = !0
            return
          }
          l && (n.value = l.h)
        },
        { immediate: !0 }
      )
      const a = (l) => {
        ;(o = !1), (n.value = l.h), (i.value = l)
      }
      return (
        An(() => {
          e.modes.includes(t.value) || (t.value = e.modes[0])
        }),
        Ot({ VSlider: { color: void 0, trackColor: void 0, trackFillColor: void 0 } }),
        se(() => {
          const l = Xo.filterProps(e)
          return g(
            Xo,
            ae(
              {
                rounded: e.rounded,
                elevation: e.elevation,
                theme: e.theme,
                class: ['v-color-picker', s.value, e.class],
                style: [{ '--v-color-picker-color-hsv': FV({ ...(r.value ?? Ka), a: 1 }) }, e.style],
              },
              l,
              { maxWidth: e.width }
            ),
            {
              default: () => [
                !e.hideCanvas &&
                  g(
                    TQ,
                    {
                      key: 'canvas',
                      color: r.value,
                      'onUpdate:color': a,
                      disabled: e.disabled,
                      dotSize: e.dotSize,
                      width: e.width,
                      height: e.canvasHeight,
                    },
                    null
                  ),
                (!e.hideSliders || !e.hideInputs) &&
                  g('div', { key: 'controls', class: 'v-color-picker__controls' }, [
                    !e.hideSliders &&
                      g(
                        BQ,
                        {
                          key: 'preview',
                          color: r.value,
                          'onUpdate:color': a,
                          hideAlpha: !t.value.endsWith('a'),
                          disabled: e.disabled,
                        },
                        null
                      ),
                    !e.hideInputs &&
                      g(
                        DQ,
                        {
                          key: 'edit',
                          modes: e.modes,
                          mode: t.value,
                          'onUpdate:mode': (u) => (t.value = u),
                          color: r.value,
                          'onUpdate:color': a,
                          disabled: e.disabled,
                        },
                        null
                      ),
                  ]),
                e.showSwatches &&
                  g(
                    uX,
                    {
                      key: 'swatches',
                      color: r.value,
                      'onUpdate:color': a,
                      maxHeight: e.swatchesMaxHeight,
                      swatches: e.swatches,
                      disabled: e.disabled,
                    },
                    null
                  ),
              ],
            }
          )
        }),
        {}
      )
    },
  })
function hX(e, t, n) {
  if (t == null) return e
  if (Array.isArray(t)) throw new Error('Multiple matches is not implemented')
  return typeof t == 'number' && ~t
    ? g(ke, null, [
        g('span', { class: 'v-combobox__unmask' }, [e.substr(0, t)]),
        g('span', { class: 'v-combobox__mask' }, [e.substr(t, n)]),
        g('span', { class: 'v-combobox__unmask' }, [e.substr(t + n)]),
      ])
    : e
}
const fX = W(
    {
      autoSelectFirst: { type: [Boolean, String] },
      clearOnSelect: { type: Boolean, default: !0 },
      delimiters: Array,
      ...pd({ filterKeys: ['title'] }),
      ...nw({ hideNoData: !0, returnObject: !0 }),
      ...Qt(Um({ modelValue: null, role: 'combobox' }), ['validationValue', 'dirty', 'appendInnerIcon']),
      ...Xi({ transition: !1 }),
    },
    'VCombobox'
  ),
  mX = ne()({
    name: 'VCombobox',
    props: fX(),
    emits: {
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:search': (e) => !0,
      'update:menu': (e) => !0,
    },
    setup(e, t) {
      var pe
      let { emit: n, slots: i } = t
      const { t: r } = jt(),
        s = le(),
        o = ye(!1),
        a = ye(!0),
        l = ye(!1),
        u = le(),
        c = le(),
        d = xe(e, 'menu'),
        f = k({
          get: () => d.value,
          set: (re) => {
            var O
            ;(d.value && !re && (O = u.value) != null && O.ΨopenChildren) || (d.value = re)
          },
        }),
        m = ye(-1)
      let p = !1
      const v = k(() => {
          var re
          return (re = s.value) == null ? void 0 : re.color
        }),
        y = k(() => (f.value ? e.closeText : e.openText)),
        { items: T, transformIn: A, transformOut: x } = Yb(e),
        { textColorClasses: N, textColorStyles: V } = Tn(v),
        D = xe(
          e,
          'modelValue',
          [],
          (re) => A(Pt(re)),
          (re) => {
            const O = x(re)
            return e.multiple ? O : O[0] ?? null
          }
        ),
        I = Fm(),
        w = k(() => !!(e.chips || i.chip)),
        _ = k(() => w.value || !!i.selection),
        S = ye(!e.multiple && !_.value ? ((pe = D.value[0]) == null ? void 0 : pe.title) ?? '' : ''),
        E = k({
          get: () => S.value,
          set: (re) => {
            var O
            if (
              ((S.value = re ?? ''),
              !e.multiple && !_.value && (D.value = [ws(e, re)]),
              re && e.multiple && (O = e.delimiters) != null && O.length)
            ) {
              const L = re.split(new RegExp(`(?:${e.delimiters.join('|')})+`))
              L.length > 1 &&
                (L.forEach((H) => {
                  ;(H = H.trim()), H && z(ws(e, H))
                }),
                (S.value = ''))
            }
            re || (m.value = -1), (a.value = !re)
          },
        }),
        C = k(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(D.value)
            : typeof e.counterValue == 'number'
            ? e.counterValue
            : e.multiple
            ? D.value.length
            : E.value.length
        )
      be(S, (re) => {
        p ? Xe(() => (p = !1)) : o.value && !f.value && (f.value = !0), n('update:search', re)
      }),
        be(D, (re) => {
          var O
          !e.multiple && !_.value && (S.value = ((O = re[0]) == null ? void 0 : O.title) ?? '')
        })
      const { filteredItems: R, getMatches: B } = yd(e, T, () => (a.value ? '' : E.value)),
        U = k(() => (e.hideSelected ? R.value.filter((re) => !D.value.some((O) => O.value === re.value)) : R.value)),
        $ = k(() => D.value.map((re) => re.value)),
        G = k(() => {
          var O
          return (
            (e.autoSelectFirst === !0 ||
              (e.autoSelectFirst === 'exact' && E.value === ((O = U.value[0]) == null ? void 0 : O.title))) &&
            U.value.length > 0 &&
            !a.value &&
            !l.value
          )
        }),
        F = k(() => (e.hideNoData && !U.value.length) || e.readonly || (I == null ? void 0 : I.isReadonly.value)),
        K = le(),
        { onListScroll: j, onListKeydown: q } = tw(K, s)
      function te(re) {
        ;(p = !0), e.openOnClear && (f.value = !0)
      }
      function ce() {
        F.value || (f.value = !0)
      }
      function Ee(re) {
        F.value || (o.value && (re.preventDefault(), re.stopPropagation()), (f.value = !f.value))
      }
      function me(re) {
        var H
        if (FG(re) || e.readonly || (I != null && I.isReadonly.value)) return
        const O = s.value.selectionStart,
          L = D.value.length
        if (
          ((m.value > -1 || ['Enter', 'ArrowDown', 'ArrowUp'].includes(re.key)) && re.preventDefault(),
          ['Enter', 'ArrowDown'].includes(re.key) && (f.value = !0),
          ['Escape'].includes(re.key) && (f.value = !1),
          ['Enter', 'Escape', 'Tab'].includes(re.key) &&
            (G.value &&
              ['Enter', 'Tab'].includes(re.key) &&
              !D.value.some((X) => {
                let { value: ee } = X
                return ee === U.value[0].value
              }) &&
              z(R.value[0]),
            (a.value = !0)),
          re.key === 'ArrowDown' && G.value && ((H = K.value) == null || H.focus('next')),
          re.key === 'Enter' && E.value && (z(ws(e, E.value)), _.value && (S.value = '')),
          ['Backspace', 'Delete'].includes(re.key))
        ) {
          if (!e.multiple && _.value && D.value.length > 0 && !E.value) return z(D.value[0], !1)
          if (~m.value) {
            const X = m.value
            z(D.value[m.value], !1), (m.value = X >= L - 1 ? L - 2 : X)
          } else re.key === 'Backspace' && !E.value && (m.value = L - 1)
        }
        if (e.multiple) {
          if (re.key === 'ArrowLeft') {
            if (m.value < 0 && O > 0) return
            const X = m.value > -1 ? m.value - 1 : L - 1
            D.value[X] ? (m.value = X) : ((m.value = -1), s.value.setSelectionRange(E.value.length, E.value.length))
          }
          if (re.key === 'ArrowRight') {
            if (m.value < 0) return
            const X = m.value + 1
            D.value[X] ? (m.value = X) : ((m.value = -1), s.value.setSelectionRange(0, 0))
          }
        }
      }
      function oe() {
        var re
        o.value && ((a.value = !0), (re = s.value) == null || re.focus())
      }
      function z(re) {
        let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
        if (!(!re || re.props.disabled))
          if (e.multiple) {
            const L = D.value.findIndex((X) => e.valueComparator(X.value, re.value)),
              H = O ?? !~L
            if (~L) {
              const X = H ? [...D.value, re] : [...D.value]
              X.splice(L, 1), (D.value = X)
            } else H && (D.value = [...D.value, re])
            e.clearOnSelect && (E.value = '')
          } else {
            const L = O !== !1
            ;(D.value = L ? [re] : []),
              (S.value = L && !_.value ? re.title : ''),
              Xe(() => {
                ;(f.value = !1), (a.value = !0)
              })
          }
      }
      function ue(re) {
        ;(o.value = !0),
          setTimeout(() => {
            l.value = !0
          })
      }
      function de(re) {
        l.value = !1
      }
      function Z(re) {
        ;(re == null || (re === '' && !e.multiple && !_.value)) && (D.value = [])
      }
      return (
        be(o, (re, O) => {
          if (!(re || re === O) && ((m.value = -1), (f.value = !1), E.value)) {
            if (e.multiple) {
              z(ws(e, E.value))
              return
            }
            if (!_.value) return
            D.value.some((L) => {
              let { title: H } = L
              return H === E.value
            })
              ? (S.value = '')
              : z(ws(e, E.value))
          }
        }),
        be(f, () => {
          if (!e.hideSelected && f.value && D.value.length) {
            const re = U.value.findIndex((O) => D.value.some((L) => e.valueComparator(L.value, O.value)))
            ct &&
              window.requestAnimationFrame(() => {
                var O
                re >= 0 && ((O = c.value) == null || O.scrollToIndex(re))
              })
          }
        }),
        be(
          () => e.items,
          (re, O) => {
            f.value || (o.value && !O.length && re.length && (f.value = !0))
          }
        ),
        se(() => {
          const re = !!(!e.hideNoData || U.value.length || i['prepend-item'] || i['append-item'] || i['no-data']),
            O = D.value.length > 0,
            L = Ko.filterProps(e)
          return g(
            Ko,
            ae({ ref: s }, L, {
              modelValue: E.value,
              'onUpdate:modelValue': [(H) => (E.value = H), Z],
              focused: o.value,
              'onUpdate:focused': (H) => (o.value = H),
              validationValue: D.externalValue,
              counterValue: C.value,
              dirty: O,
              class: [
                'v-combobox',
                {
                  'v-combobox--active-menu': f.value,
                  'v-combobox--chips': !!e.chips,
                  'v-combobox--selection-slot': !!_.value,
                  'v-combobox--selecting-index': m.value > -1,
                  [`v-combobox--${e.multiple ? 'multiple' : 'single'}`]: !0,
                },
                e.class,
              ],
              style: e.style,
              readonly: e.readonly,
              placeholder: O ? void 0 : e.placeholder,
              'onClick:clear': te,
              'onMousedown:control': ce,
              onKeydown: me,
            }),
            {
              ...i,
              default: () =>
                g(ke, null, [
                  g(
                    xl,
                    ae(
                      {
                        ref: u,
                        modelValue: f.value,
                        'onUpdate:modelValue': (H) => (f.value = H),
                        activator: 'parent',
                        contentClass: 'v-combobox__content',
                        disabled: F.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterLeave: oe,
                      },
                      e.menuProps
                    ),
                    {
                      default: () => [
                        re &&
                          g(
                            Bm,
                            ae(
                              {
                                ref: K,
                                selected: $.value,
                                selectStrategy: e.multiple ? 'independent' : 'single-independent',
                                onMousedown: (H) => H.preventDefault(),
                                onKeydown: q,
                                onFocusin: ue,
                                onFocusout: de,
                                onScrollPassive: j,
                                tabindex: '-1',
                                'aria-live': 'polite',
                                color: e.itemColor ?? e.color,
                              },
                              e.listProps
                            ),
                            {
                              default: () => {
                                var H, X, ee
                                return [
                                  (H = i['prepend-item']) == null ? void 0 : H.call(i),
                                  !U.value.length &&
                                    !e.hideNoData &&
                                    (((X = i['no-data']) == null ? void 0 : X.call(i)) ??
                                      g(Ur, { title: r(e.noDataText) }, null)),
                                  g(
                                    jm,
                                    { ref: c, renderless: !0, items: U.value },
                                    {
                                      default: (he) => {
                                        var Ae
                                        let { item: ge, index: Ie, itemRef: _e } = he
                                        const ve = ae(ge.props, {
                                          ref: _e,
                                          key: Ie,
                                          active: G.value && Ie === 0 ? !0 : void 0,
                                          onClick: () => z(ge, null),
                                        })
                                        return (
                                          ((Ae = i.item) == null
                                            ? void 0
                                            : Ae.call(i, { item: ge, index: Ie, props: ve })) ??
                                          g(Ur, ae(ve, { role: 'option' }), {
                                            prepend: (Ne) => {
                                              let { isSelected: De } = Ne
                                              return g(ke, null, [
                                                e.multiple && !e.hideSelected
                                                  ? g(
                                                      $r,
                                                      { key: ge.value, modelValue: De, ripple: !1, tabindex: '-1' },
                                                      null
                                                    )
                                                  : void 0,
                                                ge.props.prependAvatar &&
                                                  g(Vi, { image: ge.props.prependAvatar }, null),
                                                ge.props.prependIcon && g(ot, { icon: ge.props.prependIcon }, null),
                                              ])
                                            },
                                            title: () => {
                                              var Ne, De
                                              return a.value
                                                ? ge.title
                                                : hX(
                                                    ge.title,
                                                    (Ne = B(ge)) == null ? void 0 : Ne.title,
                                                    ((De = E.value) == null ? void 0 : De.length) ?? 0
                                                  )
                                            },
                                          })
                                        )
                                      },
                                    }
                                  ),
                                  (ee = i['append-item']) == null ? void 0 : ee.call(i),
                                ]
                              },
                            }
                          ),
                      ],
                    }
                  ),
                  D.value.map((H, X) => {
                    function ee(_e) {
                      _e.stopPropagation(), _e.preventDefault(), z(H, !1)
                    }
                    const he = {
                        'onClick:close': ee,
                        onKeydown(_e) {
                          ;(_e.key !== 'Enter' && _e.key !== ' ') || (_e.preventDefault(), _e.stopPropagation(), ee(_e))
                        },
                        onMousedown(_e) {
                          _e.preventDefault(), _e.stopPropagation()
                        },
                        modelValue: !0,
                        'onUpdate:modelValue': void 0,
                      },
                      ge = w.value ? !!i.chip : !!i.selection,
                      Ie = ge
                        ? Tm(w.value ? i.chip({ item: H, index: X, props: he }) : i.selection({ item: H, index: X }))
                        : void 0
                    if (!(ge && !Ie))
                      return g(
                        'div',
                        {
                          key: H.value,
                          class: [
                            'v-combobox__selection',
                            X === m.value && ['v-combobox__selection--selected', N.value],
                          ],
                          style: X === m.value ? V.value : {},
                        },
                        [
                          w.value
                            ? i.chip
                              ? g(
                                  Ge,
                                  {
                                    key: 'chip-defaults',
                                    defaults: { VChip: { closable: e.closableChips, size: 'small', text: H.title } },
                                  },
                                  { default: () => [Ie] }
                                )
                              : g(
                                  Yl,
                                  ae(
                                    {
                                      key: 'chip',
                                      closable: e.closableChips,
                                      size: 'small',
                                      text: H.title,
                                      disabled: H.props.disabled,
                                    },
                                    he
                                  ),
                                  null
                                )
                            : Ie ??
                              g('span', { class: 'v-combobox__selection-text' }, [
                                H.title,
                                e.multiple &&
                                  X < D.value.length - 1 &&
                                  g('span', { class: 'v-combobox__selection-comma' }, [Or(',')]),
                              ]),
                        ]
                      )
                  }),
                ]),
              'append-inner': function () {
                var he
                for (var H = arguments.length, X = new Array(H), ee = 0; ee < H; ee++) X[ee] = arguments[ee]
                return g(ke, null, [
                  (he = i['append-inner']) == null ? void 0 : he.call(i, ...X),
                  (!e.hideNoData || e.items.length) && e.menuIcon
                    ? g(
                        ot,
                        {
                          class: 'v-combobox__menu-icon',
                          icon: e.menuIcon,
                          onMousedown: Ee,
                          onClick: RV,
                          'aria-label': r(y.value),
                          title: r(y.value),
                          tabindex: '-1',
                        },
                        null
                      )
                    : void 0,
                ])
              },
            }
          )
        }),
        Li({ isFocused: o, isPristine: a, menu: f, search: E, selectionIndex: m, filteredItems: R, select: z }, s)
      )
    },
  }),
  gX = W(
    {
      modelValue: null,
      color: String,
      cancelText: { type: String, default: '$vuetify.confirmEdit.cancel' },
      okText: { type: String, default: '$vuetify.confirmEdit.ok' },
    },
    'VConfirmEdit'
  ),
  vX = ne()({
    name: 'VConfirmEdit',
    props: gX(),
    emits: { cancel: () => !0, save: (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const r = xe(e, 'modelValue'),
        s = le()
      $t(() => {
        s.value = structuredClone(ze(r.value))
      })
      const { t: o } = jt(),
        a = k(() => vr(r.value, s.value))
      function l() {
        ;(r.value = s.value), n('save', s.value)
      }
      function u() {
        ;(s.value = structuredClone(ze(r.value))), n('cancel')
      }
      let c = !1
      return (
        se(() => {
          var f
          const d = g(ke, null, [
            g(st, { disabled: a.value, variant: 'text', color: e.color, onClick: u, text: o(e.cancelText) }, null),
            g(st, { disabled: a.value, variant: 'text', color: e.color, onClick: l, text: o(e.okText) }, null),
          ])
          return g(ke, null, [
            (f = i.default) == null
              ? void 0
              : f.call(i, {
                  model: s,
                  save: l,
                  cancel: u,
                  isPristine: a.value,
                  get actions() {
                    return (c = !0), d
                  },
                }),
            !c && d,
          ])
        }),
        { save: l, cancel: u, isPristine: a }
      )
    },
  }),
  AN = W(
    { expandOnClick: Boolean, showExpand: Boolean, expanded: { type: Array, default: () => [] } },
    'DataTable-expand'
  ),
  kN = Symbol.for('vuetify:datatable:expanded')
function qm(e) {
  const t = Q(e, 'expandOnClick'),
    n = xe(
      e,
      'expanded',
      e.expanded,
      (a) => new Set(a),
      (a) => [...a.values()]
    )
  function i(a, l) {
    const u = new Set(n.value)
    l ? u.add(a.value) : u.delete(a.value), (n.value = u)
  }
  function r(a) {
    return n.value.has(a.value)
  }
  function s(a) {
    i(a, !r(a))
  }
  const o = { expand: i, expanded: n, expandOnClick: t, isExpanded: r, toggleExpand: s }
  return mt(kN, o), o
}
function PN() {
  const e = je(kN)
  if (!e) throw new Error('foo')
  return e
}
const ow = W({ groupBy: { type: Array, default: () => [] } }, 'DataTable-group'),
  RN = Symbol.for('vuetify:data-table-group')
function aw(e) {
  return { groupBy: xe(e, 'groupBy') }
}
function Gm(e) {
  const { disableSort: t, groupBy: n, sortBy: i } = e,
    r = le(new Set()),
    s = k(() => n.value.map((c) => ({ ...c, order: c.order ?? !1 })).concat(t != null && t.value ? [] : i.value))
  function o(c) {
    return r.value.has(c.id)
  }
  function a(c) {
    const d = new Set(r.value)
    o(c) ? d.delete(c.id) : d.add(c.id), (r.value = d)
  }
  function l(c) {
    function d(f) {
      const m = []
      for (const p of f.items) 'type' in p && p.type === 'group' ? m.push(...d(p)) : m.push(p)
      return m
    }
    return d({ type: 'group', items: c, id: 'dummy', key: 'dummy', value: 'dummy', depth: 0 })
  }
  const u = { sortByWithGroups: s, toggleGroup: a, opened: r, groupBy: n, extractRows: l, isGroupOpen: o }
  return mt(RN, u), u
}
function xN() {
  const e = je(RN)
  if (!e) throw new Error('Missing group!')
  return e
}
function pX(e, t) {
  if (!e.length) return []
  const n = new Map()
  for (const i of e) {
    const r = Go(i.raw, t)
    n.has(r) || n.set(r, []), n.get(r).push(i)
  }
  return n
}
function VN(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'root'
  if (!t.length) return []
  const r = pX(e, t[0]),
    s = [],
    o = t.slice(1)
  return (
    r.forEach((a, l) => {
      const u = t[0],
        c = `${i}_${u}_${l}`
      s.push({ depth: n, id: c, key: u, value: l, items: o.length ? VN(a, o, n + 1, c) : a, type: 'group' })
    }),
    s
  )
}
function DN(e, t) {
  const n = []
  for (const i of e)
    'type' in i && i.type === 'group'
      ? (i.value != null && n.push(i), (t.has(i.id) || i.value == null) && n.push(...DN(i.items, t)))
      : n.push(i)
  return n
}
function Km(e, t, n) {
  return {
    flatItems: k(() => {
      if (!t.value.length) return e.value
      const r = VN(
        e.value,
        t.value.map((s) => s.key)
      )
      return DN(r, n.value)
    }),
  }
}
function Ym(e) {
  let { page: t, itemsPerPage: n, sortBy: i, groupBy: r, search: s } = e
  const o = Ut('VDataTable'),
    a = k(() => ({ page: t.value, itemsPerPage: n.value, sortBy: i.value, groupBy: r.value, search: s.value }))
  let l = null
  be(
    a,
    () => {
      vr(l, a.value) ||
        (l && l.search !== a.value.search && (t.value = 1), o.emit('update:options', a.value), (l = a.value))
    },
    { deep: !0, immediate: !0 }
  )
}
const lw = W(
    { page: { type: [Number, String], default: 1 }, itemsPerPage: { type: [Number, String], default: 10 } },
    'DataTable-paginate'
  ),
  NN = Symbol.for('vuetify:data-table-pagination')
function uw(e) {
  const t = xe(e, 'page', void 0, (i) => +(i ?? 1)),
    n = xe(e, 'itemsPerPage', void 0, (i) => +(i ?? 10))
  return { page: t, itemsPerPage: n }
}
function cw(e) {
  const { page: t, itemsPerPage: n, itemsLength: i } = e,
    r = k(() => (n.value === -1 ? 0 : n.value * (t.value - 1))),
    s = k(() => (n.value === -1 ? i.value : Math.min(i.value, r.value + n.value))),
    o = k(() => (n.value === -1 || i.value === 0 ? 1 : Math.ceil(i.value / n.value)))
  $t(() => {
    t.value > o.value && (t.value = o.value)
  })
  function a(f) {
    ;(n.value = f), (t.value = 1)
  }
  function l() {
    t.value = qt(t.value + 1, 1, o.value)
  }
  function u() {
    t.value = qt(t.value - 1, 1, o.value)
  }
  function c(f) {
    t.value = qt(f, 1, o.value)
  }
  const d = {
    page: t,
    itemsPerPage: n,
    startIndex: r,
    stopIndex: s,
    pageCount: o,
    itemsLength: i,
    nextPage: l,
    prevPage: u,
    setPage: c,
    setItemsPerPage: a,
  }
  return mt(NN, d), d
}
function yX() {
  const e = je(NN)
  if (!e) throw new Error('Missing pagination!')
  return e
}
function ON(e) {
  const t = Ut('usePaginatedItems'),
    { items: n, startIndex: i, stopIndex: r, itemsPerPage: s } = e,
    o = k(() => (s.value <= 0 ? n.value : n.value.slice(i.value, r.value)))
  return (
    be(o, (a) => {
      t.emit('update:currentItems', a)
    }),
    { paginatedItems: o }
  )
}
const _X = {
    showSelectAll: !1,
    allSelected: () => [],
    select: (e) => {
      var i
      let { items: t, value: n } = e
      return new Set(n ? [(i = t[0]) == null ? void 0 : i.value] : [])
    },
    selectAll: (e) => {
      let { selected: t } = e
      return t
    },
  },
  MN = {
    showSelectAll: !0,
    allSelected: (e) => {
      let { currentPage: t } = e
      return t
    },
    select: (e) => {
      let { items: t, value: n, selected: i } = e
      for (const r of t) n ? i.add(r.value) : i.delete(r.value)
      return i
    },
    selectAll: (e) => {
      let { value: t, currentPage: n, selected: i } = e
      return MN.select({ items: n, value: t, selected: i })
    },
  },
  LN = {
    showSelectAll: !0,
    allSelected: (e) => {
      let { allItems: t } = e
      return t
    },
    select: (e) => {
      let { items: t, value: n, selected: i } = e
      for (const r of t) n ? i.add(r.value) : i.delete(r.value)
      return i
    },
    selectAll: (e) => {
      let { value: t, allItems: n, selected: i } = e
      return LN.select({ items: n, value: t, selected: i })
    },
  },
  FN = W(
    {
      showSelect: Boolean,
      selectStrategy: { type: [String, Object], default: 'page' },
      modelValue: { type: Array, default: () => [] },
      valueComparator: { type: Function, default: vr },
    },
    'DataTable-select'
  ),
  BN = Symbol.for('vuetify:data-table-selection')
function Qm(e, t) {
  let { allItems: n, currentPage: i } = t
  const r = xe(
      e,
      'modelValue',
      e.modelValue,
      (T) =>
        new Set(
          Pt(T).map((A) => {
            var x
            return ((x = n.value.find((N) => e.valueComparator(A, N.value))) == null ? void 0 : x.value) ?? A
          })
        ),
      (T) => [...T.values()]
    ),
    s = k(() => n.value.filter((T) => T.selectable)),
    o = k(() => i.value.filter((T) => T.selectable)),
    a = k(() => {
      if (typeof e.selectStrategy == 'object') return e.selectStrategy
      switch (e.selectStrategy) {
        case 'single':
          return _X
        case 'all':
          return LN
        case 'page':
        default:
          return MN
      }
    })
  function l(T) {
    return Pt(T).every((A) => r.value.has(A.value))
  }
  function u(T) {
    return Pt(T).some((A) => r.value.has(A.value))
  }
  function c(T, A) {
    const x = a.value.select({ items: T, value: A, selected: new Set(r.value) })
    r.value = x
  }
  function d(T) {
    c([T], !l([T]))
  }
  function f(T) {
    const A = a.value.selectAll({ value: T, allItems: s.value, currentPage: o.value, selected: new Set(r.value) })
    r.value = A
  }
  const m = k(() => r.value.size > 0),
    p = k(() => {
      const T = a.value.allSelected({ allItems: s.value, currentPage: o.value })
      return !!T.length && l(T)
    }),
    v = k(() => a.value.showSelectAll),
    y = {
      toggleSelect: d,
      select: c,
      selectAll: f,
      isSelected: l,
      isSomeSelected: u,
      someSelected: m,
      allSelected: p,
      showSelectAll: v,
    }
  return mt(BN, y), y
}
function Xm() {
  const e = je(BN)
  if (!e) throw new Error('Missing selection!')
  return e
}
const $N = W(
    { sortBy: { type: Array, default: () => [] }, customKeySort: Object, multiSort: Boolean, mustSort: Boolean },
    'DataTable-sort'
  ),
  UN = Symbol.for('vuetify:data-table-sort')
function Jm(e) {
  const t = xe(e, 'sortBy'),
    n = Q(e, 'mustSort'),
    i = Q(e, 'multiSort')
  return { sortBy: t, mustSort: n, multiSort: i }
}
function Zm(e) {
  const { sortBy: t, mustSort: n, multiSort: i, page: r } = e,
    s = (l) => {
      if (l.key == null) return
      let u = t.value.map((d) => ({ ...d })) ?? []
      const c = u.find((d) => d.key === l.key)
      c
        ? c.order === 'desc'
          ? n.value
            ? (c.order = 'asc')
            : (u = u.filter((d) => d.key !== l.key))
          : (c.order = 'desc')
        : i.value
        ? (u = [...u, { key: l.key, order: 'asc' }])
        : (u = [{ key: l.key, order: 'asc' }]),
        (t.value = u),
        r && (r.value = 1)
    }
  function o(l) {
    return !!t.value.find((u) => u.key === l.key)
  }
  const a = { sortBy: t, toggleSort: s, isSorted: o }
  return mt(UN, a), a
}
function jN() {
  const e = je(UN)
  if (!e) throw new Error('Missing sort!')
  return e
}
function dw(e, t, n, i) {
  const r = jt()
  return {
    sortedItems: k(() => {
      var o, a
      return n.value.length
        ? bX(t.value, n.value, r.current.value, {
            transform: i == null ? void 0 : i.transform,
            sortFunctions: {
              ...e.customKeySort,
              ...((o = i == null ? void 0 : i.sortFunctions) == null ? void 0 : o.value),
            },
            sortRawFunctions: (a = i == null ? void 0 : i.sortRawFunctions) == null ? void 0 : a.value,
          })
        : t.value
    }),
  }
}
function bX(e, t, n, i) {
  const r = new Intl.Collator(n, { sensitivity: 'accent', usage: 'sort' })
  return e
    .map((o) => [o, i != null && i.transform ? i.transform(o) : o])
    .sort((o, a) => {
      var l, u
      for (let c = 0; c < t.length; c++) {
        let d = !1
        const f = t[c].key,
          m = t[c].order ?? 'asc'
        if (m === !1) continue
        let p = Go(o[1], f),
          v = Go(a[1], f),
          y = o[0].raw,
          T = a[0].raw
        if (
          (m === 'desc' && (([p, v] = [v, p]), ([y, T] = [T, y])),
          (l = i == null ? void 0 : i.sortRawFunctions) != null && l[f])
        ) {
          const A = i.sortRawFunctions[f](y, T)
          if (A == null) continue
          if (((d = !0), A)) return A
        }
        if ((u = i == null ? void 0 : i.sortFunctions) != null && u[f]) {
          const A = i.sortFunctions[f](p, v)
          if (A == null) continue
          if (((d = !0), A)) return A
        }
        if (!d) {
          if (p instanceof Date && v instanceof Date) return p.getTime() - v.getTime()
          if ((([p, v] = [p, v].map((A) => (A != null ? A.toString().toLocaleLowerCase() : A))), p !== v))
            return ah(p) && ah(v)
              ? 0
              : ah(p)
              ? -1
              : ah(v)
              ? 1
              : !isNaN(p) && !isNaN(v)
              ? Number(p) - Number(v)
              : r.compare(p, v)
        }
      }
      return 0
    })
    .map((o) => {
      let [a] = o
      return a
    })
}
const wX = W(
  {
    items: { type: Array, default: () => [] },
    itemValue: { type: [String, Array, Function], default: 'id' },
    itemSelectable: { type: [String, Array, Function], default: null },
    returnObject: Boolean,
  },
  'DataIterator-items'
)
function IX(e, t) {
  const n = e.returnObject ? t : Jt(t, e.itemValue),
    i = Jt(t, e.itemSelectable, !0)
  return { type: 'item', value: n, selectable: i, raw: t }
}
function SX(e, t) {
  const n = []
  for (const i of t) n.push(IX(e, i))
  return n
}
function EX(e) {
  return { items: k(() => SX(e, e.items)) }
}
const TX = W(
    {
      search: String,
      loading: Boolean,
      ...Te(),
      ...wX(),
      ...FN(),
      ...$N(),
      ...lw({ itemsPerPage: 5 }),
      ...AN(),
      ...ow(),
      ...pd(),
      ...He(),
      ...Xi({ transition: { component: kc, hideOnLeave: !0 } }),
    },
    'VDataIterator'
  ),
  CX = ne()({
    name: 'VDataIterator',
    props: TX(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:groupBy': (e) => !0,
      'update:page': (e) => !0,
      'update:itemsPerPage': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:expanded': (e) => !0,
      'update:currentItems': (e) => !0,
    },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'groupBy'),
        r = Q(e, 'search'),
        { items: s } = EX(e),
        { filteredItems: o } = yd(e, s, r, { transform: (q) => q.raw }),
        { sortBy: a, multiSort: l, mustSort: u } = Jm(e),
        { page: c, itemsPerPage: d } = uw(e),
        { toggleSort: f } = Zm({ sortBy: a, multiSort: l, mustSort: u, page: c }),
        {
          sortByWithGroups: m,
          opened: p,
          extractRows: v,
          isGroupOpen: y,
          toggleGroup: T,
        } = Gm({ groupBy: i, sortBy: a }),
        { sortedItems: A } = dw(e, o, m, { transform: (q) => q.raw }),
        { flatItems: x } = Km(A, i, p),
        N = k(() => x.value.length),
        {
          startIndex: V,
          stopIndex: D,
          pageCount: I,
          prevPage: w,
          nextPage: _,
          setItemsPerPage: S,
          setPage: E,
        } = cw({ page: c, itemsPerPage: d, itemsLength: N }),
        { paginatedItems: C } = ON({ items: x, startIndex: V, stopIndex: D, itemsPerPage: d }),
        R = k(() => v(C.value)),
        { isSelected: B, select: U, selectAll: $, toggleSelect: G } = Qm(e, { allItems: s, currentPage: R }),
        { isExpanded: F, toggleExpand: K } = qm(e)
      Ym({ page: c, itemsPerPage: d, sortBy: a, groupBy: i, search: r })
      const j = k(() => ({
        page: c.value,
        itemsPerPage: d.value,
        sortBy: a.value,
        pageCount: I.value,
        toggleSort: f,
        prevPage: w,
        nextPage: _,
        setPage: E,
        setItemsPerPage: S,
        isSelected: B,
        select: U,
        selectAll: $,
        toggleSelect: G,
        isExpanded: F,
        toggleExpand: K,
        isGroupOpen: y,
        toggleGroup: T,
        items: R.value,
        groupedItems: C.value,
      }))
      return (
        se(() =>
          g(
            e.tag,
            { class: ['v-data-iterator', { 'v-data-iterator--loading': e.loading }, e.class], style: e.style },
            {
              default: () => {
                var q, te
                return [
                  (q = n.header) == null ? void 0 : q.call(n, j.value),
                  g(
                    Bn,
                    { transition: e.transition },
                    {
                      default: () => {
                        var ce, Ee
                        return [
                          e.loading
                            ? g(
                                cd,
                                { key: 'loader', name: 'v-data-iterator', active: !0 },
                                {
                                  default: (me) => {
                                    var oe
                                    return (oe = n.loader) == null ? void 0 : oe.call(n, me)
                                  },
                                }
                              )
                            : g('div', { key: 'items' }, [
                                C.value.length
                                  ? (Ee = n.default) == null
                                    ? void 0
                                    : Ee.call(n, j.value)
                                  : (ce = n['no-data']) == null
                                  ? void 0
                                  : ce.call(n),
                              ]),
                        ]
                      },
                    }
                  ),
                  (te = n.footer) == null ? void 0 : te.call(n, j.value),
                ]
              },
            }
          )
        ),
        {}
      )
    },
  })
function AX() {
  const e = le([])
  cA(() => (e.value = []))
  function t(n, i) {
    e.value[i] = n
  }
  return { refs: e, updateRef: t }
}
const kX = W(
    {
      activeColor: String,
      start: { type: [Number, String], default: 1 },
      modelValue: { type: Number, default: (e) => e.start },
      disabled: Boolean,
      length: { type: [Number, String], default: 1, validator: (e) => e % 1 === 0 },
      totalVisible: [Number, String],
      firstIcon: { type: Le, default: '$first' },
      prevIcon: { type: Le, default: '$prev' },
      nextIcon: { type: Le, default: '$next' },
      lastIcon: { type: Le, default: '$last' },
      ariaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.root' },
      pageAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.page' },
      currentPageAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.currentPage' },
      firstAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.first' },
      previousAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.previous' },
      nextAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.next' },
      lastAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.last' },
      ellipsis: { type: String, default: '...' },
      showFirstLastPage: Boolean,
      ...bi(),
      ...Te(),
      ...ln(),
      ...en(),
      ...Tt(),
      ..._r(),
      ...He({ tag: 'nav' }),
      ...Ze(),
      ...Mi({ variant: 'text' }),
    },
    'VPagination'
  ),
  oy = ne()({
    name: 'VPagination',
    props: kX(),
    emits: { 'update:modelValue': (e) => !0, first: (e) => !0, prev: (e) => !0, next: (e) => !0, last: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const r = xe(e, 'modelValue'),
        { t: s, n: o } = jt(),
        { isRtl: a } = sn(),
        { themeClasses: l } = at(e),
        { width: u } = Ni(),
        c = ye(-1)
      Ot(void 0, { scoped: !0 })
      const { resizeRef: d } = Gi((w) => {
          if (!w.length) return
          const { target: _, contentRect: S } = w[0],
            E = _.querySelector('.v-pagination__list > *')
          if (!E) return
          const C = S.width,
            R = E.offsetWidth + parseFloat(getComputedStyle(E).marginRight) * 2
          c.value = v(C, R)
        }),
        f = k(() => parseInt(e.length, 10)),
        m = k(() => parseInt(e.start, 10)),
        p = k(() => (e.totalVisible != null ? parseInt(e.totalVisible, 10) : c.value >= 0 ? c.value : v(u.value, 58)))
      function v(w, _) {
        const S = e.showFirstLastPage ? 5 : 3
        return Math.max(0, Math.floor(+((w - _ * S) / _).toFixed(2)))
      }
      const y = k(() => {
        if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER) return []
        if (p.value <= 0) return []
        if (p.value === 1) return [r.value]
        if (f.value <= p.value) return ar(f.value, m.value)
        const w = p.value % 2 === 0,
          _ = w ? p.value / 2 : Math.floor(p.value / 2),
          S = w ? _ : _ + 1,
          E = f.value - _
        if (S - r.value >= 0) return [...ar(Math.max(1, p.value - 1), m.value), e.ellipsis, f.value]
        if (r.value - E >= (w ? 1 : 0)) {
          const C = p.value - 1,
            R = f.value - C + m.value
          return [m.value, e.ellipsis, ...ar(C, R)]
        } else {
          const C = Math.max(1, p.value - 3),
            R = C === 1 ? r.value : r.value - Math.ceil(C / 2) + m.value
          return [m.value, e.ellipsis, ...ar(C, R), e.ellipsis, f.value]
        }
      })
      function T(w, _, S) {
        w.preventDefault(), (r.value = _), S && i(S, _)
      }
      const { refs: A, updateRef: x } = AX()
      Ot({
        VPaginationBtn: {
          color: Q(e, 'color'),
          border: Q(e, 'border'),
          density: Q(e, 'density'),
          size: Q(e, 'size'),
          variant: Q(e, 'variant'),
          rounded: Q(e, 'rounded'),
          elevation: Q(e, 'elevation'),
        },
      })
      const N = k(() =>
          y.value.map((w, _) => {
            const S = (E) => x(E, _)
            if (typeof w == 'string')
              return {
                isActive: !1,
                key: `ellipsis-${_}`,
                page: w,
                props: { ref: S, ellipsis: !0, icon: !0, disabled: !0 },
              }
            {
              const E = w === r.value
              return {
                isActive: E,
                key: w,
                page: o(w),
                props: {
                  ref: S,
                  ellipsis: !1,
                  icon: !0,
                  disabled: !!e.disabled || +e.length < 2,
                  color: E ? e.activeColor : e.color,
                  'aria-current': E,
                  'aria-label': s(E ? e.currentPageAriaLabel : e.pageAriaLabel, w),
                  onClick: (C) => T(C, w),
                },
              }
            }
          })
        ),
        V = k(() => {
          const w = !!e.disabled || r.value <= m.value,
            _ = !!e.disabled || r.value >= m.value + f.value - 1
          return {
            first: e.showFirstLastPage
              ? {
                  icon: a.value ? e.lastIcon : e.firstIcon,
                  onClick: (S) => T(S, m.value, 'first'),
                  disabled: w,
                  'aria-label': s(e.firstAriaLabel),
                  'aria-disabled': w,
                }
              : void 0,
            prev: {
              icon: a.value ? e.nextIcon : e.prevIcon,
              onClick: (S) => T(S, r.value - 1, 'prev'),
              disabled: w,
              'aria-label': s(e.previousAriaLabel),
              'aria-disabled': w,
            },
            next: {
              icon: a.value ? e.prevIcon : e.nextIcon,
              onClick: (S) => T(S, r.value + 1, 'next'),
              disabled: _,
              'aria-label': s(e.nextAriaLabel),
              'aria-disabled': _,
            },
            last: e.showFirstLastPage
              ? {
                  icon: a.value ? e.firstIcon : e.lastIcon,
                  onClick: (S) => T(S, m.value + f.value - 1, 'last'),
                  disabled: _,
                  'aria-label': s(e.lastAriaLabel),
                  'aria-disabled': _,
                }
              : void 0,
          }
        })
      function D() {
        var _
        const w = r.value - m.value
        ;(_ = A.value[w]) == null || _.$el.focus()
      }
      function I(w) {
        w.key === Np.left && !e.disabled && r.value > +e.start
          ? ((r.value = r.value - 1), Xe(D))
          : w.key === Np.right && !e.disabled && r.value < m.value + f.value - 1 && ((r.value = r.value + 1), Xe(D))
      }
      return (
        se(() =>
          g(
            e.tag,
            {
              ref: d,
              class: ['v-pagination', l.value, e.class],
              style: e.style,
              role: 'navigation',
              'aria-label': s(e.ariaLabel),
              onKeydown: I,
              'data-test': 'v-pagination-root',
            },
            {
              default: () => [
                g('ul', { class: 'v-pagination__list' }, [
                  e.showFirstLastPage &&
                    g('li', { key: 'first', class: 'v-pagination__first', 'data-test': 'v-pagination-first' }, [
                      n.first ? n.first(V.value.first) : g(st, ae({ _as: 'VPaginationBtn' }, V.value.first), null),
                    ]),
                  g('li', { key: 'prev', class: 'v-pagination__prev', 'data-test': 'v-pagination-prev' }, [
                    n.prev ? n.prev(V.value.prev) : g(st, ae({ _as: 'VPaginationBtn' }, V.value.prev), null),
                  ]),
                  N.value.map((w, _) =>
                    g(
                      'li',
                      {
                        key: w.key,
                        class: ['v-pagination__item', { 'v-pagination__item--is-active': w.isActive }],
                        'data-test': 'v-pagination-item',
                      },
                      [n.item ? n.item(w) : g(st, ae({ _as: 'VPaginationBtn' }, w.props), { default: () => [w.page] })]
                    )
                  ),
                  g('li', { key: 'next', class: 'v-pagination__next', 'data-test': 'v-pagination-next' }, [
                    n.next ? n.next(V.value.next) : g(st, ae({ _as: 'VPaginationBtn' }, V.value.next), null),
                  ]),
                  e.showFirstLastPage &&
                    g('li', { key: 'last', class: 'v-pagination__last', 'data-test': 'v-pagination-last' }, [
                      n.last ? n.last(V.value.last) : g(st, ae({ _as: 'VPaginationBtn' }, V.value.last), null),
                    ]),
                ]),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  hw = W(
    {
      prevIcon: { type: Le, default: '$prev' },
      nextIcon: { type: Le, default: '$next' },
      firstIcon: { type: Le, default: '$first' },
      lastIcon: { type: Le, default: '$last' },
      itemsPerPageText: { type: String, default: '$vuetify.dataFooter.itemsPerPageText' },
      pageText: { type: String, default: '$vuetify.dataFooter.pageText' },
      firstPageLabel: { type: String, default: '$vuetify.dataFooter.firstPage' },
      prevPageLabel: { type: String, default: '$vuetify.dataFooter.prevPage' },
      nextPageLabel: { type: String, default: '$vuetify.dataFooter.nextPage' },
      lastPageLabel: { type: String, default: '$vuetify.dataFooter.lastPage' },
      itemsPerPageOptions: {
        type: Array,
        default: () => [
          { value: 10, title: '10' },
          { value: 25, title: '25' },
          { value: 50, title: '50' },
          { value: 100, title: '100' },
          { value: -1, title: '$vuetify.dataFooter.itemsPerPageAll' },
        ],
      },
      showCurrentPage: Boolean,
    },
    'VDataTableFooter'
  ),
  Nc = ne()({
    name: 'VDataTableFooter',
    props: hw(),
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = jt(),
        {
          page: r,
          pageCount: s,
          startIndex: o,
          stopIndex: a,
          itemsLength: l,
          itemsPerPage: u,
          setItemsPerPage: c,
        } = yX(),
        d = k(() =>
          e.itemsPerPageOptions.map((f) =>
            typeof f == 'number'
              ? { value: f, title: f === -1 ? i('$vuetify.dataFooter.itemsPerPageAll') : String(f) }
              : { ...f, title: isNaN(Number(f.title)) ? i(f.title) : f.title }
          )
        )
      return (
        se(() => {
          var m
          const f = oy.filterProps(e)
          return g('div', { class: 'v-data-table-footer' }, [
            (m = n.prepend) == null ? void 0 : m.call(n),
            g('div', { class: 'v-data-table-footer__items-per-page' }, [
              g('span', null, [i(e.itemsPerPageText)]),
              g(
                iw,
                {
                  items: d.value,
                  modelValue: u.value,
                  'onUpdate:modelValue': (p) => c(Number(p)),
                  density: 'compact',
                  variant: 'outlined',
                  'hide-details': !0,
                },
                null
              ),
            ]),
            g('div', { class: 'v-data-table-footer__info' }, [
              g('div', null, [i(e.pageText, l.value ? o.value + 1 : 0, a.value, l.value)]),
            ]),
            g('div', { class: 'v-data-table-footer__pagination' }, [
              g(
                oy,
                ae(
                  {
                    modelValue: r.value,
                    'onUpdate:modelValue': (p) => (r.value = p),
                    density: 'comfortable',
                    'first-aria-label': e.firstPageLabel,
                    'last-aria-label': e.lastPageLabel,
                    length: s.value,
                    'next-aria-label': e.nextPageLabel,
                    'previous-aria-label': e.prevPageLabel,
                    rounded: !0,
                    'show-first-last-page': !0,
                    'total-visible': e.showCurrentPage ? 1 : 0,
                    variant: 'plain',
                  },
                  f
                ),
                null
              ),
            ]),
          ])
        }),
        {}
      )
    },
  }),
  Af = yK(
    {
      align: { type: String, default: 'start' },
      fixed: Boolean,
      fixedOffset: [Number, String],
      height: [Number, String],
      lastFixed: Boolean,
      noPadding: Boolean,
      tag: String,
      width: [Number, String],
      maxWidth: [Number, String],
      nowrap: Boolean,
    },
    (e, t) => {
      let { slots: n } = t
      const i = e.tag ?? 'td'
      return g(
        i,
        {
          class: [
            'v-data-table__td',
            {
              'v-data-table-column--fixed': e.fixed,
              'v-data-table-column--last-fixed': e.lastFixed,
              'v-data-table-column--no-padding': e.noPadding,
              'v-data-table-column--nowrap': e.nowrap,
            },
            `v-data-table-column--align-${e.align}`,
          ],
          style: {
            height: Se(e.height),
            width: Se(e.width),
            maxWidth: Se(e.maxWidth),
            left: Se(e.fixedOffset || null),
          },
        },
        {
          default: () => {
            var r
            return [(r = n.default) == null ? void 0 : r.call(n)]
          },
        }
      )
    }
  ),
  PX = W({ headers: Array }, 'DataTable-header'),
  zN = Symbol.for('vuetify:data-table-headers'),
  HN = { title: '', sortable: !1 },
  RX = { ...HN, width: 48 }
function xX() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map((n) => ({
    element: n,
    priority: 0,
  }))
  return {
    enqueue: (n, i) => {
      let r = !1
      for (let s = 0; s < t.length; s++)
        if (t[s].priority > i) {
          t.splice(s, 0, { element: n, priority: i }), (r = !0)
          break
        }
      r || t.push({ element: n, priority: i })
    },
    size: () => t.length,
    count: () => {
      let n = 0
      if (!t.length) return 0
      const i = Math.floor(t[0].priority)
      for (let r = 0; r < t.length; r++) Math.floor(t[r].priority) === i && (n += 1)
      return n
    },
    dequeue: () => t.shift(),
  }
}
function ay(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
  if (!e.children) t.push(e)
  else for (const n of e.children) ay(n, t)
  return t
}
function WN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set()
  for (const n of e) n.key && t.add(n.key), n.children && WN(n.children, t)
  return t
}
function VX(e) {
  if (e.key) {
    if (e.key === 'data-table-group') return HN
    if (['data-table-expand', 'data-table-select'].includes(e.key)) return RX
  }
}
function fw(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
  return e.children ? Math.max(t, ...e.children.map((n) => fw(n, t + 1))) : t
}
function DX(e) {
  let t = !1
  function n(s) {
    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
    if (s)
      if ((o && (s.fixed = !0), s.fixed))
        if (s.children) for (let a = s.children.length - 1; a >= 0; a--) n(s.children[a], !0)
        else t ? isNaN(+s.width) && (`${s.key}`, void 0) : (s.lastFixed = !0), (t = !0)
      else if (s.children) for (let a = s.children.length - 1; a >= 0; a--) n(s.children[a])
      else t = !1
  }
  for (let s = e.length - 1; s >= 0; s--) n(e[s])
  function i(s) {
    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
    if (!s) return o
    if (s.children) {
      s.fixedOffset = o
      for (const a of s.children) o = i(a, o)
    } else s.fixed && ((s.fixedOffset = o), (o += parseFloat(s.width || '0') || 0))
    return o
  }
  let r = 0
  for (const s of e) r = i(s, r)
}
function NX(e, t) {
  const n = []
  let i = 0
  const r = xX(e)
  for (; r.size() > 0; ) {
    let o = r.count()
    const a = []
    let l = 1
    for (; o > 0; ) {
      const { element: u, priority: c } = r.dequeue(),
        d = t - i - fw(u)
      if ((a.push({ ...u, rowspan: d ?? 1, colspan: u.children ? ay(u).length : 1 }), u.children))
        for (const f of u.children) {
          const m = (c % 1) + l / Math.pow(10, i + 2)
          r.enqueue(f, i + d + m)
        }
      ;(l += 1), (o -= 1)
    }
    ;(i += 1), n.push(a)
  }
  return { columns: e.map((o) => ay(o)).flat(), headers: n }
}
function qN(e) {
  const t = []
  for (const n of e) {
    const i = { ...VX(n), ...n },
      r = i.key ?? (typeof i.value == 'string' ? i.value : null),
      s = i.value ?? r ?? null,
      o = {
        ...i,
        key: r,
        value: s,
        sortable: i.sortable ?? (i.key != null || !!i.sort),
        children: i.children ? qN(i.children) : void 0,
      }
    t.push(o)
  }
  return t
}
function mw(e, t) {
  const n = le([]),
    i = le([]),
    r = le({}),
    s = le({}),
    o = le({})
  $t(() => {
    var v, y, T
    const u = (e.headers || Object.keys(e.items[0] ?? {}).map((A) => ({ key: A, title: gr(A) }))).slice(),
      c = WN(u)
    ;(v = t == null ? void 0 : t.groupBy) != null &&
      v.value.length &&
      !c.has('data-table-group') &&
      u.unshift({ key: 'data-table-group', title: 'Group' }),
      (y = t == null ? void 0 : t.showSelect) != null &&
        y.value &&
        !c.has('data-table-select') &&
        u.unshift({ key: 'data-table-select' }),
      (T = t == null ? void 0 : t.showExpand) != null &&
        T.value &&
        !c.has('data-table-expand') &&
        u.push({ key: 'data-table-expand' })
    const d = qN(u)
    DX(d)
    const f = Math.max(...d.map((A) => fw(A))) + 1,
      m = NX(d, f)
    ;(n.value = m.headers), (i.value = m.columns)
    const p = m.headers.flat(1)
    for (const A of p)
      A.key &&
        (A.sortable && (A.sort && (r.value[A.key] = A.sort), A.sortRaw && (s.value[A.key] = A.sortRaw)),
        A.filter && (o.value[A.key] = A.filter))
  })
  const a = { headers: n, columns: i, sortFunctions: r, sortRawFunctions: s, filterFunctions: o }
  return mt(zN, a), a
}
function eg() {
  const e = je(zN)
  if (!e) throw new Error('Missing headers!')
  return e
}
const GN = W(
    {
      color: String,
      sticky: Boolean,
      disableSort: Boolean,
      multiSort: Boolean,
      sortAscIcon: { type: Le, default: '$sortAsc' },
      sortDescIcon: { type: Le, default: '$sortDesc' },
      headerProps: { type: Object },
      ...ca(),
      ...Om(),
    },
    'VDataTableHeaders'
  ),
  Jo = ne()({
    name: 'VDataTableHeaders',
    props: GN(),
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = jt(),
        { toggleSort: r, sortBy: s, isSorted: o } = jN(),
        { someSelected: a, allSelected: l, selectAll: u, showSelectAll: c } = Xm(),
        { columns: d, headers: f } = eg(),
        { loaderClasses: m } = ud(e)
      function p(w, _) {
        if (!(!e.sticky && !w.fixed))
          return {
            position: 'sticky',
            left: w.fixed ? Se(w.fixedOffset) : void 0,
            top: e.sticky ? `calc(var(--v-table-header-height) * ${_})` : void 0,
          }
      }
      function v(w) {
        const _ = s.value.find((S) => S.key === w.key)
        return _ ? (_.order === 'asc' ? e.sortAscIcon : e.sortDescIcon) : e.sortAscIcon
      }
      const { backgroundColorClasses: y, backgroundColorStyles: T } = gt(e, 'color'),
        { displayClasses: A, mobile: x } = Ni(e),
        N = k(() => ({
          headers: f.value,
          columns: d.value,
          toggleSort: r,
          isSorted: o,
          sortBy: s.value,
          someSelected: a.value,
          allSelected: l.value,
          selectAll: u,
          getSortIcon: v,
        })),
        V = k(() => ['v-data-table__th', { 'v-data-table__th--sticky': e.sticky }, A.value, m.value]),
        D = (w) => {
          let { column: _, x: S, y: E } = w
          const C = _.key === 'data-table-select' || _.key === 'data-table-expand',
            R = ae(e.headerProps ?? {}, _.headerProps ?? {})
          return g(
            Af,
            ae(
              {
                tag: 'th',
                align: _.align,
                class: [
                  {
                    'v-data-table__th--sortable': _.sortable && !e.disableSort,
                    'v-data-table__th--sorted': o(_),
                    'v-data-table__th--fixed': _.fixed,
                  },
                  ...V.value,
                ],
                style: { width: Se(_.width), minWidth: Se(_.minWidth), maxWidth: Se(_.maxWidth), ...p(_, E) },
                colspan: _.colspan,
                rowspan: _.rowspan,
                onClick: _.sortable ? () => r(_) : void 0,
                fixed: _.fixed,
                nowrap: _.nowrap,
                lastFixed: _.lastFixed,
                noPadding: C,
              },
              R
            ),
            {
              default: () => {
                var $
                const B = `header.${_.key}`,
                  U = {
                    column: _,
                    selectAll: u,
                    isSorted: o,
                    toggleSort: r,
                    sortBy: s.value,
                    someSelected: a.value,
                    allSelected: l.value,
                    getSortIcon: v,
                  }
                return n[B]
                  ? n[B](U)
                  : _.key === 'data-table-select'
                  ? (($ = n['header.data-table-select']) == null ? void 0 : $.call(n, U)) ??
                    (c.value &&
                      g(
                        $r,
                        { modelValue: l.value, indeterminate: a.value && !l.value, 'onUpdate:modelValue': u },
                        null
                      ))
                  : g('div', { class: 'v-data-table-header__content' }, [
                      g('span', null, [_.title]),
                      _.sortable &&
                        !e.disableSort &&
                        g(ot, { key: 'icon', class: 'v-data-table-header__sort-icon', icon: v(_) }, null),
                      e.multiSort &&
                        o(_) &&
                        g(
                          'div',
                          { key: 'badge', class: ['v-data-table-header__sort-badge', ...y.value], style: T.value },
                          [s.value.findIndex((G) => G.key === _.key) + 1]
                        ),
                    ])
              },
            }
          )
        },
        I = () => {
          const w = ae(e.headerProps ?? {} ?? {}),
            _ = k(() => d.value.filter((E) => (E == null ? void 0 : E.sortable) && !e.disableSort)),
            S = k(() => {
              if (d.value.find((C) => C.key === 'data-table-select') != null)
                return l.value ? '$checkboxOn' : a.value ? '$checkboxIndeterminate' : '$checkboxOff'
            })
          return g(Af, ae({ tag: 'th', class: [...V.value], colspan: f.value.length + 1 }, w), {
            default: () => [
              g('div', { class: 'v-data-table-header__content' }, [
                g(
                  iw,
                  {
                    chips: !0,
                    class: 'v-data-table__td-sort-select',
                    clearable: !0,
                    density: 'default',
                    items: _.value,
                    label: i('$vuetify.dataTable.sortBy'),
                    multiple: e.multiSort,
                    variant: 'underlined',
                    'onClick:clear': () => (s.value = []),
                    appendIcon: S.value,
                    'onClick:append': () => u(!l.value),
                  },
                  {
                    ...n,
                    chip: (E) => {
                      var C
                      return g(
                        Yl,
                        {
                          onClick: (C = E.item.raw) != null && C.sortable ? () => r(E.item.raw) : void 0,
                          onMousedown: (R) => {
                            R.preventDefault(), R.stopPropagation()
                          },
                        },
                        {
                          default: () => [
                            E.item.title,
                            g(
                              ot,
                              {
                                class: [
                                  'v-data-table__td-sort-icon',
                                  o(E.item.raw) && 'v-data-table__td-sort-icon-active',
                                ],
                                icon: v(E.item.raw),
                                size: 'small',
                              },
                              null
                            ),
                          ],
                        }
                      )
                    },
                  }
                ),
              ]),
            ],
          })
        }
      se(() =>
        x.value
          ? g('tr', null, [g(I, null, null)])
          : g(ke, null, [
              n.headers
                ? n.headers(N.value)
                : f.value.map((w, _) => g('tr', null, [w.map((S, E) => g(D, { column: S, x: E, y: _ }, null))])),
              e.loading &&
                g('tr', { class: 'v-data-table-progress' }, [
                  g('th', { colspan: d.value.length }, [
                    g(
                      cd,
                      {
                        name: 'v-data-table-progress',
                        absolute: !0,
                        active: !0,
                        color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                        indeterminate: !0,
                      },
                      { default: n.loader }
                    ),
                  ]),
                ]),
            ])
      )
    },
  }),
  OX = W({ item: { type: Object, required: !0 } }, 'VDataTableGroupHeaderRow'),
  MX = ne()({
    name: 'VDataTableGroupHeaderRow',
    props: OX(),
    setup(e, t) {
      let { slots: n } = t
      const { isGroupOpen: i, toggleGroup: r, extractRows: s } = xN(),
        { isSelected: o, isSomeSelected: a, select: l } = Xm(),
        { columns: u } = eg(),
        c = k(() => s([e.item]))
      return () =>
        g(
          'tr',
          { class: 'v-data-table-group-header-row', style: { '--v-data-table-group-header-row-depth': e.item.depth } },
          [
            u.value.map((d) => {
              var f, m
              if (d.key === 'data-table-group') {
                const p = i(e.item) ? '$expand' : '$next',
                  v = () => r(e.item)
                return (
                  ((f = n['data-table-group']) == null
                    ? void 0
                    : f.call(n, { item: e.item, count: c.value.length, props: { icon: p, onClick: v } })) ??
                  g(
                    Af,
                    { class: 'v-data-table-group-header-row__column' },
                    {
                      default: () => [
                        g(st, { size: 'small', variant: 'text', icon: p, onClick: v }, null),
                        g('span', null, [e.item.value]),
                        g('span', null, [Or('('), c.value.length, Or(')')]),
                      ],
                    }
                  )
                )
              }
              if (d.key === 'data-table-select') {
                const p = o(c.value),
                  v = a(c.value) && !p,
                  y = (T) => l(c.value, T)
                return (
                  ((m = n['data-table-select']) == null
                    ? void 0
                    : m.call(n, { props: { modelValue: p, indeterminate: v, 'onUpdate:modelValue': y } })) ??
                  g('td', null, [g($r, { modelValue: p, indeterminate: v, 'onUpdate:modelValue': y }, null)])
                )
              }
              return g('td', null, null)
            }),
          ]
        )
    },
  }),
  LX = W(
    {
      index: Number,
      item: Object,
      cellProps: [Object, Function],
      onClick: mn(),
      onContextmenu: mn(),
      onDblclick: mn(),
      ...ca(),
    },
    'VDataTableRow'
  ),
  gw = ne()({
    name: 'VDataTableRow',
    props: LX(),
    setup(e, t) {
      let { slots: n } = t
      const { displayClasses: i, mobile: r } = Ni(e, 'v-data-table__tr'),
        { isSelected: s, toggleSelect: o, someSelected: a, allSelected: l, selectAll: u } = Xm(),
        { isExpanded: c, toggleExpand: d } = PN(),
        { toggleSort: f, sortBy: m, isSorted: p } = jN(),
        { columns: v } = eg()
      se(() =>
        g(
          'tr',
          {
            class: [
              'v-data-table__tr',
              { 'v-data-table__tr--clickable': !!(e.onClick || e.onContextmenu || e.onDblclick) },
              i.value,
            ],
            onClick: e.onClick,
            onContextmenu: e.onContextmenu,
            onDblclick: e.onDblclick,
          },
          [
            e.item &&
              v.value.map((y, T) => {
                const A = e.item,
                  x = `item.${y.key}`,
                  N = `header.${y.key}`,
                  V = {
                    index: e.index,
                    item: A.raw,
                    internalItem: A,
                    value: Go(A.columns, y.key),
                    column: y,
                    isSelected: s,
                    toggleSelect: o,
                    isExpanded: c,
                    toggleExpand: d,
                  },
                  D = {
                    column: y,
                    selectAll: u,
                    isSorted: p,
                    toggleSort: f,
                    sortBy: m.value,
                    someSelected: a.value,
                    allSelected: l.value,
                    getSortIcon: () => '',
                  },
                  I =
                    typeof e.cellProps == 'function'
                      ? e.cellProps({
                          index: V.index,
                          item: V.item,
                          internalItem: V.internalItem,
                          value: V.value,
                          column: y,
                        })
                      : e.cellProps,
                  w =
                    typeof y.cellProps == 'function'
                      ? y.cellProps({ index: V.index, item: V.item, internalItem: V.internalItem, value: V.value })
                      : y.cellProps
                return g(
                  Af,
                  ae(
                    {
                      align: y.align,
                      class: {
                        'v-data-table__td--expanded-row': y.key === 'data-table-expand',
                        'v-data-table__td--select-row': y.key === 'data-table-select',
                      },
                      fixed: y.fixed,
                      fixedOffset: y.fixedOffset,
                      lastFixed: y.lastFixed,
                      maxWidth: r.value ? void 0 : y.maxWidth,
                      noPadding: y.key === 'data-table-select' || y.key === 'data-table-expand',
                      nowrap: y.nowrap,
                      width: r.value ? void 0 : y.width,
                    },
                    I,
                    w
                  ),
                  {
                    default: () => {
                      var S, E, C, R, B
                      if (n[x] && !r.value) return (S = n[x]) == null ? void 0 : S.call(n, V)
                      if (y.key === 'data-table-select')
                        return (
                          ((E = n['item.data-table-select']) == null ? void 0 : E.call(n, V)) ??
                          g(
                            $r,
                            { disabled: !A.selectable, modelValue: s([A]), onClick: rS(() => o(A), ['stop']) },
                            null
                          )
                        )
                      if (y.key === 'data-table-expand')
                        return (
                          ((C = n['item.data-table-expand']) == null ? void 0 : C.call(n, V)) ??
                          g(
                            st,
                            {
                              icon: c(A) ? '$collapse' : '$expand',
                              size: 'small',
                              variant: 'text',
                              onClick: rS(() => d(A), ['stop']),
                            },
                            null
                          )
                        )
                      const _ = xC(V.value)
                      return r.value
                        ? g(ke, null, [
                            g('div', { class: 'v-data-table__td-title' }, [
                              ((R = n[N]) == null ? void 0 : R.call(n, D)) ?? y.title,
                            ]),
                            g('div', { class: 'v-data-table__td-value' }, [
                              ((B = n[x]) == null ? void 0 : B.call(n, V)) ?? _,
                            ]),
                          ])
                        : _
                    },
                  }
                )
              }),
          ]
        )
      )
    },
  }),
  KN = W(
    {
      loading: [Boolean, String],
      loadingText: { type: String, default: '$vuetify.dataIterator.loadingText' },
      hideNoData: Boolean,
      items: { type: Array, default: () => [] },
      noDataText: { type: String, default: '$vuetify.noDataText' },
      rowProps: [Object, Function],
      cellProps: [Object, Function],
      ...ca(),
    },
    'VDataTableRows'
  ),
  Zo = ne()({
    name: 'VDataTableRows',
    inheritAttrs: !1,
    props: KN(),
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { columns: r } = eg(),
        { expandOnClick: s, toggleExpand: o, isExpanded: a } = PN(),
        { isSelected: l, toggleSelect: u } = Xm(),
        { toggleGroup: c, isGroupOpen: d } = xN(),
        { t: f } = jt(),
        { mobile: m } = Ni(e)
      return (
        se(() => {
          var p, v
          return e.loading && (!e.items.length || i.loading)
            ? g('tr', { class: 'v-data-table-rows-loading', key: 'loading' }, [
                g('td', { colspan: r.value.length }, [
                  ((p = i.loading) == null ? void 0 : p.call(i)) ?? f(e.loadingText),
                ]),
              ])
            : !e.loading && !e.items.length && !e.hideNoData
            ? g('tr', { class: 'v-data-table-rows-no-data', key: 'no-data' }, [
                g('td', { colspan: r.value.length }, [
                  ((v = i['no-data']) == null ? void 0 : v.call(i)) ?? f(e.noDataText),
                ]),
              ])
            : g(ke, null, [
                e.items.map((y, T) => {
                  var N
                  if (y.type === 'group') {
                    const V = {
                      index: T,
                      item: y,
                      columns: r.value,
                      isExpanded: a,
                      toggleExpand: o,
                      isSelected: l,
                      toggleSelect: u,
                      toggleGroup: c,
                      isGroupOpen: d,
                    }
                    return i['group-header']
                      ? i['group-header'](V)
                      : g(
                          MX,
                          ae(
                            { key: `group-header_${y.id}`, item: y },
                            bT(n, ':group-header', () => V)
                          ),
                          i
                        )
                  }
                  const A = {
                      index: T,
                      item: y.raw,
                      internalItem: y,
                      columns: r.value,
                      isExpanded: a,
                      toggleExpand: o,
                      isSelected: l,
                      toggleSelect: u,
                    },
                    x = {
                      ...A,
                      props: ae(
                        {
                          key: `item_${y.key ?? y.index}`,
                          onClick: s.value
                            ? () => {
                                o(y)
                              }
                            : void 0,
                          index: T,
                          item: y,
                          cellProps: e.cellProps,
                          mobile: m.value,
                        },
                        bT(n, ':row', () => A),
                        typeof e.rowProps == 'function'
                          ? e.rowProps({ item: A.item, index: A.index, internalItem: A.internalItem })
                          : e.rowProps
                      ),
                    }
                  return g(ke, { key: x.props.key }, [
                    i.item ? i.item(x) : g(gw, x.props, i),
                    a(y) && ((N = i['expanded-row']) == null ? void 0 : N.call(i, A)),
                  ])
                }),
              ])
        }),
        {}
      )
    },
  }),
  YN = W(
    {
      fixedHeader: Boolean,
      fixedFooter: Boolean,
      height: [Number, String],
      hover: Boolean,
      ...Te(),
      ...ln(),
      ...He(),
      ...Ze(),
    },
    'VTable'
  ),
  ea = ne()({
    name: 'VTable',
    props: YN(),
    setup(e, t) {
      let { slots: n, emit: i } = t
      const { themeClasses: r } = at(e),
        { densityClasses: s } = Un(e)
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-table',
                {
                  'v-table--fixed-height': !!e.height,
                  'v-table--fixed-header': e.fixedHeader,
                  'v-table--fixed-footer': e.fixedFooter,
                  'v-table--has-top': !!n.top,
                  'v-table--has-bottom': !!n.bottom,
                  'v-table--hover': e.hover,
                },
                r.value,
                s.value,
                e.class,
              ],
              style: e.style,
            },
            {
              default: () => {
                var o, a, l
                return [
                  (o = n.top) == null ? void 0 : o.call(n),
                  n.default
                    ? g('div', { class: 'v-table__wrapper', style: { height: Se(e.height) } }, [
                        g('table', null, [n.default()]),
                      ])
                    : (a = n.wrapper) == null
                    ? void 0
                    : a.call(n),
                  (l = n.bottom) == null ? void 0 : l.call(n),
                ]
              },
            }
          )
        ),
        {}
      )
    },
  }),
  FX = W(
    {
      items: { type: Array, default: () => [] },
      itemValue: { type: [String, Array, Function], default: 'id' },
      itemSelectable: { type: [String, Array, Function], default: null },
      rowProps: [Object, Function],
      cellProps: [Object, Function],
      returnObject: Boolean,
    },
    'DataTable-items'
  )
function BX(e, t, n, i) {
  const r = e.returnObject ? t : Jt(t, e.itemValue),
    s = Jt(t, e.itemSelectable, !0),
    o = i.reduce((a, l) => (l.key != null && (a[l.key] = Jt(t, l.value)), a), {})
  return {
    type: 'item',
    key: e.returnObject ? Jt(t, e.itemValue) : r,
    index: n,
    value: r,
    selectable: s,
    columns: o,
    raw: t,
  }
}
function $X(e, t, n) {
  return t.map((i, r) => BX(e, i, r, n))
}
function vw(e, t) {
  return { items: k(() => $X(e, e.items, t.value)) }
}
const pw = W(
    {
      ...KN(),
      hideDefaultBody: Boolean,
      hideDefaultFooter: Boolean,
      hideDefaultHeader: Boolean,
      width: [String, Number],
      search: String,
      ...AN(),
      ...ow(),
      ...PX(),
      ...FX(),
      ...FN(),
      ...$N(),
      ...GN(),
      ...YN(),
    },
    'DataTable'
  ),
  UX = W({ ...lw(), ...pw(), ...pd(), ...hw() }, 'VDataTable'),
  jX = ne()({
    name: 'VDataTable',
    props: UX(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:page': (e) => !0,
      'update:itemsPerPage': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:groupBy': (e) => !0,
      'update:expanded': (e) => !0,
      'update:currentItems': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { groupBy: r } = aw(e),
        { sortBy: s, multiSort: o, mustSort: a } = Jm(e),
        { page: l, itemsPerPage: u } = uw(e),
        { disableSort: c } = js(e),
        {
          columns: d,
          headers: f,
          sortFunctions: m,
          sortRawFunctions: p,
          filterFunctions: v,
        } = mw(e, { groupBy: r, showSelect: Q(e, 'showSelect'), showExpand: Q(e, 'showExpand') }),
        { items: y } = vw(e, d),
        T = Q(e, 'search'),
        { filteredItems: A } = yd(e, y, T, { transform: (z) => z.columns, customKeyFilter: v }),
        { toggleSort: x } = Zm({ sortBy: s, multiSort: o, mustSort: a, page: l }),
        {
          sortByWithGroups: N,
          opened: V,
          extractRows: D,
          isGroupOpen: I,
          toggleGroup: w,
        } = Gm({ groupBy: r, sortBy: s, disableSort: c }),
        { sortedItems: _ } = dw(e, A, N, {
          transform: (z) => ({ ...z.raw, ...z.columns }),
          sortFunctions: m,
          sortRawFunctions: p,
        }),
        { flatItems: S } = Km(_, r, V),
        E = k(() => S.value.length),
        {
          startIndex: C,
          stopIndex: R,
          pageCount: B,
          setItemsPerPage: U,
        } = cw({ page: l, itemsPerPage: u, itemsLength: E }),
        { paginatedItems: $ } = ON({ items: S, startIndex: C, stopIndex: R, itemsPerPage: u }),
        G = k(() => D($.value)),
        {
          isSelected: F,
          select: K,
          selectAll: j,
          toggleSelect: q,
          someSelected: te,
          allSelected: ce,
        } = Qm(e, { allItems: y, currentPage: G }),
        { isExpanded: Ee, toggleExpand: me } = qm(e)
      Ym({ page: l, itemsPerPage: u, sortBy: s, groupBy: r, search: T }),
        Ot({
          VDataTableRows: {
            hideNoData: Q(e, 'hideNoData'),
            noDataText: Q(e, 'noDataText'),
            loading: Q(e, 'loading'),
            loadingText: Q(e, 'loadingText'),
          },
        })
      const oe = k(() => ({
        page: l.value,
        itemsPerPage: u.value,
        sortBy: s.value,
        pageCount: B.value,
        toggleSort: x,
        setItemsPerPage: U,
        someSelected: te.value,
        allSelected: ce.value,
        isSelected: F,
        select: K,
        selectAll: j,
        toggleSelect: q,
        isExpanded: Ee,
        toggleExpand: me,
        isGroupOpen: I,
        toggleGroup: w,
        items: G.value.map((z) => z.raw),
        internalItems: G.value,
        groupedItems: $.value,
        columns: d.value,
        headers: f.value,
      }))
      return (
        se(() => {
          const z = Nc.filterProps(e),
            ue = Jo.filterProps(e),
            de = Zo.filterProps(e),
            Z = ea.filterProps(e)
          return g(
            ea,
            ae(
              {
                class: [
                  'v-data-table',
                  { 'v-data-table--show-select': e.showSelect, 'v-data-table--loading': e.loading },
                  e.class,
                ],
                style: e.style,
              },
              Z
            ),
            {
              top: () => {
                var pe
                return (pe = i.top) == null ? void 0 : pe.call(i, oe.value)
              },
              default: () => {
                var pe, re, O, L, H, X
                return i.default
                  ? i.default(oe.value)
                  : g(ke, null, [
                      (pe = i.colgroup) == null ? void 0 : pe.call(i, oe.value),
                      !e.hideDefaultHeader && g('thead', { key: 'thead' }, [g(Jo, ue, i)]),
                      (re = i.thead) == null ? void 0 : re.call(i, oe.value),
                      !e.hideDefaultBody &&
                        g('tbody', null, [
                          (O = i['body.prepend']) == null ? void 0 : O.call(i, oe.value),
                          i.body ? i.body(oe.value) : g(Zo, ae(n, de, { items: $.value }), i),
                          (L = i['body.append']) == null ? void 0 : L.call(i, oe.value),
                        ]),
                      (H = i.tbody) == null ? void 0 : H.call(i, oe.value),
                      (X = i.tfoot) == null ? void 0 : X.call(i, oe.value),
                    ])
              },
              bottom: () =>
                i.bottom
                  ? i.bottom(oe.value)
                  : !e.hideDefaultFooter &&
                    g(ke, null, [g(md, null, null), g(Nc, z, { prepend: i['footer.prepend'] })]),
            }
          )
        }),
        {}
      )
    },
  }),
  zX = W({ ...pw(), ...ow(), ...lN(), ...pd() }, 'VDataTableVirtual'),
  HX = ne()({
    name: 'VDataTableVirtual',
    props: zX(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:groupBy': (e) => !0,
      'update:expanded': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { groupBy: r } = aw(e),
        { sortBy: s, multiSort: o, mustSort: a } = Jm(e),
        { disableSort: l } = js(e),
        {
          columns: u,
          headers: c,
          filterFunctions: d,
          sortFunctions: f,
          sortRawFunctions: m,
        } = mw(e, { groupBy: r, showSelect: Q(e, 'showSelect'), showExpand: Q(e, 'showExpand') }),
        { items: p } = vw(e, u),
        v = Q(e, 'search'),
        { filteredItems: y } = yd(e, p, v, { transform: (ue) => ue.columns, customKeyFilter: d }),
        { toggleSort: T } = Zm({ sortBy: s, multiSort: o, mustSort: a }),
        {
          sortByWithGroups: A,
          opened: x,
          extractRows: N,
          isGroupOpen: V,
          toggleGroup: D,
        } = Gm({ groupBy: r, sortBy: s, disableSort: l }),
        { sortedItems: I } = dw(e, y, A, {
          transform: (ue) => ({ ...ue.raw, ...ue.columns }),
          sortFunctions: f,
          sortRawFunctions: m,
        }),
        { flatItems: w } = Km(I, r, x),
        _ = k(() => N(w.value)),
        {
          isSelected: S,
          select: E,
          selectAll: C,
          toggleSelect: R,
          someSelected: B,
          allSelected: U,
        } = Qm(e, { allItems: _, currentPage: _ }),
        { isExpanded: $, toggleExpand: G } = qm(e),
        {
          containerRef: F,
          markerRef: K,
          paddingTop: j,
          paddingBottom: q,
          computedItems: te,
          handleItemResize: ce,
          handleScroll: Ee,
          handleScrollend: me,
        } = uN(e, w),
        oe = k(() => te.value.map((ue) => ue.raw))
      Ym({ sortBy: s, page: ye(1), itemsPerPage: ye(-1), groupBy: r, search: v }),
        Ot({
          VDataTableRows: {
            hideNoData: Q(e, 'hideNoData'),
            noDataText: Q(e, 'noDataText'),
            loading: Q(e, 'loading'),
            loadingText: Q(e, 'loadingText'),
          },
        })
      const z = k(() => ({
        sortBy: s.value,
        toggleSort: T,
        someSelected: B.value,
        allSelected: U.value,
        isSelected: S,
        select: E,
        selectAll: C,
        toggleSelect: R,
        isExpanded: $,
        toggleExpand: G,
        isGroupOpen: V,
        toggleGroup: D,
        items: _.value.map((ue) => ue.raw),
        internalItems: _.value,
        groupedItems: w.value,
        columns: u.value,
        headers: c.value,
      }))
      se(() => {
        const ue = Jo.filterProps(e),
          de = Zo.filterProps(e),
          Z = ea.filterProps(e)
        return g(
          ea,
          ae({ class: ['v-data-table', { 'v-data-table--loading': e.loading }, e.class], style: e.style }, Z),
          {
            top: () => {
              var pe
              return (pe = i.top) == null ? void 0 : pe.call(i, z.value)
            },
            wrapper: () => {
              var pe, re, O
              return g(
                'div',
                {
                  ref: F,
                  onScrollPassive: Ee,
                  onScrollend: me,
                  class: 'v-table__wrapper',
                  style: { height: Se(e.height) },
                },
                [
                  g('table', null, [
                    (pe = i.colgroup) == null ? void 0 : pe.call(i, z.value),
                    !e.hideDefaultHeader && g('thead', { key: 'thead' }, [g(Jo, ae(ue, { sticky: e.fixedHeader }), i)]),
                    !e.hideDefaultBody &&
                      g('tbody', null, [
                        g('tr', { ref: K, style: { height: Se(j.value), border: 0 } }, [
                          g('td', { colspan: u.value.length, style: { height: 0, border: 0 } }, null),
                        ]),
                        (re = i['body.prepend']) == null ? void 0 : re.call(i, z.value),
                        g(Zo, ae(n, de, { items: oe.value }), {
                          ...i,
                          item: (L) =>
                            g(
                              aN,
                              {
                                key: L.internalItem.index,
                                renderless: !0,
                                'onUpdate:height': (H) => ce(L.internalItem.index, H),
                              },
                              {
                                default: (H) => {
                                  var ee
                                  let { itemRef: X } = H
                                  return (
                                    ((ee = i.item) == null ? void 0 : ee.call(i, { ...L, itemRef: X })) ??
                                    g(
                                      gw,
                                      ae(L.props, { ref: X, key: L.internalItem.index, index: L.internalItem.index }),
                                      i
                                    )
                                  )
                                },
                              }
                            ),
                        }),
                        (O = i['body.append']) == null ? void 0 : O.call(i, z.value),
                        g('tr', { style: { height: Se(q.value), border: 0 } }, [
                          g('td', { colspan: u.value.length, style: { height: 0, border: 0 } }, null),
                        ]),
                      ]),
                  ]),
                ]
              )
            },
            bottom: () => {
              var pe
              return (pe = i.bottom) == null ? void 0 : pe.call(i, z.value)
            },
          }
        )
      })
    },
  }),
  WX = W({ itemsLength: { type: [Number, String], required: !0 }, ...lw(), ...pw(), ...hw() }, 'VDataTableServer'),
  qX = ne()({
    name: 'VDataTableServer',
    props: WX(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:page': (e) => !0,
      'update:itemsPerPage': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:expanded': (e) => !0,
      'update:groupBy': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const { groupBy: r } = aw(e),
        { sortBy: s, multiSort: o, mustSort: a } = Jm(e),
        { page: l, itemsPerPage: u } = uw(e),
        { disableSort: c } = js(e),
        d = k(() => parseInt(e.itemsLength, 10)),
        { columns: f, headers: m } = mw(e, {
          groupBy: r,
          showSelect: Q(e, 'showSelect'),
          showExpand: Q(e, 'showExpand'),
        }),
        { items: p } = vw(e, f),
        { toggleSort: v } = Zm({ sortBy: s, multiSort: o, mustSort: a, page: l }),
        { opened: y, isGroupOpen: T, toggleGroup: A, extractRows: x } = Gm({ groupBy: r, sortBy: s, disableSort: c }),
        { pageCount: N, setItemsPerPage: V } = cw({ page: l, itemsPerPage: u, itemsLength: d }),
        { flatItems: D } = Km(p, r, y),
        {
          isSelected: I,
          select: w,
          selectAll: _,
          toggleSelect: S,
          someSelected: E,
          allSelected: C,
        } = Qm(e, { allItems: p, currentPage: p }),
        { isExpanded: R, toggleExpand: B } = qm(e),
        U = k(() => x(p.value))
      Ym({ page: l, itemsPerPage: u, sortBy: s, groupBy: r, search: Q(e, 'search') }),
        mt('v-data-table', { toggleSort: v, sortBy: s }),
        Ot({
          VDataTableRows: {
            hideNoData: Q(e, 'hideNoData'),
            noDataText: Q(e, 'noDataText'),
            loading: Q(e, 'loading'),
            loadingText: Q(e, 'loadingText'),
          },
        })
      const $ = k(() => ({
        page: l.value,
        itemsPerPage: u.value,
        sortBy: s.value,
        pageCount: N.value,
        toggleSort: v,
        setItemsPerPage: V,
        someSelected: E.value,
        allSelected: C.value,
        isSelected: I,
        select: w,
        selectAll: _,
        toggleSelect: S,
        isExpanded: R,
        toggleExpand: B,
        isGroupOpen: T,
        toggleGroup: A,
        items: U.value.map((G) => G.raw),
        internalItems: U.value,
        groupedItems: D.value,
        columns: f.value,
        headers: m.value,
      }))
      se(() => {
        const G = Nc.filterProps(e),
          F = Jo.filterProps(e),
          K = Zo.filterProps(e),
          j = ea.filterProps(e)
        return g(
          ea,
          ae({ class: ['v-data-table', { 'v-data-table--loading': e.loading }, e.class], style: e.style }, j),
          {
            top: () => {
              var q
              return (q = i.top) == null ? void 0 : q.call(i, $.value)
            },
            default: () => {
              var q, te, ce, Ee, me, oe
              return i.default
                ? i.default($.value)
                : g(ke, null, [
                    (q = i.colgroup) == null ? void 0 : q.call(i, $.value),
                    !e.hideDefaultHeader &&
                      g('thead', { key: 'thead', class: 'v-data-table__thead', role: 'rowgroup' }, [
                        g(Jo, ae(F, { sticky: e.fixedHeader }), i),
                      ]),
                    (te = i.thead) == null ? void 0 : te.call(i, $.value),
                    !e.hideDefaultBody &&
                      g('tbody', { class: 'v-data-table__tbody', role: 'rowgroup' }, [
                        (ce = i['body.prepend']) == null ? void 0 : ce.call(i, $.value),
                        i.body ? i.body($.value) : g(Zo, ae(n, K, { items: D.value }), i),
                        (Ee = i['body.append']) == null ? void 0 : Ee.call(i, $.value),
                      ]),
                    (me = i.tbody) == null ? void 0 : me.call(i, $.value),
                    (oe = i.tfoot) == null ? void 0 : oe.call(i, $.value),
                  ])
            },
            bottom: () =>
              i.bottom
                ? i.bottom($.value)
                : !e.hideDefaultFooter && g(ke, null, [g(md, null, null), g(Nc, G, { prepend: i['footer.prepend'] })]),
          }
        )
      })
    },
  }),
  GX = W({ fluid: { type: Boolean, default: !1 }, ...Te(), ...He() }, 'VContainer'),
  KX = ne()({
    name: 'VContainer',
    props: GX(),
    setup(e, t) {
      let { slots: n } = t
      const { rtlClasses: i } = sn()
      return (
        se(() =>
          g(e.tag, { class: ['v-container', { 'v-container--fluid': e.fluid }, i.value, e.class], style: e.style }, n)
        ),
        {}
      )
    },
  }),
  QN = km.reduce((e, t) => ((e[t] = { type: [Boolean, String, Number], default: !1 }), e), {}),
  XN = km.reduce((e, t) => {
    const n = 'offset' + gr(t)
    return (e[n] = { type: [String, Number], default: null }), e
  }, {}),
  JN = km.reduce((e, t) => {
    const n = 'order' + gr(t)
    return (e[n] = { type: [String, Number], default: null }), e
  }, {}),
  WT = { col: Object.keys(QN), offset: Object.keys(XN), order: Object.keys(JN) }
function YX(e, t, n) {
  let i = e
  if (!(n == null || n === !1)) {
    if (t) {
      const r = t.replace(e, '')
      i += `-${r}`
    }
    return e === 'col' && (i = 'v-' + i), (e === 'col' && (n === '' || n === !0)) || (i += `-${n}`), i.toLowerCase()
  }
}
const QX = ['auto', 'start', 'end', 'center', 'baseline', 'stretch'],
  XX = W(
    {
      cols: { type: [Boolean, String, Number], default: !1 },
      ...QN,
      offset: { type: [String, Number], default: null },
      ...XN,
      order: { type: [String, Number], default: null },
      ...JN,
      alignSelf: { type: String, default: null, validator: (e) => QX.includes(e) },
      ...Te(),
      ...He(),
    },
    'VCol'
  ),
  JX = ne()({
    name: 'VCol',
    props: XX(),
    setup(e, t) {
      let { slots: n } = t
      const i = k(() => {
        const r = []
        let s
        for (s in WT)
          WT[s].forEach((a) => {
            const l = e[a],
              u = YX(s, a, l)
            u && r.push(u)
          })
        const o = r.some((a) => a.startsWith('v-col-'))
        return (
          r.push({
            'v-col': !o || !e.cols,
            [`v-col-${e.cols}`]: e.cols,
            [`offset-${e.offset}`]: e.offset,
            [`order-${e.order}`]: e.order,
            [`align-self-${e.alignSelf}`]: e.alignSelf,
          }),
          r
        )
      })
      return () => {
        var r
        return Yi(e.tag, { class: [i.value, e.class], style: e.style }, (r = n.default) == null ? void 0 : r.call(n))
      }
    },
  }),
  yw = ['start', 'end', 'center'],
  ZN = ['space-between', 'space-around', 'space-evenly']
function _w(e, t) {
  return km.reduce((n, i) => {
    const r = e + gr(i)
    return (n[r] = t()), n
  }, {})
}
const ZX = [...yw, 'baseline', 'stretch'],
  eO = (e) => ZX.includes(e),
  tO = _w('align', () => ({ type: String, default: null, validator: eO })),
  eJ = [...yw, ...ZN],
  nO = (e) => eJ.includes(e),
  iO = _w('justify', () => ({ type: String, default: null, validator: nO })),
  tJ = [...yw, ...ZN, 'stretch'],
  rO = (e) => tJ.includes(e),
  sO = _w('alignContent', () => ({ type: String, default: null, validator: rO })),
  qT = { align: Object.keys(tO), justify: Object.keys(iO), alignContent: Object.keys(sO) },
  nJ = { align: 'align', justify: 'justify', alignContent: 'align-content' }
function iJ(e, t, n) {
  let i = nJ[e]
  if (n != null) {
    if (t) {
      const r = t.replace(e, '')
      i += `-${r}`
    }
    return (i += `-${n}`), i.toLowerCase()
  }
}
const rJ = W(
    {
      dense: Boolean,
      noGutters: Boolean,
      align: { type: String, default: null, validator: eO },
      ...tO,
      justify: { type: String, default: null, validator: nO },
      ...iO,
      alignContent: { type: String, default: null, validator: rO },
      ...sO,
      ...Te(),
      ...He(),
    },
    'VRow'
  ),
  sJ = ne()({
    name: 'VRow',
    props: rJ(),
    setup(e, t) {
      let { slots: n } = t
      const i = k(() => {
        const r = []
        let s
        for (s in qT)
          qT[s].forEach((o) => {
            const a = e[o],
              l = iJ(s, o, a)
            l && r.push(l)
          })
        return (
          r.push({
            'v-row--no-gutters': e.noGutters,
            'v-row--dense': e.dense,
            [`align-${e.align}`]: e.align,
            [`justify-${e.justify}`]: e.justify,
            [`align-content-${e.alignContent}`]: e.alignContent,
          }),
          r
        )
      })
      return () => {
        var r
        return Yi(
          e.tag,
          { class: ['v-row', i.value, e.class], style: e.style },
          (r = n.default) == null ? void 0 : r.call(n)
        )
      }
    },
  }),
  oO = yr('v-spacer', 'div', 'VSpacer'),
  aO = W(
    {
      active: { type: [String, Array], default: void 0 },
      disabled: { type: [Boolean, String, Array], default: !1 },
      nextIcon: { type: Le, default: '$next' },
      prevIcon: { type: Le, default: '$prev' },
      modeIcon: { type: Le, default: '$subgroup' },
      text: String,
      viewMode: { type: String, default: 'month' },
    },
    'VDatePickerControls'
  ),
  ly = ne()({
    name: 'VDatePickerControls',
    props: aO(),
    emits: {
      'click:year': () => !0,
      'click:month': () => !0,
      'click:prev': () => !0,
      'click:next': () => !0,
      'click:text': () => !0,
    },
    setup(e, t) {
      let { emit: n } = t
      const i = k(() => (Array.isArray(e.disabled) ? e.disabled.includes('text') : !!e.disabled)),
        r = k(() => (Array.isArray(e.disabled) ? e.disabled.includes('mode') : !!e.disabled)),
        s = k(() => (Array.isArray(e.disabled) ? e.disabled.includes('prev') : !!e.disabled)),
        o = k(() => (Array.isArray(e.disabled) ? e.disabled.includes('next') : !!e.disabled))
      function a() {
        n('click:prev')
      }
      function l() {
        n('click:next')
      }
      function u() {
        n('click:year')
      }
      function c() {
        n('click:month')
      }
      return (
        se(() =>
          g('div', { class: ['v-date-picker-controls'] }, [
            g(
              st,
              {
                class: 'v-date-picker-controls__month-btn',
                disabled: i.value,
                text: e.text,
                variant: 'text',
                rounded: !0,
                onClick: c,
              },
              null
            ),
            g(
              st,
              {
                key: 'mode-btn',
                class: 'v-date-picker-controls__mode-btn',
                disabled: r.value,
                density: 'comfortable',
                icon: e.modeIcon,
                variant: 'text',
                onClick: u,
              },
              null
            ),
            g(oO, { key: 'mode-spacer' }, null),
            g('div', { key: 'month-buttons', class: 'v-date-picker-controls__month' }, [
              g(st, { disabled: s.value, icon: e.prevIcon, variant: 'text', onClick: a }, null),
              g(st, { disabled: o.value, icon: e.nextIcon, variant: 'text', onClick: l }, null),
            ]),
          ])
        ),
        {}
      )
    },
  }),
  oJ = W({ appendIcon: String, color: String, header: String, transition: String, onClick: mn() }, 'VDatePickerHeader'),
  uy = ne()({
    name: 'VDatePickerHeader',
    props: oJ(),
    emits: { click: () => !0, 'click:append': () => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const { backgroundColorClasses: r, backgroundColorStyles: s } = gt(e, 'color')
      function o() {
        n('click')
      }
      function a() {
        n('click:append')
      }
      return (
        se(() => {
          const l = !!(i.default || e.header),
            u = !!(i.append || e.appendIcon)
          return g(
            'div',
            {
              class: ['v-date-picker-header', { 'v-date-picker-header--clickable': !!e.onClick }, r.value],
              style: s.value,
              onClick: o,
            },
            [
              i.prepend && g('div', { key: 'prepend', class: 'v-date-picker-header__prepend' }, [i.prepend()]),
              l &&
                g(
                  Bn,
                  { key: 'content', name: e.transition },
                  {
                    default: () => {
                      var c
                      return [
                        g('div', { key: e.header, class: 'v-date-picker-header__content' }, [
                          ((c = i.default) == null ? void 0 : c.call(i)) ?? e.header,
                        ]),
                      ]
                    },
                  }
                ),
              u &&
                g('div', { class: 'v-date-picker-header__append' }, [
                  i.append
                    ? g(
                        Ge,
                        {
                          key: 'append-defaults',
                          disabled: !e.appendIcon,
                          defaults: { VBtn: { icon: e.appendIcon, variant: 'text' } },
                        },
                        {
                          default: () => {
                            var c
                            return [(c = i.append) == null ? void 0 : c.call(i)]
                          },
                        }
                      )
                    : g(st, { key: 'append-btn', icon: e.appendIcon, variant: 'text', onClick: a }, null),
                ]),
            ]
          )
        }),
        {}
      )
    },
  }),
  aJ = W(
    {
      allowedDates: [Array, Function],
      disabled: Boolean,
      displayValue: null,
      modelValue: Array,
      month: [Number, String],
      max: null,
      min: null,
      showAdjacentMonths: Boolean,
      year: [Number, String],
      weekdays: { type: Array, default: () => [0, 1, 2, 3, 4, 5, 6] },
      weeksInMonth: { type: String, default: 'dynamic' },
      firstDayOfWeek: [Number, String],
    },
    'calendar'
  )
function lJ(e) {
  const t = ad(),
    n = xe(e, 'modelValue', [], (m) => Pt(m)),
    i = k(() =>
      e.displayValue
        ? t.date(e.displayValue)
        : n.value.length > 0
        ? t.date(n.value[0])
        : e.min
        ? t.date(e.min)
        : Array.isArray(e.allowedDates)
        ? t.date(e.allowedDates[0])
        : t.date()
    ),
    r = xe(
      e,
      'year',
      void 0,
      (m) => {
        const p = m != null ? Number(m) : t.getYear(i.value)
        return t.startOfYear(t.setYear(t.date(), p))
      },
      (m) => t.getYear(m)
    ),
    s = xe(
      e,
      'month',
      void 0,
      (m) => {
        const p = m != null ? Number(m) : t.getMonth(i.value),
          v = t.setYear(t.startOfMonth(t.date()), t.getYear(r.value))
        return t.setMonth(v, p)
      },
      (m) => t.getMonth(m)
    ),
    o = k(() => {
      const m = Number(e.firstDayOfWeek ?? 0)
      return e.weekdays.map((p) => (p + m) % 7)
    }),
    a = k(() => {
      const m = t.getWeekArray(s.value, e.firstDayOfWeek),
        p = m.flat(),
        v = 6 * 7
      if (e.weeksInMonth === 'static' && p.length < v) {
        const y = p[p.length - 1]
        let T = []
        for (let A = 1; A <= v - p.length; A++) T.push(t.addDays(y, A)), A % 7 === 0 && (m.push(T), (T = []))
      }
      return m
    })
  function l(m, p) {
    return m
      .filter((v) => o.value.includes(t.toJsDate(v).getDay()))
      .map((v, y) => {
        const T = t.toISO(v),
          A = !t.isSameMonth(v, s.value),
          x = t.isSameDay(v, t.startOfMonth(s.value)),
          N = t.isSameDay(v, t.endOfMonth(s.value)),
          V = t.isSameDay(v, s.value)
        return {
          date: v,
          isoDate: T,
          formatted: t.format(v, 'keyboardDate'),
          year: t.getYear(v),
          month: t.getMonth(v),
          isDisabled: f(v),
          isWeekStart: y % 7 === 0,
          isWeekEnd: y % 7 === 6,
          isToday: t.isSameDay(v, p),
          isAdjacent: A,
          isHidden: A && !e.showAdjacentMonths,
          isStart: x,
          isSelected: n.value.some((D) => t.isSameDay(v, D)),
          isEnd: N,
          isSame: V,
          localized: t.format(v, 'dayOfMonth'),
        }
      })
  }
  const u = k(() => {
      const m = t.startOfWeek(i.value, e.firstDayOfWeek),
        p = []
      for (let y = 0; y <= 6; y++) p.push(t.addDays(m, y))
      const v = t.date()
      return l(p, v)
    }),
    c = k(() => {
      const m = a.value.flat(),
        p = t.date()
      return l(m, p)
    }),
    d = k(() => a.value.map((m) => (m.length ? v7(t, m[0]) : null)))
  function f(m) {
    if (e.disabled) return !0
    const p = t.date(m)
    return (e.min && t.isAfter(t.date(e.min), p)) || (e.max && t.isAfter(p, t.date(e.max)))
      ? !0
      : Array.isArray(e.allowedDates) && e.allowedDates.length > 0
      ? !e.allowedDates.some((v) => t.isSameDay(t.date(v), p))
      : typeof e.allowedDates == 'function'
      ? !e.allowedDates(p)
      : !1
  }
  return {
    displayValue: i,
    daysInMonth: c,
    daysInWeek: u,
    genDays: l,
    model: n,
    weeksInMonth: a,
    weekDays: o,
    weekNumbers: d,
  }
}
const lO = W(
    {
      color: String,
      hideWeekdays: Boolean,
      multiple: [Boolean, Number, String],
      showWeek: Boolean,
      transition: { type: String, default: 'picker-transition' },
      reverseTransition: { type: String, default: 'picker-reverse-transition' },
      ...aJ(),
    },
    'VDatePickerMonth'
  ),
  cy = ne()({
    name: 'VDatePickerMonth',
    props: lO(),
    emits: { 'update:modelValue': (e) => !0, 'update:month': (e) => !0, 'update:year': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const r = le(),
        { daysInMonth: s, model: o, weekNumbers: a } = lJ(e),
        l = ad(),
        u = ye(),
        c = ye(),
        d = ye(!1),
        f = k(() => (d.value ? e.reverseTransition : e.transition))
      e.multiple === 'range' &&
        o.value.length > 0 &&
        ((u.value = o.value[0]), o.value.length > 1 && (c.value = o.value[o.value.length - 1]))
      const m = k(() => {
        const T = ['number', 'string'].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0
        return o.value.length >= T
      })
      be(s, (T, A) => {
        A && (d.value = l.isBefore(T[0].date, A[0].date))
      })
      function p(T) {
        const A = l.startOfDay(T)
        if (
          (o.value.length === 0
            ? (u.value = void 0)
            : o.value.length === 1 && ((u.value = o.value[0]), (c.value = void 0)),
          !u.value)
        )
          (u.value = A), (o.value = [u.value])
        else if (c.value) (u.value = T), (c.value = void 0), (o.value = [u.value])
        else {
          if (l.isSameDay(A, u.value)) {
            ;(u.value = void 0), (o.value = [])
            return
          } else l.isBefore(A, u.value) ? ((c.value = l.endOfDay(u.value)), (u.value = A)) : (c.value = l.endOfDay(A))
          const x = l.getDiff(c.value, u.value, 'days'),
            N = [u.value]
          for (let V = 1; V < x; V++) {
            const D = l.addDays(u.value, V)
            N.push(D)
          }
          N.push(c.value), (o.value = N)
        }
      }
      function v(T) {
        const A = o.value.findIndex((x) => l.isSameDay(x, T))
        if (A === -1) o.value = [...o.value, T]
        else {
          const x = [...o.value]
          x.splice(A, 1), (o.value = x)
        }
      }
      function y(T) {
        e.multiple === 'range' ? p(T) : e.multiple ? v(T) : (o.value = [T])
      }
      return () =>
        g('div', { class: 'v-date-picker-month' }, [
          e.showWeek &&
            g('div', { key: 'weeks', class: 'v-date-picker-month__weeks' }, [
              !e.hideWeekdays && g('div', { key: 'hide-week-days', class: 'v-date-picker-month__day' }, [Or(' ')]),
              a.value.map((T) =>
                g('div', { class: ['v-date-picker-month__day', 'v-date-picker-month__day--adjacent'] }, [T])
              ),
            ]),
          g(
            Bn,
            { name: f.value },
            {
              default: () => {
                var T
                return [
                  g(
                    'div',
                    {
                      ref: r,
                      key: (T = s.value[0].date) == null ? void 0 : T.toString(),
                      class: 'v-date-picker-month__days',
                    },
                    [
                      !e.hideWeekdays &&
                        l
                          .getWeekdays(e.firstDayOfWeek)
                          .map((A) =>
                            g('div', { class: ['v-date-picker-month__day', 'v-date-picker-month__weekday'] }, [A])
                          ),
                      s.value.map((A, x) => {
                        const N = { props: { onClick: () => y(A.date) }, item: A, i: x }
                        return (
                          m.value && !A.isSelected && (A.isDisabled = !0),
                          g(
                            'div',
                            {
                              class: [
                                'v-date-picker-month__day',
                                {
                                  'v-date-picker-month__day--adjacent': A.isAdjacent,
                                  'v-date-picker-month__day--hide-adjacent': A.isHidden,
                                  'v-date-picker-month__day--selected': A.isSelected,
                                  'v-date-picker-month__day--week-end': A.isWeekEnd,
                                  'v-date-picker-month__day--week-start': A.isWeekStart,
                                },
                              ],
                              'data-v-date': A.isDisabled ? void 0 : A.isoDate,
                            },
                            [
                              (e.showAdjacentMonths || !A.isAdjacent) &&
                                g(
                                  Ge,
                                  {
                                    defaults: {
                                      VBtn: {
                                        class: 'v-date-picker-month__day-btn',
                                        color: (A.isSelected || A.isToday) && !A.isDisabled ? e.color : void 0,
                                        disabled: A.isDisabled,
                                        icon: !0,
                                        ripple: !1,
                                        text: A.localized,
                                        variant: A.isDisabled
                                          ? A.isToday
                                            ? 'outlined'
                                            : 'text'
                                          : A.isToday && !A.isSelected
                                          ? 'outlined'
                                          : 'flat',
                                        onClick: () => y(A.date),
                                      },
                                    },
                                  },
                                  {
                                    default: () => {
                                      var V
                                      return [((V = i.day) == null ? void 0 : V.call(i, N)) ?? g(st, N.props, null)]
                                    },
                                  }
                                ),
                            ]
                          )
                        )
                      }),
                    ]
                  ),
                ]
              },
            }
          ),
        ])
    },
  }),
  uO = W(
    { color: String, height: [String, Number], min: null, max: null, modelValue: Number, year: Number },
    'VDatePickerMonths'
  ),
  dy = ne()({
    name: 'VDatePickerMonths',
    props: uO(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const r = ad(),
        s = xe(e, 'modelValue'),
        o = k(() => {
          let a = r.startOfYear(r.date())
          return (
            e.year && (a = r.setYear(a, e.year)),
            ar(12).map((l) => {
              const u = r.format(a, 'monthShort'),
                c = !!(
                  (e.min && r.isAfter(r.startOfMonth(r.date(e.min)), a)) ||
                  (e.max && r.isAfter(a, r.startOfMonth(r.date(e.max))))
                )
              return (a = r.getNextMonth(a)), { isDisabled: c, text: u, value: l }
            })
          )
        })
      return (
        $t(() => {
          s.value = s.value ?? r.getMonth(r.date())
        }),
        se(() =>
          g('div', { class: 'v-date-picker-months', style: { height: Se(e.height) } }, [
            g('div', { class: 'v-date-picker-months__content' }, [
              o.value.map((a, l) => {
                var d
                const u = {
                  active: s.value === l,
                  color: s.value === l ? e.color : void 0,
                  disabled: a.isDisabled,
                  rounded: !0,
                  text: a.text,
                  variant: s.value === a.value ? 'flat' : 'text',
                  onClick: () => c(l),
                }
                function c(f) {
                  if (s.value === f) {
                    n('update:modelValue', s.value)
                    return
                  }
                  s.value = f
                }
                return (
                  ((d = i.month) == null ? void 0 : d.call(i, { month: a, i: l, props: u })) ??
                  g(st, ae({ key: 'month' }, u), null)
                )
              }),
            ]),
          ])
        ),
        {}
      )
    },
  }),
  cO = W({ color: String, height: [String, Number], min: null, max: null, modelValue: Number }, 'VDatePickerYears'),
  hy = ne()({
    name: 'VDatePickerYears',
    props: cO(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const r = ad(),
        s = xe(e, 'modelValue'),
        o = k(() => {
          const l = r.getYear(r.date())
          let u = l - 100,
            c = l + 52
          e.min && (u = r.getYear(r.date(e.min))), e.max && (c = r.getYear(r.date(e.max)))
          let d = r.startOfYear(r.date())
          return (
            (d = r.setYear(d, u)),
            ar(c - u + 1, u).map((f) => {
              const m = r.format(d, 'year')
              return (d = r.setYear(d, r.getYear(d) + 1)), { text: m, value: f }
            })
          )
        })
      $t(() => {
        s.value = s.value ?? r.getYear(r.date())
      })
      const a = wf()
      return (
        An(async () => {
          var l
          await Xe(), (l = a.el) == null || l.scrollIntoView({ block: 'center' })
        }),
        se(() =>
          g('div', { class: 'v-date-picker-years', style: { height: Se(e.height) } }, [
            g('div', { class: 'v-date-picker-years__content' }, [
              o.value.map((l, u) => {
                var d
                const c = {
                  ref: s.value === l.value ? a : void 0,
                  active: s.value === l.value,
                  color: s.value === l.value ? e.color : void 0,
                  rounded: !0,
                  text: l.text,
                  variant: s.value === l.value ? 'flat' : 'text',
                  onClick: () => {
                    if (s.value === l.value) {
                      n('update:modelValue', s.value)
                      return
                    }
                    s.value = l.value
                  },
                }
                return (
                  ((d = i.year) == null ? void 0 : d.call(i, { year: l, i: u, props: c })) ??
                  g(st, ae({ key: 'month' }, c), null)
                )
              }),
            ]),
          ])
        ),
        {}
      )
    },
  }),
  uJ = yr('v-picker-title'),
  dO = W({ bgColor: String, landscape: Boolean, title: String, hideHeader: Boolean, ...Wm() }, 'VPicker'),
  GT = ne()({
    name: 'VPicker',
    props: dO(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: i, backgroundColorStyles: r } = gt(Q(e, 'color'))
      return (
        se(() => {
          const s = Xo.filterProps(e),
            o = !!(e.title || n.title)
          return g(
            Xo,
            ae(s, {
              color: e.bgColor,
              class: [
                'v-picker',
                { 'v-picker--landscape': e.landscape, 'v-picker--with-actions': !!n.actions },
                e.class,
              ],
              style: e.style,
            }),
            {
              default: () => {
                var a
                return [
                  !e.hideHeader &&
                    g('div', { key: 'header', class: [i.value], style: [r.value] }, [
                      o &&
                        g(
                          uJ,
                          { key: 'picker-title' },
                          {
                            default: () => {
                              var l
                              return [((l = n.title) == null ? void 0 : l.call(n)) ?? e.title]
                            },
                          }
                        ),
                      n.header && g('div', { class: 'v-picker__header' }, [n.header()]),
                    ]),
                  g('div', { class: 'v-picker__body' }, [(a = n.default) == null ? void 0 : a.call(n)]),
                  n.actions &&
                    g(
                      Ge,
                      { defaults: { VBtn: { slim: !0, variant: 'text' } } },
                      { default: () => [g('div', { class: 'v-picker__actions' }, [n.actions()])] }
                    ),
                ]
              },
            }
          )
        }),
        {}
      )
    },
  }),
  cJ = W(
    {
      header: { type: String, default: '$vuetify.datePicker.header' },
      ...aO(),
      ...lO({ weeksInMonth: 'static' }),
      ...Qt(uO(), ['modelValue']),
      ...Qt(cO(), ['modelValue']),
      ...dO({ title: '$vuetify.datePicker.title' }),
      modelValue: null,
    },
    'VDatePicker'
  ),
  dJ = ne()({
    name: 'VDatePicker',
    props: cJ(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:month': (e) => !0,
      'update:year': (e) => !0,
      'update:viewMode': (e) => !0,
    },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const r = ad(),
        { t: s } = jt(),
        o = xe(
          e,
          'modelValue',
          void 0,
          (_) => Pt(_),
          (_) => (e.multiple ? _ : _[0])
        ),
        a = xe(e, 'viewMode'),
        l = k(() => {
          var S
          const _ = r.date((S = o.value) == null ? void 0 : S[0])
          return _ && r.isValid(_) ? _ : r.date()
        }),
        u = le(Number(e.month ?? r.getMonth(r.startOfMonth(l.value)))),
        c = le(Number(e.year ?? r.getYear(r.startOfYear(r.setMonth(l.value, u.value))))),
        d = ye(!1),
        f = k(() =>
          e.multiple && o.value.length > 1
            ? s('$vuetify.datePicker.itemsSelected', o.value.length)
            : o.value[0] && r.isValid(o.value[0])
            ? r.format(r.date(o.value[0]), 'normalDateWithWeekday')
            : s(e.header)
        ),
        m = k(() => {
          let _ = r.date()
          return (
            (_ = r.setDate(_, 1)),
            (_ = r.setMonth(_, u.value)),
            (_ = r.setYear(_, c.value)),
            r.format(_, 'monthAndYear')
          )
        }),
        p = k(() => `date-picker-header${d.value ? '-reverse' : ''}-transition`),
        v = k(() => {
          const _ = r.date(e.min)
          return e.min && r.isValid(_) ? _ : null
        }),
        y = k(() => {
          const _ = r.date(e.max)
          return e.max && r.isValid(_) ? _ : null
        }),
        T = k(() => {
          if (e.disabled) return !0
          const _ = []
          if (a.value !== 'month') _.push('prev', 'next')
          else {
            let S = r.date()
            if (((S = r.setYear(S, c.value)), (S = r.setMonth(S, u.value)), v.value)) {
              const E = r.addDays(r.startOfMonth(S), -1)
              r.isAfter(v.value, E) && _.push('prev')
            }
            if (y.value) {
              const E = r.addDays(r.endOfMonth(S), 1)
              r.isAfter(E, y.value) && _.push('next')
            }
          }
          return _
        })
      function A() {
        u.value < 11 ? u.value++ : (c.value++, (u.value = 0), w(c.value)), I(u.value)
      }
      function x() {
        u.value > 0 ? u.value-- : (c.value--, (u.value = 11), w(c.value)), I(u.value)
      }
      function N() {
        a.value = 'month'
      }
      function V() {
        a.value = a.value === 'months' ? 'month' : 'months'
      }
      function D() {
        a.value = a.value === 'year' ? 'month' : 'year'
      }
      function I(_) {
        a.value === 'months' && V(), n('update:month', _)
      }
      function w(_) {
        a.value === 'year' && D(), n('update:year', _)
      }
      return (
        be(o, (_, S) => {
          const E = Pt(S),
            C = Pt(_)
          if (!C.length) return
          const R = r.date(E[E.length - 1]),
            B = r.date(C[C.length - 1]),
            U = r.getMonth(B),
            $ = r.getYear(B)
          U !== u.value && ((u.value = U), I(u.value)),
            $ !== c.value && ((c.value = $), w(c.value)),
            (d.value = r.isBefore(R, B))
        }),
        se(() => {
          const _ = GT.filterProps(e),
            S = ly.filterProps(e),
            E = uy.filterProps(e),
            C = cy.filterProps(e),
            R = Qt(dy.filterProps(e), ['modelValue']),
            B = Qt(hy.filterProps(e), ['modelValue']),
            U = { header: f.value, transition: p.value }
          return g(
            GT,
            ae(_, {
              class: [
                'v-date-picker',
                `v-date-picker--${a.value}`,
                { 'v-date-picker--show-week': e.showWeek },
                e.class,
              ],
              style: e.style,
            }),
            {
              title: () => {
                var $
                return (
                  (($ = i.title) == null ? void 0 : $.call(i)) ??
                  g('div', { class: 'v-date-picker__title' }, [s(e.title)])
                )
              },
              header: () =>
                i.header
                  ? g(
                      Ge,
                      { defaults: { VDatePickerHeader: { ...U } } },
                      {
                        default: () => {
                          var $
                          return [($ = i.header) == null ? void 0 : $.call(i, U)]
                        },
                      }
                    )
                  : g(uy, ae({ key: 'header' }, E, U, { onClick: a.value !== 'month' ? N : void 0 }), {
                      ...i,
                      default: void 0,
                    }),
              default: () =>
                g(ke, null, [
                  g(
                    ly,
                    ae(S, {
                      disabled: T.value,
                      text: m.value,
                      'onClick:next': A,
                      'onClick:prev': x,
                      'onClick:month': V,
                      'onClick:year': D,
                    }),
                    null
                  ),
                  g(
                    kc,
                    { hideOnLeave: !0 },
                    {
                      default: () => [
                        a.value === 'months'
                          ? g(
                              dy,
                              ae({ key: 'date-picker-months' }, R, {
                                modelValue: u.value,
                                'onUpdate:modelValue': [($) => (u.value = $), I],
                                min: v.value,
                                max: y.value,
                                year: c.value,
                              }),
                              null
                            )
                          : a.value === 'year'
                          ? g(
                              hy,
                              ae({ key: 'date-picker-years' }, B, {
                                modelValue: c.value,
                                'onUpdate:modelValue': [($) => (c.value = $), w],
                                min: v.value,
                                max: y.value,
                              }),
                              null
                            )
                          : g(
                              cy,
                              ae({ key: 'date-picker-month' }, C, {
                                modelValue: o.value,
                                'onUpdate:modelValue': ($) => (o.value = $),
                                month: u.value,
                                'onUpdate:month': [($) => (u.value = $), I],
                                year: c.value,
                                'onUpdate:year': [($) => (c.value = $), w],
                                min: v.value,
                                max: y.value,
                              }),
                              null
                            ),
                      ],
                    }
                  ),
                ]),
              actions: i.actions,
            }
          )
        }),
        {}
      )
    },
  }),
  hJ = W(
    {
      actionText: String,
      bgColor: String,
      color: String,
      icon: Le,
      image: String,
      justify: { type: String, default: 'center' },
      headline: String,
      title: String,
      text: String,
      textWidth: { type: [Number, String], default: 500 },
      href: String,
      to: String,
      ...Te(),
      ...on(),
      ..._r({ size: void 0 }),
      ...Ze(),
    },
    'VEmptyState'
  ),
  fJ = ne()({
    name: 'VEmptyState',
    props: hJ(),
    emits: { 'click:action': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const { themeClasses: r } = at(e),
        { backgroundColorClasses: s, backgroundColorStyles: o } = gt(Q(e, 'bgColor')),
        { dimensionStyles: a } = an(e),
        { displayClasses: l } = Ni()
      function u(c) {
        n('click:action', c)
      }
      return (
        se(() => {
          var y, T, A
          const c = !!(i.actions || e.actionText),
            d = !!(i.headline || e.headline),
            f = !!(i.title || e.title),
            m = !!(i.text || e.text),
            p = !!(i.media || e.image || e.icon),
            v = e.size || (e.image ? 200 : 96)
          return g(
            'div',
            {
              class: ['v-empty-state', { [`v-empty-state--${e.justify}`]: !0 }, r.value, s.value, l.value, e.class],
              style: [o.value, a.value, e.style],
            },
            [
              p &&
                g('div', { key: 'media', class: 'v-empty-state__media' }, [
                  i.media
                    ? g(
                        Ge,
                        {
                          key: 'media-defaults',
                          defaults: { VImg: { src: e.image, height: v }, VIcon: { size: v, icon: e.icon } },
                        },
                        { default: () => [i.media()] }
                      )
                    : g(ke, null, [
                        e.image
                          ? g(Br, { key: 'image', src: e.image, height: v }, null)
                          : e.icon
                          ? g(ot, { key: 'icon', color: e.color, size: v, icon: e.icon }, null)
                          : void 0,
                      ]),
                ]),
              d &&
                g('div', { key: 'headline', class: 'v-empty-state__headline' }, [
                  ((y = i.headline) == null ? void 0 : y.call(i)) ?? e.headline,
                ]),
              f &&
                g('div', { key: 'title', class: 'v-empty-state__title' }, [
                  ((T = i.title) == null ? void 0 : T.call(i)) ?? e.title,
                ]),
              m &&
                g('div', { key: 'text', class: 'v-empty-state__text', style: { maxWidth: Se(e.textWidth) } }, [
                  ((A = i.text) == null ? void 0 : A.call(i)) ?? e.text,
                ]),
              i.default && g('div', { key: 'content', class: 'v-empty-state__content' }, [i.default()]),
              c &&
                g('div', { key: 'actions', class: 'v-empty-state__actions' }, [
                  g(
                    Ge,
                    {
                      defaults: {
                        VBtn: {
                          class: 'v-empty-state__action-btn',
                          color: e.color ?? 'surface-variant',
                          text: e.actionText,
                        },
                      },
                    },
                    {
                      default: () => {
                        var x
                        return [
                          ((x = i.actions) == null ? void 0 : x.call(i, { props: { onClick: u } })) ??
                            g(st, { onClick: u }, null),
                        ]
                      },
                    }
                  ),
                ]),
            ]
          )
        }),
        {}
      )
    },
  }),
  Oc = Symbol.for('vuetify:v-expansion-panel'),
  hO = W({ ...Te(), ...Jb() }, 'VExpansionPanelText'),
  fy = ne()({
    name: 'VExpansionPanelText',
    props: hO(),
    setup(e, t) {
      let { slots: n } = t
      const i = je(Oc)
      if (!i) throw new Error('[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel')
      const { hasContent: r, onAfterLeave: s } = Zb(e, i.isSelected)
      return (
        se(() =>
          g(
            Vm,
            { onAfterLeave: s },
            {
              default: () => {
                var o
                return [
                  Rt(
                    g('div', { class: ['v-expansion-panel-text', e.class], style: e.style }, [
                      n.default &&
                        r.value &&
                        g('div', { class: 'v-expansion-panel-text__wrapper' }, [
                          (o = n.default) == null ? void 0 : o.call(n),
                        ]),
                    ]),
                    [[Qi, i.isSelected.value]]
                  ),
                ]
              },
            }
          )
        ),
        {}
      )
    },
  }),
  fO = W(
    {
      color: String,
      expandIcon: { type: Le, default: '$expand' },
      collapseIcon: { type: Le, default: '$collapse' },
      hideActions: Boolean,
      focusable: Boolean,
      static: Boolean,
      ripple: { type: [Boolean, Object], default: !1 },
      readonly: Boolean,
      ...Te(),
    },
    'VExpansionPanelTitle'
  ),
  my = ne()({
    name: 'VExpansionPanelTitle',
    directives: { Ripple: Yr },
    props: fO(),
    setup(e, t) {
      let { slots: n } = t
      const i = je(Oc)
      if (!i) throw new Error('[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel')
      const { backgroundColorClasses: r, backgroundColorStyles: s } = gt(e, 'color'),
        o = k(() => ({
          collapseIcon: e.collapseIcon,
          disabled: i.disabled.value,
          expanded: i.isSelected.value,
          expandIcon: e.expandIcon,
          readonly: e.readonly,
        })),
        a = k(() => (i.isSelected.value ? e.collapseIcon : e.expandIcon))
      return (
        se(() => {
          var l
          return Rt(
            g(
              'button',
              {
                class: [
                  'v-expansion-panel-title',
                  {
                    'v-expansion-panel-title--active': i.isSelected.value,
                    'v-expansion-panel-title--focusable': e.focusable,
                    'v-expansion-panel-title--static': e.static,
                  },
                  r.value,
                  e.class,
                ],
                style: [s.value, e.style],
                type: 'button',
                tabindex: i.disabled.value ? -1 : void 0,
                disabled: i.disabled.value,
                'aria-expanded': i.isSelected.value,
                onClick: e.readonly ? void 0 : i.toggle,
              },
              [
                g('span', { class: 'v-expansion-panel-title__overlay' }, null),
                (l = n.default) == null ? void 0 : l.call(n, o.value),
                !e.hideActions &&
                  g(
                    Ge,
                    { defaults: { VIcon: { icon: a.value } } },
                    {
                      default: () => {
                        var u
                        return [
                          g('span', { class: 'v-expansion-panel-title__icon' }, [
                            ((u = n.actions) == null ? void 0 : u.call(n, o.value)) ?? g(ot, null, null),
                          ]),
                        ]
                      },
                    }
                  ),
              ]
            ),
            [[pi('ripple'), e.ripple]]
          )
        }),
        {}
      )
    },
  }),
  mO = W(
    { title: String, text: String, bgColor: String, ...en(), ...va(), ...Tt(), ...He(), ...fO(), ...hO() },
    'VExpansionPanel'
  ),
  mJ = ne()({
    name: 'VExpansionPanel',
    props: mO(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = pa(e, Oc),
        { backgroundColorClasses: r, backgroundColorStyles: s } = gt(e, 'bgColor'),
        { elevationClasses: o } = yn(e),
        { roundedClasses: a } = Mt(e),
        l = k(() => (i == null ? void 0 : i.disabled.value) || e.disabled),
        u = k(() =>
          i.group.items.value.reduce((f, m, p) => (i.group.selected.value.includes(m.id) && f.push(p), f), [])
        ),
        c = k(() => {
          const f = i.group.items.value.findIndex((m) => m.id === i.id)
          return !i.isSelected.value && u.value.some((m) => m - f === 1)
        }),
        d = k(() => {
          const f = i.group.items.value.findIndex((m) => m.id === i.id)
          return !i.isSelected.value && u.value.some((m) => m - f === -1)
        })
      return (
        mt(Oc, i),
        se(() => {
          const f = !!(n.text || e.text),
            m = !!(n.title || e.title),
            p = my.filterProps(e),
            v = fy.filterProps(e)
          return g(
            e.tag,
            {
              class: [
                'v-expansion-panel',
                {
                  'v-expansion-panel--active': i.isSelected.value,
                  'v-expansion-panel--before-active': c.value,
                  'v-expansion-panel--after-active': d.value,
                  'v-expansion-panel--disabled': l.value,
                },
                a.value,
                r.value,
                e.class,
              ],
              style: [s.value, e.style],
            },
            {
              default: () => [
                g('div', { class: ['v-expansion-panel__shadow', ...o.value] }, null),
                g(
                  Ge,
                  { defaults: { VExpansionPanelTitle: { ...p }, VExpansionPanelText: { ...v } } },
                  {
                    default: () => {
                      var y
                      return [
                        m && g(my, { key: 'title' }, { default: () => [n.title ? n.title() : e.title] }),
                        f && g(fy, { key: 'text' }, { default: () => [n.text ? n.text() : e.text] }),
                        (y = n.default) == null ? void 0 : y.call(n),
                      ]
                    },
                  }
                ),
              ],
            }
          )
        }),
        { groupItem: i }
      )
    },
  }),
  gJ = ['default', 'accordion', 'inset', 'popout'],
  vJ = W(
    {
      flat: Boolean,
      ...ga(),
      ...kb(mO(), [
        'bgColor',
        'collapseIcon',
        'color',
        'eager',
        'elevation',
        'expandIcon',
        'focusable',
        'hideActions',
        'readonly',
        'ripple',
        'rounded',
        'tile',
        'static',
      ]),
      ...Ze(),
      ...Te(),
      ...He(),
      variant: { type: String, default: 'default', validator: (e) => gJ.includes(e) },
    },
    'VExpansionPanels'
  ),
  pJ = ne()({
    name: 'VExpansionPanels',
    props: vJ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { next: i, prev: r } = Ys(e, Oc),
        { themeClasses: s } = at(e),
        o = k(() => e.variant && `v-expansion-panels--variant-${e.variant}`)
      return (
        Ot({
          VExpansionPanel: {
            bgColor: Q(e, 'bgColor'),
            collapseIcon: Q(e, 'collapseIcon'),
            color: Q(e, 'color'),
            eager: Q(e, 'eager'),
            elevation: Q(e, 'elevation'),
            expandIcon: Q(e, 'expandIcon'),
            focusable: Q(e, 'focusable'),
            hideActions: Q(e, 'hideActions'),
            readonly: Q(e, 'readonly'),
            ripple: Q(e, 'ripple'),
            rounded: Q(e, 'rounded'),
            static: Q(e, 'static'),
          },
        }),
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-expansion-panels',
                { 'v-expansion-panels--flat': e.flat, 'v-expansion-panels--tile': e.tile },
                s.value,
                o.value,
                e.class,
              ],
              style: e.style,
            },
            {
              default: () => {
                var a
                return [(a = n.default) == null ? void 0 : a.call(n, { prev: r, next: i })]
              },
            }
          )
        ),
        { next: i, prev: r }
      )
    },
  }),
  yJ = W(
    {
      app: Boolean,
      appear: Boolean,
      extended: Boolean,
      layout: Boolean,
      offset: Boolean,
      modelValue: { type: Boolean, default: !0 },
      ...Qt(Mm({ active: !0 }), ['location']),
      ...da(),
      ...Kr(),
      ...Xi({ transition: 'fab-transition' }),
    },
    'VFab'
  ),
  _J = ne()({
    name: 'VFab',
    props: yJ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        r = ye(56),
        s = le(),
        { resizeRef: o } = Gi((d) => {
          d.length && (r.value = d[0].target.clientHeight)
        }),
        a = k(() => e.app || e.absolute),
        l = k(() => {
          var d
          return a.value ? ((d = e.location) == null ? void 0 : d.split(' ').shift()) ?? 'bottom' : !1
        }),
        u = k(() => {
          var d
          return a.value ? ((d = e.location) == null ? void 0 : d.split(' ')[1]) ?? 'end' : !1
        })
      ii(
        () => e.app,
        () => {
          const d = ha({
            id: e.name,
            order: k(() => parseInt(e.order, 10)),
            position: l,
            layoutSize: k(() => (e.layout ? r.value + 24 : 0)),
            elementSize: k(() => r.value + 24),
            active: k(() => e.app && i.value),
            absolute: Q(e, 'absolute'),
          })
          $t(() => {
            s.value = d.layoutItemStyles.value
          })
        }
      )
      const c = le()
      return (
        se(() => {
          const d = st.filterProps(e)
          return g(
            'div',
            {
              ref: c,
              class: [
                'v-fab',
                {
                  'v-fab--absolute': e.absolute,
                  'v-fab--app': !!e.app,
                  'v-fab--extended': e.extended,
                  'v-fab--offset': e.offset,
                  [`v-fab--${l.value}`]: a.value,
                  [`v-fab--${u.value}`]: a.value,
                },
                e.class,
              ],
              style: [e.app ? { ...s.value } : { height: 'inherit', width: void 0 }, e.style],
            },
            [
              g('div', { class: 'v-fab__container' }, [
                g(
                  Bn,
                  { appear: e.appear, transition: e.transition },
                  {
                    default: () => [
                      Rt(g(st, ae({ ref: o }, d, { active: void 0, location: void 0 }), n), [[Qi, e.active]]),
                    ],
                  }
                ),
              ]),
            ]
          )
        }),
        {}
      )
    },
  }),
  bJ = W(
    {
      chips: Boolean,
      counter: Boolean,
      counterSizeString: { type: String, default: '$vuetify.fileInput.counterSize' },
      counterString: { type: String, default: '$vuetify.fileInput.counter' },
      hideInput: Boolean,
      multiple: Boolean,
      showSize: {
        type: [Boolean, Number, String],
        default: !1,
        validator: (e) => typeof e == 'boolean' || [1e3, 1024].includes(Number(e)),
      },
      ...Xr({ prependIcon: '$file' }),
      modelValue: {
        type: [Array, Object],
        default: (e) => (e.multiple ? [] : null),
        validator: (e) => Pt(e).every((t) => t != null && typeof t == 'object'),
      },
      ...vd({ clearable: !0 }),
    },
    'VFileInput'
  ),
  wJ = ne()({
    name: 'VFileInput',
    inheritAttrs: !1,
    props: bJ(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const { t: s } = jt(),
        o = xe(
          e,
          'modelValue',
          e.modelValue,
          (_) => Pt(_),
          (_) => (e.multiple || Array.isArray(e.modelValue) ? _ : _[0] ?? null)
        ),
        { isFocused: a, focus: l, blur: u } = Qr(e),
        c = k(() => (typeof e.showSize != 'boolean' ? e.showSize : void 0)),
        d = k(() =>
          (o.value ?? []).reduce((_, S) => {
            let { size: E = 0 } = S
            return _ + E
          }, 0)
        ),
        f = k(() => rT(d.value, c.value)),
        m = k(() =>
          (o.value ?? []).map((_) => {
            const { name: S = '', size: E = 0 } = _
            return e.showSize ? `${S} (${rT(E, c.value)})` : S
          })
        ),
        p = k(() => {
          var S
          const _ = ((S = o.value) == null ? void 0 : S.length) ?? 0
          return e.showSize ? s(e.counterSizeString, _, f.value) : s(e.counterString, _)
        }),
        v = le(),
        y = le(),
        T = le(),
        A = k(() => a.value || e.active),
        x = k(() => ['plain', 'underlined'].includes(e.variant))
      function N() {
        var _
        T.value !== document.activeElement && ((_ = T.value) == null || _.focus()), a.value || l()
      }
      function V(_) {
        var S
        ;(S = T.value) == null || S.click()
      }
      function D(_) {
        i('mousedown:control', _)
      }
      function I(_) {
        var S
        ;(S = T.value) == null || S.click(), i('click:control', _)
      }
      function w(_) {
        _.stopPropagation(),
          N(),
          Xe(() => {
            ;(o.value = []), Rb(e['onClick:clear'], _)
          })
      }
      return (
        be(o, (_) => {
          ;(!Array.isArray(_) || !_.length) && T.value && (T.value.value = '')
        }),
        se(() => {
          const _ = !!(r.counter || e.counter),
            S = !!(_ || r.details),
            [E, C] = Gs(n),
            { modelValue: R, ...B } = Cn.filterProps(e),
            U = ew(e)
          return g(
            Cn,
            ae(
              {
                ref: v,
                modelValue: o.value,
                'onUpdate:modelValue': ($) => (o.value = $),
                class: [
                  'v-file-input',
                  {
                    'v-file-input--chips': !!e.chips,
                    'v-file-input--hide': e.hideInput,
                    'v-input--plain-underlined': x.value,
                  },
                  e.class,
                ],
                style: e.style,
                'onClick:prepend': V,
              },
              E,
              B,
              { centerAffix: !x.value, focused: a.value }
            ),
            {
              ...r,
              default: ($) => {
                let { id: G, isDisabled: F, isDirty: K, isReadonly: j, isValid: q } = $
                return g(
                  Ql,
                  ae(
                    {
                      ref: y,
                      'prepend-icon': e.prependIcon,
                      onMousedown: D,
                      onClick: I,
                      'onClick:clear': w,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner'],
                    },
                    U,
                    {
                      id: G.value,
                      active: A.value || K.value,
                      dirty: K.value || e.dirty,
                      disabled: F.value,
                      focused: a.value,
                      error: q.value === !1,
                    }
                  ),
                  {
                    ...r,
                    default: (te) => {
                      var me
                      let {
                        props: { class: ce, ...Ee },
                      } = te
                      return g(ke, null, [
                        g(
                          'input',
                          ae(
                            {
                              ref: T,
                              type: 'file',
                              readonly: j.value,
                              disabled: F.value,
                              multiple: e.multiple,
                              name: e.name,
                              onClick: (oe) => {
                                oe.stopPropagation(), j.value && oe.preventDefault(), N()
                              },
                              onChange: (oe) => {
                                if (!oe.target) return
                                const z = oe.target
                                o.value = [...(z.files ?? [])]
                              },
                              onFocus: N,
                              onBlur: u,
                            },
                            Ee,
                            C
                          ),
                          null
                        ),
                        g('div', { class: ce }, [
                          !!((me = o.value) != null && me.length) &&
                            !e.hideInput &&
                            (r.selection
                              ? r.selection({ fileNames: m.value, totalBytes: d.value, totalBytesReadable: f.value })
                              : e.chips
                              ? m.value.map((oe) => g(Yl, { key: oe, size: 'small', text: oe }, null))
                              : m.value.join(', ')),
                        ]),
                      ])
                    },
                  }
                )
              },
              details: S
                ? ($) => {
                    var G, F
                    return g(ke, null, [
                      (G = r.details) == null ? void 0 : G.call(r, $),
                      _ &&
                        g(ke, null, [
                          g('span', null, null),
                          g(
                            $m,
                            { active: !!((F = o.value) != null && F.length), value: p.value, disabled: e.disabled },
                            r.counter
                          ),
                        ]),
                    ])
                  }
                : void 0,
            }
          )
        }),
        Li({}, v, y, T)
      )
    },
  }),
  IJ = W(
    {
      app: Boolean,
      color: String,
      height: { type: [Number, String], default: 'auto' },
      ...bi(),
      ...Te(),
      ...en(),
      ...da(),
      ...Tt(),
      ...He({ tag: 'footer' }),
      ...Ze(),
    },
    'VFooter'
  ),
  SJ = ne()({
    name: 'VFooter',
    props: IJ(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { backgroundColorClasses: r, backgroundColorStyles: s } = gt(Q(e, 'color')),
        { borderClasses: o } = Oi(e),
        { elevationClasses: a } = yn(e),
        { roundedClasses: l } = Mt(e),
        u = ye(32),
        { resizeRef: c } = Gi((p) => {
          p.length && (u.value = p[0].target.clientHeight)
        }),
        d = k(() => (e.height === 'auto' ? u.value : parseInt(e.height, 10))),
        { layoutItemStyles: f, layoutIsReady: m } = ha({
          id: e.name,
          order: k(() => parseInt(e.order, 10)),
          position: k(() => 'bottom'),
          layoutSize: d,
          elementSize: k(() => (e.height === 'auto' ? void 0 : d.value)),
          active: k(() => e.app),
          absolute: Q(e, 'absolute'),
        })
      return (
        se(() =>
          g(
            e.tag,
            {
              ref: c,
              class: ['v-footer', i.value, r.value, o.value, a.value, l.value, e.class],
              style: [s.value, e.app ? f.value : { height: Se(e.height) }, e.style],
            },
            n
          )
        ),
        e.app ? m : {}
      )
    },
  }),
  EJ = W({ ...Te(), ...x8() }, 'VForm'),
  TJ = ne()({
    name: 'VForm',
    props: EJ(),
    emits: { 'update:modelValue': (e) => !0, submit: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const r = V8(e),
        s = le()
      function o(l) {
        l.preventDefault(), r.reset()
      }
      function a(l) {
        const u = l,
          c = r.validate()
        ;(u.then = c.then.bind(c)),
          (u.catch = c.catch.bind(c)),
          (u.finally = c.finally.bind(c)),
          i('submit', u),
          u.defaultPrevented ||
            c.then((d) => {
              var m
              let { valid: f } = d
              f && ((m = s.value) == null || m.submit())
            }),
          u.preventDefault()
      }
      return (
        se(() => {
          var l
          return g(
            'form',
            { ref: s, class: ['v-form', e.class], style: e.style, novalidate: !0, onReset: o, onSubmit: a },
            [(l = n.default) == null ? void 0 : l.call(n, r)]
          )
        }),
        Li(r, s)
      )
    },
  }),
  CJ = W({ disabled: Boolean, modelValue: { type: Boolean, default: null }, ...Qb() }, 'VHover'),
  AJ = ne()({
    name: 'VHover',
    props: CJ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        { runOpenDelay: r, runCloseDelay: s } = Xb(e, (o) => !e.disabled && (i.value = o))
      return () => {
        var o
        return (o = n.default) == null
          ? void 0
          : o.call(n, { isHovering: i.value, props: { onMouseenter: r, onMouseleave: s } })
      }
    },
  }),
  kJ = W(
    {
      color: String,
      direction: { type: String, default: 'vertical', validator: (e) => ['vertical', 'horizontal'].includes(e) },
      side: { type: String, default: 'end', validator: (e) => ['start', 'end', 'both'].includes(e) },
      mode: { type: String, default: 'intersect', validator: (e) => ['intersect', 'manual'].includes(e) },
      margin: [Number, String],
      loadMoreText: { type: String, default: '$vuetify.infiniteScroll.loadMore' },
      emptyText: { type: String, default: '$vuetify.infiniteScroll.empty' },
      ...on(),
      ...He(),
    },
    'VInfiniteScroll'
  ),
  KT = yi({
    name: 'VInfiniteScrollIntersect',
    props: { side: { type: String, required: !0 }, rootRef: null, rootMargin: String },
    emits: { intersect: (e, t) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const { intersectionRef: i, isIntersecting: r } = Dm(
        (s) => {},
        e.rootMargin ? { rootMargin: e.rootMargin } : void 0
      )
      return (
        be(r, async (s) => {
          n('intersect', e.side, s)
        }),
        se(() => g('div', { class: 'v-infinite-scroll-intersect', ref: i }, [Or(' ')])),
        {}
      )
    },
  }),
  PJ = ne()({
    name: 'VInfiniteScroll',
    props: kJ(),
    emits: { load: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const r = le(),
        s = ye('ok'),
        o = ye('ok'),
        a = k(() => Se(e.margin)),
        l = ye(!1)
      function u(V) {
        if (!r.value) return
        const D = e.direction === 'vertical' ? 'scrollTop' : 'scrollLeft'
        r.value[D] = V
      }
      function c() {
        if (!r.value) return 0
        const V = e.direction === 'vertical' ? 'scrollTop' : 'scrollLeft'
        return r.value[V]
      }
      function d() {
        if (!r.value) return 0
        const V = e.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth'
        return r.value[V]
      }
      function f() {
        if (!r.value) return 0
        const V = e.direction === 'vertical' ? 'clientHeight' : 'clientWidth'
        return r.value[V]
      }
      An(() => {
        r.value && (e.side === 'start' ? u(d()) : e.side === 'both' && u(d() / 2 - f() / 2))
      })
      function m(V, D) {
        V === 'start' ? (s.value = D) : V === 'end' && (o.value = D)
      }
      function p(V) {
        return V === 'start' ? s.value : o.value
      }
      let v = 0
      function y(V, D) {
        ;(l.value = D), l.value && T(V)
      }
      function T(V) {
        if (e.mode !== 'manual' && !l.value) return
        const D = p(V)
        if (!r.value || ['empty', 'loading'].includes(D)) return
        ;(v = d()), m(V, 'loading')
        function I(w) {
          m(V, w),
            Xe(() => {
              w === 'empty' ||
                w === 'error' ||
                (w === 'ok' && V === 'start' && u(d() - v + c()),
                e.mode !== 'manual' &&
                  Xe(() => {
                    window.requestAnimationFrame(() => {
                      window.requestAnimationFrame(() => {
                        window.requestAnimationFrame(() => {
                          T(V)
                        })
                      })
                    })
                  }))
            })
        }
        i('load', { side: V, done: I })
      }
      const { t: A } = jt()
      function x(V, D) {
        var _, S, E, C, R
        if (e.side !== V && e.side !== 'both') return
        const I = () => T(V),
          w = { side: V, props: { onClick: I, color: e.color } }
        return D === 'error'
          ? (_ = n.error) == null
            ? void 0
            : _.call(n, w)
          : D === 'empty'
          ? ((S = n.empty) == null ? void 0 : S.call(n, w)) ?? g('div', null, [A(e.emptyText)])
          : e.mode === 'manual'
          ? D === 'loading'
            ? ((E = n.loading) == null ? void 0 : E.call(n, w)) ?? g(Rl, { indeterminate: !0, color: e.color }, null)
            : ((C = n['load-more']) == null ? void 0 : C.call(n, w)) ??
              g(st, { variant: 'outlined', color: e.color, onClick: I }, { default: () => [A(e.loadMoreText)] })
          : ((R = n.loading) == null ? void 0 : R.call(n, w)) ?? g(Rl, { indeterminate: !0, color: e.color }, null)
      }
      const { dimensionStyles: N } = an(e)
      se(() => {
        const V = e.tag,
          D = e.side === 'start' || e.side === 'both',
          I = e.side === 'end' || e.side === 'both',
          w = e.mode === 'intersect'
        return g(
          V,
          {
            ref: r,
            class: [
              'v-infinite-scroll',
              `v-infinite-scroll--${e.direction}`,
              { 'v-infinite-scroll--start': D, 'v-infinite-scroll--end': I },
            ],
            style: N.value,
          },
          {
            default: () => {
              var _
              return [
                g('div', { class: 'v-infinite-scroll__side' }, [x('start', s.value)]),
                r.value &&
                  D &&
                  w &&
                  g(KT, { key: 'start', side: 'start', onIntersect: y, rootRef: r.value, rootMargin: a.value }, null),
                (_ = n.default) == null ? void 0 : _.call(n),
                r.value &&
                  I &&
                  w &&
                  g(KT, { key: 'end', side: 'end', onIntersect: y, rootRef: r.value, rootMargin: a.value }, null),
                g('div', { class: 'v-infinite-scroll__side' }, [x('end', o.value)]),
              ]
            },
          }
        )
      })
    },
  }),
  gO = Symbol.for('vuetify:v-item-group'),
  RJ = W({ ...Te(), ...ga({ selectedClass: 'v-item--selected' }), ...He(), ...Ze() }, 'VItemGroup'),
  xJ = ne()({
    name: 'VItemGroup',
    props: RJ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { isSelected: r, select: s, next: o, prev: a, selected: l } = Ys(e, gO)
      return () =>
        g(
          e.tag,
          { class: ['v-item-group', i.value, e.class], style: e.style },
          {
            default: () => {
              var u
              return [
                (u = n.default) == null
                  ? void 0
                  : u.call(n, { isSelected: r, select: s, next: o, prev: a, selected: l.value }),
              ]
            },
          }
        )
    },
  }),
  VJ = ne()({
    name: 'VItem',
    props: va(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isSelected: i, select: r, toggle: s, selectedClass: o, value: a, disabled: l } = pa(e, gO)
      return () => {
        var u
        return (u = n.default) == null
          ? void 0
          : u.call(n, {
              isSelected: i.value,
              selectedClass: o.value,
              select: r,
              toggle: s,
              value: a.value,
              disabled: l.value,
            })
      }
    },
  }),
  DJ = yr('v-kbd'),
  NJ = W({ ...Te(), ...on(), ...rD() }, 'VLayout'),
  OJ = ne()({
    name: 'VLayout',
    props: NJ(),
    setup(e, t) {
      let { slots: n } = t
      const { layoutClasses: i, layoutStyles: r, getLayoutItem: s, items: o, layoutRef: a } = oD(e),
        { dimensionStyles: l } = an(e)
      return (
        se(() =>
          g('div', { ref: a, class: [i.value, e.class], style: [l.value, r.value, e.style] }, [
            g(RA, null, {
              default: () => {
                var u
                return [g(ke, null, [(u = n.default) == null ? void 0 : u.call(n)])]
              },
            }),
          ])
        ),
        { getLayoutItem: s, items: o }
      )
    },
  }),
  MJ = W(
    {
      position: { type: String, required: !0 },
      size: { type: [Number, String], default: 300 },
      modelValue: Boolean,
      ...Te(),
      ...da(),
    },
    'VLayoutItem'
  ),
  LJ = ne()({
    name: 'VLayoutItem',
    props: MJ(),
    setup(e, t) {
      let { slots: n } = t
      const { layoutItemStyles: i, layoutIsReady: r } = ha({
        id: e.name,
        order: k(() => parseInt(e.order, 10)),
        position: Q(e, 'position'),
        elementSize: Q(e, 'size'),
        layoutSize: Q(e, 'size'),
        active: Q(e, 'modelValue'),
        absolute: Q(e, 'absolute'),
      })
      return (
        se(() => {
          var s
          return g('div', { class: ['v-layout-item', e.class], style: [i.value, e.style] }, [
            (s = n.default) == null ? void 0 : s.call(n),
          ])
        }),
        r
      )
    },
  }),
  FJ = W(
    {
      modelValue: Boolean,
      options: { type: Object, default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }) },
      ...Te(),
      ...on(),
      ...He(),
      ...Xi({ transition: 'fade-transition' }),
    },
    'VLazy'
  ),
  BJ = ne()({
    name: 'VLazy',
    directives: { intersect: ld },
    props: FJ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: i } = an(e),
        r = xe(e, 'modelValue')
      function s(o) {
        r.value || (r.value = o)
      }
      return (
        se(() =>
          Rt(
            g(
              e.tag,
              { class: ['v-lazy', e.class], style: [i.value, e.style] },
              {
                default: () => [
                  r.value &&
                    g(
                      Bn,
                      { transition: e.transition, appear: !0 },
                      {
                        default: () => {
                          var o
                          return [(o = n.default) == null ? void 0 : o.call(n)]
                        },
                      }
                    ),
                ],
              }
            ),
            [[pi('intersect'), { handler: s, options: e.options }, null]]
          )
        ),
        {}
      )
    },
  }),
  $J = W(
    { locale: String, fallbackLocale: String, messages: Object, rtl: { type: Boolean, default: void 0 }, ...Te() },
    'VLocaleProvider'
  ),
  UJ = ne()({
    name: 'VLocaleProvider',
    props: $J(),
    setup(e, t) {
      let { slots: n } = t
      const { rtlClasses: i } = AK(e)
      return (
        se(() => {
          var r
          return g('div', { class: ['v-locale-provider', i.value, e.class], style: e.style }, [
            (r = n.default) == null ? void 0 : r.call(n),
          ])
        }),
        {}
      )
    },
  }),
  jJ = W({ scrollable: Boolean, ...Te(), ...on(), ...He({ tag: 'main' }) }, 'VMain'),
  zJ = ne()({
    name: 'VMain',
    props: jJ(),
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: i } = an(e),
        { mainStyles: r, layoutIsReady: s } = sD(),
        { ssrBootStyles: o } = fa()
      return (
        se(() =>
          g(
            e.tag,
            {
              class: ['v-main', { 'v-main--scrollable': e.scrollable }, e.class],
              style: [r.value, o.value, i.value, e.style],
            },
            {
              default: () => {
                var a, l
                return [
                  e.scrollable
                    ? g('div', { class: 'v-main__scroller' }, [(a = n.default) == null ? void 0 : a.call(n)])
                    : (l = n.default) == null
                    ? void 0
                    : l.call(n),
                ]
              },
            }
          )
        ),
        s
      )
    },
  })
function HJ(e) {
  let { rootEl: t, isSticky: n, layoutItemStyles: i } = e
  const r = ye(!1),
    s = ye(0),
    o = k(() => {
      const u = typeof r.value == 'boolean' ? 'top' : r.value
      return [
        n.value ? { top: 'auto', bottom: 'auto', height: void 0 } : void 0,
        r.value ? { [u]: Se(s.value) } : { top: i.value.top },
      ]
    })
  An(() => {
    be(
      n,
      (u) => {
        u ? window.addEventListener('scroll', l, { passive: !0 }) : window.removeEventListener('scroll', l)
      },
      { immediate: !0 }
    )
  }),
    kn(() => {
      window.removeEventListener('scroll', l)
    })
  let a = 0
  function l() {
    const u = a > window.scrollY ? 'up' : 'down',
      c = t.value.getBoundingClientRect(),
      d = parseFloat(i.value.top ?? 0),
      f = window.scrollY - Math.max(0, s.value - d),
      m = c.height + Math.max(s.value, d) - window.scrollY - window.innerHeight,
      p = parseFloat(getComputedStyle(t.value).getPropertyValue('--v-body-scroll-y')) || 0
    c.height < window.innerHeight - d
      ? ((r.value = 'top'), (s.value = d))
      : (u === 'up' && r.value === 'bottom') || (u === 'down' && r.value === 'top')
      ? ((s.value = window.scrollY + c.top - p), (r.value = !0))
      : u === 'down' && m <= 0
      ? ((s.value = 0), (r.value = 'bottom'))
      : u === 'up' &&
        f <= 0 &&
        (p
          ? r.value !== 'top' && ((s.value = -f + p + d), (r.value = 'top'))
          : ((s.value = c.top + f), (r.value = 'top'))),
      (a = window.scrollY)
  }
  return { isStuck: r, stickyStyles: o }
}
const WJ = 100,
  qJ = 20
function YT(e) {
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * 1.41421356237
}
function QT(e) {
  if (e.length < 2) return 0
  if (e.length === 2) return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t)
  let t = 0
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t) continue
    const i = YT(t),
      r = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t)
    ;(t += (r - i) * Math.abs(r)), n === e.length - 1 && (t *= 0.5)
  }
  return YT(t) * 1e3
}
function GJ() {
  const e = {}
  function t(r) {
    Array.from(r.changedTouches).forEach((s) => {
      ;(e[s.identifier] ?? (e[s.identifier] = new UG(qJ))).push([r.timeStamp, s])
    })
  }
  function n(r) {
    Array.from(r.changedTouches).forEach((s) => {
      delete e[s.identifier]
    })
  }
  function i(r) {
    var u
    const s = (u = e[r]) == null ? void 0 : u.values().reverse()
    if (!s) throw new Error(`No samples for touch id ${r}`)
    const o = s[0],
      a = [],
      l = []
    for (const c of s) {
      if (o[0] - c[0] > WJ) break
      a.push({ t: c[0], d: c[1].clientX }), l.push({ t: c[0], d: c[1].clientY })
    }
    return {
      x: QT(a),
      y: QT(l),
      get direction() {
        const { x: c, y: d } = this,
          [f, m] = [Math.abs(c), Math.abs(d)]
        return f > m && c >= 0
          ? 'right'
          : f > m && c <= 0
          ? 'left'
          : m > f && d >= 0
          ? 'down'
          : m > f && d <= 0
          ? 'up'
          : KJ()
      },
    }
  }
  return { addMovement: t, endTouch: n, getVelocity: i }
}
function KJ() {
  throw new Error()
}
function YJ(e) {
  let { el: t, isActive: n, isTemporary: i, width: r, touchless: s, position: o } = e
  An(() => {
    window.addEventListener('touchstart', A, { passive: !0 }),
      window.addEventListener('touchmove', x, { passive: !1 }),
      window.addEventListener('touchend', N, { passive: !0 })
  }),
    kn(() => {
      window.removeEventListener('touchstart', A),
        window.removeEventListener('touchmove', x),
        window.removeEventListener('touchend', N)
    })
  const a = k(() => ['left', 'right'].includes(o.value)),
    { addMovement: l, endTouch: u, getVelocity: c } = GJ()
  let d = !1
  const f = ye(!1),
    m = ye(0),
    p = ye(0)
  let v
  function y(D, I) {
    return (
      (o.value === 'left'
        ? D
        : o.value === 'right'
        ? document.documentElement.clientWidth - D
        : o.value === 'top'
        ? D
        : o.value === 'bottom'
        ? document.documentElement.clientHeight - D
        : Oa()) - (I ? r.value : 0)
    )
  }
  function T(D) {
    let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
    const w =
      o.value === 'left'
        ? (D - p.value) / r.value
        : o.value === 'right'
        ? (document.documentElement.clientWidth - D - p.value) / r.value
        : o.value === 'top'
        ? (D - p.value) / r.value
        : o.value === 'bottom'
        ? (document.documentElement.clientHeight - D - p.value) / r.value
        : Oa()
    return I ? Math.max(0, Math.min(1, w)) : w
  }
  function A(D) {
    if (s.value) return
    const I = D.changedTouches[0].clientX,
      w = D.changedTouches[0].clientY,
      _ = 25,
      S =
        o.value === 'left'
          ? I < _
          : o.value === 'right'
          ? I > document.documentElement.clientWidth - _
          : o.value === 'top'
          ? w < _
          : o.value === 'bottom'
          ? w > document.documentElement.clientHeight - _
          : Oa(),
      E =
        n.value &&
        (o.value === 'left'
          ? I < r.value
          : o.value === 'right'
          ? I > document.documentElement.clientWidth - r.value
          : o.value === 'top'
          ? w < r.value
          : o.value === 'bottom'
          ? w > document.documentElement.clientHeight - r.value
          : Oa())
    ;(S || E || (n.value && i.value)) &&
      ((v = [I, w]),
      (p.value = y(a.value ? I : w, n.value)),
      (m.value = T(a.value ? I : w)),
      (d = p.value > -20 && p.value < 80),
      u(D),
      l(D))
  }
  function x(D) {
    const I = D.changedTouches[0].clientX,
      w = D.changedTouches[0].clientY
    if (d) {
      if (!D.cancelable) {
        d = !1
        return
      }
      const S = Math.abs(I - v[0]),
        E = Math.abs(w - v[1])
      ;(a.value ? S > E && S > 3 : E > S && E > 3) ? ((f.value = !0), (d = !1)) : (a.value ? E : S) > 3 && (d = !1)
    }
    if (!f.value) return
    D.preventDefault(), l(D)
    const _ = T(a.value ? I : w, !1)
    ;(m.value = Math.max(0, Math.min(1, _))),
      _ > 1 ? (p.value = y(a.value ? I : w, !0)) : _ < 0 && (p.value = y(a.value ? I : w, !1))
  }
  function N(D) {
    if (((d = !1), !f.value)) return
    l(D), (f.value = !1)
    const I = c(D.changedTouches[0].identifier),
      w = Math.abs(I.x),
      _ = Math.abs(I.y)
    ;(a.value ? w > _ && w > 400 : _ > w && _ > 3)
      ? (n.value = I.direction === ({ left: 'right', right: 'left', top: 'down', bottom: 'up' }[o.value] || Oa()))
      : (n.value = m.value > 0.5)
  }
  const V = k(() =>
    f.value
      ? {
          transform:
            o.value === 'left'
              ? `translateX(calc(-100% + ${m.value * r.value}px))`
              : o.value === 'right'
              ? `translateX(calc(100% - ${m.value * r.value}px))`
              : o.value === 'top'
              ? `translateY(calc(-100% + ${m.value * r.value}px))`
              : o.value === 'bottom'
              ? `translateY(calc(100% - ${m.value * r.value}px))`
              : Oa(),
          transition: 'none',
        }
      : void 0
  )
  return (
    ii(f, () => {
      var w, _
      const D = ((w = t.value) == null ? void 0 : w.style.transform) ?? null,
        I = ((_ = t.value) == null ? void 0 : _.style.transition) ?? null
      $t(() => {
        var S, E, C, R
        ;(E = t.value) == null ||
          E.style.setProperty('transform', ((S = V.value) == null ? void 0 : S.transform) || 'none'),
          (R = t.value) == null ||
            R.style.setProperty('transition', ((C = V.value) == null ? void 0 : C.transition) || null)
      }),
        gn(() => {
          var S, E
          ;(S = t.value) == null || S.style.setProperty('transform', D),
            (E = t.value) == null || E.style.setProperty('transition', I)
        })
    }),
    { isDragging: f, dragProgress: m, dragStyles: V }
  )
}
function Oa() {
  throw new Error()
}
const QJ = ['start', 'end', 'left', 'right', 'top', 'bottom'],
  XJ = W(
    {
      color: String,
      disableResizeWatcher: Boolean,
      disableRouteWatcher: Boolean,
      expandOnHover: Boolean,
      floating: Boolean,
      modelValue: { type: Boolean, default: null },
      permanent: Boolean,
      rail: { type: Boolean, default: null },
      railWidth: { type: [Number, String], default: 56 },
      scrim: { type: [Boolean, String], default: !0 },
      image: String,
      temporary: Boolean,
      persistent: Boolean,
      touchless: Boolean,
      width: { type: [Number, String], default: 256 },
      location: { type: String, default: 'start', validator: (e) => QJ.includes(e) },
      sticky: Boolean,
      ...bi(),
      ...Te(),
      ...Qb(),
      ...ca({ mobile: null }),
      ...en(),
      ...da(),
      ...Tt(),
      ...He({ tag: 'nav' }),
      ...Ze(),
    },
    'VNavigationDrawer'
  ),
  JJ = ne()({
    name: 'VNavigationDrawer',
    props: XJ(),
    emits: { 'update:modelValue': (e) => !0, 'update:rail': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const { isRtl: s } = sn(),
        { themeClasses: o } = at(e),
        { borderClasses: a } = Oi(e),
        { backgroundColorClasses: l, backgroundColorStyles: u } = gt(Q(e, 'color')),
        { elevationClasses: c } = yn(e),
        { displayClasses: d, mobile: f } = Ni(e),
        { roundedClasses: m } = Mt(e),
        p = pD(),
        v = xe(e, 'modelValue', null, (te) => !!te),
        { ssrBootStyles: y } = fa(),
        { scopeId: T } = _a(),
        A = le(),
        x = ye(!1),
        { runOpenDelay: N, runCloseDelay: V } = Xb(e, (te) => {
          x.value = te
        }),
        D = k(() => (e.rail && e.expandOnHover && x.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width))),
        I = k(() => Lp(e.location, s.value)),
        w = k(() => e.persistent),
        _ = k(() => !e.permanent && (f.value || e.temporary)),
        S = k(() => e.sticky && !_.value && I.value !== 'bottom')
      ii(
        () => e.expandOnHover && e.rail != null,
        () => {
          be(x, (te) => i('update:rail', !te))
        }
      ),
        ii(
          () => !e.disableResizeWatcher,
          () => {
            be(_, (te) => !e.permanent && Xe(() => (v.value = !te)))
          }
        ),
        ii(
          () => !e.disableRouteWatcher && !!p,
          () => {
            be(p.currentRoute, () => _.value && (v.value = !1))
          }
        ),
        be(
          () => e.permanent,
          (te) => {
            te && (v.value = !0)
          }
        ),
        e.modelValue == null && !_.value && (v.value = e.permanent || !f.value)
      const { isDragging: E, dragProgress: C } = YJ({
          el: A,
          isActive: v,
          isTemporary: _,
          width: D,
          touchless: Q(e, 'touchless'),
          position: I,
        }),
        R = k(() => {
          const te = _.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : D.value
          return E.value ? te * C.value : te
        }),
        B = k(() => (['top', 'bottom'].includes(e.location) ? 0 : D.value)),
        {
          layoutItemStyles: U,
          layoutItemScrimStyles: $,
          layoutIsReady: G,
        } = ha({
          id: e.name,
          order: k(() => parseInt(e.order, 10)),
          position: I,
          layoutSize: R,
          elementSize: B,
          active: k(() => v.value || E.value),
          disableTransitions: k(() => E.value),
          absolute: k(() => e.absolute || (S.value && typeof F.value != 'string')),
        }),
        { isStuck: F, stickyStyles: K } = HJ({ rootEl: A, isSticky: S, layoutItemStyles: U }),
        j = gt(k(() => (typeof e.scrim == 'string' ? e.scrim : null))),
        q = k(() => ({ ...(E.value ? { opacity: C.value * 0.2, transition: 'none' } : void 0), ...$.value }))
      return (
        Ot({ VList: { bgColor: 'transparent' } }),
        se(() => {
          const te = r.image || e.image
          return g(ke, null, [
            g(
              e.tag,
              ae(
                {
                  ref: A,
                  onMouseenter: N,
                  onMouseleave: V,
                  class: [
                    'v-navigation-drawer',
                    `v-navigation-drawer--${I.value}`,
                    {
                      'v-navigation-drawer--expand-on-hover': e.expandOnHover,
                      'v-navigation-drawer--floating': e.floating,
                      'v-navigation-drawer--is-hovering': x.value,
                      'v-navigation-drawer--rail': e.rail,
                      'v-navigation-drawer--temporary': _.value,
                      'v-navigation-drawer--persistent': w.value,
                      'v-navigation-drawer--active': v.value,
                      'v-navigation-drawer--sticky': S.value,
                    },
                    o.value,
                    l.value,
                    a.value,
                    d.value,
                    c.value,
                    m.value,
                    e.class,
                  ],
                  style: [
                    u.value,
                    U.value,
                    y.value,
                    K.value,
                    e.style,
                    ['top', 'bottom'].includes(I.value) ? { height: 'auto' } : {},
                  ],
                },
                T,
                n
              ),
              {
                default: () => {
                  var ce, Ee, me
                  return [
                    te &&
                      g('div', { key: 'image', class: 'v-navigation-drawer__img' }, [
                        r.image
                          ? g(
                              Ge,
                              {
                                key: 'image-defaults',
                                disabled: !e.image,
                                defaults: { VImg: { alt: '', cover: !0, height: 'inherit', src: e.image } },
                              },
                              r.image
                            )
                          : g(Br, { key: 'image-img', alt: '', cover: !0, height: 'inherit', src: e.image }, null),
                      ]),
                    r.prepend &&
                      g('div', { class: 'v-navigation-drawer__prepend' }, [
                        (ce = r.prepend) == null ? void 0 : ce.call(r),
                      ]),
                    g('div', { class: 'v-navigation-drawer__content' }, [
                      (Ee = r.default) == null ? void 0 : Ee.call(r),
                    ]),
                    r.append &&
                      g('div', { class: 'v-navigation-drawer__append' }, [
                        (me = r.append) == null ? void 0 : me.call(r),
                      ]),
                  ]
                },
              }
            ),
            g(
              dr,
              { name: 'fade-transition' },
              {
                default: () => [
                  _.value &&
                    (E.value || v.value) &&
                    !!e.scrim &&
                    g(
                      'div',
                      ae(
                        {
                          class: ['v-navigation-drawer__scrim', j.backgroundColorClasses.value],
                          style: [q.value, j.backgroundColorStyles.value],
                          onClick: () => {
                            w.value || (v.value = !1)
                          },
                        },
                        T
                      ),
                      null
                    ),
                ],
              }
            ),
          ])
        }),
        G.then(() => ({ isStuck: F }))
      )
    },
  }),
  ZJ = yi({
    name: 'VNoSsr',
    setup(e, t) {
      let { slots: n } = t
      const i = nN()
      return () => {
        var r
        return i.value && ((r = n.default) == null ? void 0 : r.call(n))
      }
    },
  }),
  eZ = W(
    {
      autofocus: Boolean,
      divider: String,
      focusAll: Boolean,
      label: { type: String, default: '$vuetify.input.otp' },
      length: { type: [Number, String], default: 6 },
      modelValue: { type: [Number, String], default: void 0 },
      placeholder: String,
      type: { type: String, default: 'number' },
      ...on(),
      ...fd(),
      ...Sm(vd({ variant: 'outlined' }), [
        'baseColor',
        'bgColor',
        'class',
        'color',
        'disabled',
        'error',
        'loading',
        'rounded',
        'style',
        'theme',
        'variant',
      ]),
    },
    'VOtpInput'
  ),
  tZ = ne()({
    name: 'VOtpInput',
    props: eZ(),
    emits: { finish: (e) => !0, 'update:focused': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const { dimensionStyles: s } = an(e),
        { isFocused: o, focus: a, blur: l } = Qr(e),
        u = xe(
          e,
          'modelValue',
          '',
          (w) => (w == null ? [] : String(w).split('')),
          (w) => w.join('')
        ),
        { t: c } = jt(),
        d = k(() => Number(e.length)),
        f = k(() => Array(d.value).fill(0)),
        m = le(-1),
        p = le(),
        v = le([]),
        y = k(() => v.value[m.value])
      function T() {
        if (I(y.value.value)) {
          y.value.value = ''
          return
        }
        const w = u.value.slice(),
          _ = y.value.value
        w[m.value] = _
        let S = null
        m.value > u.value.length ? (S = u.value.length + 1) : m.value + 1 !== d.value && (S = 'next'),
          (u.value = w),
          S && Cl(p.value, S)
      }
      function A(w) {
        const _ = u.value.slice(),
          S = m.value
        let E = null
        ;['ArrowLeft', 'ArrowRight', 'Backspace', 'Delete'].includes(w.key) &&
          (w.preventDefault(),
          w.key === 'ArrowLeft'
            ? (E = 'prev')
            : w.key === 'ArrowRight'
            ? (E = 'next')
            : ['Backspace', 'Delete'].includes(w.key) &&
              ((_[m.value] = ''),
              (u.value = _),
              m.value > 0 && w.key === 'Backspace'
                ? (E = 'prev')
                : requestAnimationFrame(() => {
                    var C
                    ;(C = v.value[S]) == null || C.select()
                  })),
          requestAnimationFrame(() => {
            E != null && Cl(p.value, E)
          }))
      }
      function x(w, _) {
        var E, C
        _.preventDefault(), _.stopPropagation()
        const S =
          ((E = _ == null ? void 0 : _.clipboardData) == null ? void 0 : E.getData('Text').slice(0, d.value)) ?? ''
        I(S) || ((u.value = S.split('')), (C = v.value) == null || C[w].blur())
      }
      function N() {
        u.value = []
      }
      function V(w, _) {
        a(), (m.value = _)
      }
      function D() {
        l(), (m.value = -1)
      }
      function I(w) {
        return e.type === 'number' && /[^0-9]/g.test(w)
      }
      return (
        Ot(
          {
            VField: {
              color: k(() => e.color),
              bgColor: k(() => e.color),
              baseColor: k(() => e.baseColor),
              disabled: k(() => e.disabled),
              error: k(() => e.error),
              variant: k(() => e.variant),
            },
          },
          { scoped: !0 }
        ),
        be(
          u,
          (w) => {
            w.length === d.value && i('finish', w.join(''))
          },
          { deep: !0 }
        ),
        be(m, (w) => {
          w < 0 ||
            Xe(() => {
              var _
              ;(_ = v.value[w]) == null || _.select()
            })
        }),
        se(() => {
          var S
          const [w, _] = Gs(n)
          return g(
            'div',
            ae({ class: ['v-otp-input', { 'v-otp-input--divided': !!e.divider }, e.class], style: [e.style] }, w),
            [
              g('div', { ref: p, class: 'v-otp-input__content', style: [s.value] }, [
                f.value.map((E, C) =>
                  g(ke, null, [
                    e.divider && C !== 0 && g('span', { class: 'v-otp-input__divider' }, [e.divider]),
                    g(
                      Ql,
                      { focused: (o.value && e.focusAll) || m.value === C, key: C },
                      {
                        ...r,
                        loader: void 0,
                        default: () =>
                          g(
                            'input',
                            {
                              ref: (R) => (v.value[C] = R),
                              'aria-label': c(e.label, C + 1),
                              autofocus: C === 0 && e.autofocus,
                              autocomplete: 'one-time-code',
                              class: ['v-otp-input__field'],
                              disabled: e.disabled,
                              inputmode: e.type === 'number' ? 'numeric' : 'text',
                              min: e.type === 'number' ? 0 : void 0,
                              maxlength: '1',
                              placeholder: e.placeholder,
                              type: e.type === 'number' ? 'text' : e.type,
                              value: u.value[C],
                              onInput: T,
                              onFocus: (R) => V(R, C),
                              onBlur: D,
                              onKeydown: A,
                              onPaste: (R) => x(C, R),
                            },
                            null
                          ),
                      }
                    ),
                  ])
                ),
                g('input', ae({ class: 'v-otp-input-input', type: 'hidden' }, _, { value: u.value.join('') }), null),
                g(
                  mr,
                  { contained: !0, 'content-class': 'v-otp-input__loader', 'model-value': !!e.loading, persistent: !0 },
                  {
                    default: () => {
                      var E
                      return [
                        ((E = r.loader) == null ? void 0 : E.call(r)) ??
                          g(
                            Rl,
                            {
                              color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                              indeterminate: !0,
                              size: '24',
                              width: '2',
                            },
                            null
                          ),
                      ]
                    },
                  }
                ),
                (S = r.default) == null ? void 0 : S.call(r),
              ]),
            ]
          )
        }),
        {
          blur: () => {
            var w
            ;(w = v.value) == null || w.some((_) => _.blur())
          },
          focus: () => {
            var w
            ;(w = v.value) == null || w[0].focus()
          },
          reset: N,
          isFocused: o,
        }
      )
    },
  })
function nZ(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e)
}
const iZ = W({ scale: { type: [Number, String], default: 0.5 }, ...Te() }, 'VParallax'),
  rZ = ne()({
    name: 'VParallax',
    props: iZ(),
    setup(e, t) {
      let { slots: n } = t
      const { intersectionRef: i, isIntersecting: r } = Dm(),
        { resizeRef: s, contentRect: o } = Gi(),
        { height: a } = Ni(),
        l = le()
      $t(() => {
        var m
        i.value = s.value = (m = l.value) == null ? void 0 : m.$el
      })
      let u
      be(r, (m) => {
        m
          ? ((u = Ob(i.value)),
            (u = u === document.scrollingElement ? document : u),
            u.addEventListener('scroll', f, { passive: !0 }),
            f())
          : u.removeEventListener('scroll', f)
      }),
        kn(() => {
          u == null || u.removeEventListener('scroll', f)
        }),
        be(a, f),
        be(() => {
          var m
          return (m = o.value) == null ? void 0 : m.height
        }, f)
      const c = k(() => 1 - qt(+e.scale))
      let d = -1
      function f() {
        r.value &&
          (cancelAnimationFrame(d),
          (d = requestAnimationFrame(() => {
            var V
            const m = ((V = l.value) == null ? void 0 : V.$el).querySelector('.v-img__img')
            if (!m) return
            const p = u instanceof Document ? document.documentElement.clientHeight : u.clientHeight,
              v = u instanceof Document ? window.scrollY : u.scrollTop,
              y = i.value.getBoundingClientRect().top + v,
              T = o.value.height,
              A = y + (T - p) / 2,
              x = nZ((v - A) * c.value),
              N = Math.max(1, (c.value * (p - T) + T) / T)
            m.style.setProperty('transform', `translateY(${x}px) scale(${N})`)
          })))
      }
      return (
        se(() =>
          g(
            Br,
            {
              class: ['v-parallax', { 'v-parallax--active': r.value }, e.class],
              style: e.style,
              ref: l,
              cover: !0,
              onLoadstart: f,
              onLoad: f,
            },
            n
          )
        ),
        {}
      )
    },
  }),
  sZ = W({ ...Lm({ falseIcon: '$radioOff', trueIcon: '$radioOn' }) }, 'VRadio'),
  oZ = ne()({
    name: 'VRadio',
    props: sZ(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() => {
          const i = Fs.filterProps(e)
          return g(Fs, ae(i, { class: ['v-radio', e.class], style: e.style, type: 'radio' }), n)
        }),
        {}
      )
    },
  }),
  aZ = W(
    {
      height: { type: [Number, String], default: 'auto' },
      ...Xr(),
      ...Qt(Wb(), ['multiple']),
      trueIcon: { type: Le, default: '$radioOn' },
      falseIcon: { type: Le, default: '$radioOff' },
      type: { type: String, default: 'radio' },
    },
    'VRadioGroup'
  ),
  lZ = ne()({
    name: 'VRadioGroup',
    inheritAttrs: !1,
    props: aZ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const r = pn(),
        s = k(() => e.id || `radio-group-${r}`),
        o = xe(e, 'modelValue')
      return (
        se(() => {
          const [a, l] = Gs(n),
            u = Cn.filterProps(e),
            c = Fs.filterProps(e),
            d = i.label ? i.label({ label: e.label, props: { for: s.value } }) : e.label
          return g(
            Cn,
            ae({ class: ['v-radio-group', e.class], style: e.style }, a, u, {
              modelValue: o.value,
              'onUpdate:modelValue': (f) => (o.value = f),
              id: s.value,
            }),
            {
              ...i,
              default: (f) => {
                let { id: m, messagesId: p, isDisabled: v, isReadonly: y } = f
                return g(ke, null, [
                  d && g(Kl, { id: m.value }, { default: () => [d] }),
                  g(
                    kD,
                    ae(
                      c,
                      {
                        id: m.value,
                        'aria-describedby': p.value,
                        defaultsTarget: 'VRadio',
                        trueIcon: e.trueIcon,
                        falseIcon: e.falseIcon,
                        type: e.type,
                        disabled: v.value,
                        readonly: y.value,
                        'aria-labelledby': d ? m.value : void 0,
                        multiple: !1,
                      },
                      l,
                      { modelValue: o.value, 'onUpdate:modelValue': (T) => (o.value = T) }
                    ),
                    i
                  ),
                ])
              },
            }
          )
        }),
        {}
      )
    },
  }),
  uZ = W(
    { ...fd(), ...Xr(), ...SN(), strict: Boolean, modelValue: { type: Array, default: () => [0, 0] } },
    'VRangeSlider'
  ),
  cZ = ne()({
    name: 'VRangeSlider',
    props: uZ(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0, end: (e) => !0, start: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: i } = t
      const r = le(),
        s = le(),
        o = le(),
        { rtlClasses: a } = sn()
      function l(S) {
        if (!r.value || !s.value) return
        const E = iy(S, r.value.$el, e.direction),
          C = iy(S, s.value.$el, e.direction),
          R = Math.abs(E),
          B = Math.abs(C)
        return R < B || (R === B && E < 0) ? r.value.$el : s.value.$el
      }
      const u = EN(e),
        c = xe(e, 'modelValue', void 0, (S) => (S != null && S.length ? S.map((E) => u.roundValue(E)) : [0, 0])),
        {
          activeThumbRef: d,
          hasLabels: f,
          max: m,
          min: p,
          mousePressed: v,
          onSliderMousedown: y,
          onSliderTouchstart: T,
          position: A,
          trackContainerRef: x,
          readonly: N,
        } = TN({
          props: e,
          steps: u,
          onSliderStart: () => {
            i('start', c.value)
          },
          onSliderEnd: (S) => {
            var R
            let { value: E } = S
            const C = d.value === ((R = r.value) == null ? void 0 : R.$el) ? [E, c.value[1]] : [c.value[0], E]
            !e.strict && C[0] < C[1] && (c.value = C), i('end', c.value)
          },
          onSliderMove: (S) => {
            var B, U, $, G
            let { value: E } = S
            const [C, R] = c.value
            !e.strict &&
              C === R &&
              C !== p.value &&
              ((d.value = E > C ? ((B = s.value) == null ? void 0 : B.$el) : (U = r.value) == null ? void 0 : U.$el),
              ($ = d.value) == null || $.focus()),
              d.value === ((G = r.value) == null ? void 0 : G.$el)
                ? (c.value = [Math.min(E, R), R])
                : (c.value = [C, Math.max(C, E)])
          },
          getActiveThumb: l,
        }),
        { isFocused: V, focus: D, blur: I } = Qr(e),
        w = k(() => A(c.value[0])),
        _ = k(() => A(c.value[1]))
      return (
        se(() => {
          const S = Cn.filterProps(e),
            E = !!(e.label || n.label || n.prepend)
          return g(
            Cn,
            ae(
              {
                class: [
                  'v-slider',
                  'v-range-slider',
                  {
                    'v-slider--has-labels': !!n['tick-label'] || f.value,
                    'v-slider--focused': V.value,
                    'v-slider--pressed': v.value,
                    'v-slider--disabled': e.disabled,
                  },
                  a.value,
                  e.class,
                ],
                style: e.style,
                ref: o,
              },
              S,
              { focused: V.value }
            ),
            {
              ...n,
              prepend: E
                ? (C) => {
                    var R, B
                    return g(ke, null, [
                      ((R = n.label) == null ? void 0 : R.call(n, C)) ??
                        (e.label ? g(Kl, { class: 'v-slider__label', text: e.label }, null) : void 0),
                      (B = n.prepend) == null ? void 0 : B.call(n, C),
                    ])
                  }
                : void 0,
              default: (C) => {
                var U, $
                let { id: R, messagesId: B } = C
                return g(
                  'div',
                  {
                    class: 'v-slider__container',
                    onMousedown: N.value ? void 0 : y,
                    onTouchstartPassive: N.value ? void 0 : T,
                  },
                  [
                    g(
                      'input',
                      {
                        id: `${R.value}_start`,
                        name: e.name || R.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: '-1',
                        value: c.value[0],
                      },
                      null
                    ),
                    g(
                      'input',
                      {
                        id: `${R.value}_stop`,
                        name: e.name || R.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: '-1',
                        value: c.value[1],
                      },
                      null
                    ),
                    g(CN, { ref: x, start: w.value, stop: _.value }, { 'tick-label': n['tick-label'] }),
                    g(
                      ry,
                      {
                        ref: r,
                        'aria-describedby': B.value,
                        focused: V && d.value === ((U = r.value) == null ? void 0 : U.$el),
                        modelValue: c.value[0],
                        'onUpdate:modelValue': (G) => (c.value = [G, c.value[1]]),
                        onFocus: (G) => {
                          var F, K, j, q
                          D(),
                            (d.value = (F = r.value) == null ? void 0 : F.$el),
                            c.value[0] === c.value[1] &&
                              c.value[1] === p.value &&
                              G.relatedTarget !== ((K = s.value) == null ? void 0 : K.$el) &&
                              ((j = r.value) == null || j.$el.blur(), (q = s.value) == null || q.$el.focus())
                        },
                        onBlur: () => {
                          I(), (d.value = void 0)
                        },
                        min: p.value,
                        max: c.value[1],
                        position: w.value,
                        ripple: e.ripple,
                      },
                      { 'thumb-label': n['thumb-label'] }
                    ),
                    g(
                      ry,
                      {
                        ref: s,
                        'aria-describedby': B.value,
                        focused: V && d.value === (($ = s.value) == null ? void 0 : $.$el),
                        modelValue: c.value[1],
                        'onUpdate:modelValue': (G) => (c.value = [c.value[0], G]),
                        onFocus: (G) => {
                          var F, K, j, q
                          D(),
                            (d.value = (F = s.value) == null ? void 0 : F.$el),
                            c.value[0] === c.value[1] &&
                              c.value[0] === m.value &&
                              G.relatedTarget !== ((K = r.value) == null ? void 0 : K.$el) &&
                              ((j = s.value) == null || j.$el.blur(), (q = r.value) == null || q.$el.focus())
                        },
                        onBlur: () => {
                          I(), (d.value = void 0)
                        },
                        min: c.value[0],
                        max: m.value,
                        position: _.value,
                        ripple: e.ripple,
                      },
                      { 'thumb-label': n['thumb-label'] }
                    ),
                  ]
                )
              },
            }
          )
        }),
        {}
      )
    },
  }),
  dZ = W(
    {
      name: String,
      itemAriaLabel: { type: String, default: '$vuetify.rating.ariaLabel.item' },
      activeColor: String,
      color: String,
      clearable: Boolean,
      disabled: Boolean,
      emptyIcon: { type: Le, default: '$ratingEmpty' },
      fullIcon: { type: Le, default: '$ratingFull' },
      halfIncrements: Boolean,
      hover: Boolean,
      length: { type: [Number, String], default: 5 },
      readonly: Boolean,
      modelValue: { type: [Number, String], default: 0 },
      itemLabels: Array,
      itemLabelPosition: { type: String, default: 'top', validator: (e) => ['top', 'bottom'].includes(e) },
      ripple: Boolean,
      ...Te(),
      ...ln(),
      ..._r(),
      ...He(),
      ...Ze(),
    },
    'VRating'
  ),
  hZ = ne()({
    name: 'VRating',
    props: dZ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { t: i } = jt(),
        { themeClasses: r } = at(e),
        s = xe(e, 'modelValue'),
        o = k(() => qt(parseFloat(s.value), 0, +e.length)),
        a = k(() => ar(Number(e.length), 1)),
        l = k(() => a.value.flatMap((v) => (e.halfIncrements ? [v - 0.5, v] : [v]))),
        u = ye(-1),
        c = k(() =>
          l.value.map((v) => {
            const y = e.hover && u.value > -1,
              T = o.value >= v,
              A = u.value >= v,
              N = (y ? A : T) ? e.fullIcon : e.emptyIcon,
              V = e.activeColor ?? e.color,
              D = T || A ? V : e.color
            return { isFilled: T, isHovered: A, icon: N, color: D }
          })
        ),
        d = k(() =>
          [0, ...l.value].map((v) => {
            function y() {
              u.value = v
            }
            function T() {
              u.value = -1
            }
            function A() {
              e.disabled || e.readonly || (s.value = o.value === v && e.clearable ? 0 : v)
            }
            return { onMouseenter: e.hover ? y : void 0, onMouseleave: e.hover ? T : void 0, onClick: A }
          })
        ),
        f = k(() => e.name ?? `v-rating-${pn()}`)
      function m(v) {
        var w, _
        let { value: y, index: T, showStar: A = !0 } = v
        const { onMouseenter: x, onMouseleave: N, onClick: V } = d.value[T + 1],
          D = `${f.value}-${String(y).replace('.', '-')}`,
          I = {
            color: (w = c.value[T]) == null ? void 0 : w.color,
            density: e.density,
            disabled: e.disabled,
            icon: (_ = c.value[T]) == null ? void 0 : _.icon,
            ripple: e.ripple,
            size: e.size,
            variant: 'plain',
          }
        return g(ke, null, [
          g(
            'label',
            {
              for: D,
              class: {
                'v-rating__item--half': e.halfIncrements && y % 1 > 0,
                'v-rating__item--full': e.halfIncrements && y % 1 === 0,
              },
              onMouseenter: x,
              onMouseleave: N,
              onClick: V,
            },
            [
              g('span', { class: 'v-rating__hidden' }, [i(e.itemAriaLabel, y, e.length)]),
              A
                ? n.item
                  ? n.item({ ...c.value[T], props: I, value: y, index: T, rating: o.value })
                  : g(st, ae({ 'aria-label': i(e.itemAriaLabel, y, e.length) }, I), null)
                : void 0,
            ]
          ),
          g(
            'input',
            {
              class: 'v-rating__hidden',
              name: f.value,
              id: D,
              type: 'radio',
              value: y,
              checked: o.value === y,
              tabindex: -1,
              readonly: e.readonly,
              disabled: e.disabled,
            },
            null
          ),
        ])
      }
      function p(v) {
        return n['item-label'] ? n['item-label'](v) : v.label ? g('span', null, [v.label]) : g('span', null, [Or(' ')])
      }
      return (
        se(() => {
          var y
          const v = !!((y = e.itemLabels) != null && y.length) || n['item-label']
          return g(
            e.tag,
            {
              class: ['v-rating', { 'v-rating--hover': e.hover, 'v-rating--readonly': e.readonly }, r.value, e.class],
              style: e.style,
            },
            {
              default: () => [
                g(m, { value: 0, index: -1, showStar: !1 }, null),
                a.value.map((T, A) => {
                  var x, N
                  return g('div', { class: 'v-rating__wrapper' }, [
                    v && e.itemLabelPosition === 'top'
                      ? p({ value: T, index: A, label: (x = e.itemLabels) == null ? void 0 : x[A] })
                      : void 0,
                    g('div', { class: 'v-rating__item' }, [
                      e.halfIncrements
                        ? g(ke, null, [
                            g(m, { value: T - 0.5, index: A * 2 }, null),
                            g(m, { value: T, index: A * 2 + 1 }, null),
                          ])
                        : g(m, { value: T, index: A }, null),
                    ]),
                    v && e.itemLabelPosition === 'bottom'
                      ? p({ value: T, index: A, label: (N = e.itemLabels) == null ? void 0 : N[A] })
                      : void 0,
                  ])
                }),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  fZ = {
    actions: 'button@2',
    article: 'heading, paragraph',
    avatar: 'avatar',
    button: 'button',
    card: 'image, heading',
    'card-avatar': 'image, list-item-avatar',
    chip: 'chip',
    'date-picker': 'list-item, heading, divider, date-picker-options, date-picker-days, actions',
    'date-picker-options': 'text, avatar@2',
    'date-picker-days': 'avatar@28',
    divider: 'divider',
    heading: 'heading',
    image: 'image',
    'list-item': 'text',
    'list-item-avatar': 'avatar, text',
    'list-item-two-line': 'sentences',
    'list-item-avatar-two-line': 'avatar, sentences',
    'list-item-three-line': 'paragraph',
    'list-item-avatar-three-line': 'avatar, paragraph',
    ossein: 'ossein',
    paragraph: 'text@3',
    sentences: 'text@2',
    subtitle: 'text',
    table: 'table-heading, table-thead, table-tbody, table-tfoot',
    'table-heading': 'chip, text',
    'table-thead': 'heading@6',
    'table-tbody': 'table-row-divider@6',
    'table-row-divider': 'table-row, divider',
    'table-row': 'text@6',
    'table-tfoot': 'text@2, avatar@2',
    text: 'text',
  }
function mZ(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
  return g('div', { class: ['v-skeleton-loader__bone', `v-skeleton-loader__${e}`] }, [t])
}
function XT(e) {
  const [t, n] = e.split('@')
  return Array.from({ length: n }).map(() => tg(t))
}
function tg(e) {
  let t = []
  if (!e) return t
  const n = fZ[e]
  if (e !== n) {
    if (e.includes(',')) return JT(e)
    if (e.includes('@')) return XT(e)
    n.includes(',') ? (t = JT(n)) : n.includes('@') ? (t = XT(n)) : n && t.push(tg(n))
  }
  return [mZ(e, t)]
}
function JT(e) {
  return e.replace(/\s/g, '').split(',').map(tg)
}
const gZ = W(
    {
      boilerplate: Boolean,
      color: String,
      loading: Boolean,
      loadingText: { type: String, default: '$vuetify.loading' },
      type: { type: [String, Array], default: 'ossein' },
      ...on(),
      ...en(),
      ...Ze(),
    },
    'VSkeletonLoader'
  ),
  vZ = ne()({
    name: 'VSkeletonLoader',
    props: gZ(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: i, backgroundColorStyles: r } = gt(Q(e, 'color')),
        { dimensionStyles: s } = an(e),
        { elevationClasses: o } = yn(e),
        { themeClasses: a } = at(e),
        { t: l } = jt(),
        u = k(() => tg(Pt(e.type).join(',')))
      return (
        se(() => {
          var d
          const c = !n.default || e.loading
          return g(
            'div',
            {
              class: [
                'v-skeleton-loader',
                { 'v-skeleton-loader--boilerplate': e.boilerplate },
                a.value,
                i.value,
                o.value,
              ],
              style: [r.value, c ? s.value : {}],
              'aria-busy': e.boilerplate ? void 0 : c,
              'aria-live': e.boilerplate ? void 0 : 'polite',
              'aria-label': e.boilerplate ? void 0 : l(e.loadingText),
              role: e.boilerplate ? void 0 : 'alert',
            },
            [c ? u.value : (d = n.default) == null ? void 0 : d.call(n)]
          )
        }),
        {}
      )
    },
  }),
  pZ = ne()({
    name: 'VSlideGroupItem',
    props: va(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = pa(e, LD)
      return () => {
        var r
        return (r = n.default) == null
          ? void 0
          : r.call(n, {
              isSelected: i.isSelected.value,
              select: i.select,
              toggle: i.toggle,
              selectedClass: i.selectedClass.value,
            })
      }
    },
  })
function yZ(e) {
  const t = ye(e)
  let n = -1
  function i() {
    clearInterval(n)
  }
  function r() {
    i(), Xe(() => (t.value = e))
  }
  function s(o) {
    const a = o ? getComputedStyle(o) : { transitionDuration: 0.2 },
      l = parseFloat(a.transitionDuration) * 1e3 || 200
    if ((i(), t.value <= 0)) return
    const u = performance.now()
    n = window.setInterval(() => {
      const c = performance.now() - u + l
      ;(t.value = Math.max(e - c, 0)), t.value <= 0 && i()
    }, l)
  }
  return gn(i), { clear: i, time: t, start: s, reset: r }
}
const _Z = W(
    {
      multiLine: Boolean,
      text: String,
      timer: [Boolean, String],
      timeout: { type: [Number, String], default: 5e3 },
      vertical: Boolean,
      ...Kr({ location: 'bottom' }),
      ...ql(),
      ...Tt(),
      ...Mi(),
      ...Ze(),
      ...Qt(gd({ transition: 'v-snackbar-transition' }), ['persistent', 'noClickAnimation', 'scrim', 'scrollStrategy']),
    },
    'VSnackbar'
  ),
  bZ = ne()({
    name: 'VSnackbar',
    props: _Z(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        { positionClasses: r } = Gl(e),
        { scopeId: s } = _a(),
        { themeClasses: o } = at(e),
        { colorClasses: a, colorStyles: l, variantClasses: u } = ma(e),
        { roundedClasses: c } = Mt(e),
        d = yZ(Number(e.timeout)),
        f = le(),
        m = le(),
        p = ye(!1),
        v = ye(0),
        y = le(),
        T = je(Ac, void 0)
      ii(
        () => !!T,
        () => {
          const S = sD()
          $t(() => {
            y.value = S.mainStyles.value
          })
        }
      ),
        be(i, x),
        be(() => e.timeout, x),
        An(() => {
          i.value && x()
        })
      let A = -1
      function x() {
        d.reset(), window.clearTimeout(A)
        const S = Number(e.timeout)
        if (!i.value || S === -1) return
        const E = Ab(m.value)
        d.start(E),
          (A = window.setTimeout(() => {
            i.value = !1
          }, S))
      }
      function N() {
        d.reset(), window.clearTimeout(A)
      }
      function V() {
        ;(p.value = !0), N()
      }
      function D() {
        ;(p.value = !1), x()
      }
      function I(S) {
        v.value = S.touches[0].clientY
      }
      function w(S) {
        Math.abs(v.value - S.changedTouches[0].clientY) > 50 && (i.value = !1)
      }
      const _ = k(() => e.location.split(' ').reduce((S, E) => ((S[`v-snackbar--${E}`] = !0), S), {}))
      return (
        se(() => {
          const S = mr.filterProps(e),
            E = !!(n.default || n.text || e.text)
          return g(
            mr,
            ae(
              {
                ref: f,
                class: [
                  'v-snackbar',
                  {
                    'v-snackbar--active': i.value,
                    'v-snackbar--multi-line': e.multiLine && !e.vertical,
                    'v-snackbar--timer': !!e.timer,
                    'v-snackbar--vertical': e.vertical,
                  },
                  _.value,
                  r.value,
                  e.class,
                ],
                style: [y.value, e.style],
              },
              S,
              {
                modelValue: i.value,
                'onUpdate:modelValue': (C) => (i.value = C),
                contentProps: ae(
                  {
                    class: ['v-snackbar__wrapper', o.value, a.value, c.value, u.value],
                    style: [l.value],
                    onPointerenter: V,
                    onPointerleave: D,
                  },
                  S.contentProps
                ),
                persistent: !0,
                noClickAnimation: !0,
                scrim: !1,
                scrollStrategy: 'none',
                _disableGlobalStack: !0,
                onTouchstartPassive: I,
                onTouchend: w,
              },
              s
            ),
            {
              default: () => {
                var C, R
                return [
                  Ks(!1, 'v-snackbar'),
                  e.timer &&
                    !p.value &&
                    g('div', { key: 'timer', class: 'v-snackbar__timer' }, [
                      g(
                        Nm,
                        {
                          ref: m,
                          color: typeof e.timer == 'string' ? e.timer : 'info',
                          max: e.timeout,
                          'model-value': d.time.value,
                        },
                        null
                      ),
                    ]),
                  E &&
                    g('div', { key: 'content', class: 'v-snackbar__content', role: 'status', 'aria-live': 'polite' }, [
                      ((C = n.text) == null ? void 0 : C.call(n)) ?? e.text,
                      (R = n.default) == null ? void 0 : R.call(n),
                    ]),
                  n.actions &&
                    g(
                      Ge,
                      { defaults: { VBtn: { variant: 'text', ripple: !1, slim: !0 } } },
                      { default: () => [g('div', { class: 'v-snackbar__actions' }, [n.actions({ isActive: i })])] }
                    ),
                ]
              },
              activator: n.activator,
            }
          )
        }),
        Li({}, f)
      )
    },
  }),
  vO = W(
    {
      autoDraw: Boolean,
      autoDrawDuration: [Number, String],
      autoDrawEasing: { type: String, default: 'ease' },
      color: String,
      gradient: { type: Array, default: () => [] },
      gradientDirection: {
        type: String,
        validator: (e) => ['top', 'bottom', 'left', 'right'].includes(e),
        default: 'top',
      },
      height: { type: [String, Number], default: 75 },
      labels: { type: Array, default: () => [] },
      labelSize: { type: [Number, String], default: 7 },
      lineWidth: { type: [String, Number], default: 4 },
      id: String,
      itemValue: { type: String, default: 'value' },
      modelValue: { type: Array, default: () => [] },
      min: [String, Number],
      max: [String, Number],
      padding: { type: [String, Number], default: 8 },
      showLabels: Boolean,
      smooth: Boolean,
      width: { type: [Number, String], default: 300 },
    },
    'Line'
  ),
  pO = W({ autoLineWidth: Boolean, ...vO() }, 'VBarline'),
  ZT = ne()({
    name: 'VBarline',
    props: pO(),
    setup(e, t) {
      let { slots: n } = t
      const i = pn(),
        r = k(() => e.id || `barline-${i}`),
        s = k(() => Number(e.autoDrawDuration) || 500),
        o = k(() => !!(e.showLabels || e.labels.length > 0 || (n != null && n.label))),
        a = k(() => parseFloat(e.lineWidth) || 4),
        l = k(() => Math.max(e.modelValue.length * a.value, Number(e.width))),
        u = k(() => ({ minX: 0, maxX: l.value, minY: 0, maxY: parseInt(e.height, 10) })),
        c = k(() => e.modelValue.map((v) => Jt(v, e.itemValue, v)))
      function d(v, y) {
        const { minX: T, maxX: A, minY: x, maxY: N } = y,
          V = v.length
        let D = e.max != null ? Number(e.max) : Math.max(...v),
          I = e.min != null ? Number(e.min) : Math.min(...v)
        I > 0 && e.min == null && (I = 0), D < 0 && e.max == null && (D = 0)
        const w = A / V,
          _ = (N - x) / (D - I || 1),
          S = N - Math.abs(I * _)
        return v.map((E, C) => {
          const R = Math.abs(_ * E)
          return { x: T + C * w, y: S - R + +(E < 0) * R, height: R, value: E }
        })
      }
      const f = k(() => {
          const v = [],
            y = d(c.value, u.value),
            T = y.length
          for (let A = 0; v.length < T; A++) {
            const x = y[A]
            let N = e.labels[A]
            N || (N = typeof x == 'object' ? x.value : x), v.push({ x: x.x, value: String(N) })
          }
          return v
        }),
        m = k(() => d(c.value, u.value)),
        p = k(() => (Math.abs(m.value[0].x - m.value[1].x) - a.value) / 2)
      se(() => {
        const v = e.gradient.slice().length ? e.gradient.slice().reverse() : ['']
        return g('svg', { display: 'block' }, [
          g('defs', null, [
            g(
              'linearGradient',
              {
                id: r.value,
                gradientUnits: 'userSpaceOnUse',
                x1: e.gradientDirection === 'left' ? '100%' : '0',
                y1: e.gradientDirection === 'top' ? '100%' : '0',
                x2: e.gradientDirection === 'right' ? '100%' : '0',
                y2: e.gradientDirection === 'bottom' ? '100%' : '0',
              },
              [
                v.map((y, T) =>
                  g('stop', { offset: T / Math.max(v.length - 1, 1), 'stop-color': y || 'currentColor' }, null)
                ),
              ]
            ),
          ]),
          g('clipPath', { id: `${r.value}-clip` }, [
            m.value.map((y) =>
              g(
                'rect',
                {
                  x: y.x + p.value,
                  y: y.y,
                  width: a.value,
                  height: y.height,
                  rx: typeof e.smooth == 'number' ? e.smooth : e.smooth ? 2 : 0,
                  ry: typeof e.smooth == 'number' ? e.smooth : e.smooth ? 2 : 0,
                },
                [
                  e.autoDraw &&
                    g(ke, null, [
                      g(
                        'animate',
                        { attributeName: 'y', from: y.y + y.height, to: y.y, dur: `${s.value}ms`, fill: 'freeze' },
                        null
                      ),
                      g(
                        'animate',
                        { attributeName: 'height', from: '0', to: y.height, dur: `${s.value}ms`, fill: 'freeze' },
                        null
                      ),
                    ]),
                ]
              )
            ),
          ]),
          o.value &&
            g(
              'g',
              {
                key: 'labels',
                style: { textAnchor: 'middle', dominantBaseline: 'mathematical', fill: 'currentColor' },
              },
              [
                f.value.map((y, T) => {
                  var A
                  return g(
                    'text',
                    {
                      x: y.x + p.value + a.value / 2,
                      y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * 0.75),
                      'font-size': Number(e.labelSize) || 7,
                    },
                    [((A = n.label) == null ? void 0 : A.call(n, { index: T, value: y.value })) ?? y.value]
                  )
                }),
              ]
            ),
          g('g', { 'clip-path': `url(#${r.value}-clip)`, fill: `url(#${r.value})` }, [
            g(
              'rect',
              { x: 0, y: 0, width: Math.max(e.modelValue.length * a.value, Number(e.width)), height: e.height },
              null
            ),
          ]),
        ])
      })
    },
  })
function wZ(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75
  if (e.length === 0) return ''
  const r = e.shift(),
    s = e[e.length - 1]
  return (
    (n ? `M${r.x} ${i - r.x + 2} L${r.x} ${r.y}` : `M${r.x} ${r.y}`) +
    e
      .map((o, a) => {
        const l = e[a + 1],
          u = e[a - 1] || r,
          c = l && IZ(l, o, u)
        if (!l || c) return `L${o.x} ${o.y}`
        const d = Math.min(eC(u, o), eC(l, o)),
          m = d / 2 < t ? d / 2 : t,
          p = tC(u, o, m),
          v = tC(l, o, m)
        return `L${p.x} ${p.y}S${o.x} ${o.y} ${v.x} ${v.y}`
      })
      .join('') +
    (n ? `L${s.x} ${i - r.x + 2} Z` : '')
  )
}
function dh(e) {
  return parseInt(e, 10)
}
function IZ(e, t, n) {
  return dh(e.x + n.x) === dh(2 * t.x) && dh(e.y + n.y) === dh(2 * t.y)
}
function eC(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}
function tC(e, t, n) {
  const i = { x: e.x - t.x, y: e.y - t.y },
    r = Math.sqrt(i.x * i.x + i.y * i.y),
    s = { x: i.x / r, y: i.y / r }
  return { x: t.x + s.x * n, y: t.y + s.y * n }
}
const yO = W({ fill: Boolean, ...vO() }, 'VTrendline'),
  nC = ne()({
    name: 'VTrendline',
    props: yO(),
    setup(e, t) {
      let { slots: n } = t
      const i = pn(),
        r = k(() => e.id || `trendline-${i}`),
        s = k(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)),
        o = le(0),
        a = le(null)
      function l(y, T) {
        const { minX: A, maxX: x, minY: N, maxY: V } = T,
          D = y.length,
          I = e.max != null ? Number(e.max) : Math.max(...y),
          w = e.min != null ? Number(e.min) : Math.min(...y),
          _ = (x - A) / (D - 1),
          S = (V - N) / (I - w || 1)
        return y.map((E, C) => ({ x: A + C * _, y: V - (E - w) * S, value: E }))
      }
      const u = k(() => !!(e.showLabels || e.labels.length > 0 || (n != null && n.label))),
        c = k(() => parseFloat(e.lineWidth) || 4),
        d = k(() => Number(e.width)),
        f = k(() => {
          const y = Number(e.padding)
          return { minX: y, maxX: d.value - y, minY: y, maxY: parseInt(e.height, 10) - y }
        }),
        m = k(() => e.modelValue.map((y) => Jt(y, e.itemValue, y))),
        p = k(() => {
          const y = [],
            T = l(m.value, f.value),
            A = T.length
          for (let x = 0; y.length < A; x++) {
            const N = T[x]
            let V = e.labels[x]
            V || (V = typeof N == 'object' ? N.value : N), y.push({ x: N.x, value: String(V) })
          }
          return y
        })
      be(
        () => e.modelValue,
        async () => {
          if ((await Xe(), !e.autoDraw || !a.value)) return
          const y = a.value,
            T = y.getTotalLength()
          e.fill
            ? ((y.style.transformOrigin = 'bottom center'),
              (y.style.transition = 'none'),
              (y.style.transform = 'scaleY(0)'),
              y.getBoundingClientRect(),
              (y.style.transition = `transform ${s.value}ms ${e.autoDrawEasing}`),
              (y.style.transform = 'scaleY(1)'))
            : ((y.style.strokeDasharray = `${T}`),
              (y.style.strokeDashoffset = `${T}`),
              y.getBoundingClientRect(),
              (y.style.transition = `stroke-dashoffset ${s.value}ms ${e.autoDrawEasing}`),
              (y.style.strokeDashoffset = '0')),
            (o.value = T)
        },
        { immediate: !0 }
      )
      function v(y) {
        return wZ(l(m.value, f.value), e.smooth ? 8 : Number(e.smooth), y, parseInt(e.height, 10))
      }
      se(() => {
        var T
        const y = e.gradient.slice().length ? e.gradient.slice().reverse() : ['']
        return g('svg', { display: 'block', 'stroke-width': parseFloat(e.lineWidth) ?? 4 }, [
          g('defs', null, [
            g(
              'linearGradient',
              {
                id: r.value,
                gradientUnits: 'userSpaceOnUse',
                x1: e.gradientDirection === 'left' ? '100%' : '0',
                y1: e.gradientDirection === 'top' ? '100%' : '0',
                x2: e.gradientDirection === 'right' ? '100%' : '0',
                y2: e.gradientDirection === 'bottom' ? '100%' : '0',
              },
              [
                y.map((A, x) =>
                  g('stop', { offset: x / Math.max(y.length - 1, 1), 'stop-color': A || 'currentColor' }, null)
                ),
              ]
            ),
          ]),
          u.value &&
            g(
              'g',
              {
                key: 'labels',
                style: { textAnchor: 'middle', dominantBaseline: 'mathematical', fill: 'currentColor' },
              },
              [
                p.value.map((A, x) => {
                  var N
                  return g(
                    'text',
                    {
                      x: A.x + c.value / 2 + c.value / 2,
                      y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * 0.75),
                      'font-size': Number(e.labelSize) || 7,
                    },
                    [((N = n.label) == null ? void 0 : N.call(n, { index: x, value: A.value })) ?? A.value]
                  )
                }),
              ]
            ),
          g(
            'path',
            {
              ref: a,
              d: v(e.fill),
              fill: e.fill ? `url(#${r.value})` : 'none',
              stroke: e.fill ? 'none' : `url(#${r.value})`,
            },
            null
          ),
          e.fill &&
            g('path', { d: v(!1), fill: 'none', stroke: e.color ?? ((T = e.gradient) == null ? void 0 : T[0]) }, null),
        ])
      })
    },
  }),
  SZ = W({ type: { type: String, default: 'trend' }, ...pO(), ...yO() }, 'VSparkline'),
  EZ = ne()({
    name: 'VSparkline',
    props: SZ(),
    setup(e, t) {
      let { slots: n } = t
      const { textColorClasses: i, textColorStyles: r } = Tn(Q(e, 'color')),
        s = k(() => !!(e.showLabels || e.labels.length > 0 || (n != null && n.label))),
        o = k(() => {
          let a = parseInt(e.height, 10)
          return s.value && (a += parseInt(e.labelSize, 10) * 1.5), a
        })
      se(() => {
        const a = e.type === 'trend' ? nC : ZT,
          l = e.type === 'trend' ? nC.filterProps(e) : ZT.filterProps(e)
        return g(
          a,
          ae({ key: e.type, class: i.value, style: r.value, viewBox: `0 0 ${e.width} ${parseInt(o.value, 10)}` }, l),
          n
        )
      })
    },
  }),
  TZ = W(
    {
      ...Te(),
      ...oN({
        offset: 8,
        minWidth: 0,
        openDelay: 0,
        closeDelay: 100,
        location: 'top center',
        transition: 'scale-transition',
      }),
    },
    'VSpeedDial'
  ),
  CZ = ne()({
    name: 'VSpeedDial',
    props: TZ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        r = le(),
        s = k(() => {
          const [a, l = 'center'] = e.location.split(' ')
          return `${a} ${l}`
        }),
        o = k(() => ({ [`v-speed-dial__content--${s.value.replace(' ', '-')}`]: !0 }))
      return (
        se(() => {
          const a = xl.filterProps(e)
          return g(
            xl,
            ae(a, {
              modelValue: i.value,
              'onUpdate:modelValue': (l) => (i.value = l),
              class: e.class,
              style: e.style,
              contentClass: ['v-speed-dial__content', o.value],
              location: s.value,
              ref: r,
              transition: 'fade-transition',
            }),
            {
              ...n,
              default: (l) =>
                g(
                  Ge,
                  { defaults: { VBtn: { size: 'small' } } },
                  {
                    default: () => [
                      g(
                        Bn,
                        { appear: !0, group: !0, transition: e.transition },
                        {
                          default: () => {
                            var u
                            return [(u = n.default) == null ? void 0 : u.call(n, l)]
                          },
                        }
                      ),
                    ],
                  }
                ),
            }
          )
        }),
        {}
      )
    },
  }),
  bw = Symbol.for('vuetify:v-stepper'),
  _O = W(
    {
      color: String,
      disabled: { type: [Boolean, String], default: !1 },
      prevText: { type: String, default: '$vuetify.stepper.prev' },
      nextText: { type: String, default: '$vuetify.stepper.next' },
    },
    'VStepperActions'
  ),
  bO = ne()({
    name: 'VStepperActions',
    props: _O(),
    emits: { 'click:prev': () => !0, 'click:next': () => !0 },
    setup(e, t) {
      let { emit: n, slots: i } = t
      const { t: r } = jt()
      function s() {
        n('click:prev')
      }
      function o() {
        n('click:next')
      }
      return (
        se(() => {
          const a = { onClick: s },
            l = { onClick: o }
          return g('div', { class: 'v-stepper-actions' }, [
            g(
              Ge,
              {
                defaults: {
                  VBtn: { disabled: ['prev', !0].includes(e.disabled), text: r(e.prevText), variant: 'text' },
                },
              },
              {
                default: () => {
                  var u
                  return [((u = i.prev) == null ? void 0 : u.call(i, { props: a })) ?? g(st, a, null)]
                },
              }
            ),
            g(
              Ge,
              {
                defaults: {
                  VBtn: {
                    color: e.color,
                    disabled: ['next', !0].includes(e.disabled),
                    text: r(e.nextText),
                    variant: 'tonal',
                  },
                },
              },
              {
                default: () => {
                  var u
                  return [((u = i.next) == null ? void 0 : u.call(i, { props: l })) ?? g(st, l, null)]
                },
              }
            ),
          ])
        }),
        {}
      )
    },
  }),
  wO = yr('v-stepper-header'),
  AZ = W(
    {
      color: String,
      title: String,
      subtitle: String,
      complete: Boolean,
      completeIcon: { type: String, default: '$complete' },
      editable: Boolean,
      editIcon: { type: String, default: '$edit' },
      error: Boolean,
      errorIcon: { type: String, default: '$error' },
      icon: String,
      ripple: { type: [Boolean, Object], default: !0 },
      rules: { type: Array, default: () => [] },
    },
    'StepperItem'
  ),
  kZ = W({ ...AZ(), ...va() }, 'VStepperItem'),
  IO = ne()({
    name: 'VStepperItem',
    directives: { Ripple: Yr },
    props: kZ(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = pa(e, bw, !0),
        r = k(() => (i == null ? void 0 : i.value.value) ?? e.value),
        s = k(() => e.rules.every((f) => f() === !0)),
        o = k(() => !e.disabled && e.editable),
        a = k(() => !e.disabled && e.editable),
        l = k(() => e.error || !s.value),
        u = k(() => e.complete || (e.rules.length > 0 && s.value)),
        c = k(() =>
          l.value ? e.errorIcon : u.value ? e.completeIcon : i.isSelected.value && e.editable ? e.editIcon : e.icon
        ),
        d = k(() => ({
          canEdit: a.value,
          hasError: l.value,
          hasCompleted: u.value,
          title: e.title,
          subtitle: e.subtitle,
          step: r.value,
          value: e.value,
        }))
      return (
        se(() => {
          var y, T, A
          const f = (!i || i.isSelected.value || u.value || a.value) && !l.value && !e.disabled,
            m = !!(e.title != null || n.title),
            p = !!(e.subtitle != null || n.subtitle)
          function v() {
            i == null || i.toggle()
          }
          return Rt(
            g(
              'button',
              {
                class: [
                  'v-stepper-item',
                  {
                    'v-stepper-item--complete': u.value,
                    'v-stepper-item--disabled': e.disabled,
                    'v-stepper-item--error': l.value,
                  },
                  i == null ? void 0 : i.selectedClass.value,
                ],
                disabled: !e.editable,
                onClick: v,
              },
              [
                o.value && Ks(!0, 'v-stepper-item'),
                g(
                  Vi,
                  { key: 'stepper-avatar', class: 'v-stepper-item__avatar', color: f ? e.color : void 0, size: 24 },
                  {
                    default: () => {
                      var x
                      return [
                        ((x = n.icon) == null ? void 0 : x.call(n, d.value)) ??
                          (c.value ? g(ot, { icon: c.value }, null) : r.value),
                      ]
                    },
                  }
                ),
                g('div', { class: 'v-stepper-item__content' }, [
                  m &&
                    g('div', { key: 'title', class: 'v-stepper-item__title' }, [
                      ((y = n.title) == null ? void 0 : y.call(n, d.value)) ?? e.title,
                    ]),
                  p &&
                    g('div', { key: 'subtitle', class: 'v-stepper-item__subtitle' }, [
                      ((T = n.subtitle) == null ? void 0 : T.call(n, d.value)) ?? e.subtitle,
                    ]),
                  (A = n.default) == null ? void 0 : A.call(n, d.value),
                ]),
              ]
            ),
            [[pi('ripple'), e.ripple && e.editable, null]]
          )
        }),
        {}
      )
    },
  }),
  PZ = W({ ...Qt(zm(), ['continuous', 'nextIcon', 'prevIcon', 'showArrows', 'touch', 'mandatory']) }, 'VStepperWindow'),
  SO = ne()({
    name: 'VStepperWindow',
    props: PZ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = je(bw, null),
        r = xe(e, 'modelValue'),
        s = k({
          get() {
            var o
            return r.value != null || !i
              ? r.value
              : (o = i.items.value.find((a) => i.selected.value.includes(a.id))) == null
              ? void 0
              : o.value
          },
          set(o) {
            r.value = o
          },
        })
      return (
        se(() => {
          const o = Yo.filterProps(e)
          return g(
            Yo,
            ae({ _as: 'VStepperWindow' }, o, {
              modelValue: s.value,
              'onUpdate:modelValue': (a) => (s.value = a),
              class: ['v-stepper-window', e.class],
              style: e.style,
              mandatory: !1,
              touch: !1,
            }),
            n
          )
        }),
        {}
      )
    },
  }),
  RZ = W({ ...Hm() }, 'VStepperWindowItem'),
  EO = ne()({
    name: 'VStepperWindowItem',
    props: RZ(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() => {
          const i = Qo.filterProps(e)
          return g(
            Qo,
            ae({ _as: 'VStepperWindowItem' }, i, { class: ['v-stepper-window-item', e.class], style: e.style }),
            n
          )
        }),
        {}
      )
    },
  }),
  xZ = W(
    {
      altLabels: Boolean,
      bgColor: String,
      completeIcon: String,
      editIcon: String,
      editable: Boolean,
      errorIcon: String,
      hideActions: Boolean,
      items: { type: Array, default: () => [] },
      itemTitle: { type: String, default: 'title' },
      itemValue: { type: String, default: 'value' },
      nonLinear: Boolean,
      flat: Boolean,
      ...ca(),
    },
    'Stepper'
  ),
  VZ = W(
    {
      ...xZ(),
      ...ga({ mandatory: 'force', selectedClass: 'v-stepper-item--selected' }),
      ...Wm(),
      ...Sm(_O(), ['prevText', 'nextText']),
    },
    'VStepper'
  ),
  DZ = ne()({
    name: 'VStepper',
    props: VZ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { items: i, next: r, prev: s, selected: o } = Ys(e, bw),
        { displayClasses: a, mobile: l } = Ni(e),
        { completeIcon: u, editIcon: c, errorIcon: d, color: f, editable: m, prevText: p, nextText: v } = js(e),
        y = k(() =>
          e.items.map((x, N) => {
            const V = Jt(x, e.itemTitle, x),
              D = Jt(x, e.itemValue, N + 1)
            return { title: V, value: D, raw: x }
          })
        ),
        T = k(() => i.value.findIndex((x) => o.value.includes(x.id))),
        A = k(() => (e.disabled ? e.disabled : T.value === 0 ? 'prev' : T.value === i.value.length - 1 ? 'next' : !1))
      return (
        Ot({
          VStepperItem: { editable: m, errorIcon: d, completeIcon: u, editIcon: c, prevText: p, nextText: v },
          VStepperActions: { color: f, disabled: A, prevText: p, nextText: v },
        }),
        se(() => {
          const x = Xo.filterProps(e),
            N = !!(n.header || e.items.length),
            V = e.items.length > 0,
            D = !e.hideActions && !!(V || n.actions)
          return g(
            Xo,
            ae(x, {
              color: e.bgColor,
              class: [
                'v-stepper',
                {
                  'v-stepper--alt-labels': e.altLabels,
                  'v-stepper--flat': e.flat,
                  'v-stepper--non-linear': e.nonLinear,
                  'v-stepper--mobile': l.value,
                },
                a.value,
                e.class,
              ],
              style: e.style,
            }),
            {
              default: () => {
                var I, w
                return [
                  N &&
                    g(
                      wO,
                      { key: 'stepper-header' },
                      {
                        default: () => [
                          y.value.map((_, S) => {
                            let { raw: E, ...C } = _
                            return g(ke, null, [
                              !!S && g(md, null, null),
                              g(IO, C, {
                                default: n[`header-item.${C.value}`] ?? n.header,
                                icon: n.icon,
                                title: n.title,
                                subtitle: n.subtitle,
                              }),
                            ])
                          }),
                        ],
                      }
                    ),
                  V &&
                    g(
                      SO,
                      { key: 'stepper-window' },
                      {
                        default: () => [
                          y.value.map((_) =>
                            g(
                              EO,
                              { value: _.value },
                              {
                                default: () => {
                                  var S, E
                                  return (
                                    ((S = n[`item.${_.value}`]) == null ? void 0 : S.call(n, _)) ??
                                    ((E = n.item) == null ? void 0 : E.call(n, _))
                                  )
                                },
                              }
                            )
                          ),
                        ],
                      }
                    ),
                  (I = n.default) == null ? void 0 : I.call(n, { prev: s, next: r }),
                  D &&
                    (((w = n.actions) == null ? void 0 : w.call(n, { next: r, prev: s })) ??
                      g(bO, { key: 'stepper-actions', 'onClick:prev': s, 'onClick:next': r }, n)),
                ]
              },
            }
          )
        }),
        { prev: s, next: r }
      )
    },
  }),
  NZ = W(
    {
      indeterminate: Boolean,
      inset: Boolean,
      flat: Boolean,
      loading: { type: [Boolean, String], default: !1 },
      ...Xr(),
      ...Lm(),
    },
    'VSwitch'
  ),
  OZ = ne()({
    name: 'VSwitch',
    inheritAttrs: !1,
    props: NZ(),
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0, 'update:indeterminate': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const r = xe(e, 'indeterminate'),
        s = xe(e, 'modelValue'),
        { loaderClasses: o } = ud(e),
        { isFocused: a, focus: l, blur: u } = Qr(e),
        c = le(),
        d = ct && window.matchMedia('(forced-colors: active)').matches,
        f = k(() => (typeof e.loading == 'string' && e.loading !== '' ? e.loading : e.color)),
        m = pn(),
        p = k(() => e.id || `switch-${m}`)
      function v() {
        r.value && (r.value = !1)
      }
      function y(T) {
        var A, x
        T.stopPropagation(), T.preventDefault(), (x = (A = c.value) == null ? void 0 : A.input) == null || x.click()
      }
      return (
        se(() => {
          const [T, A] = Gs(n),
            x = Cn.filterProps(e),
            N = Fs.filterProps(e)
          return g(
            Cn,
            ae(
              {
                class: [
                  'v-switch',
                  { 'v-switch--flat': e.flat },
                  { 'v-switch--inset': e.inset },
                  { 'v-switch--indeterminate': r.value },
                  o.value,
                  e.class,
                ],
              },
              T,
              x,
              {
                modelValue: s.value,
                'onUpdate:modelValue': (V) => (s.value = V),
                id: p.value,
                focused: a.value,
                style: e.style,
              }
            ),
            {
              ...i,
              default: (V) => {
                let { id: D, messagesId: I, isDisabled: w, isReadonly: _, isValid: S } = V
                const E = { model: s, isValid: S }
                return g(
                  Fs,
                  ae(
                    { ref: c },
                    N,
                    {
                      modelValue: s.value,
                      'onUpdate:modelValue': [(C) => (s.value = C), v],
                      id: D.value,
                      'aria-describedby': I.value,
                      type: 'checkbox',
                      'aria-checked': r.value ? 'mixed' : void 0,
                      disabled: w.value,
                      readonly: _.value,
                      onFocus: l,
                      onBlur: u,
                    },
                    A
                  ),
                  {
                    ...i,
                    default: (C) => {
                      let { backgroundColorClasses: R, backgroundColorStyles: B } = C
                      return g(
                        'div',
                        { class: ['v-switch__track', d ? void 0 : R.value], style: B.value, onClick: y },
                        [
                          i['track-true'] &&
                            g('div', { key: 'prepend', class: 'v-switch__track-true' }, [i['track-true'](E)]),
                          i['track-false'] &&
                            g('div', { key: 'append', class: 'v-switch__track-false' }, [i['track-false'](E)]),
                        ]
                      )
                    },
                    input: (C) => {
                      let { inputNode: R, icon: B, backgroundColorClasses: U, backgroundColorStyles: $ } = C
                      return g(ke, null, [
                        R,
                        g(
                          'div',
                          {
                            class: [
                              'v-switch__thumb',
                              { 'v-switch__thumb--filled': B || e.loading },
                              e.inset || d ? void 0 : U.value,
                            ],
                            style: e.inset ? void 0 : $.value,
                          },
                          [
                            i.thumb
                              ? g(
                                  Ge,
                                  { defaults: { VIcon: { icon: B, size: 'x-small' } } },
                                  { default: () => [i.thumb({ ...E, icon: B })] }
                                )
                              : g($b, null, {
                                  default: () => [
                                    e.loading
                                      ? g(
                                          cd,
                                          { name: 'v-switch', active: !0, color: S.value === !1 ? void 0 : f.value },
                                          {
                                            default: (G) =>
                                              i.loader
                                                ? i.loader(G)
                                                : g(
                                                    Rl,
                                                    {
                                                      active: G.isActive,
                                                      color: G.color,
                                                      indeterminate: !0,
                                                      size: '16',
                                                      width: '2',
                                                    },
                                                    null
                                                  ),
                                          }
                                        )
                                      : B && g(ot, { key: String(B), icon: B, size: 'x-small' }, null),
                                  ],
                                }),
                          ]
                        ),
                      ])
                    },
                  }
                )
              },
            }
          )
        }),
        {}
      )
    },
  }),
  MZ = W(
    { color: String, height: [Number, String], window: Boolean, ...Te(), ...en(), ...da(), ...Tt(), ...He(), ...Ze() },
    'VSystemBar'
  ),
  LZ = ne()({
    name: 'VSystemBar',
    props: MZ(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { backgroundColorClasses: r, backgroundColorStyles: s } = gt(Q(e, 'color')),
        { elevationClasses: o } = yn(e),
        { roundedClasses: a } = Mt(e),
        { ssrBootStyles: l } = fa(),
        u = k(() => e.height ?? (e.window ? 32 : 24)),
        { layoutItemStyles: c } = ha({
          id: e.name,
          order: k(() => parseInt(e.order, 10)),
          position: ye('top'),
          layoutSize: u,
          elementSize: u,
          active: k(() => !0),
          absolute: Q(e, 'absolute'),
        })
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-system-bar',
                { 'v-system-bar--window': e.window },
                i.value,
                r.value,
                o.value,
                a.value,
                e.class,
              ],
              style: [s.value, c.value, l.value, e.style],
            },
            n
          )
        ),
        {}
      )
    },
  }),
  ww = Symbol.for('vuetify:v-tabs'),
  FZ = W(
    {
      fixed: Boolean,
      sliderColor: String,
      hideSlider: Boolean,
      direction: { type: String, default: 'horizontal' },
      ...Qt(Mm({ selectedClass: 'v-tab--selected', variant: 'text' }), [
        'active',
        'block',
        'flat',
        'location',
        'position',
        'symbol',
      ]),
    },
    'VTab'
  ),
  TO = ne()({
    name: 'VTab',
    props: FZ(),
    setup(e, t) {
      let { slots: n, attrs: i } = t
      const { textColorClasses: r, textColorStyles: s } = Tn(e, 'sliderColor'),
        o = le(),
        a = le(),
        l = k(() => e.direction === 'horizontal'),
        u = k(() => {
          var d, f
          return ((f = (d = o.value) == null ? void 0 : d.group) == null ? void 0 : f.isSelected.value) ?? !1
        })
      function c(d) {
        var m, p
        let { value: f } = d
        if (f) {
          const v =
              (p = (m = o.value) == null ? void 0 : m.$el.parentElement) == null
                ? void 0
                : p.querySelector('.v-tab--selected .v-tab__slider'),
            y = a.value
          if (!v || !y) return
          const T = getComputedStyle(v).color,
            A = v.getBoundingClientRect(),
            x = y.getBoundingClientRect(),
            N = l.value ? 'x' : 'y',
            V = l.value ? 'X' : 'Y',
            D = l.value ? 'right' : 'bottom',
            I = l.value ? 'width' : 'height',
            w = A[N],
            _ = x[N],
            S = w > _ ? A[D] - x[D] : A[N] - x[N],
            E =
              Math.sign(S) > 0
                ? l.value
                  ? 'right'
                  : 'bottom'
                : Math.sign(S) < 0
                ? l.value
                  ? 'left'
                  : 'top'
                : 'center',
            R = (Math.abs(S) + (Math.sign(S) < 0 ? A[I] : x[I])) / Math.max(A[I], x[I]) || 0,
            B = A[I] / x[I] || 0,
            U = 1.5
          _o(
            y,
            {
              backgroundColor: [T, 'currentcolor'],
              transform: [
                `translate${V}(${S}px) scale${V}(${B})`,
                `translate${V}(${S / U}px) scale${V}(${(R - 1) / U + 1})`,
                'none',
              ],
              transformOrigin: Array(3).fill(E),
            },
            { duration: 225, easing: Tc }
          )
        }
      }
      return (
        se(() => {
          const d = st.filterProps(e)
          return g(
            st,
            ae(
              {
                symbol: ww,
                ref: o,
                class: ['v-tab', e.class],
                style: e.style,
                tabindex: u.value ? 0 : -1,
                role: 'tab',
                'aria-selected': String(u.value),
                active: !1,
              },
              d,
              i,
              { block: e.fixed, maxWidth: e.fixed ? 300 : void 0, 'onGroup:selected': c }
            ),
            {
              ...n,
              default: () => {
                var f
                return g(ke, null, [
                  ((f = n.default) == null ? void 0 : f.call(n)) ?? e.text,
                  !e.hideSlider && g('div', { ref: a, class: ['v-tab__slider', r.value], style: s.value }, null),
                ])
              },
            }
          )
        }),
        Li({}, o)
      )
    },
  }),
  BZ = W({ ...Qt(zm(), ['continuous', 'nextIcon', 'prevIcon', 'showArrows', 'touch', 'mandatory']) }, 'VTabsWindow'),
  CO = ne()({
    name: 'VTabsWindow',
    props: BZ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = je(ww, null),
        r = xe(e, 'modelValue'),
        s = k({
          get() {
            var o
            return r.value != null || !i
              ? r.value
              : (o = i.items.value.find((a) => i.selected.value.includes(a.id))) == null
              ? void 0
              : o.value
          },
          set(o) {
            r.value = o
          },
        })
      return (
        se(() => {
          const o = Yo.filterProps(e)
          return g(
            Yo,
            ae({ _as: 'VTabsWindow' }, o, {
              modelValue: s.value,
              'onUpdate:modelValue': (a) => (s.value = a),
              class: ['v-tabs-window', e.class],
              style: e.style,
              mandatory: !1,
              touch: !1,
            }),
            n
          )
        }),
        {}
      )
    },
  }),
  $Z = W({ ...Hm() }, 'VTabsWindowItem'),
  AO = ne()({
    name: 'VTabsWindowItem',
    props: $Z(),
    setup(e, t) {
      let { slots: n } = t
      return (
        se(() => {
          const i = Qo.filterProps(e)
          return g(Qo, ae({ _as: 'VTabsWindowItem' }, i, { class: ['v-tabs-window-item', e.class], style: e.style }), n)
        }),
        {}
      )
    },
  })
function UZ(e) {
  return e ? e.map((t) => (Sc(t) ? t : { text: t, value: t })) : []
}
const jZ = W(
    {
      alignTabs: { type: String, default: 'start' },
      color: String,
      fixedTabs: Boolean,
      items: { type: Array, default: () => [] },
      stacked: Boolean,
      bgColor: String,
      grow: Boolean,
      height: { type: [Number, String], default: void 0 },
      hideSlider: Boolean,
      sliderColor: String,
      ...qb({ mandatory: 'force', selectedClass: 'v-tab-item--selected' }),
      ...ln(),
      ...He(),
    },
    'VTabs'
  ),
  zZ = ne()({
    name: 'VTabs',
    props: jZ(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: i } = t
      const r = xe(e, 'modelValue'),
        s = k(() => UZ(e.items)),
        { densityClasses: o } = Un(e),
        { backgroundColorClasses: a, backgroundColorStyles: l } = gt(Q(e, 'bgColor')),
        { scopeId: u } = _a()
      return (
        Ot({
          VTab: {
            color: Q(e, 'color'),
            direction: Q(e, 'direction'),
            stacked: Q(e, 'stacked'),
            fixed: Q(e, 'fixedTabs'),
            sliderColor: Q(e, 'sliderColor'),
            hideSlider: Q(e, 'hideSlider'),
          },
        }),
        se(() => {
          const c = Vc.filterProps(e),
            d = !!(i.window || e.items.length > 0)
          return g(ke, null, [
            g(
              Vc,
              ae(
                c,
                {
                  modelValue: r.value,
                  'onUpdate:modelValue': (f) => (r.value = f),
                  class: [
                    'v-tabs',
                    `v-tabs--${e.direction}`,
                    `v-tabs--align-tabs-${e.alignTabs}`,
                    { 'v-tabs--fixed-tabs': e.fixedTabs, 'v-tabs--grow': e.grow, 'v-tabs--stacked': e.stacked },
                    o.value,
                    a.value,
                    e.class,
                  ],
                  style: [{ '--v-tabs-height': Se(e.height) }, l.value, e.style],
                  role: 'tablist',
                  symbol: ww,
                },
                u,
                n
              ),
              {
                default: () => {
                  var f
                  return [
                    ((f = i.default) == null ? void 0 : f.call(i)) ??
                      s.value.map((m) => {
                        var p
                        return (
                          ((p = i.tab) == null ? void 0 : p.call(i, { item: m })) ??
                          g(TO, ae(m, { key: m.text, value: m.value }), {
                            default: i[`tab.${m.value}`]
                              ? () => {
                                  var v
                                  return (v = i[`tab.${m.value}`]) == null ? void 0 : v.call(i, { item: m })
                                }
                              : void 0,
                          })
                        )
                      }),
                  ]
                },
              }
            ),
            d &&
              g(CO, ae({ modelValue: r.value, 'onUpdate:modelValue': (f) => (r.value = f), key: 'tabs-window' }, u), {
                default: () => {
                  var f
                  return [
                    s.value.map((m) => {
                      var p
                      return (
                        ((p = i.item) == null ? void 0 : p.call(i, { item: m })) ??
                        g(
                          AO,
                          { value: m.value },
                          {
                            default: () => {
                              var v
                              return (v = i[`item.${m.value}`]) == null ? void 0 : v.call(i, { item: m })
                            },
                          }
                        )
                      )
                    }),
                    (f = i.window) == null ? void 0 : f.call(i),
                  ]
                },
              }),
          ])
        }),
        {}
      )
    },
  }),
  HZ = W(
    {
      autoGrow: Boolean,
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: Function,
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      noResize: Boolean,
      rows: { type: [Number, String], default: 5, validator: (e) => !isNaN(parseFloat(e)) },
      maxRows: { type: [Number, String], validator: (e) => !isNaN(parseFloat(e)) },
      suffix: String,
      modelModifiers: Object,
      ...Xr(),
      ...vd(),
    },
    'VTextarea'
  ),
  WZ = ne()({
    name: 'VTextarea',
    directives: { Intersect: ld },
    inheritAttrs: !1,
    props: HZ(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, emit: i, slots: r } = t
      const s = xe(e, 'modelValue'),
        { isFocused: o, focus: a, blur: l } = Qr(e),
        u = k(() =>
          typeof e.counterValue == 'function' ? e.counterValue(s.value) : (s.value || '').toString().length
        ),
        c = k(() => {
          if (n.maxlength) return n.maxlength
          if (!(!e.counter || (typeof e.counter != 'number' && typeof e.counter != 'string'))) return e.counter
        })
      function d(E, C) {
        var R, B
        !e.autofocus || !E || (B = (R = C[0].target) == null ? void 0 : R.focus) == null || B.call(R)
      }
      const f = le(),
        m = le(),
        p = ye(''),
        v = le(),
        y = k(() => e.persistentPlaceholder || o.value || e.active)
      function T() {
        var E
        v.value !== document.activeElement && ((E = v.value) == null || E.focus()), o.value || a()
      }
      function A(E) {
        T(), i('click:control', E)
      }
      function x(E) {
        i('mousedown:control', E)
      }
      function N(E) {
        E.stopPropagation(),
          T(),
          Xe(() => {
            ;(s.value = ''), Rb(e['onClick:clear'], E)
          })
      }
      function V(E) {
        var R
        const C = E.target
        if (((s.value = C.value), (R = e.modelModifiers) != null && R.trim)) {
          const B = [C.selectionStart, C.selectionEnd]
          Xe(() => {
            ;(C.selectionStart = B[0]), (C.selectionEnd = B[1])
          })
        }
      }
      const D = le(),
        I = le(+e.rows),
        w = k(() => ['plain', 'underlined'].includes(e.variant))
      $t(() => {
        e.autoGrow || (I.value = +e.rows)
      })
      function _() {
        e.autoGrow &&
          Xe(() => {
            if (!D.value || !m.value) return
            const E = getComputedStyle(D.value),
              C = getComputedStyle(m.value.$el),
              R =
                parseFloat(E.getPropertyValue('--v-field-padding-top')) +
                parseFloat(E.getPropertyValue('--v-input-padding-top')) +
                parseFloat(E.getPropertyValue('--v-field-padding-bottom')),
              B = D.value.scrollHeight,
              U = parseFloat(E.lineHeight),
              $ = Math.max(parseFloat(e.rows) * U + R, parseFloat(C.getPropertyValue('--v-input-control-height'))),
              G = parseFloat(e.maxRows) * U + R || 1 / 0,
              F = qt(B ?? 0, $, G)
            ;(I.value = Math.floor((F - R) / U)), (p.value = Se(F))
          })
      }
      An(_), be(s, _), be(() => e.rows, _), be(() => e.maxRows, _), be(() => e.density, _)
      let S
      return (
        be(D, (E) => {
          E ? ((S = new ResizeObserver(_)), S.observe(D.value)) : S == null || S.disconnect()
        }),
        kn(() => {
          S == null || S.disconnect()
        }),
        se(() => {
          const E = !!(r.counter || e.counter || e.counterValue),
            C = !!(E || r.details),
            [R, B] = Gs(n),
            { modelValue: U, ...$ } = Cn.filterProps(e),
            G = ew(e)
          return g(
            Cn,
            ae(
              {
                ref: f,
                modelValue: s.value,
                'onUpdate:modelValue': (F) => (s.value = F),
                class: [
                  'v-textarea v-text-field',
                  {
                    'v-textarea--prefixed': e.prefix,
                    'v-textarea--suffixed': e.suffix,
                    'v-text-field--prefixed': e.prefix,
                    'v-text-field--suffixed': e.suffix,
                    'v-textarea--auto-grow': e.autoGrow,
                    'v-textarea--no-resize': e.noResize || e.autoGrow,
                    'v-input--plain-underlined': w.value,
                  },
                  e.class,
                ],
                style: e.style,
              },
              R,
              $,
              { centerAffix: I.value === 1 && !w.value, focused: o.value }
            ),
            {
              ...r,
              default: (F) => {
                let { id: K, isDisabled: j, isDirty: q, isReadonly: te, isValid: ce } = F
                return g(
                  Ql,
                  ae(
                    {
                      ref: m,
                      style: { '--v-textarea-control-height': p.value },
                      onClick: A,
                      onMousedown: x,
                      'onClick:clear': N,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner'],
                    },
                    G,
                    {
                      id: K.value,
                      active: y.value || q.value,
                      centerAffix: I.value === 1 && !w.value,
                      dirty: q.value || e.dirty,
                      disabled: j.value,
                      focused: o.value,
                      error: ce.value === !1,
                    }
                  ),
                  {
                    ...r,
                    default: (Ee) => {
                      let {
                        props: { class: me, ...oe },
                      } = Ee
                      return g(ke, null, [
                        e.prefix && g('span', { class: 'v-text-field__prefix' }, [e.prefix]),
                        Rt(
                          g(
                            'textarea',
                            ae(
                              {
                                ref: v,
                                class: me,
                                value: s.value,
                                onInput: V,
                                autofocus: e.autofocus,
                                readonly: te.value,
                                disabled: j.value,
                                placeholder: e.placeholder,
                                rows: e.rows,
                                name: e.name,
                                onFocus: T,
                                onBlur: l,
                              },
                              oe,
                              B
                            ),
                            null
                          ),
                          [[pi('intersect'), { handler: d }, null, { once: !0 }]]
                        ),
                        e.autoGrow &&
                          Rt(
                            g(
                              'textarea',
                              {
                                class: [me, 'v-textarea__sizer'],
                                id: `${oe.id}-sizer`,
                                'onUpdate:modelValue': (z) => (s.value = z),
                                ref: D,
                                readonly: !0,
                                'aria-hidden': 'true',
                              },
                              null
                            ),
                            [[$F, s.value]]
                          ),
                        e.suffix && g('span', { class: 'v-text-field__suffix' }, [e.suffix]),
                      ])
                    },
                  }
                )
              },
              details: C
                ? (F) => {
                    var K
                    return g(ke, null, [
                      (K = r.details) == null ? void 0 : K.call(r, F),
                      E &&
                        g(ke, null, [
                          g('span', null, null),
                          g(
                            $m,
                            {
                              active: e.persistentCounter || o.value,
                              value: u.value,
                              max: c.value,
                              disabled: e.disabled,
                            },
                            r.counter
                          ),
                        ]),
                    ])
                  }
                : void 0,
            }
          )
        }),
        Li({}, f, m, v)
      )
    },
  }),
  qZ = W({ withBackground: Boolean, ...Te(), ...Ze(), ...He() }, 'VThemeProvider'),
  GZ = ne()({
    name: 'VThemeProvider',
    props: qZ(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e)
      return () => {
        var r
        return e.withBackground
          ? g(
              e.tag,
              { class: ['v-theme-provider', i.value, e.class], style: e.style },
              {
                default: () => {
                  var s
                  return [(s = n.default) == null ? void 0 : s.call(n)]
                },
              }
            )
          : (r = n.default) == null
          ? void 0
          : r.call(n)
      }
    },
  }),
  KZ = W(
    {
      dotColor: String,
      fillDot: Boolean,
      hideDot: Boolean,
      icon: Le,
      iconColor: String,
      lineColor: String,
      ...Te(),
      ...Tt(),
      ..._r(),
      ...en(),
    },
    'VTimelineDivider'
  ),
  YZ = ne()({
    name: 'VTimelineDivider',
    props: KZ(),
    setup(e, t) {
      let { slots: n } = t
      const { sizeClasses: i, sizeStyles: r } = Wl(e, 'v-timeline-divider__dot'),
        { backgroundColorStyles: s, backgroundColorClasses: o } = gt(Q(e, 'dotColor')),
        { roundedClasses: a } = Mt(e, 'v-timeline-divider__dot'),
        { elevationClasses: l } = yn(e),
        { backgroundColorClasses: u, backgroundColorStyles: c } = gt(Q(e, 'lineColor'))
      return (
        se(() =>
          g(
            'div',
            { class: ['v-timeline-divider', { 'v-timeline-divider--fill-dot': e.fillDot }, e.class], style: e.style },
            [
              g('div', { class: ['v-timeline-divider__before', u.value], style: c.value }, null),
              !e.hideDot &&
                g(
                  'div',
                  { key: 'dot', class: ['v-timeline-divider__dot', l.value, a.value, i.value], style: r.value },
                  [
                    g('div', { class: ['v-timeline-divider__inner-dot', o.value, a.value], style: s.value }, [
                      n.default
                        ? g(
                            Ge,
                            {
                              key: 'icon-defaults',
                              disabled: !e.icon,
                              defaults: { VIcon: { color: e.iconColor, icon: e.icon, size: e.size } },
                            },
                            n.default
                          )
                        : g(ot, { key: 'icon', color: e.iconColor, icon: e.icon, size: e.size }, null),
                    ]),
                  ]
                ),
              g('div', { class: ['v-timeline-divider__after', u.value], style: c.value }, null),
            ]
          )
        ),
        {}
      )
    },
  }),
  kO = W(
    {
      density: String,
      dotColor: String,
      fillDot: Boolean,
      hideDot: Boolean,
      hideOpposite: { type: Boolean, default: void 0 },
      icon: Le,
      iconColor: String,
      lineInset: [Number, String],
      ...Te(),
      ...on(),
      ...en(),
      ...Tt(),
      ..._r(),
      ...He(),
    },
    'VTimelineItem'
  ),
  QZ = ne()({
    name: 'VTimelineItem',
    props: kO(),
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: i } = an(e),
        r = ye(0),
        s = le()
      return (
        be(
          s,
          (o) => {
            var a
            o &&
              (r.value =
                ((a = o.$el.querySelector('.v-timeline-divider__dot')) == null
                  ? void 0
                  : a.getBoundingClientRect().width) ?? 0)
          },
          { flush: 'post' }
        ),
        se(() => {
          var o, a
          return g(
            'div',
            {
              class: ['v-timeline-item', { 'v-timeline-item--fill-dot': e.fillDot }, e.class],
              style: [
                {
                  '--v-timeline-dot-size': Se(r.value),
                  '--v-timeline-line-inset': e.lineInset
                    ? `calc(var(--v-timeline-dot-size) / 2 + ${Se(e.lineInset)})`
                    : Se(0),
                },
                e.style,
              ],
            },
            [
              g('div', { class: 'v-timeline-item__body', style: i.value }, [
                (o = n.default) == null ? void 0 : o.call(n),
              ]),
              g(
                YZ,
                {
                  ref: s,
                  hideDot: e.hideDot,
                  icon: e.icon,
                  iconColor: e.iconColor,
                  size: e.size,
                  elevation: e.elevation,
                  dotColor: e.dotColor,
                  fillDot: e.fillDot,
                  rounded: e.rounded,
                },
                { default: n.icon }
              ),
              e.density !== 'compact' &&
                g('div', { class: 'v-timeline-item__opposite' }, [
                  !e.hideOpposite && ((a = n.opposite) == null ? void 0 : a.call(n)),
                ]),
            ]
          )
        }),
        {}
      )
    },
  }),
  XZ = W(
    {
      align: { type: String, default: 'center', validator: (e) => ['center', 'start'].includes(e) },
      direction: { type: String, default: 'vertical', validator: (e) => ['vertical', 'horizontal'].includes(e) },
      justify: { type: String, default: 'auto', validator: (e) => ['auto', 'center'].includes(e) },
      side: { type: String, validator: (e) => e == null || ['start', 'end'].includes(e) },
      lineThickness: { type: [String, Number], default: 2 },
      lineColor: String,
      truncateLine: { type: String, validator: (e) => ['start', 'end', 'both'].includes(e) },
      ...Sm(kO({ lineInset: 0 }), ['dotColor', 'fillDot', 'hideOpposite', 'iconColor', 'lineInset', 'size']),
      ...Te(),
      ...ln(),
      ...He(),
      ...Ze(),
    },
    'VTimeline'
  ),
  JZ = ne()({
    name: 'VTimeline',
    props: XZ(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: i } = at(e),
        { densityClasses: r } = Un(e),
        { rtlClasses: s } = sn()
      Ot({
        VTimelineDivider: { lineColor: Q(e, 'lineColor') },
        VTimelineItem: {
          density: Q(e, 'density'),
          dotColor: Q(e, 'dotColor'),
          fillDot: Q(e, 'fillDot'),
          hideOpposite: Q(e, 'hideOpposite'),
          iconColor: Q(e, 'iconColor'),
          lineColor: Q(e, 'lineColor'),
          lineInset: Q(e, 'lineInset'),
          size: Q(e, 'size'),
        },
      })
      const o = k(() => {
          const l = e.side ? e.side : e.density !== 'default' ? 'end' : null
          return l && `v-timeline--side-${l}`
        }),
        a = k(() => {
          const l = ['v-timeline--truncate-line-start', 'v-timeline--truncate-line-end']
          switch (e.truncateLine) {
            case 'both':
              return l
            case 'start':
              return l[0]
            case 'end':
              return l[1]
            default:
              return null
          }
        })
      return (
        se(() =>
          g(
            e.tag,
            {
              class: [
                'v-timeline',
                `v-timeline--${e.direction}`,
                `v-timeline--align-${e.align}`,
                `v-timeline--justify-${e.justify}`,
                a.value,
                { 'v-timeline--inset-line': !!e.lineInset },
                i.value,
                r.value,
                o.value,
                s.value,
                e.class,
              ],
              style: [{ '--v-timeline-line-thickness': Se(e.lineThickness) }, e.style],
            },
            n
          )
        ),
        {}
      )
    },
  }),
  ZZ = W({ ...Te(), ...Mi({ variant: 'text' }) }, 'VToolbarItems'),
  eee = ne()({
    name: 'VToolbarItems',
    props: ZZ(),
    setup(e, t) {
      let { slots: n } = t
      return (
        Ot({ VBtn: { color: Q(e, 'color'), height: 'inherit', variant: Q(e, 'variant') } }),
        se(() => {
          var i
          return g('div', { class: ['v-toolbar-items', e.class], style: e.style }, [
            (i = n.default) == null ? void 0 : i.call(n),
          ])
        }),
        {}
      )
    },
  }),
  tee = W(
    {
      id: String,
      text: String,
      ...Qt(
        gd({
          closeOnBack: !1,
          location: 'end',
          locationStrategy: 'connected',
          eager: !0,
          minWidth: 0,
          offset: 10,
          openOnClick: !1,
          openOnHover: !0,
          origin: 'auto',
          scrim: !1,
          scrollStrategy: 'reposition',
          transition: !1,
        }),
        ['absolute', 'persistent']
      ),
    },
    'VTooltip'
  ),
  PO = ne()({
    name: 'VTooltip',
    props: tee(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = xe(e, 'modelValue'),
        { scopeId: r } = _a(),
        s = pn(),
        o = k(() => e.id || `v-tooltip-${s}`),
        a = le(),
        l = k(() => (e.location.split(' ').length > 1 ? e.location : e.location + ' center')),
        u = k(() =>
          e.origin === 'auto' ||
          e.origin === 'overlap' ||
          e.origin.split(' ').length > 1 ||
          e.location.split(' ').length > 1
            ? e.origin
            : e.origin + ' center'
        ),
        c = k(() => (e.transition ? e.transition : i.value ? 'scale-transition' : 'fade-transition')),
        d = k(() => ae({ 'aria-describedby': o.value }, e.activatorProps))
      return (
        se(() => {
          const f = mr.filterProps(e)
          return g(
            mr,
            ae(
              { ref: a, class: ['v-tooltip', e.class], style: e.style, id: o.value },
              f,
              {
                modelValue: i.value,
                'onUpdate:modelValue': (m) => (i.value = m),
                transition: c.value,
                absolute: !0,
                location: l.value,
                origin: u.value,
                persistent: !0,
                role: 'tooltip',
                activatorProps: d.value,
                _disableGlobalStack: !0,
              },
              r
            ),
            {
              activator: n.activator,
              default: function () {
                var y
                for (var m = arguments.length, p = new Array(m), v = 0; v < m; v++) p[v] = arguments[v]
                return ((y = n.default) == null ? void 0 : y.call(n, ...p)) ?? e.text
              },
            }
          )
        }),
        Li({}, a)
      )
    },
  }),
  nee = ne()({
    name: 'VValidation',
    props: DD(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const i = ND(e, 'validation')
      return () => {
        var r
        return (r = n.default) == null ? void 0 : r.call(n, i)
      }
    },
  }),
  iee = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        VAlert: T8,
        VAlertTitle: CD,
        VApp: N7,
        VAppBar: e8,
        VAppBarNavIcon: w8,
        VAppBarTitle: I8,
        VAutocomplete: GY,
        VAvatar: Vi,
        VBadge: YY,
        VBanner: JY,
        VBannerActions: cN,
        VBannerText: dN,
        VBottomNavigation: eQ,
        VBottomSheet: nQ,
        VBreadcrumbs: oQ,
        VBreadcrumbsDivider: fN,
        VBreadcrumbsItem: mN,
        VBtn: st,
        VBtnGroup: qp,
        VBtnToggle: o8,
        VCard: dQ,
        VCardActions: gN,
        VCardItem: yN,
        VCardSubtitle: vN,
        VCardText: _N,
        VCardTitle: pN,
        VCarousel: bQ,
        VCarouselItem: IQ,
        VCheckbox: N8,
        VCheckboxBtn: $r,
        VChip: Yl,
        VChipGroup: B8,
        VClassIcon: Rm,
        VCode: SQ,
        VCol: JX,
        VColorPicker: dX,
        VCombobox: mX,
        VComponentIcon: zp,
        VConfirmEdit: vX,
        VContainer: KX,
        VCounter: $m,
        VDataIterator: CX,
        VDataTable: jX,
        VDataTableFooter: Nc,
        VDataTableHeaders: Jo,
        VDataTableRow: gw,
        VDataTableRows: Zo,
        VDataTableServer: qX,
        VDataTableVirtual: HX,
        VDatePicker: dJ,
        VDatePickerControls: ly,
        VDatePickerHeader: uy,
        VDatePickerMonth: cy,
        VDatePickerMonths: dy,
        VDatePickerYears: hy,
        VDefaultsProvider: Ge,
        VDialog: ey,
        VDialogBottomTransition: F7,
        VDialogTopTransition: B7,
        VDialogTransition: xm,
        VDivider: md,
        VEmptyState: fJ,
        VExpandTransition: Vm,
        VExpandXTransition: jb,
        VExpansionPanel: mJ,
        VExpansionPanelText: fy,
        VExpansionPanelTitle: my,
        VExpansionPanels: pJ,
        VFab: _J,
        VFabTransition: L7,
        VFadeTransition: kc,
        VField: Ql,
        VFieldLabel: Ou,
        VFileInput: wJ,
        VFooter: SJ,
        VForm: TJ,
        VHover: AJ,
        VIcon: ot,
        VImg: Br,
        VInfiniteScroll: PJ,
        VInput: Cn,
        VItem: VJ,
        VItemGroup: xJ,
        VKbd: DJ,
        VLabel: Kl,
        VLayout: OJ,
        VLayoutItem: LJ,
        VLazy: BJ,
        VLigatureIcon: T7,
        VList: Bm,
        VListGroup: Qp,
        VListImg: lY,
        VListItem: Ur,
        VListItemAction: cY,
        VListItemMedia: hY,
        VListItemSubtitle: qD,
        VListItemTitle: GD,
        VListSubheader: KD,
        VLocaleProvider: UJ,
        VMain: zJ,
        VMenu: xl,
        VMessages: xD,
        VNavigationDrawer: JJ,
        VNoSsr: ZJ,
        VOtpInput: tZ,
        VOverlay: mr,
        VPagination: oy,
        VParallax: rZ,
        VProgressCircular: Rl,
        VProgressLinear: Nm,
        VRadio: oZ,
        VRadioGroup: lZ,
        VRangeSlider: cZ,
        VRating: hZ,
        VResponsive: Hp,
        VRow: sJ,
        VScaleTransition: $b,
        VScrollXReverseTransition: U7,
        VScrollXTransition: $7,
        VScrollYReverseTransition: z7,
        VScrollYTransition: j7,
        VSelect: iw,
        VSelectionControl: Fs,
        VSelectionControlGroup: kD,
        VSheet: Xo,
        VSkeletonLoader: vZ,
        VSlideGroup: Vc,
        VSlideGroupItem: pZ,
        VSlideXReverseTransition: W7,
        VSlideXTransition: H7,
        VSlideYReverseTransition: q7,
        VSlideYTransition: Ub,
        VSlider: sy,
        VSnackbar: bZ,
        VSpacer: oO,
        VSparkline: EZ,
        VSpeedDial: CZ,
        VStepper: DZ,
        VStepperActions: bO,
        VStepperHeader: wO,
        VStepperItem: IO,
        VStepperWindow: SO,
        VStepperWindowItem: EO,
        VSvgIcon: Fb,
        VSwitch: OZ,
        VSystemBar: LZ,
        VTab: TO,
        VTable: ea,
        VTabs: zZ,
        VTabsWindow: CO,
        VTabsWindowItem: AO,
        VTextField: Ko,
        VTextarea: WZ,
        VThemeProvider: GZ,
        VTimeline: JZ,
        VTimelineItem: QZ,
        VToolbar: Wp,
        VToolbarItems: eee,
        VToolbarTitle: Bb,
        VTooltip: PO,
        VValidation: nee,
        VVirtualScroll: jm,
        VWindow: Yo,
        VWindowItem: Qo,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function ree(e, t) {
  const n = t.modifiers || {},
    i = t.value,
    { once: r, immediate: s, ...o } = n,
    a = !Object.keys(o).length,
    { handler: l, options: u } =
      typeof i == 'object'
        ? i
        : {
            handler: i,
            options: {
              attributes: (o == null ? void 0 : o.attr) ?? a,
              characterData: (o == null ? void 0 : o.char) ?? a,
              childList: (o == null ? void 0 : o.child) ?? a,
              subtree: (o == null ? void 0 : o.sub) ?? a,
            },
          },
    c = new MutationObserver(function () {
      let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        f = arguments.length > 1 ? arguments[1] : void 0
      l == null || l(d, f), r && RO(e, t)
    })
  s && (l == null || l([], c)),
    (e._mutate = Object(e._mutate)),
    (e._mutate[t.instance.$.uid] = { observer: c }),
    c.observe(e, u)
}
function RO(e, t) {
  var n
  ;(n = e._mutate) != null &&
    n[t.instance.$.uid] &&
    (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid])
}
const see = { mounted: ree, unmounted: RO }
function oee(e, t) {
  var r, s
  const n = t.value,
    i = { passive: !((r = t.modifiers) != null && r.active) }
  window.addEventListener('resize', n, i),
    (e._onResize = Object(e._onResize)),
    (e._onResize[t.instance.$.uid] = { handler: n, options: i }),
    ((s = t.modifiers) != null && s.quiet) || n()
}
function aee(e, t) {
  var r
  if (!((r = e._onResize) != null && r[t.instance.$.uid])) return
  const { handler: n, options: i } = e._onResize[t.instance.$.uid]
  window.removeEventListener('resize', n, i), delete e._onResize[t.instance.$.uid]
}
const lee = { mounted: oee, unmounted: aee }
function xO(e, t) {
  const { self: n = !1 } = t.modifiers ?? {},
    i = t.value,
    r = (typeof i == 'object' && i.options) || { passive: !0 },
    s = typeof i == 'function' || 'handleEvent' in i ? i : i.handler,
    o = n ? e : t.arg ? document.querySelector(t.arg) : window
  o &&
    (o.addEventListener('scroll', s, r),
    (e._onScroll = Object(e._onScroll)),
    (e._onScroll[t.instance.$.uid] = { handler: s, options: r, target: n ? void 0 : o }))
}
function VO(e, t) {
  var s
  if (!((s = e._onScroll) != null && s[t.instance.$.uid])) return
  const { handler: n, options: i, target: r = e } = e._onScroll[t.instance.$.uid]
  r.removeEventListener('scroll', n, i), delete e._onScroll[t.instance.$.uid]
}
function uee(e, t) {
  t.value !== t.oldValue && (VO(e, t), xO(e, t))
}
const cee = { mounted: xO, unmounted: VO, updated: uee }
function dee(e, t) {
  const n = typeof e == 'string' ? fL(e) : e,
    i = hee(n, t)
  return {
    mounted: i,
    updated: i,
    unmounted(r) {
      GA(null, r)
    },
  }
}
function hee(e, t) {
  return function (n, i, r) {
    var d, f, m
    const s = typeof t == 'function' ? t(i) : t,
      o = ((d = i.value) == null ? void 0 : d.text) ?? i.value ?? (s == null ? void 0 : s.text),
      a = Sc(i.value) ? i.value : {},
      l = () => o ?? n.innerHTML,
      u =
        (r.ctx === i.instance.$
          ? (f = fee(r, i.instance.$)) == null
            ? void 0
            : f.provides
          : (m = r.ctx) == null
          ? void 0
          : m.provides) ?? i.instance.$.provides,
      c = Yi(e, ae(s, a), l)
    ;(c.appContext = Object.assign(Object.create(null), i.instance.$.appContext, { provides: u })), GA(c, n)
  }
}
function fee(e, t) {
  const n = new Set(),
    i = (s) => {
      var o, a
      for (const l of s) {
        if (!l) continue
        if (l === e) return !0
        n.add(l)
        let u
        if (
          (l.suspense
            ? (u = i([l.ssContent]))
            : Array.isArray(l.children)
            ? (u = i(l.children))
            : (o = l.component) != null && o.vnode && (u = i([(a = l.component) == null ? void 0 : a.subTree])),
          u)
        )
          return u
        n.delete(l)
      }
      return !1
    }
  if (!i([t.subTree])) throw new Error('Could not find original vnode')
  const r = Array.from(n).reverse()
  for (const s of r) if (s.component) return s.component
  return t
}
const mee = dee(PO, (e) => {
    var t
    return {
      activator: 'parent',
      location: ((t = e.arg) == null ? void 0 : t.replace('-', ' ')) ?? 'top',
      text: typeof e.value == 'boolean' ? void 0 : e.value,
    }
  }),
  gee = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        ClickOutside: sN,
        Intersect: ld,
        Mutate: see,
        Resize: lee,
        Ripple: Yr,
        Scroll: cee,
        Tooltip: mee,
        Touch: rw,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  vee = {
    collapse: 'fas fa-chevron-up',
    complete: 'fas fa-check',
    cancel: 'fas fa-times-circle',
    close: 'fas fa-times',
    delete: 'fas fa-times-circle',
    clear: 'fas fa-times-circle',
    success: 'fas fa-check-circle',
    info: 'fas fa-info-circle',
    warning: 'fas fa-exclamation',
    error: 'fas fa-exclamation-triangle',
    prev: 'fas fa-chevron-left',
    next: 'fas fa-chevron-right',
    checkboxOn: 'fas fa-check-square',
    checkboxOff: 'far fa-square',
    checkboxIndeterminate: 'fas fa-minus-square',
    delimiter: 'fas fa-circle',
    sortAsc: 'fas fa-arrow-up',
    sortDesc: 'fas fa-arrow-down',
    expand: 'fas fa-chevron-down',
    menu: 'fas fa-bars',
    subgroup: 'fas fa-caret-down',
    dropdown: 'fas fa-caret-down',
    radioOn: 'far fa-dot-circle',
    radioOff: 'far fa-circle',
    edit: 'fas fa-edit',
    ratingEmpty: 'far fa-star',
    ratingFull: 'fas fa-star',
    ratingHalf: 'fas fa-star-half',
    loading: 'fas fa-sync',
    first: 'fas fa-step-backward',
    last: 'fas fa-step-forward',
    unfold: 'fas fa-arrows-alt-v',
    file: 'fas fa-paperclip',
    plus: 'fas fa-plus',
    minus: 'fas fa-minus',
    calendar: 'fas fa-calendar',
    treeviewCollapse: 'fas fa-caret-down',
    treeviewExpand: 'fas fa-caret-right',
    eyeDropper: 'fas fa-eye-dropper',
  },
  pee = { component: Rm }
var DO =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
function NO(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
var OO = { exports: {} }
;(function (e, t) {
  ;(function (n, i) {
    e.exports = i()
  })(DO, function () {
    var n = 1e3,
      i = 6e4,
      r = 36e5,
      s = 'millisecond',
      o = 'second',
      a = 'minute',
      l = 'hour',
      u = 'day',
      c = 'week',
      d = 'month',
      f = 'quarter',
      m = 'year',
      p = 'date',
      v = 'Invalid Date',
      y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      T = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      A = {
        name: 'en',
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        ordinal: function (B) {
          var U = ['th', 'st', 'nd', 'rd'],
            $ = B % 100
          return '[' + B + (U[($ - 20) % 10] || U[$] || U[0]) + ']'
        },
      },
      x = function (B, U, $) {
        var G = String(B)
        return !G || G.length >= U ? B : '' + Array(U + 1 - G.length).join($) + B
      },
      N = {
        s: x,
        z: function (B) {
          var U = -B.utcOffset(),
            $ = Math.abs(U),
            G = Math.floor($ / 60),
            F = $ % 60
          return (U <= 0 ? '+' : '-') + x(G, 2, '0') + ':' + x(F, 2, '0')
        },
        m: function B(U, $) {
          if (U.date() < $.date()) return -B($, U)
          var G = 12 * ($.year() - U.year()) + ($.month() - U.month()),
            F = U.clone().add(G, d),
            K = $ - F < 0,
            j = U.clone().add(G + (K ? -1 : 1), d)
          return +(-(G + ($ - F) / (K ? F - j : j - F)) || 0)
        },
        a: function (B) {
          return B < 0 ? Math.ceil(B) || 0 : Math.floor(B)
        },
        p: function (B) {
          return (
            { M: d, y: m, w: c, d: u, D: p, h: l, m: a, s: o, ms: s, Q: f }[B] ||
            String(B || '')
              .toLowerCase()
              .replace(/s$/, '')
          )
        },
        u: function (B) {
          return B === void 0
        },
      },
      V = 'en',
      D = {}
    D[V] = A
    var I = '$isDayjsObject',
      w = function (B) {
        return B instanceof C || !(!B || !B[I])
      },
      _ = function B(U, $, G) {
        var F
        if (!U) return V
        if (typeof U == 'string') {
          var K = U.toLowerCase()
          D[K] && (F = K), $ && ((D[K] = $), (F = K))
          var j = U.split('-')
          if (!F && j.length > 1) return B(j[0])
        } else {
          var q = U.name
          ;(D[q] = U), (F = q)
        }
        return !G && F && (V = F), F || (!G && V)
      },
      S = function (B, U) {
        if (w(B)) return B.clone()
        var $ = typeof U == 'object' ? U : {}
        return ($.date = B), ($.args = arguments), new C($)
      },
      E = N
    ;(E.l = _),
      (E.i = w),
      (E.w = function (B, U) {
        return S(B, { locale: U.$L, utc: U.$u, x: U.$x, $offset: U.$offset })
      })
    var C = (function () {
        function B($) {
          ;(this.$L = _($.locale, null, !0)), this.parse($), (this.$x = this.$x || $.x || {}), (this[I] = !0)
        }
        var U = B.prototype
        return (
          (U.parse = function ($) {
            ;(this.$d = (function (G) {
              var F = G.date,
                K = G.utc
              if (F === null) return new Date(NaN)
              if (E.u(F)) return new Date()
              if (F instanceof Date) return new Date(F)
              if (typeof F == 'string' && !/Z$/i.test(F)) {
                var j = F.match(y)
                if (j) {
                  var q = j[2] - 1 || 0,
                    te = (j[7] || '0').substring(0, 3)
                  return K
                    ? new Date(Date.UTC(j[1], q, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, te))
                    : new Date(j[1], q, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, te)
                }
              }
              return new Date(F)
            })($)),
              this.init()
          }),
          (U.init = function () {
            var $ = this.$d
            ;(this.$y = $.getFullYear()),
              (this.$M = $.getMonth()),
              (this.$D = $.getDate()),
              (this.$W = $.getDay()),
              (this.$H = $.getHours()),
              (this.$m = $.getMinutes()),
              (this.$s = $.getSeconds()),
              (this.$ms = $.getMilliseconds())
          }),
          (U.$utils = function () {
            return E
          }),
          (U.isValid = function () {
            return this.$d.toString() !== v
          }),
          (U.isSame = function ($, G) {
            var F = S($)
            return this.startOf(G) <= F && F <= this.endOf(G)
          }),
          (U.isAfter = function ($, G) {
            return S($) < this.startOf(G)
          }),
          (U.isBefore = function ($, G) {
            return this.endOf(G) < S($)
          }),
          (U.$g = function ($, G, F) {
            return E.u($) ? this[G] : this.set(F, $)
          }),
          (U.unix = function () {
            return Math.floor(this.valueOf() / 1e3)
          }),
          (U.valueOf = function () {
            return this.$d.getTime()
          }),
          (U.startOf = function ($, G) {
            var F = this,
              K = !!E.u(G) || G,
              j = E.p($),
              q = function (de, Z) {
                var pe = E.w(F.$u ? Date.UTC(F.$y, Z, de) : new Date(F.$y, Z, de), F)
                return K ? pe : pe.endOf(u)
              },
              te = function (de, Z) {
                return E.w(F.toDate()[de].apply(F.toDate('s'), (K ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Z)), F)
              },
              ce = this.$W,
              Ee = this.$M,
              me = this.$D,
              oe = 'set' + (this.$u ? 'UTC' : '')
            switch (j) {
              case m:
                return K ? q(1, 0) : q(31, 11)
              case d:
                return K ? q(1, Ee) : q(0, Ee + 1)
              case c:
                var z = this.$locale().weekStart || 0,
                  ue = (ce < z ? ce + 7 : ce) - z
                return q(K ? me - ue : me + (6 - ue), Ee)
              case u:
              case p:
                return te(oe + 'Hours', 0)
              case l:
                return te(oe + 'Minutes', 1)
              case a:
                return te(oe + 'Seconds', 2)
              case o:
                return te(oe + 'Milliseconds', 3)
              default:
                return this.clone()
            }
          }),
          (U.endOf = function ($) {
            return this.startOf($, !1)
          }),
          (U.$set = function ($, G) {
            var F,
              K = E.p($),
              j = 'set' + (this.$u ? 'UTC' : ''),
              q = ((F = {}),
              (F[u] = j + 'Date'),
              (F[p] = j + 'Date'),
              (F[d] = j + 'Month'),
              (F[m] = j + 'FullYear'),
              (F[l] = j + 'Hours'),
              (F[a] = j + 'Minutes'),
              (F[o] = j + 'Seconds'),
              (F[s] = j + 'Milliseconds'),
              F)[K],
              te = K === u ? this.$D + (G - this.$W) : G
            if (K === d || K === m) {
              var ce = this.clone().set(p, 1)
              ce.$d[q](te), ce.init(), (this.$d = ce.set(p, Math.min(this.$D, ce.daysInMonth())).$d)
            } else q && this.$d[q](te)
            return this.init(), this
          }),
          (U.set = function ($, G) {
            return this.clone().$set($, G)
          }),
          (U.get = function ($) {
            return this[E.p($)]()
          }),
          (U.add = function ($, G) {
            var F,
              K = this
            $ = Number($)
            var j = E.p(G),
              q = function (Ee) {
                var me = S(K)
                return E.w(me.date(me.date() + Math.round(Ee * $)), K)
              }
            if (j === d) return this.set(d, this.$M + $)
            if (j === m) return this.set(m, this.$y + $)
            if (j === u) return q(1)
            if (j === c) return q(7)
            var te = ((F = {}), (F[a] = i), (F[l] = r), (F[o] = n), F)[j] || 1,
              ce = this.$d.getTime() + $ * te
            return E.w(ce, this)
          }),
          (U.subtract = function ($, G) {
            return this.add(-1 * $, G)
          }),
          (U.format = function ($) {
            var G = this,
              F = this.$locale()
            if (!this.isValid()) return F.invalidDate || v
            var K = $ || 'YYYY-MM-DDTHH:mm:ssZ',
              j = E.z(this),
              q = this.$H,
              te = this.$m,
              ce = this.$M,
              Ee = F.weekdays,
              me = F.months,
              oe = F.meridiem,
              z = function (Z, pe, re, O) {
                return (Z && (Z[pe] || Z(G, K))) || re[pe].slice(0, O)
              },
              ue = function (Z) {
                return E.s(q % 12 || 12, Z, '0')
              },
              de =
                oe ||
                function (Z, pe, re) {
                  var O = Z < 12 ? 'AM' : 'PM'
                  return re ? O.toLowerCase() : O
                }
            return K.replace(T, function (Z, pe) {
              return (
                pe ||
                (function (re) {
                  switch (re) {
                    case 'YY':
                      return String(G.$y).slice(-2)
                    case 'YYYY':
                      return E.s(G.$y, 4, '0')
                    case 'M':
                      return ce + 1
                    case 'MM':
                      return E.s(ce + 1, 2, '0')
                    case 'MMM':
                      return z(F.monthsShort, ce, me, 3)
                    case 'MMMM':
                      return z(me, ce)
                    case 'D':
                      return G.$D
                    case 'DD':
                      return E.s(G.$D, 2, '0')
                    case 'd':
                      return String(G.$W)
                    case 'dd':
                      return z(F.weekdaysMin, G.$W, Ee, 2)
                    case 'ddd':
                      return z(F.weekdaysShort, G.$W, Ee, 3)
                    case 'dddd':
                      return Ee[G.$W]
                    case 'H':
                      return String(q)
                    case 'HH':
                      return E.s(q, 2, '0')
                    case 'h':
                      return ue(1)
                    case 'hh':
                      return ue(2)
                    case 'a':
                      return de(q, te, !0)
                    case 'A':
                      return de(q, te, !1)
                    case 'm':
                      return String(te)
                    case 'mm':
                      return E.s(te, 2, '0')
                    case 's':
                      return String(G.$s)
                    case 'ss':
                      return E.s(G.$s, 2, '0')
                    case 'SSS':
                      return E.s(G.$ms, 3, '0')
                    case 'Z':
                      return j
                  }
                  return null
                })(Z) ||
                j.replace(':', '')
              )
            })
          }),
          (U.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
          }),
          (U.diff = function ($, G, F) {
            var K,
              j = this,
              q = E.p(G),
              te = S($),
              ce = (te.utcOffset() - this.utcOffset()) * i,
              Ee = this - te,
              me = function () {
                return E.m(j, te)
              }
            switch (q) {
              case m:
                K = me() / 12
                break
              case d:
                K = me()
                break
              case f:
                K = me() / 3
                break
              case c:
                K = (Ee - ce) / 6048e5
                break
              case u:
                K = (Ee - ce) / 864e5
                break
              case l:
                K = Ee / r
                break
              case a:
                K = Ee / i
                break
              case o:
                K = Ee / n
                break
              default:
                K = Ee
            }
            return F ? K : E.a(K)
          }),
          (U.daysInMonth = function () {
            return this.endOf(d).$D
          }),
          (U.$locale = function () {
            return D[this.$L]
          }),
          (U.locale = function ($, G) {
            if (!$) return this.$L
            var F = this.clone(),
              K = _($, G, !0)
            return K && (F.$L = K), F
          }),
          (U.clone = function () {
            return E.w(this.$d, this)
          }),
          (U.toDate = function () {
            return new Date(this.valueOf())
          }),
          (U.toJSON = function () {
            return this.isValid() ? this.toISOString() : null
          }),
          (U.toISOString = function () {
            return this.$d.toISOString()
          }),
          (U.toString = function () {
            return this.$d.toUTCString()
          }),
          B
        )
      })(),
      R = C.prototype
    return (
      (S.prototype = R),
      [
        ['$ms', s],
        ['$s', o],
        ['$m', a],
        ['$H', l],
        ['$W', u],
        ['$M', d],
        ['$y', m],
        ['$D', p],
      ].forEach(function (B) {
        R[B[1]] = function (U) {
          return this.$g(U, B[0], B[1])
        }
      }),
      (S.extend = function (B, U) {
        return B.$i || (B(U, C, S), (B.$i = !0)), S
      }),
      (S.locale = _),
      (S.isDayjs = w),
      (S.unix = function (B) {
        return S(1e3 * B)
      }),
      (S.en = D[V]),
      (S.Ls = D),
      (S.p = {}),
      S
    )
  })
})(OO)
var yee = OO.exports
const _ee = NO(yee)
var MO = { exports: {} }
;(function (e, t) {
  ;(function (n, i) {
    e.exports = i()
  })(DO, function () {
    return function (n, i, r) {
      n = n || {}
      var s = i.prototype,
        o = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        }
      function a(u, c, d, f) {
        return s.fromToBase(u, c, d, f)
      }
      ;(r.en.relativeTime = o),
        (s.fromToBase = function (u, c, d, f, m) {
          for (
            var p,
              v,
              y,
              T = d.$locale().relativeTime || o,
              A = n.thresholds || [
                { l: 's', r: 44, d: 'second' },
                { l: 'm', r: 89 },
                { l: 'mm', r: 44, d: 'minute' },
                { l: 'h', r: 89 },
                { l: 'hh', r: 21, d: 'hour' },
                { l: 'd', r: 35 },
                { l: 'dd', r: 25, d: 'day' },
                { l: 'M', r: 45 },
                { l: 'MM', r: 10, d: 'month' },
                { l: 'y', r: 17 },
                { l: 'yy', d: 'year' },
              ],
              x = A.length,
              N = 0;
            N < x;
            N += 1
          ) {
            var V = A[N]
            V.d && (p = f ? r(u).diff(d, V.d, !0) : d.diff(u, V.d, !0))
            var D = (n.rounding || Math.round)(Math.abs(p))
            if (((y = p > 0), D <= V.r || !V.r)) {
              D <= 1 && N > 0 && (V = A[N - 1])
              var I = T[V.l]
              m && (D = m('' + D)), (v = typeof I == 'string' ? I.replace('%d', D) : I(D, c, V.l, y))
              break
            }
          }
          if (c) return v
          var w = y ? T.future : T.past
          return typeof w == 'function' ? w(v) : w.replace('%s', v)
        }),
        (s.to = function (u, c) {
          return a(u, c, this, !0)
        }),
        (s.from = function (u, c) {
          return a(u, c, this)
        })
      var l = function (u) {
        return u.$u ? r.utc() : r()
      }
      ;(s.toNow = function (u) {
        return this.to(l(this), u)
      }),
        (s.fromNow = function (u) {
          return this.from(l(this), u)
        })
    }
  })
})(MO)
var bee = MO.exports
const wee = NO(bee)
/*!
 * vue-router v4.4.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */ const za = typeof document < 'u'
function Iee(e) {
  return e.__esModule || e[Symbol.toStringTag] === 'Module'
}
const vt = Object.assign
function gv(e, t) {
  const n = {}
  for (const i in t) {
    const r = t[i]
    n[i] = Ki(r) ? r.map(e) : e(r)
  }
  return n
}
const ec = () => {},
  Ki = Array.isArray,
  LO = /#/g,
  See = /&/g,
  Eee = /\//g,
  Tee = /=/g,
  Cee = /\?/g,
  FO = /\+/g,
  Aee = /%5B/g,
  kee = /%5D/g,
  BO = /%5E/g,
  Pee = /%60/g,
  $O = /%7B/g,
  Ree = /%7C/g,
  UO = /%7D/g,
  xee = /%20/g
function Iw(e) {
  return encodeURI('' + e)
    .replace(Ree, '|')
    .replace(Aee, '[')
    .replace(kee, ']')
}
function Vee(e) {
  return Iw(e).replace($O, '{').replace(UO, '}').replace(BO, '^')
}
function gy(e) {
  return Iw(e)
    .replace(FO, '%2B')
    .replace(xee, '+')
    .replace(LO, '%23')
    .replace(See, '%26')
    .replace(Pee, '`')
    .replace($O, '{')
    .replace(UO, '}')
    .replace(BO, '^')
}
function Dee(e) {
  return gy(e).replace(Tee, '%3D')
}
function Nee(e) {
  return Iw(e).replace(LO, '%23').replace(Cee, '%3F')
}
function Oee(e) {
  return e == null ? '' : Nee(e).replace(Eee, '%2F')
}
function Mc(e) {
  try {
    return decodeURIComponent('' + e)
  } catch {}
  return '' + e
}
const Mee = /\/$/,
  Lee = (e) => e.replace(Mee, '')
function vv(e, t, n = '/') {
  let i,
    r = {},
    s = '',
    o = ''
  const a = t.indexOf('#')
  let l = t.indexOf('?')
  return (
    a < l && a >= 0 && (l = -1),
    l > -1 && ((i = t.slice(0, l)), (s = t.slice(l + 1, a > -1 ? a : t.length)), (r = e(s))),
    a > -1 && ((i = i || t.slice(0, a)), (o = t.slice(a, t.length))),
    (i = Uee(i ?? t, n)),
    { fullPath: i + (s && '?') + s + o, path: i, query: r, hash: Mc(o) }
  )
}
function Fee(e, t) {
  const n = t.query ? e(t.query) : ''
  return t.path + (n && '?') + n + (t.hash || '')
}
function iC(e, t) {
  return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || '/'
}
function Bee(e, t, n) {
  const i = t.matched.length - 1,
    r = n.matched.length - 1
  return (
    i > -1 &&
    i === r &&
    Vl(t.matched[i], n.matched[r]) &&
    jO(t.params, n.params) &&
    e(t.query) === e(n.query) &&
    t.hash === n.hash
  )
}
function Vl(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}
function jO(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1
  for (const n in e) if (!$ee(e[n], t[n])) return !1
  return !0
}
function $ee(e, t) {
  return Ki(e) ? rC(e, t) : Ki(t) ? rC(t, e) : e === t
}
function rC(e, t) {
  return Ki(t) ? e.length === t.length && e.every((n, i) => n === t[i]) : e.length === 1 && e[0] === t
}
function Uee(e, t) {
  if (e.startsWith('/')) return e
  if (!e) return t
  const n = t.split('/'),
    i = e.split('/'),
    r = i[i.length - 1]
  ;(r === '..' || r === '.') && i.push('')
  let s = n.length - 1,
    o,
    a
  for (o = 0; o < i.length; o++)
    if (((a = i[o]), a !== '.'))
      if (a === '..') s > 1 && s--
      else break
  return n.slice(0, s).join('/') + '/' + i.slice(o).join('/')
}
const as = {
  path: '/',
  name: void 0,
  params: {},
  query: {},
  hash: '',
  fullPath: '/',
  matched: [],
  meta: {},
  redirectedFrom: void 0,
}
var Lc
;(function (e) {
  ;(e.pop = 'pop'), (e.push = 'push')
})(Lc || (Lc = {}))
var tc
;(function (e) {
  ;(e.back = 'back'), (e.forward = 'forward'), (e.unknown = '')
})(tc || (tc = {}))
function jee(e) {
  if (!e)
    if (za) {
      const t = document.querySelector('base')
      ;(e = (t && t.getAttribute('href')) || '/'), (e = e.replace(/^\w+:\/\/[^\/]+/, ''))
    } else e = '/'
  return e[0] !== '/' && e[0] !== '#' && (e = '/' + e), Lee(e)
}
const zee = /^[^#]+#/
function Hee(e, t) {
  return e.replace(zee, '#') + t
}
function Wee(e, t) {
  const n = document.documentElement.getBoundingClientRect(),
    i = e.getBoundingClientRect()
  return { behavior: t.behavior, left: i.left - n.left - (t.left || 0), top: i.top - n.top - (t.top || 0) }
}
const ng = () => ({ left: window.scrollX, top: window.scrollY })
function qee(e) {
  let t
  if ('el' in e) {
    const n = e.el,
      i = typeof n == 'string' && n.startsWith('#'),
      r = typeof n == 'string' ? (i ? document.getElementById(n.slice(1)) : document.querySelector(n)) : n
    if (!r) return
    t = Wee(r, e)
  } else t = e
  'scrollBehavior' in document.documentElement.style
    ? window.scrollTo(t)
    : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}
function sC(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}
const vy = new Map()
function Gee(e, t) {
  vy.set(e, t)
}
function Kee(e) {
  const t = vy.get(e)
  return vy.delete(e), t
}
let Yee = () => location.protocol + '//' + location.host
function zO(e, t) {
  const { pathname: n, search: i, hash: r } = t,
    s = e.indexOf('#')
  if (s > -1) {
    let a = r.includes(e.slice(s)) ? e.slice(s).length : 1,
      l = r.slice(a)
    return l[0] !== '/' && (l = '/' + l), iC(l, '')
  }
  return iC(n, e) + i + r
}
function Qee(e, t, n, i) {
  let r = [],
    s = [],
    o = null
  const a = ({ state: f }) => {
    const m = zO(e, location),
      p = n.value,
      v = t.value
    let y = 0
    if (f) {
      if (((n.value = m), (t.value = f), o && o === p)) {
        o = null
        return
      }
      y = v ? f.position - v.position : 0
    } else i(m)
    r.forEach((T) => {
      T(n.value, p, { delta: y, type: Lc.pop, direction: y ? (y > 0 ? tc.forward : tc.back) : tc.unknown })
    })
  }
  function l() {
    o = n.value
  }
  function u(f) {
    r.push(f)
    const m = () => {
      const p = r.indexOf(f)
      p > -1 && r.splice(p, 1)
    }
    return s.push(m), m
  }
  function c() {
    const { history: f } = window
    f.state && f.replaceState(vt({}, f.state, { scroll: ng() }), '')
  }
  function d() {
    for (const f of s) f()
    ;(s = []), window.removeEventListener('popstate', a), window.removeEventListener('beforeunload', c)
  }
  return (
    window.addEventListener('popstate', a),
    window.addEventListener('beforeunload', c, { passive: !0 }),
    { pauseListeners: l, listen: u, destroy: d }
  )
}
function oC(e, t, n, i = !1, r = !1) {
  return { back: e, current: t, forward: n, replaced: i, position: window.history.length, scroll: r ? ng() : null }
}
function Xee(e) {
  const { history: t, location: n } = window,
    i = { value: zO(e, n) },
    r = { value: t.state }
  r.value ||
    s(i.value, { back: null, current: i.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0)
  function s(l, u, c) {
    const d = e.indexOf('#'),
      f = d > -1 ? (n.host && document.querySelector('base') ? e : e.slice(d)) + l : Yee() + e + l
    try {
      t[c ? 'replaceState' : 'pushState'](u, '', f), (r.value = u)
    } catch (m) {
      console.error(m), n[c ? 'replace' : 'assign'](f)
    }
  }
  function o(l, u) {
    const c = vt({}, t.state, oC(r.value.back, l, r.value.forward, !0), u, { position: r.value.position })
    s(l, c, !0), (i.value = l)
  }
  function a(l, u) {
    const c = vt({}, r.value, t.state, { forward: l, scroll: ng() })
    s(c.current, c, !0)
    const d = vt({}, oC(i.value, l, null), { position: c.position + 1 }, u)
    s(l, d, !1), (i.value = l)
  }
  return { location: i, state: r, push: a, replace: o }
}
function Jee(e) {
  e = jee(e)
  const t = Xee(e),
    n = Qee(e, t.state, t.location, t.replace)
  function i(s, o = !0) {
    o || n.pauseListeners(), history.go(s)
  }
  const r = vt({ location: '', base: e, go: i, createHref: Hee.bind(null, e) }, t, n)
  return (
    Object.defineProperty(r, 'location', { enumerable: !0, get: () => t.location.value }),
    Object.defineProperty(r, 'state', { enumerable: !0, get: () => t.state.value }),
    r
  )
}
function Zee(e) {
  return (e = location.host ? e || location.pathname + location.search : ''), e.includes('#') || (e += '#'), Jee(e)
}
function ete(e) {
  return typeof e == 'string' || (e && typeof e == 'object')
}
function HO(e) {
  return typeof e == 'string' || typeof e == 'symbol'
}
const WO = Symbol('')
var aC
;(function (e) {
  ;(e[(e.aborted = 4)] = 'aborted'), (e[(e.cancelled = 8)] = 'cancelled'), (e[(e.duplicated = 16)] = 'duplicated')
})(aC || (aC = {}))
function Dl(e, t) {
  return vt(new Error(), { type: e, [WO]: !0 }, t)
}
function Ir(e, t) {
  return e instanceof Error && WO in e && (t == null || !!(e.type & t))
}
const lC = '[^/]+?',
  tte = { sensitive: !1, strict: !1, start: !0, end: !0 },
  nte = /[.+*?^${}()[\]/\\]/g
function ite(e, t) {
  const n = vt({}, tte, t),
    i = []
  let r = n.start ? '^' : ''
  const s = []
  for (const u of e) {
    const c = u.length ? [] : [90]
    n.strict && !u.length && (r += '/')
    for (let d = 0; d < u.length; d++) {
      const f = u[d]
      let m = 40 + (n.sensitive ? 0.25 : 0)
      if (f.type === 0) d || (r += '/'), (r += f.value.replace(nte, '\\$&')), (m += 40)
      else if (f.type === 1) {
        const { value: p, repeatable: v, optional: y, regexp: T } = f
        s.push({ name: p, repeatable: v, optional: y })
        const A = T || lC
        if (A !== lC) {
          m += 10
          try {
            new RegExp(`(${A})`)
          } catch (N) {
            throw new Error(`Invalid custom RegExp for param "${p}" (${A}): ` + N.message)
          }
        }
        let x = v ? `((?:${A})(?:/(?:${A}))*)` : `(${A})`
        d || (x = y && u.length < 2 ? `(?:/${x})` : '/' + x),
          y && (x += '?'),
          (r += x),
          (m += 20),
          y && (m += -8),
          v && (m += -20),
          A === '.*' && (m += -50)
      }
      c.push(m)
    }
    i.push(c)
  }
  if (n.strict && n.end) {
    const u = i.length - 1
    i[u][i[u].length - 1] += 0.7000000000000001
  }
  n.strict || (r += '/?'), n.end ? (r += '$') : n.strict && (r += '(?:/|$)')
  const o = new RegExp(r, n.sensitive ? '' : 'i')
  function a(u) {
    const c = u.match(o),
      d = {}
    if (!c) return null
    for (let f = 1; f < c.length; f++) {
      const m = c[f] || '',
        p = s[f - 1]
      d[p.name] = m && p.repeatable ? m.split('/') : m
    }
    return d
  }
  function l(u) {
    let c = '',
      d = !1
    for (const f of e) {
      ;(!d || !c.endsWith('/')) && (c += '/'), (d = !1)
      for (const m of f)
        if (m.type === 0) c += m.value
        else if (m.type === 1) {
          const { value: p, repeatable: v, optional: y } = m,
            T = p in u ? u[p] : ''
          if (Ki(T) && !v)
            throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`)
          const A = Ki(T) ? T.join('/') : T
          if (!A)
            if (y) f.length < 2 && (c.endsWith('/') ? (c = c.slice(0, -1)) : (d = !0))
            else throw new Error(`Missing required param "${p}"`)
          c += A
        }
    }
    return c || '/'
  }
  return { re: o, score: i, keys: s, parse: a, stringify: l }
}
function rte(e, t) {
  let n = 0
  for (; n < e.length && n < t.length; ) {
    const i = t[n] - e[n]
    if (i) return i
    n++
  }
  return e.length < t.length
    ? e.length === 1 && e[0] === 80
      ? -1
      : 1
    : e.length > t.length
    ? t.length === 1 && t[0] === 80
      ? 1
      : -1
    : 0
}
function qO(e, t) {
  let n = 0
  const i = e.score,
    r = t.score
  for (; n < i.length && n < r.length; ) {
    const s = rte(i[n], r[n])
    if (s) return s
    n++
  }
  if (Math.abs(r.length - i.length) === 1) {
    if (uC(i)) return 1
    if (uC(r)) return -1
  }
  return r.length - i.length
}
function uC(e) {
  const t = e[e.length - 1]
  return e.length > 0 && t[t.length - 1] < 0
}
const ste = { type: 0, value: '' },
  ote = /[a-zA-Z0-9_]/
function ate(e) {
  if (!e) return [[]]
  if (e === '/') return [[ste]]
  if (!e.startsWith('/')) throw new Error(`Invalid path "${e}"`)
  function t(m) {
    throw new Error(`ERR (${n})/"${u}": ${m}`)
  }
  let n = 0,
    i = n
  const r = []
  let s
  function o() {
    s && r.push(s), (s = [])
  }
  let a = 0,
    l,
    u = '',
    c = ''
  function d() {
    u &&
      (n === 0
        ? s.push({ type: 0, value: u })
        : n === 1 || n === 2 || n === 3
        ? (s.length > 1 &&
            (l === '*' || l === '+') &&
            t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),
          s.push({
            type: 1,
            value: u,
            regexp: c,
            repeatable: l === '*' || l === '+',
            optional: l === '*' || l === '?',
          }))
        : t('Invalid state to consume buffer'),
      (u = ''))
  }
  function f() {
    u += l
  }
  for (; a < e.length; ) {
    if (((l = e[a++]), l === '\\' && n !== 2)) {
      ;(i = n), (n = 4)
      continue
    }
    switch (n) {
      case 0:
        l === '/' ? (u && d(), o()) : l === ':' ? (d(), (n = 1)) : f()
        break
      case 4:
        f(), (n = i)
        break
      case 1:
        l === '(' ? (n = 2) : ote.test(l) ? f() : (d(), (n = 0), l !== '*' && l !== '?' && l !== '+' && a--)
        break
      case 2:
        l === ')' ? (c[c.length - 1] == '\\' ? (c = c.slice(0, -1) + l) : (n = 3)) : (c += l)
        break
      case 3:
        d(), (n = 0), l !== '*' && l !== '?' && l !== '+' && a--, (c = '')
        break
      default:
        t('Unknown state')
        break
    }
  }
  return n === 2 && t(`Unfinished custom RegExp for param "${u}"`), d(), o(), r
}
function lte(e, t, n) {
  const i = ite(ate(e.path), n),
    r = vt(i, { record: e, parent: t, children: [], alias: [] })
  return t && !r.record.aliasOf == !t.record.aliasOf && t.children.push(r), r
}
function ute(e, t) {
  const n = [],
    i = new Map()
  t = hC({ strict: !1, end: !0, sensitive: !1 }, t)
  function r(d) {
    return i.get(d)
  }
  function s(d, f, m) {
    const p = !m,
      v = cte(d)
    v.aliasOf = m && m.record
    const y = hC(t, d),
      T = [v]
    if ('alias' in d) {
      const N = typeof d.alias == 'string' ? [d.alias] : d.alias
      for (const V of N)
        T.push(vt({}, v, { components: m ? m.record.components : v.components, path: V, aliasOf: m ? m.record : v }))
    }
    let A, x
    for (const N of T) {
      const { path: V } = N
      if (f && V[0] !== '/') {
        const D = f.record.path,
          I = D[D.length - 1] === '/' ? '' : '/'
        N.path = f.record.path + (V && I + V)
      }
      if (
        ((A = lte(N, f, y)),
        m ? m.alias.push(A) : ((x = x || A), x !== A && x.alias.push(A), p && d.name && !dC(A) && o(d.name)),
        GO(A) && l(A),
        v.children)
      ) {
        const D = v.children
        for (let I = 0; I < D.length; I++) s(D[I], A, m && m.children[I])
      }
      m = m || A
    }
    return x
      ? () => {
          o(x)
        }
      : ec
  }
  function o(d) {
    if (HO(d)) {
      const f = i.get(d)
      f && (i.delete(d), n.splice(n.indexOf(f), 1), f.children.forEach(o), f.alias.forEach(o))
    } else {
      const f = n.indexOf(d)
      f > -1 && (n.splice(f, 1), d.record.name && i.delete(d.record.name), d.children.forEach(o), d.alias.forEach(o))
    }
  }
  function a() {
    return n
  }
  function l(d) {
    const f = fte(d, n)
    n.splice(f, 0, d), d.record.name && !dC(d) && i.set(d.record.name, d)
  }
  function u(d, f) {
    let m,
      p = {},
      v,
      y
    if ('name' in d && d.name) {
      if (((m = i.get(d.name)), !m)) throw Dl(1, { location: d })
      ;(y = m.record.name),
        (p = vt(
          cC(
            f.params,
            m.keys
              .filter((x) => !x.optional)
              .concat(m.parent ? m.parent.keys.filter((x) => x.optional) : [])
              .map((x) => x.name)
          ),
          d.params &&
            cC(
              d.params,
              m.keys.map((x) => x.name)
            )
        )),
        (v = m.stringify(p))
    } else if (d.path != null)
      (v = d.path), (m = n.find((x) => x.re.test(v))), m && ((p = m.parse(v)), (y = m.record.name))
    else {
      if (((m = f.name ? i.get(f.name) : n.find((x) => x.re.test(f.path))), !m))
        throw Dl(1, { location: d, currentLocation: f })
      ;(y = m.record.name), (p = vt({}, f.params, d.params)), (v = m.stringify(p))
    }
    const T = []
    let A = m
    for (; A; ) T.unshift(A.record), (A = A.parent)
    return { name: y, path: v, params: p, matched: T, meta: hte(T) }
  }
  e.forEach((d) => s(d))
  function c() {
    ;(n.length = 0), i.clear()
  }
  return { addRoute: s, resolve: u, removeRoute: o, clearRoutes: c, getRoutes: a, getRecordMatcher: r }
}
function cC(e, t) {
  const n = {}
  for (const i of t) i in e && (n[i] = e[i])
  return n
}
function cte(e) {
  return {
    path: e.path,
    redirect: e.redirect,
    name: e.name,
    meta: e.meta || {},
    aliasOf: void 0,
    beforeEnter: e.beforeEnter,
    props: dte(e),
    children: e.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: 'components' in e ? e.components || null : e.component && { default: e.component },
  }
}
function dte(e) {
  const t = {},
    n = e.props || !1
  if ('component' in e) t.default = n
  else for (const i in e.components) t[i] = typeof n == 'object' ? n[i] : n
  return t
}
function dC(e) {
  for (; e; ) {
    if (e.record.aliasOf) return !0
    e = e.parent
  }
  return !1
}
function hte(e) {
  return e.reduce((t, n) => vt(t, n.meta), {})
}
function hC(e, t) {
  const n = {}
  for (const i in e) n[i] = i in t ? t[i] : e[i]
  return n
}
function fte(e, t) {
  let n = 0,
    i = t.length
  for (; n !== i; ) {
    const s = (n + i) >> 1
    qO(e, t[s]) < 0 ? (i = s) : (n = s + 1)
  }
  const r = mte(e)
  return r && (i = t.lastIndexOf(r, i - 1)), i
}
function mte(e) {
  let t = e
  for (; (t = t.parent); ) if (GO(t) && qO(e, t) === 0) return t
}
function GO({ record: e }) {
  return !!(e.name || (e.components && Object.keys(e.components).length) || e.redirect)
}
function gte(e) {
  const t = {}
  if (e === '' || e === '?') return t
  const i = (e[0] === '?' ? e.slice(1) : e).split('&')
  for (let r = 0; r < i.length; ++r) {
    const s = i[r].replace(FO, ' '),
      o = s.indexOf('='),
      a = Mc(o < 0 ? s : s.slice(0, o)),
      l = o < 0 ? null : Mc(s.slice(o + 1))
    if (a in t) {
      let u = t[a]
      Ki(u) || (u = t[a] = [u]), u.push(l)
    } else t[a] = l
  }
  return t
}
function fC(e) {
  let t = ''
  for (let n in e) {
    const i = e[n]
    if (((n = Dee(n)), i == null)) {
      i !== void 0 && (t += (t.length ? '&' : '') + n)
      continue
    }
    ;(Ki(i) ? i.map((s) => s && gy(s)) : [i && gy(i)]).forEach((s) => {
      s !== void 0 && ((t += (t.length ? '&' : '') + n), s != null && (t += '=' + s))
    })
  }
  return t
}
function vte(e) {
  const t = {}
  for (const n in e) {
    const i = e[n]
    i !== void 0 && (t[n] = Ki(i) ? i.map((r) => (r == null ? null : '' + r)) : i == null ? i : '' + i)
  }
  return t
}
const pte = Symbol(''),
  mC = Symbol(''),
  ig = Symbol(''),
  Sw = Symbol(''),
  py = Symbol('')
function Eu() {
  let e = []
  function t(i) {
    return (
      e.push(i),
      () => {
        const r = e.indexOf(i)
        r > -1 && e.splice(r, 1)
      }
    )
  }
  function n() {
    e = []
  }
  return { add: t, list: () => e.slice(), reset: n }
}
function fs(e, t, n, i, r, s = (o) => o()) {
  const o = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || [])
  return () =>
    new Promise((a, l) => {
      const u = (f) => {
          f === !1
            ? l(Dl(4, { from: n, to: t }))
            : f instanceof Error
            ? l(f)
            : ete(f)
            ? l(Dl(2, { from: t, to: f }))
            : (o && i.enterCallbacks[r] === o && typeof f == 'function' && o.push(f), a())
        },
        c = s(() => e.call(i && i.instances[r], t, n, u))
      let d = Promise.resolve(c)
      e.length < 3 && (d = d.then(u)), d.catch((f) => l(f))
    })
}
function pv(e, t, n, i, r = (s) => s()) {
  const s = []
  for (const o of e)
    for (const a in o.components) {
      let l = o.components[a]
      if (!(t !== 'beforeRouteEnter' && !o.instances[a]))
        if (yte(l)) {
          const c = (l.__vccOpts || l)[t]
          c && s.push(fs(c, n, i, o, a, r))
        } else {
          let u = l()
          s.push(() =>
            u.then((c) => {
              if (!c) return Promise.reject(new Error(`Couldn't resolve component "${a}" at "${o.path}"`))
              const d = Iee(c) ? c.default : c
              o.components[a] = d
              const m = (d.__vccOpts || d)[t]
              return m && fs(m, n, i, o, a, r)()
            })
          )
        }
    }
  return s
}
function yte(e) {
  return typeof e == 'object' || 'displayName' in e || 'props' in e || '__vccOpts' in e
}
function gC(e) {
  const t = je(ig),
    n = je(Sw),
    i = k(() => {
      const l = Lt(e.to)
      return t.resolve(l)
    }),
    r = k(() => {
      const { matched: l } = i.value,
        { length: u } = l,
        c = l[u - 1],
        d = n.matched
      if (!c || !d.length) return -1
      const f = d.findIndex(Vl.bind(null, c))
      if (f > -1) return f
      const m = vC(l[u - 2])
      return u > 1 && vC(c) === m && d[d.length - 1].path !== m ? d.findIndex(Vl.bind(null, l[u - 2])) : f
    }),
    s = k(() => r.value > -1 && Ite(n.params, i.value.params)),
    o = k(() => r.value > -1 && r.value === n.matched.length - 1 && jO(n.params, i.value.params))
  function a(l = {}) {
    return wte(l) ? t[Lt(e.replace) ? 'replace' : 'push'](Lt(e.to)).catch(ec) : Promise.resolve()
  }
  return { route: i, href: k(() => i.value.href), isActive: s, isExactActive: o, navigate: a }
}
const _te = Of({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
      to: { type: [String, Object], required: !0 },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: { type: String, default: 'page' },
    },
    useLink: gC,
    setup(e, { slots: t }) {
      const n = wn(gC(e)),
        { options: i } = je(ig),
        r = k(() => ({
          [pC(e.activeClass, i.linkActiveClass, 'router-link-active')]: n.isActive,
          [pC(e.exactActiveClass, i.linkExactActiveClass, 'router-link-exact-active')]: n.isExactActive,
        }))
      return () => {
        const s = t.default && t.default(n)
        return e.custom
          ? s
          : Yi(
              'a',
              {
                'aria-current': n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: r.value,
              },
              s
            )
      }
    },
  }),
  bte = _te
function wte(e) {
  if (
    !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) &&
    !e.defaultPrevented &&
    !(e.button !== void 0 && e.button !== 0)
  ) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute('target')
      if (/\b_blank\b/i.test(t)) return
    }
    return e.preventDefault && e.preventDefault(), !0
  }
}
function Ite(e, t) {
  for (const n in t) {
    const i = t[n],
      r = e[n]
    if (typeof i == 'string') {
      if (i !== r) return !1
    } else if (!Ki(r) || r.length !== i.length || i.some((s, o) => s !== r[o])) return !1
  }
  return !0
}
function vC(e) {
  return e ? (e.aliasOf ? e.aliasOf.path : e.path) : ''
}
const pC = (e, t, n) => e ?? t ?? n,
  Ste = Of({
    name: 'RouterView',
    inheritAttrs: !1,
    props: { name: { type: String, default: 'default' }, route: Object },
    compatConfig: { MODE: 3 },
    setup(e, { attrs: t, slots: n }) {
      const i = je(py),
        r = k(() => e.route || i.value),
        s = je(mC, 0),
        o = k(() => {
          let u = Lt(s)
          const { matched: c } = r.value
          let d
          for (; (d = c[u]) && !d.components; ) u++
          return u
        }),
        a = k(() => r.value.matched[o.value])
      mt(
        mC,
        k(() => o.value + 1)
      ),
        mt(pte, a),
        mt(py, r)
      const l = le()
      return (
        be(
          () => [l.value, a.value, e.name],
          ([u, c, d], [f, m, p]) => {
            c &&
              ((c.instances[d] = u),
              m &&
                m !== c &&
                u &&
                u === f &&
                (c.leaveGuards.size || (c.leaveGuards = m.leaveGuards),
                c.updateGuards.size || (c.updateGuards = m.updateGuards))),
              u && c && (!m || !Vl(c, m) || !f) && (c.enterCallbacks[d] || []).forEach((v) => v(u))
          },
          { flush: 'post' }
        ),
        () => {
          const u = r.value,
            c = e.name,
            d = a.value,
            f = d && d.components[c]
          if (!f) return yC(n.default, { Component: f, route: u })
          const m = d.props[c],
            p = m ? (m === !0 ? u.params : typeof m == 'function' ? m(u) : m) : null,
            y = Yi(
              f,
              vt({}, p, t, {
                onVnodeUnmounted: (T) => {
                  T.component.isUnmounted && (d.instances[c] = null)
                },
                ref: l,
              })
            )
          return yC(n.default, { Component: y, route: u }) || y
        }
      )
    },
  })
function yC(e, t) {
  if (!e) return null
  const n = e(t)
  return n.length === 1 ? n[0] : n
}
const KO = Ste
function Ete(e) {
  const t = ute(e.routes, e),
    n = e.parseQuery || gte,
    i = e.stringifyQuery || fC,
    r = e.history,
    s = Eu(),
    o = Eu(),
    a = Eu(),
    l = ye(as)
  let u = as
  za && e.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual')
  const c = gv.bind(null, (z) => '' + z),
    d = gv.bind(null, Oee),
    f = gv.bind(null, Mc)
  function m(z, ue) {
    let de, Z
    return HO(z) ? ((de = t.getRecordMatcher(z)), (Z = ue)) : (Z = z), t.addRoute(Z, de)
  }
  function p(z) {
    const ue = t.getRecordMatcher(z)
    ue && t.removeRoute(ue)
  }
  function v() {
    return t.getRoutes().map((z) => z.record)
  }
  function y(z) {
    return !!t.getRecordMatcher(z)
  }
  function T(z, ue) {
    if (((ue = vt({}, ue || l.value)), typeof z == 'string')) {
      const L = vv(n, z, ue.path),
        H = t.resolve({ path: L.path }, ue),
        X = r.createHref(L.fullPath)
      return vt(L, H, { params: f(H.params), hash: Mc(L.hash), redirectedFrom: void 0, href: X })
    }
    let de
    if (z.path != null) de = vt({}, z, { path: vv(n, z.path, ue.path).path })
    else {
      const L = vt({}, z.params)
      for (const H in L) L[H] == null && delete L[H]
      ;(de = vt({}, z, { params: d(L) })), (ue.params = d(ue.params))
    }
    const Z = t.resolve(de, ue),
      pe = z.hash || ''
    Z.params = c(f(Z.params))
    const re = Fee(i, vt({}, z, { hash: Vee(pe), path: Z.path })),
      O = r.createHref(re)
    return vt({ fullPath: re, hash: pe, query: i === fC ? vte(z.query) : z.query || {} }, Z, {
      redirectedFrom: void 0,
      href: O,
    })
  }
  function A(z) {
    return typeof z == 'string' ? vv(n, z, l.value.path) : vt({}, z)
  }
  function x(z, ue) {
    if (u !== z) return Dl(8, { from: ue, to: z })
  }
  function N(z) {
    return I(z)
  }
  function V(z) {
    return N(vt(A(z), { replace: !0 }))
  }
  function D(z) {
    const ue = z.matched[z.matched.length - 1]
    if (ue && ue.redirect) {
      const { redirect: de } = ue
      let Z = typeof de == 'function' ? de(z) : de
      return (
        typeof Z == 'string' && ((Z = Z.includes('?') || Z.includes('#') ? (Z = A(Z)) : { path: Z }), (Z.params = {})),
        vt({ query: z.query, hash: z.hash, params: Z.path != null ? {} : z.params }, Z)
      )
    }
  }
  function I(z, ue) {
    const de = (u = T(z)),
      Z = l.value,
      pe = z.state,
      re = z.force,
      O = z.replace === !0,
      L = D(de)
    if (L)
      return I(vt(A(L), { state: typeof L == 'object' ? vt({}, pe, L.state) : pe, force: re, replace: O }), ue || de)
    const H = de
    H.redirectedFrom = ue
    let X
    return (
      !re && Bee(i, Z, de) && ((X = Dl(16, { to: H, from: Z })), q(Z, Z, !0, !1)),
      (X ? Promise.resolve(X) : S(H, Z))
        .catch((ee) => (Ir(ee) ? (Ir(ee, 2) ? ee : j(ee)) : F(ee, H, Z)))
        .then((ee) => {
          if (ee) {
            if (Ir(ee, 2))
              return I(
                vt({ replace: O }, A(ee.to), {
                  state: typeof ee.to == 'object' ? vt({}, pe, ee.to.state) : pe,
                  force: re,
                }),
                ue || H
              )
          } else ee = C(H, Z, !0, O, pe)
          return E(H, Z, ee), ee
        })
    )
  }
  function w(z, ue) {
    const de = x(z, ue)
    return de ? Promise.reject(de) : Promise.resolve()
  }
  function _(z) {
    const ue = Ee.values().next().value
    return ue && typeof ue.runWithContext == 'function' ? ue.runWithContext(z) : z()
  }
  function S(z, ue) {
    let de
    const [Z, pe, re] = Tte(z, ue)
    de = pv(Z.reverse(), 'beforeRouteLeave', z, ue)
    for (const L of Z)
      L.leaveGuards.forEach((H) => {
        de.push(fs(H, z, ue))
      })
    const O = w.bind(null, z, ue)
    return (
      de.push(O),
      oe(de)
        .then(() => {
          de = []
          for (const L of s.list()) de.push(fs(L, z, ue))
          return de.push(O), oe(de)
        })
        .then(() => {
          de = pv(pe, 'beforeRouteUpdate', z, ue)
          for (const L of pe)
            L.updateGuards.forEach((H) => {
              de.push(fs(H, z, ue))
            })
          return de.push(O), oe(de)
        })
        .then(() => {
          de = []
          for (const L of re)
            if (L.beforeEnter)
              if (Ki(L.beforeEnter)) for (const H of L.beforeEnter) de.push(fs(H, z, ue))
              else de.push(fs(L.beforeEnter, z, ue))
          return de.push(O), oe(de)
        })
        .then(
          () => (
            z.matched.forEach((L) => (L.enterCallbacks = {})),
            (de = pv(re, 'beforeRouteEnter', z, ue, _)),
            de.push(O),
            oe(de)
          )
        )
        .then(() => {
          de = []
          for (const L of o.list()) de.push(fs(L, z, ue))
          return de.push(O), oe(de)
        })
        .catch((L) => (Ir(L, 8) ? L : Promise.reject(L)))
    )
  }
  function E(z, ue, de) {
    a.list().forEach((Z) => _(() => Z(z, ue, de)))
  }
  function C(z, ue, de, Z, pe) {
    const re = x(z, ue)
    if (re) return re
    const O = ue === as,
      L = za ? history.state : {}
    de && (Z || O ? r.replace(z.fullPath, vt({ scroll: O && L && L.scroll }, pe)) : r.push(z.fullPath, pe)),
      (l.value = z),
      q(z, ue, de, O),
      j()
  }
  let R
  function B() {
    R ||
      (R = r.listen((z, ue, de) => {
        if (!me.listening) return
        const Z = T(z),
          pe = D(Z)
        if (pe) {
          I(vt(pe, { replace: !0 }), Z).catch(ec)
          return
        }
        u = Z
        const re = l.value
        za && Gee(sC(re.fullPath, de.delta), ng()),
          S(Z, re)
            .catch((O) =>
              Ir(O, 12)
                ? O
                : Ir(O, 2)
                ? (I(O.to, Z)
                    .then((L) => {
                      Ir(L, 20) && !de.delta && de.type === Lc.pop && r.go(-1, !1)
                    })
                    .catch(ec),
                  Promise.reject())
                : (de.delta && r.go(-de.delta, !1), F(O, Z, re))
            )
            .then((O) => {
              ;(O = O || C(Z, re, !1)),
                O && (de.delta && !Ir(O, 8) ? r.go(-de.delta, !1) : de.type === Lc.pop && Ir(O, 20) && r.go(-1, !1)),
                E(Z, re, O)
            })
            .catch(ec)
      }))
  }
  let U = Eu(),
    $ = Eu(),
    G
  function F(z, ue, de) {
    j(z)
    const Z = $.list()
    return Z.length ? Z.forEach((pe) => pe(z, ue, de)) : console.error(z), Promise.reject(z)
  }
  function K() {
    return G && l.value !== as
      ? Promise.resolve()
      : new Promise((z, ue) => {
          U.add([z, ue])
        })
  }
  function j(z) {
    return G || ((G = !z), B(), U.list().forEach(([ue, de]) => (z ? de(z) : ue())), U.reset()), z
  }
  function q(z, ue, de, Z) {
    const { scrollBehavior: pe } = e
    if (!za || !pe) return Promise.resolve()
    const re = (!de && Kee(sC(z.fullPath, 0))) || ((Z || !de) && history.state && history.state.scroll) || null
    return Xe()
      .then(() => pe(z, ue, re))
      .then((O) => O && qee(O))
      .catch((O) => F(O, z, ue))
  }
  const te = (z) => r.go(z)
  let ce
  const Ee = new Set(),
    me = {
      currentRoute: l,
      listening: !0,
      addRoute: m,
      removeRoute: p,
      clearRoutes: t.clearRoutes,
      hasRoute: y,
      getRoutes: v,
      resolve: T,
      options: e,
      push: N,
      replace: V,
      go: te,
      back: () => te(-1),
      forward: () => te(1),
      beforeEach: s.add,
      beforeResolve: o.add,
      afterEach: a.add,
      onError: $.add,
      isReady: K,
      install(z) {
        const ue = this
        z.component('RouterLink', bte),
          z.component('RouterView', KO),
          (z.config.globalProperties.$router = ue),
          Object.defineProperty(z.config.globalProperties, '$route', { enumerable: !0, get: () => Lt(l) }),
          za && !ce && l.value === as && ((ce = !0), N(r.location).catch((pe) => {}))
        const de = {}
        for (const pe in as) Object.defineProperty(de, pe, { get: () => l.value[pe], enumerable: !0 })
        z.provide(ig, ue), z.provide(Sw, WC(de)), z.provide(py, l)
        const Z = z.unmount
        Ee.add(z),
          (z.unmount = function () {
            Ee.delete(z), Ee.size < 1 && ((u = as), R && R(), (R = null), (l.value = as), (ce = !1), (G = !1)), Z()
          })
      },
    }
  function oe(z) {
    return z.reduce((ue, de) => ue.then(() => _(de)), Promise.resolve())
  }
  return me
}
function Tte(e, t) {
  const n = [],
    i = [],
    r = [],
    s = Math.max(t.matched.length, e.matched.length)
  for (let o = 0; o < s; o++) {
    const a = t.matched[o]
    a && (e.matched.find((u) => Vl(u, a)) ? i.push(a) : n.push(a))
    const l = e.matched[o]
    l && (t.matched.find((u) => Vl(u, l)) || r.push(l))
  }
  return [n, i, r]
}
function one() {
  return je(ig)
}
function ane(e) {
  return je(Sw)
}
const Cte = Of({
    __name: 'App',
    setup(e) {
      return (t, n) => (Bf(), zy(Lt(KO)))
    },
  }),
  Ate = 'modulepreload',
  kte = function (e) {
    return '/ASLA/' + e
  },
  _C = {},
  Ma = function (t, n, i) {
    let r = Promise.resolve()
    if (n && n.length > 0) {
      document.getElementsByTagName('link')
      const s = document.querySelector('meta[property=csp-nonce]'),
        o = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute('nonce'))
      r = Promise.all(
        n.map((a) => {
          if (((a = kte(a)), a in _C)) return
          _C[a] = !0
          const l = a.endsWith('.css'),
            u = l ? '[rel="stylesheet"]' : ''
          if (document.querySelector(`link[href="${a}"]${u}`)) return
          const c = document.createElement('link')
          if (
            ((c.rel = l ? 'stylesheet' : Ate),
            l || ((c.as = 'script'), (c.crossOrigin = '')),
            (c.href = a),
            o && c.setAttribute('nonce', o),
            document.head.appendChild(c),
            l)
          )
            return new Promise((d, f) => {
              c.addEventListener('load', d),
                c.addEventListener('error', () => f(new Error(`Unable to preload CSS for ${a}`)))
            })
        })
      )
    }
    return r
      .then(() => t())
      .catch((s) => {
        const o = new Event('vite:preloadError', { cancelable: !0 })
        if (((o.payload = s), window.dispatchEvent(o), !o.defaultPrevented)) throw s
      })
  },
  Pte = '/setlist',
  bC = '/login',
  Rte = Ete({
    history: Zee('/ASLA/'),
    routes: [
      { path: Pte, component: () => Ma(() => import('./SetlistsIndex-CO_nWPJI.js'), __vite__mapDeps([0, 1, 2])) },
      {
        path: '/setlist/create',
        component: () => Ma(() => import('./SetlistCreateUpdate-D57DwXV-.js'), __vite__mapDeps([3, 4, 5, 1, 2, 6, 7])),
      },
      {
        path: '/setlist/:id/edit',
        component: () => Ma(() => import('./SetlistCreateUpdate-D57DwXV-.js'), __vite__mapDeps([3, 4, 5, 1, 2, 6, 7])),
      },
      {
        path: '/setlist/:id',
        component: () => Ma(() => import('./SetlistRead-6iFH7K3d.js'), __vite__mapDeps([8, 4, 5, 6, 9])),
      },
      { path: bC, component: () => Ma(() => import('./Login-CAiAw9gx.js'), __vite__mapDeps([10, 2, 6])) },
      {
        path: '/settings',
        component: () => Ma(() => import('./Settings-DZPSPFku.js'), __vite__mapDeps([11, 4, 1, 2, 6, 12])),
      },
      { path: '/', redirect: bC },
    ],
  }),
  xte = aD({
    components: iee,
    directives: gee,
    theme: {
      defaultTheme: 'customLightTheme',
      themes: {
        customLightTheme: {
          dark: !1,
          colors: { background: '#f7f7f7', surface: '#FFFFFF', primary: '#38A700', secondary: '#A72608' },
        },
      },
    },
    icons: { defaultSet: 'fa', aliases: vee, sets: { fa: pee } },
  })
_ee.extend(wee)
const _d = HF(Cte)
_d.use(KF())
_d.use(Rte)
_d.use(h9, { firebaseApp: od, modules: [l9()] })
_d.use(xte)
_d.mount('#app')
export {
  wn as $,
  dd as A,
  WD as B,
  Un as C,
  je as D,
  Ur as E,
  ke as F,
  Rt as G,
  pi as H,
  Le as I,
  Ks as J,
  cY as K,
  st as L,
  Rl as M,
  GD as N,
  qD as O,
  ye as P,
  $r as Q,
  pd as R,
  aY as S,
  oY as T,
  Q as U,
  Qp as V,
  xe as W,
  yd as X,
  mt as Y,
  Ot as Z,
  Bm as _,
  rne as a,
  Xe as a0,
  Wy as a1,
  Yi as a2,
  Nte as a3,
  Ote as a4,
  Vte as a5,
  nF as a6,
  Lte as a7,
  Vf as a8,
  mL as a9,
  Fte as aA,
  Ute as aB,
  bC as aC,
  $te as aD,
  jte as aE,
  TW as aa,
  tne as ab,
  be as ac,
  ane as ad,
  one as ae,
  Pte as af,
  Yte as ag,
  Gte as ah,
  sne as ai,
  Kte as aj,
  Zte as ak,
  Jte as al,
  Qte as am,
  $t as an,
  kn as ao,
  xf as ap,
  Er as aq,
  Qi as ar,
  Xte as as,
  An as at,
  Iy as au,
  gn as av,
  $c as aw,
  Bte as ax,
  nne as ay,
  bte as az,
  OA as b,
  zy as c,
  Of as d,
  g as e,
  Or as f,
  Mte as g,
  Dte as h,
  rS as i,
  Lt as j,
  Qt as k,
  ne as l,
  J8 as m,
  le as n,
  Bf as o,
  W as p,
  k as q,
  fL as r,
  ine as s,
  xC as t,
  ene as u,
  se as v,
  sL as w,
  Ge as x,
  ae as y,
  eY as z,
}
